# DP: updates from the 4.9 branch upto 20141011 (r216116).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Sat Oct 11 09:18:03 CEST 2014
Sat Oct 11 07:18:03 UTC 2014 (revision 216116)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_4_9_1_release svn://gcc.gnu.org/svn/gcc/branches/gcc-4_9-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libitm/configure.tgt
===================================================================
--- a/src/libitm/configure.tgt	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/configure.tgt	(.../branches/gcc-4_9-branch)
@@ -46,6 +46,7 @@
 # Map the target cpu to an ARCH sub-directory.  At the same time,
 # work out any special compilation flags as necessary.
 case "${target_cpu}" in
+  aarch64*)		ARCH=aarch64 ;;
   alpha*)		ARCH=alpha ;;
   rs6000 | powerpc*)
 	XCFLAGS="${XCFLAGS} -mhtm"
Index: libitm/ChangeLog
===================================================================
--- a/src/libitm/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,9 @@
+2014-07-24  Richard Henderson  <rth@redhat.com>
+
+	* config/aarch64/sjlj.S: New file.
+	* config/aarch64/target.h: New file.
+	* configure.tgt: Enable aarch64.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libitm/config/aarch64/sjlj.S
===================================================================
--- a/src/libitm/config/aarch64/sjlj.S	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/config/aarch64/sjlj.S	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,92 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "asmcfi.h"
+
+	.text
+	.align	2
+	.global	_ITM_beginTransaction
+	.type	_ITM_beginTransaction, %function
+
+_ITM_beginTransaction:
+	cfi_startproc
+	mov	x1, sp
+	stp	x29, x30, [sp, -11*16]!
+	cfi_adjust_cfa_offset(11*16)
+	cfi_rel_offset(x29, 0)
+	cfi_rel_offset(x30, 8)
+	mov	x29, sp
+	stp	x19, x20, [sp, 1*16]
+	stp	x21, x22, [sp, 2*16]
+	stp	x23, x24, [sp, 3*16]
+	stp	x25, x26, [sp, 4*16]
+	stp	x27, x28, [sp, 5*16]
+	stp	d8, d9,   [sp, 6*16]
+	stp	d10, d11, [sp, 7*16]
+	stp	d12, d13, [sp, 8*16]
+	stp	d14, d15, [sp, 9*16]
+	str	x1, [sp, 10*16]
+
+	/* Invoke GTM_begin_transaction with the struct we just built.  */
+	mov	x1, sp
+	bl	GTM_begin_transaction
+
+	/* Return; we don't need to restore any of the call-saved regs.  */
+	ldp	x29, x30, [sp], 11*16
+	cfi_adjust_cfa_offset(-11*16)
+	cfi_restore(x29)
+	cfi_restore(x30)
+	ret
+	cfi_endproc
+	.size	_ITM_beginTransaction, . - _ITM_beginTransaction
+
+	.align	2
+	.global	GTM_longjmp
+	.hidden	GTM_longjmp
+	.type	GTM_longjmp, %function
+
+GTM_longjmp:
+	/* The first parameter becomes the return value (x0).
+	   The third parameter is ignored for now.  */
+	cfi_startproc
+	ldp	x19, x20, [x1, 1*16]
+	ldp	x21, x22, [x1, 2*16]
+	ldp	x23, x24, [x1, 3*16]
+	ldp	x25, x26, [x1, 4*16]
+	ldp	x27, x28, [x1, 5*16]
+	ldp	d8, d9,   [x1, 6*16]
+	ldp	d10, d11, [x1, 7*16]
+	ldp	d12, d13, [x1, 8*16]
+	ldp	d14, d15, [x1, 9*16]
+	ldr	x3, [x1, 10*16]
+	ldp	x29, x30, [x1]
+	cfi_def_cfa(x1, 0)
+	mov	sp, x3
+	br	x30
+	cfi_endproc
+	.size	GTM_longjmp, . - GTM_longjmp
+
+#ifdef __linux__
+.section .note.GNU-stack, "", %progbits
+#endif
Index: libitm/config/aarch64/target.h
===================================================================
--- a/src/libitm/config/aarch64/target.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libitm/config/aarch64/target.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,45 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Richard Henderson <rth@redhat.com>.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+namespace GTM HIDDEN {
+
+typedef struct gtm_jmpbuf
+{
+  unsigned long long fp;	/* x29 */
+  unsigned long long pc;	/* x30 */
+  unsigned long long gr[10];	/* x19-x28 */
+  unsigned long long vr[8];	/* d8-d15 */
+  void *cfa;
+} gtm_jmpbuf;
+
+/* ??? The size of one line in hardware caches (in bytes). */
+#define HW_CACHELINE_SIZE 128
+
+static inline void
+cpu_relax (void)
+{
+  __asm volatile ("" : : : "memory");
+}
+
+} // namespace GTM
Index: libgomp/libgomp.h
===================================================================
--- a/src/libgomp/libgomp.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/libgomp.h	(.../branches/gcc-4_9-branch)
@@ -274,6 +274,7 @@
   struct gomp_task *task;
   bool is_in;
   bool redundant;
+  bool redundant_out;
 };
 
 struct gomp_dependers_vec
@@ -283,6 +284,17 @@
   struct gomp_task *elem[];
 };
 
+/* Used when in GOMP_taskwait or in gomp_task_maybe_wait_for_dependencies.  */
+
+struct gomp_taskwait
+{
+  bool in_taskwait;
+  bool in_depend_wait;
+  size_t n_depend;
+  struct gomp_task *last_parent_depends_on;
+  gomp_sem_t taskwait_sem;
+};
+
 /* This structure describes a "task" to be run by a thread.  */
 
 struct gomp_task
@@ -298,6 +310,7 @@
   struct gomp_taskgroup *taskgroup;
   struct gomp_dependers_vec *dependers;
   struct htab *depend_hash;
+  struct gomp_taskwait *taskwait;
   size_t depend_count;
   size_t num_dependees;
   struct gomp_task_icv icv;
@@ -304,11 +317,10 @@
   void (*fn) (void *);
   void *fn_data;
   enum gomp_task_kind kind;
-  bool in_taskwait;
   bool in_tied_task;
   bool final_task;
   bool copy_ctors_done;
-  gomp_sem_t taskwait_sem;
+  bool parent_depends_on;
   struct gomp_task_depend_entry depend[];
 };
 
@@ -582,7 +594,6 @@
 {
   if (__builtin_expect (task->depend_hash != NULL, 0))
     free (task->depend_hash);
-  gomp_sem_destroy (&task->taskwait_sem);
 }
 
 /* team.c */
Index: libgomp/task.c
===================================================================
--- a/src/libgomp/task.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/task.c	(.../branches/gcc-4_9-branch)
@@ -66,16 +66,16 @@
   task->parent = parent_task;
   task->icv = *prev_icv;
   task->kind = GOMP_TASK_IMPLICIT;
-  task->in_taskwait = false;
+  task->taskwait = NULL;
   task->in_tied_task = false;
   task->final_task = false;
   task->copy_ctors_done = false;
+  task->parent_depends_on = false;
   task->children = NULL;
   task->taskgroup = NULL;
   task->dependers = NULL;
   task->depend_hash = NULL;
   task->depend_count = 0;
-  gomp_sem_init (&task->taskwait_sem, 0);
 }
 
 /* Clean up a task, after completing it.  */
@@ -104,6 +104,8 @@
     while (task != children);
 }
 
+static void gomp_task_maybe_wait_for_dependencies (void **depend);
+
 /* Called when encountering an explicit task directive.  If IF_CLAUSE is
    false, then we must not delay in executing the task.  If UNTIED is true,
    then the task may be executed by any member of the team.  */
@@ -141,35 +143,12 @@
 
       /* If there are depend clauses and earlier deferred sibling tasks
 	 with depend clauses, check if there isn't a dependency.  If there
-	 is, fall through to the deferred task handling, as we can't
-	 schedule such tasks right away.  There is no need to handle
+	 is, we need to wait for them.  There is no need to handle
 	 depend clauses for non-deferred tasks other than this, because
 	 the parent task is suspended until the child task finishes and thus
 	 it can't start further child tasks.  */
       if ((flags & 8) && thr->task && thr->task->depend_hash)
-	{
-	  struct gomp_task *parent = thr->task;
-	  struct gomp_task_depend_entry elem, *ent = NULL;
-	  size_t ndepend = (uintptr_t) depend[0];
-	  size_t nout = (uintptr_t) depend[1];
-	  size_t i;
-	  gomp_mutex_lock (&team->task_lock);
-	  for (i = 0; i < ndepend; i++)
-	    {
-	      elem.addr = depend[i + 2];
-	      ent = htab_find (parent->depend_hash, &elem);
-	      for (; ent; ent = ent->next)
-		if (i >= nout && ent->is_in)
-		  continue;
-		else
-		  break;
-	      if (ent)
-		break;
-	    }
-	  gomp_mutex_unlock (&team->task_lock);
-	  if (ent)
-	    goto defer;
-	}
+	gomp_task_maybe_wait_for_dependencies (depend);
 
       gomp_init_task (&task, thr->task, gomp_icv (false));
       task.kind = GOMP_TASK_IFFALSE;
@@ -209,7 +188,6 @@
     }
   else
     {
-     defer:;
       struct gomp_task *task;
       struct gomp_task *parent = thr->task;
       struct gomp_taskgroup *taskgroup = parent->taskgroup;
@@ -275,11 +253,12 @@
 	      task->depend[i].task = task;
 	      task->depend[i].is_in = i >= nout;
 	      task->depend[i].redundant = false;
+	      task->depend[i].redundant_out = false;
 
 	      hash_entry_type *slot
 		= htab_find_slot (&parent->depend_hash, &task->depend[i],
 				  INSERT);
-	      hash_entry_type out = NULL;
+	      hash_entry_type out = NULL, last = NULL;
 	      if (*slot)
 		{
 		  /* If multiple depends on the same task are the
@@ -294,6 +273,11 @@
 		    }
 		  for (ent = *slot; ent; ent = ent->next)
 		    {
+		      if (ent->redundant_out)
+			break;
+
+		      last = ent;
+
 		      /* depend(in:...) doesn't depend on earlier
 			 depend(in:...).  */
 		      if (i >= nout && ent->is_in)
@@ -341,7 +325,8 @@
 	      *slot = &task->depend[i];
 
 	      /* There is no need to store more than one depend({,in}out:)
-		 task per address in the hash table chain, because each out
+		 task per address in the hash table chain for the purpose
+		 of creation of deferred tasks, because each out
 		 depends on all earlier outs, thus it is enough to record
 		 just the last depend({,in}out:).  For depend(in:), we need
 		 to keep all of the previous ones not terminated yet, because
@@ -348,14 +333,23 @@
 		 a later depend({,in}out:) might need to depend on all of
 		 them.  So, if the new task's clause is depend({,in}out:),
 		 we know there is at most one other depend({,in}out:) clause
-		 in the list (out) and to maintain the invariant we now
-		 need to remove it from the list.  */
+		 in the list (out).  For non-deferred tasks we want to see
+		 all outs, so they are moved to the end of the chain,
+		 after first redundant_out entry all following entries
+		 should be redundant_out.  */
 	      if (!task->depend[i].is_in && out)
 		{
-		  if (out->next)
-		    out->next->prev = out->prev;
-		  out->prev->next = out->next;
-		  out->redundant = true;
+		  if (out != last)
+		    {
+		      out->next->prev = out->prev;
+		      out->prev->next = out->next;
+		      out->next = last->next;
+		      out->prev = last;
+		      last->next = out;
+		      if (out->next)
+			out->next->prev = out;
+		    }
+		  out->redundant_out = true;
 		}
 	    }
 	  if (task->num_dependees)
@@ -421,8 +415,20 @@
 gomp_task_run_pre (struct gomp_task *child_task, struct gomp_task *parent,
 		   struct gomp_taskgroup *taskgroup, struct gomp_team *team)
 {
-  if (parent && parent->children == child_task)
-    parent->children = child_task->next_child;
+  if (parent)
+    {
+      if (parent->children == child_task)
+	parent->children = child_task->next_child;
+      if (__builtin_expect (child_task->parent_depends_on, 0)
+	  && parent->taskwait->last_parent_depends_on == child_task)
+	{
+	  if (child_task->prev_child->kind == GOMP_TASK_WAITING
+	      && child_task->prev_child->parent_depends_on)
+	    parent->taskwait->last_parent_depends_on = child_task->prev_child;
+	  else
+	    parent->taskwait->last_parent_depends_on = NULL;
+	}
+    }
   if (taskgroup && taskgroup->children == child_task)
     taskgroup->children = child_task->next_taskgroup;
   child_task->prev_queue->next_queue = child_task->next_queue;
@@ -489,8 +495,23 @@
 	{
 	  if (parent->children)
 	    {
-	      task->next_child = parent->children;
-	      task->prev_child = parent->children->prev_child;
+	      /* If parent is in gomp_task_maybe_wait_for_dependencies
+		 and it doesn't need to wait for this task, put it after
+		 all ready to run tasks it needs to wait for.  */
+	      if (parent->taskwait && parent->taskwait->last_parent_depends_on
+		  && !task->parent_depends_on)
+		{
+		  struct gomp_task *last_parent_depends_on
+		    = parent->taskwait->last_parent_depends_on;
+		  task->next_child = last_parent_depends_on->next_child;
+		  task->prev_child = last_parent_depends_on;
+		}
+	      else
+		{
+		  task->next_child = parent->children;
+		  task->prev_child = parent->children->prev_child;
+		  parent->children = task;
+		}
 	      task->next_child->prev_child = task;
 	      task->prev_child->next_child = task;
 	    }
@@ -498,12 +519,23 @@
 	    {
 	      task->next_child = task;
 	      task->prev_child = task;
+	      parent->children = task;
 	    }
-	  parent->children = task;
-	  if (parent->in_taskwait)
+	  if (parent->taskwait)
 	    {
-	      parent->in_taskwait = false;
-	      gomp_sem_post (&parent->taskwait_sem);
+	      if (parent->taskwait->in_taskwait)
+		{
+		  parent->taskwait->in_taskwait = false;
+		  gomp_sem_post (&parent->taskwait->taskwait_sem);
+		}
+	      else if (parent->taskwait->in_depend_wait)
+		{
+		  parent->taskwait->in_depend_wait = false;
+		  gomp_sem_post (&parent->taskwait->taskwait_sem);
+		}
+	      if (parent->taskwait->last_parent_depends_on == NULL
+		  && task->parent_depends_on)
+		parent->taskwait->last_parent_depends_on = task;
 	    }
 	}
       if (taskgroup)
@@ -575,6 +607,13 @@
   struct gomp_task *parent = child_task->parent;
   if (parent == NULL)
     return;
+  if (__builtin_expect (child_task->parent_depends_on, 0)
+      && --parent->taskwait->n_depend == 0
+      && parent->taskwait->in_depend_wait)
+    {
+      parent->taskwait->in_depend_wait = false;
+      gomp_sem_post (&parent->taskwait->taskwait_sem);
+    }
   child_task->prev_child->next_child = child_task->next_child;
   child_task->next_child->prev_child = child_task->prev_child;
   if (parent->children != child_task)
@@ -589,10 +628,10 @@
 	 written by child_task->fn above is flushed
 	 before the NULL is written.  */
       __atomic_store_n (&parent->children, NULL, MEMMODEL_RELEASE);
-      if (parent->in_taskwait)
+      if (parent->taskwait && parent->taskwait->in_taskwait)
 	{
-	  parent->in_taskwait = false;
-	  gomp_sem_post (&parent->taskwait_sem);
+	  parent->taskwait->in_taskwait = false;
+	  gomp_sem_post (&parent->taskwait->taskwait_sem);
 	}
     }
 }
@@ -736,6 +775,7 @@
   struct gomp_task *task = thr->task;
   struct gomp_task *child_task = NULL;
   struct gomp_task *to_free = NULL;
+  struct gomp_taskwait taskwait;
   int do_wake = 0;
 
   /* The acquire barrier on load of task->children here synchronizes
@@ -748,6 +788,7 @@
       || __atomic_load_n (&task->children, MEMMODEL_ACQUIRE) == NULL)
     return;
 
+  memset (&taskwait, 0, sizeof (taskwait));
   gomp_mutex_lock (&team->task_lock);
   while (1)
     {
@@ -754,6 +795,8 @@
       bool cancelled = false;
       if (task->children == NULL)
 	{
+	  bool destroy_taskwait = task->taskwait != NULL;
+	  task->taskwait = NULL;
 	  gomp_mutex_unlock (&team->task_lock);
 	  if (to_free)
 	    {
@@ -760,6 +803,8 @@
 	      gomp_finish_task (to_free);
 	      free (to_free);
 	    }
+	  if (destroy_taskwait)
+	    gomp_sem_destroy (&taskwait.taskwait_sem);
 	  return;
 	}
       if (task->children->kind == GOMP_TASK_WAITING)
@@ -780,9 +825,180 @@
 	    }
 	}
       else
+	{
+	  /* All tasks we are waiting for are already running
+	     in other threads.  Wait for them.  */
+	  if (task->taskwait == NULL)
+	    {
+	      taskwait.in_depend_wait = false;
+	      gomp_sem_init (&taskwait.taskwait_sem, 0);
+	      task->taskwait = &taskwait;
+	    }
+	  taskwait.in_taskwait = true;
+	}
+      gomp_mutex_unlock (&team->task_lock);
+      if (do_wake)
+	{
+	  gomp_team_barrier_wake (&team->barrier, do_wake);
+	  do_wake = 0;
+	}
+      if (to_free)
+	{
+	  gomp_finish_task (to_free);
+	  free (to_free);
+	  to_free = NULL;
+	}
+      if (child_task)
+	{
+	  thr->task = child_task;
+	  child_task->fn (child_task->fn_data);
+	  thr->task = task;
+	}
+      else
+	gomp_sem_wait (&taskwait.taskwait_sem);
+      gomp_mutex_lock (&team->task_lock);
+      if (child_task)
+	{
+	 finish_cancelled:;
+	  size_t new_tasks
+	    = gomp_task_run_post_handle_depend (child_task, team);
+	  child_task->prev_child->next_child = child_task->next_child;
+	  child_task->next_child->prev_child = child_task->prev_child;
+	  if (task->children == child_task)
+	    {
+	      if (child_task->next_child != child_task)
+		task->children = child_task->next_child;
+	      else
+		task->children = NULL;
+	    }
+	  gomp_clear_parent (child_task->children);
+	  gomp_task_run_post_remove_taskgroup (child_task);
+	  to_free = child_task;
+	  child_task = NULL;
+	  team->task_count--;
+	  if (new_tasks > 1)
+	    {
+	      do_wake = team->nthreads - team->task_running_count
+			- !task->in_tied_task;
+	      if (do_wake > new_tasks)
+		do_wake = new_tasks;
+	    }
+	}
+    }
+}
+
+/* This is like GOMP_taskwait, but we only wait for tasks that the
+   upcoming task depends on.  */
+
+static void
+gomp_task_maybe_wait_for_dependencies (void **depend)
+{
+  struct gomp_thread *thr = gomp_thread ();
+  struct gomp_task *task = thr->task;
+  struct gomp_team *team = thr->ts.team;
+  struct gomp_task_depend_entry elem, *ent = NULL;
+  struct gomp_taskwait taskwait;
+  struct gomp_task *last_parent_depends_on = NULL;
+  size_t ndepend = (uintptr_t) depend[0];
+  size_t nout = (uintptr_t) depend[1];
+  size_t i;
+  size_t num_awaited = 0;
+  struct gomp_task *child_task = NULL;
+  struct gomp_task *to_free = NULL;
+  int do_wake = 0;
+
+  gomp_mutex_lock (&team->task_lock);
+  for (i = 0; i < ndepend; i++)
+    {
+      elem.addr = depend[i + 2];
+      ent = htab_find (task->depend_hash, &elem);
+      for (; ent; ent = ent->next)
+	if (i >= nout && ent->is_in)
+	  continue;
+	else
+	  {
+	    struct gomp_task *tsk = ent->task;
+	    if (!tsk->parent_depends_on)
+	      {
+		tsk->parent_depends_on = true;
+		++num_awaited;
+		if (tsk->num_dependees == 0 && tsk->kind == GOMP_TASK_WAITING)
+		  {
+		    /* If a task we need to wait for is not already
+		       running and is ready to be scheduled, move it
+		       to front, so that we run it as soon as possible.  */
+		    if (last_parent_depends_on)
+		      {
+			tsk->prev_child->next_child = tsk->next_child;
+			tsk->next_child->prev_child = tsk->prev_child;
+			tsk->prev_child = last_parent_depends_on;
+			tsk->next_child = last_parent_depends_on->next_child;
+			tsk->prev_child->next_child = tsk;
+			tsk->next_child->prev_child = tsk;
+		      }
+		    else if (tsk != task->children)
+		      {
+			tsk->prev_child->next_child = tsk->next_child;
+			tsk->next_child->prev_child = tsk->prev_child;
+			tsk->prev_child = task->children;
+			tsk->next_child = task->children->next_child;
+			task->children = tsk;
+			tsk->prev_child->next_child = tsk;
+			tsk->next_child->prev_child = tsk;
+		      }
+		    last_parent_depends_on = tsk;
+		  }
+	      }
+	  }
+    }
+  if (num_awaited == 0)
+    {
+      gomp_mutex_unlock (&team->task_lock);
+      return;
+    }
+
+  memset (&taskwait, 0, sizeof (taskwait));
+  taskwait.n_depend = num_awaited;
+  taskwait.last_parent_depends_on = last_parent_depends_on;
+  gomp_sem_init (&taskwait.taskwait_sem, 0);
+  task->taskwait = &taskwait;
+
+  while (1)
+    {
+      bool cancelled = false;
+      if (taskwait.n_depend == 0)
+	{
+	  task->taskwait = NULL;
+	  gomp_mutex_unlock (&team->task_lock);
+	  if (to_free)
+	    {
+	      gomp_finish_task (to_free);
+	      free (to_free);
+	    }
+	  gomp_sem_destroy (&taskwait.taskwait_sem);
+	  return;
+	}
+      if (task->children->kind == GOMP_TASK_WAITING)
+	{
+	  child_task = task->children;
+	  cancelled
+	    = gomp_task_run_pre (child_task, task, child_task->taskgroup,
+				 team);
+	  if (__builtin_expect (cancelled, 0))
+	    {
+	      if (to_free)
+		{
+		  gomp_finish_task (to_free);
+		  free (to_free);
+		  to_free = NULL;
+		}
+	      goto finish_cancelled;
+	    }
+	}
+      else
 	/* All tasks we are waiting for are already running
 	   in other threads.  Wait for them.  */
-	task->in_taskwait = true;
+	taskwait.in_depend_wait = true;
       gomp_mutex_unlock (&team->task_lock);
       if (do_wake)
 	{
@@ -802,7 +1018,7 @@
 	  thr->task = task;
 	}
       else
-	gomp_sem_wait (&task->taskwait_sem);
+	gomp_sem_wait (&taskwait.taskwait_sem);
       gomp_mutex_lock (&team->task_lock);
       if (child_task)
 	{
@@ -809,6 +1025,8 @@
 	 finish_cancelled:;
 	  size_t new_tasks
 	    = gomp_task_run_post_handle_depend (child_task, team);
+	  if (child_task->parent_depends_on)
+	    --taskwait.n_depend;
 	  child_task->prev_child->next_child = child_task->next_child;
 	  child_task->next_child->prev_child = child_task->prev_child;
 	  if (task->children == child_task)
@@ -897,18 +1115,26 @@
       if (taskgroup->children == NULL)
 	{
 	  if (taskgroup->num_children)
-	    goto do_wait;
-	  gomp_mutex_unlock (&team->task_lock);
-	  if (to_free)
 	    {
-	      gomp_finish_task (to_free);
-	      free (to_free);
+	      if (task->children == NULL)
+		goto do_wait;
+	      child_task = task->children;
+            }
+          else
+	    {
+	      gomp_mutex_unlock (&team->task_lock);
+	      if (to_free)
+		{
+		  gomp_finish_task (to_free);
+		  free (to_free);
+		}
+	      goto finish;
 	    }
-	  goto finish;
 	}
-      if (taskgroup->children->kind == GOMP_TASK_WAITING)
+      else
+	child_task = taskgroup->children;
+      if (child_task->kind == GOMP_TASK_WAITING)
 	{
-	  child_task = taskgroup->children;
 	  cancelled
 	    = gomp_task_run_pre (child_task, child_task->parent, taskgroup,
 				 team);
@@ -925,6 +1151,7 @@
 	}
       else
 	{
+	  child_task = NULL;
 	 do_wait:
 	  /* All tasks we are waiting for are already running
 	     in other threads.  Wait for them.  */
@@ -956,20 +1183,9 @@
 	 finish_cancelled:;
 	  size_t new_tasks
 	    = gomp_task_run_post_handle_depend (child_task, team);
-	  child_task->prev_taskgroup->next_taskgroup
-	    = child_task->next_taskgroup;
-	  child_task->next_taskgroup->prev_taskgroup
-	    = child_task->prev_taskgroup;
-	  --taskgroup->num_children;
-	  if (taskgroup->children == child_task)
-	    {
-	      if (child_task->next_taskgroup != child_task)
-		taskgroup->children = child_task->next_taskgroup;
-	      else
-		taskgroup->children = NULL;
-	    }
 	  gomp_task_run_post_remove_parent (child_task);
 	  gomp_clear_parent (child_task->children);
+	  gomp_task_run_post_remove_taskgroup (child_task);
 	  to_free = child_task;
 	  child_task = NULL;
 	  team->task_count--;
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,54 @@
+2014-10-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/61200
+	* testsuite/libgomp.c/pr61200.c: New test.
+
+2014-09-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/63248
+	* testsuite/libgomp.c++/pr63248.C: New test.
+
+2014-08-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* task.c (GOMP_taskgroup_end): If taskgroup->num_children
+	is not zero, but taskgroup->children is NULL and there are
+	any task->children, schedule those instead of waiting.
+	* testsuite/libgomp.c/depend-6.c: New test.
+	* testsuite/libgomp.c/depend-7.c: New test.
+	* testsuite/libgomp.c/depend-8.c: New test.
+	* testsuite/libgomp.c/depend-9.c: New test.
+	* testsuite/libgomp.c/depend-10.c: New test.
+
+2014-08-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* libgomp.h (struct gomp_task_depend_entry): Add redundant_out field.
+	(struct gomp_taskwait): New type.
+	(struct gomp_task): Add taskwait and parent_depends_on, remove
+	in_taskwait and taskwait_sem fields.
+	(gomp_finish_task): Don't destroy taskwait_sem.
+	* task.c (gomp_init_task): Don't init in_taskwait, instead init
+	taskwait and parent_depends_on.
+	(GOMP_task): For if (0) tasks with depend clause that depend on
+	earlier tasks don't defer them, instead call
+	gomp_task_maybe_wait_for_dependencies to wait for the dependencies.
+	Initialize redundant_out field, for redundant out entries just
+	move them at the end of linked list instead of removing them
+	completely, and set redundant_out flag instead of redundant.
+	(gomp_task_run_pre): Update last_parent_depends_on if scheduling
+	that task.
+	(gomp_task_run_post_handle_dependers): If parent is in
+	gomp_task_maybe_wait_for_dependencies and newly runnable task
+	is not parent_depends_on, queue it in parent->children linked
+	list after all runnable tasks with parent_depends_on set.
+	Adjust for addition of taskwait indirection.
+	(gomp_task_run_post_remove_parent): If parent is in
+	gomp_task_maybe_wait_for_dependencies and task to be removed
+	is parent_depends_on, decrement n_depend and if needed awake
+	parent.  Adjust for addition of taskwait indirection.
+	(GOMP_taskwait): Adjust for addition of taskwait indirection.
+	(gomp_task_maybe_wait_for_dependencies): New function.
+	* testsuite/libgomp.c/depend-5.c: New test.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgomp/testsuite/libgomp.c++/pr63248.C
===================================================================
--- a/src/libgomp/testsuite/libgomp.c++/pr63248.C	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c++/pr63248.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,62 @@
+// PR c++/63248
+// { dg-do run }
+
+int *v;
+
+template <typename T>
+T
+foo (T A, T B)
+{
+  T a = 2;
+  T b = 4;
+
+#pragma omp target map(v[a:b])
+  v[a] = 1;
+
+#pragma omp target map(v[A:B])
+  v[a] = 2;
+
+#pragma omp target map(A)
+  A = 19;
+  return A;
+}
+
+template <int N>
+int
+bar (int A, int B)
+{
+#pragma omp target map(A)
+  A = 8;
+  if (A != 8)
+    __builtin_abort ();
+#pragma omp target map(A, B)
+  {
+    A = 1;
+    B = 2;
+  }
+  return A + B;
+}
+
+int
+baz (int A, int B)
+{
+#pragma omp target map(A)
+  A = 8;
+  if (A != 8)
+    __builtin_abort ();
+#pragma omp target map(A, B)
+  {
+    A = 1;
+    B = 2;
+  }
+  return A + B;
+}
+
+int
+main ()
+{
+  int a[10] = { 0 };
+  v = a;
+  if (foo (1, 5) != 19 || v[2] != 2 || bar<0> (5, 7) != 3 || baz (5, 7) != 3)
+    __builtin_abort ();
+}
Index: libgomp/testsuite/libgomp.c/depend-8.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-8.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-3.c"
Index: libgomp/testsuite/libgomp.c/pr61200.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr61200.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr61200.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,87 @@
+/* PR libgomp/61200 */
+/* { dg-do run } */
+
+#include <omp.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+volatile int x;
+
+void
+foo ()
+{
+  int var = 1;
+  int i;
+
+  for (i = 0; i < 2; i++)
+    {
+      if (i == 1)
+	{
+	  #pragma omp parallel num_threads(2)
+	    if (x)
+	      var++;
+	    else
+	      {
+		#pragma omp single
+		  sleep (2);
+	      }
+	}
+      else
+	{
+	  #pragma omp task shared(var)
+	  {
+	    sleep (1);
+	    var = 2;
+	  }
+	}
+    }
+  #pragma omp taskwait
+  if (var != 2)
+    abort ();
+}
+
+void
+bar ()
+{
+  int var = 1;
+  int i;
+
+  for (i = 0; i < 2; i++)
+    {
+      if (i == 0)
+	{
+	  #pragma omp task shared(var)
+	  {
+	    sleep (1);
+	    var = 2;
+	  }
+	}
+      else
+	{
+	  #pragma omp parallel num_threads(2)
+	    if (x)
+	      var++;
+	    else
+	      {
+		#pragma omp single
+		  sleep (2);
+	      }
+	}
+    }
+  #pragma omp taskwait
+  if (var != 2)
+    abort ();
+}
+
+int
+main ()
+{
+  omp_set_nested (1);
+  #pragma omp parallel num_threads(2)
+    #pragma omp single
+      foo ();
+  #pragma omp parallel num_threads(2)
+    #pragma omp single
+      bar ();
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/depend-10.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-10.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-5.c"
Index: libgomp/testsuite/libgomp.c/depend-5.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-5.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-5.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,98 @@
+#include <stdlib.h>
+
+__attribute__((noinline, noclone)) void
+f1 (int ifval)
+{
+  int x = 1, y = 2, z = 3;
+  #pragma omp parallel
+  #pragma omp single
+  {
+    #pragma omp task shared (x) depend(out: x)
+    x = 2;
+    #pragma omp task shared (x) depend(inout: x)
+    {
+      if (x != 2)
+	abort ();
+      x = 3;
+    }
+    #pragma omp task shared (x) depend(inout: x)
+    {
+      if (x != 3)
+	abort ();
+      x = 4;
+    }
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (z) depend(in: z)
+    if (z != 3)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task shared (y) depend(in: y)
+    if (y != 2)
+      abort ();
+    #pragma omp task if (ifval) shared (x, y) depend(in: x) depend(inout: y)
+    {
+      if (x != 4 || y != 2)
+	abort ();
+      y = 3;
+    }
+    if (ifval == 0)
+      {
+	/* The above if (0) task should have waited till all
+	   the tasks with x and y dependencies finish.  */
+	if (x != 4 || y != 3)
+	  abort ();
+	x = 5;
+	y = 4;
+      }
+    #pragma omp task shared (z) depend(inout: z)
+    {
+      if (z != 3)
+	abort ();
+      z = 4;
+    }
+    #pragma omp task shared (z) depend(inout: z)
+    {
+      if (z != 4)
+	abort ();
+      z = 5;
+    }
+    #pragma omp taskwait
+    if (x != (ifval ? 4 : 5) || y != (ifval ? 3 : 4) || z != 5)
+      abort ();
+    #pragma omp task if (ifval) shared (x, y) depend(in: x) depend(inout: y)
+    {
+      if (x != (ifval ? 4 : 5) || y != (ifval ? 3 : 4))
+	abort ();
+    }
+  }
+}
+
+int
+main ()
+{
+  f1 (0);
+  f1 (1);
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/depend-9.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-9.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-9.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-4.c"
Index: libgomp/testsuite/libgomp.c/depend-6.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-6.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-1.c"
Index: libgomp/testsuite/libgomp.c/depend-7.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/depend-7.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgomp/testsuite/libgomp.c/depend-7.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+/* { dg-set-target-env-var OMP_NUM_THREADS "1" } */
+
+#include "depend-2.c"
Index: libstdc++-v3/python/libstdcxx/v6/printers.py
===================================================================
--- a/src/libstdc++-v3/python/libstdcxx/v6/printers.py	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/python/libstdcxx/v6/printers.py	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,4 @@
-# Pretty-printers for libstc++.
+# Pretty-printers for libstdc++.
 
 # Copyright (C) 2008-2014 Free Software Foundation, Inc.
 
@@ -18,7 +18,51 @@
 import gdb
 import itertools
 import re
+import sys
 
+### Python 2 + Python 3 compatibility code
+
+# Resources about compatibility:
+#
+#  * <http://pythonhosted.org/six/>: Documentation of the "six" module
+
+# FIXME: The handling of e.g. std::basic_string (at least on char)
+# probably needs updating to work with Python 3's new string rules.
+#
+# In particular, Python 3 has a separate type (called byte) for
+# bytestrings, and a special b"" syntax for the byte literals; the old
+# str() type has been redefined to always store Unicode text.
+#
+# We probably can't do much about this until this GDB PR is addressed:
+# <https://sourceware.org/bugzilla/show_bug.cgi?id=17138>
+
+if sys.version_info[0] > 2:
+    ### Python 3 stuff
+    Iterator = object
+    # Python 3 folds these into the normal functions.
+    imap = map
+    izip = zip
+    # Also, int subsumes long
+    long = int
+else:
+    ### Python 2 stuff
+    class Iterator:
+        """Compatibility mixin for iterators
+
+        Instead of writing next() methods for iterators, write
+        __next__() methods and use this mixin to make them work in
+        Python 2 as well as Python 3.
+
+        Idea stolen from the "six" documentation:
+        <http://pythonhosted.org/six/#six.Iterator>
+        """
+
+        def next(self):
+            return self.__next__()
+
+    # In Python 2, we still need these from itertools
+    from itertools import imap, izip
+
 # Try to use the new-style pretty-printing if available.
 _use_gdb_pp = True
 try:
@@ -51,7 +95,7 @@
         # anything fancier here.
         field = typ.fields()[0]
         if not field.is_base_class:
-            raise ValueError, "Cannot find type %s::%s" % (str(orig), name)
+            raise ValueError("Cannot find type %s::%s" % (str(orig), name))
         typ = field.type
 
 class SharedPointerPrinter:
@@ -87,7 +131,7 @@
 class StdListPrinter:
     "Print a std::list"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__(self, nodetype, head):
             self.nodetype = nodetype
             self.base = head['_M_next']
@@ -97,7 +141,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == self.head:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -135,7 +179,7 @@
 class StdSlistPrinter:
     "Print a __gnu_cxx::slist"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__(self, nodetype, head):
             self.nodetype = nodetype
             self.base = head['_M_head']['_M_next']
@@ -144,7 +188,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == 0:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -180,7 +224,7 @@
 class StdVectorPrinter:
     "Print a std::vector"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__ (self, start, finish, bitvec):
             self.bitvec = bitvec
             if bitvec:
@@ -198,7 +242,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             count = self.count
             self.count = self.count + 1
             if self.bitvec:
@@ -265,7 +309,7 @@
 class StdTuplePrinter:
     "Print a std::tuple"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__ (self, head):
             self.head = head
 
@@ -276,13 +320,13 @@
                 # Set the actual head to the first pair.
                 self.head  = self.head.cast (nodes[0].type)
             elif len (nodes) != 0:
-                raise ValueError, "Top of tuple tree does not consist of a single node."
+                raise ValueError("Top of tuple tree does not consist of a single node.")
             self.count = 0
 
         def __iter__ (self):
             return self
 
-        def next (self):
+        def __next__ (self):
             nodes = self.head.type.fields ()
             # Check for further recursions in the inheritance tree.
             if len (nodes) == 0:
@@ -289,7 +333,7 @@
                 raise StopIteration
             # Check that this iteration has an expected structure.
             if len (nodes) != 2:
-                raise ValueError, "Cannot parse more than 2 nodes in a tuple tree."
+                raise ValueError("Cannot parse more than 2 nodes in a tuple tree.")
 
             # - Left node is the next recursion parent.
             # - Right node is the actual class contained in the tuple.
@@ -341,7 +385,7 @@
             return self.visualizer.display_hint ()
         return None
 
-class RbtreeIterator:
+class RbtreeIterator(Iterator):
     def __init__(self, rbtree):
         self.size = rbtree['_M_t']['_M_impl']['_M_node_count']
         self.node = rbtree['_M_t']['_M_impl']['_M_header']['_M_left']
@@ -353,7 +397,7 @@
     def __len__(self):
         return int (self.size)
 
-    def next(self):
+    def __next__(self):
         if self.count == self.size:
             raise StopIteration
         result = self.node
@@ -389,7 +433,7 @@
             return p.dereference()
     except:
         pass
-    raise ValueError, "Unsupported implementation for %s" % str(node.type)
+    raise ValueError("Unsupported implementation for %s" % str(node.type))
 
 # This is a pretty printer for std::_Rb_tree_iterator (which is
 # std::map::iterator), and has nothing to do with the RbtreeIterator
@@ -422,7 +466,7 @@
     "Print a std::map or std::multimap"
 
     # Turn an RbtreeIterator into a pretty-print iterator.
-    class _iter:
+    class _iter(Iterator):
         def __init__(self, rbiter, type):
             self.rbiter = rbiter
             self.count = 0
@@ -431,9 +475,9 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.count % 2 == 0:
-                n = self.rbiter.next()
+                n = next(self.rbiter)
                 n = n.cast(self.type).dereference()
                 n = get_value_from_Rb_tree_node(n)
                 self.pair = n
@@ -465,7 +509,7 @@
     "Print a std::set or std::multiset"
 
     # Turn an RbtreeIterator into a pretty-print iterator.
-    class _iter:
+    class _iter(Iterator):
         def __init__(self, rbiter, type):
             self.rbiter = rbiter
             self.count = 0
@@ -474,8 +518,8 @@
         def __iter__(self):
             return self
 
-        def next(self):
-            item = self.rbiter.next()
+        def __next__(self):
+            item = next(self.rbiter)
             item = item.cast(self.type).dereference()
             item = get_value_from_Rb_tree_node(item)
             # FIXME: this is weird ... what to do?
@@ -541,7 +585,7 @@
 class StdDequePrinter:
     "Print a std::deque"
 
-    class _iter:
+    class _iter(Iterator):
         def __init__(self, node, start, end, last, buffer_size):
             self.node = node
             self.p = start
@@ -553,7 +597,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.p == self.last:
                 raise StopIteration
 
@@ -638,7 +682,7 @@
     def display_hint (self):
         return 'string'
 
-class Tr1HashtableIterator:
+class Tr1HashtableIterator(Iterator):
     def __init__ (self, hash):
         self.buckets = hash['_M_buckets']
         self.bucket = 0
@@ -654,7 +698,7 @@
     def __iter__ (self):
         return self
 
-    def next (self):
+    def __next__ (self):
         if self.node == 0:
             raise StopIteration
         node = self.node.cast(self.node_type)
@@ -669,7 +713,7 @@
                 self.bucket = self.bucket + 1
         return result
 
-class StdHashtableIterator:
+class StdHashtableIterator(Iterator):
     def __init__(self, hash):
         self.node = hash['_M_before_begin']['_M_nxt']
         self.node_type = find_type(hash.type, '__node_type').pointer()
@@ -677,7 +721,7 @@
     def __iter__(self):
         return self
 
-    def next(self):
+    def __next__(self):
         if self.node == 0:
             raise StopIteration
         elt = self.node.cast(self.node_type).dereference()
@@ -706,10 +750,10 @@
         return '[%d]' % i
 
     def children (self):
-        counter = itertools.imap (self.format_count, itertools.count())
+        counter = imap (self.format_count, itertools.count())
         if self.typename.startswith('std::tr1'):
-            return itertools.izip (counter, Tr1HashtableIterator (self.hashtable()))
-        return itertools.izip (counter, StdHashtableIterator (self.hashtable()))
+            return izip (counter, Tr1HashtableIterator (self.hashtable()))
+        return izip (counter, StdHashtableIterator (self.hashtable()))
 
 class Tr1UnorderedMapPrinter:
     "Print a tr1::unordered_map"
@@ -741,15 +785,15 @@
         return '[%d]' % i
 
     def children (self):
-        counter = itertools.imap (self.format_count, itertools.count())
+        counter = imap (self.format_count, itertools.count())
         # Map over the hash table and flatten the result.
         if self.typename.startswith('std::tr1'):
-            data = self.flatten (itertools.imap (self.format_one, Tr1HashtableIterator (self.hashtable())))
+            data = self.flatten (imap (self.format_one, Tr1HashtableIterator (self.hashtable())))
             # Zip the two iterators together.
-            return itertools.izip (counter, data)
-        data = self.flatten (itertools.imap (self.format_one, StdHashtableIterator (self.hashtable())))
+            return izip (counter, data)
+        data = self.flatten (imap (self.format_one, StdHashtableIterator (self.hashtable())))
         # Zip the two iterators together.
-        return itertools.izip (counter, data)
+        return izip (counter, data)
         
 
     def display_hint (self):
@@ -758,7 +802,7 @@
 class StdForwardListPrinter:
     "Print a std::forward_list"
 
-    class _iterator:
+    class _iterator(Iterator):
         def __init__(self, nodetype, head):
             self.nodetype = nodetype
             self.base = head['_M_next']
@@ -767,7 +811,7 @@
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == 0:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -827,7 +871,7 @@
         # A small sanity check.
         # FIXME
         if not self.compiled_rx.match(name + '<>'):
-            raise ValueError, 'libstdc++ programming error: "%s" does not match' % name
+            raise ValueError('libstdc++ programming error: "%s" does not match' % name)
         printer = RxPrinter(name, function)
         self.subprinters.append(printer)
         self.lookup[name] = printer
Index: libstdc++-v3/doc/xml/manual/containers.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/containers.xml	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/doc/xml/manual/containers.xml	(.../branches/gcc-4_9-branch)
@@ -25,8 +25,9 @@
   <section xml:id="sequences.list.size" xreflabel="list::size() is O(n)"><info><title>list::size() is O(n)</title></info>
     
    <para>
-     Yes it is, and that's okay.  This is a decision that we preserved
-     when we imported SGI's STL implementation.  The following is
+     Yes it is, and that was okay until the 2011 edition of the C++ standard.
+     In future GCC will change it to O(1) but O(N) was a decision that we
+     preserved when we imported SGI's STL implementation.  The following is
      quoted from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.sgi.com/tech/stl/FAQ.html">their FAQ</link>:
    </para>
    <blockquote>
@@ -72,26 +73,6 @@
   </section>
 </section>
 
-<section xml:id="containers.sequences.vector" xreflabel="vector"><info><title>vector</title></info>
-<?dbhtml filename="vector.html"?>
-  
-  <para>
-  </para>
-  <section xml:id="sequences.vector.management" xreflabel="Space Overhead Management"><info><title>Space Overhead Management</title></info>
-    
-   <para>
-     In <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/ml/libstdc++/2002-04/msg00105.html">this
-     message to the list</link>, Daniel Kostecky announced work on an
-     alternate form of <code>std::vector</code> that would support
-     hints on the number of elements to be over-allocated.  The design
-     was also described, along with possible implementation choices.
-   </para>
-   <para>
-     The first two alpha releases were announced <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/ml/libstdc++/2002-07/msg00048.html">here</link>
-     and <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/ml/libstdc++/2002-07/msg00111.html">here</link>.
-   </para>
-
-  </section></section>
 </section>
 
 <!-- Sect1 02 : Associative -->
Index: libstdc++-v3/doc/xml/manual/status_cxx2011.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/status_cxx2011.xml	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/doc/xml/manual/status_cxx2011.xml	(.../branches/gcc-4_9-branch)
@@ -606,10 +606,11 @@
       <entry/>
     </row>
     <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
       <entry>20.6.12.4</entry>
       <entry><code>uninitialized_fill_n</code></entry>
-      <entry>Y</entry>
-      <entry/>
+      <entry>Partial</entry>
+      <entry>Returns <code>void</code>.</entry>
     </row>
     <row>
       <entry>20.6.13</entry>
@@ -1184,10 +1185,11 @@
       <entry/>
     </row>
     <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
       <entry>22.3.3.1</entry>
       <entry>Character classification</entry>
-      <entry>Y</entry>
-      <entry/>
+      <entry>Partial</entry>
+      <entry>Missing <code>isblank</code>.</entry>
     </row>
     <row>
       <entry>22.3.3.2</entry>
@@ -1429,7 +1431,7 @@
       <entry>23.3.5</entry>
       <entry>Class template <code>list</code></entry>
       <entry>Partial</entry>
-      <entry>Incomplete allocator support.</entry>
+      <entry>O(N) size. Incomplete allocator support.</entry>
     </row>
     <row>
       <entry>23.3.6</entry>
@@ -1640,10 +1642,11 @@
       <entry/>
     </row>
     <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
       <entry>25.3</entry>
       <entry>Mutating sequence operations</entry>
-      <entry>Y</entry>
-      <entry/>
+      <entry>Partial</entry>
+      <entry><code>rotate</code> returns <code>void</code>.</entry>
     </row>
     <row>
       <entry>25.4</entry>
@@ -2050,10 +2053,13 @@
       <entry/>
     </row>
     <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
       <entry>26.8</entry>
       <entry>C Library</entry>
-      <entry>Y</entry>
-      <entry/>
+      <entry>Partial</entry>
+      <entry><code>&lt;ctgmath&gt;</code> doesn't include
+	<code>&lt;ccomplex&gt;</code>
+      </entry>
     </row>
     <row>
       <entry>
Index: libstdc++-v3/doc/html/index.html
===================================================================
--- a/src/libstdc++-v3/doc/html/index.html	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/doc/html/index.html	(.../branches/gcc-4_9-branch)
@@ -43,7 +43,7 @@
 </a></span></dt><dd><dl><dt><span class="section"><a href="manual/localization.html#std.localization.locales">Locales</a></span></dt><dd><dl><dt><span class="section"><a href="manual/localization.html#std.localization.locales.locale">locale</a></span></dt><dd><dl><dt><span class="section"><a href="manual/localization.html#locales.locale.req">Requirements</a></span></dt><dt><span class="section"><a href="manual/localization.html#locales.locale.design">Design</a></span></dt><dt><span class="section"><a href="manual/localization.html#locales.locale.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="manual/localization.html#locale.impl.c">Interacting with "C" locales</a></span></dt></dl></dd><dt><span class="section"><a href="manual/localization.html#locales.locale.future">Future</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/facets.html">Facets</a></span></dt><dd><dl><dt><span class="section"><a href="manual/facets.html#std.localization.facet.ctype">ctype</a></span></dt><dd><dl><dt><span class="section"><a href="manual/facets.html#facet.ctype.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="manual/facets.html#idm269891548288">Specializations</a></span></dt></dl></dd><dt><span class="section"><a href="manual/facets.html#facet.ctype.future">Future</a></span></dt></dl></dd><dt><span class="section"><a href="manual/facets.html#std.localization.facet.codecvt">codecvt</a></span></dt><dd><dl><dt><span class="section"><a href="manual/facets.html#facet.codecvt.req">Requirements</a></span></dt><dt><span class="section"><a href="manual/facets.html#facet.codecvt.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="manual/facets.html#codecvt.design.wchar_t_size"><span class="type">wchar_t</span> Size</a></span></dt><dt><span class="section"><a href="manual/facets.html#codecvt.design.unicode">Support for Unicode</a></span></dt><dt><span class="section"><a href="manual/facets.html#codecvt.design.issues">Other Issues</a></span></dt></dl></dd><dt><span class="section"><a href="manual/facets.html#facet.codecvt.impl">Implementation</a></span></dt><dt><span class="section"><a href="manual/facets.html#facet.codecvt.use">Use</a></span></dt><dt><span class="section"><a href="manual/facets.html#facet.codecvt.future">Future</a></span></dt></dl></dd><dt><span class="section"><a href="manual/facets.html#manual.localization.facet.messages">messages</a></span></dt><dd><dl><dt><span class="section"><a href="manual/facets.html#facet.messages.req">Requirements</a></span></dt><dt><span class="section"><a href="manual/facets.html#facet.messages.design">Design</a></span></dt><dt><span class="section"><a href="manual/facets.html#facet.messages.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="manual/facets.html#messages.impl.models">Models</a></span></dt><dt><span class="section"><a href="manual/facets.html#messages.impl.gnu">The GNU Model</a></span></dt></dl></dd><dt><span class="section"><a href="manual/facets.html#facet.messages.use">Use</a></span></dt><dt><span class="section"><a href="manual/facets.html#facet.messages.future">Future</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/containers.html">9. 
   Containers
   
-</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd><dt><span class="section"><a href="manual/containers.html#containers.sequences.vector">vector</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers.html#sequences.vector.management">Space Overhead Management</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="manual/associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="manual/associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="manual/associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="manual/associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="manual/unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="manual/unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="manual/unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/iterators.html">10. 
+</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="manual/associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="manual/associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="manual/associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="manual/associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="manual/unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="manual/unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="manual/unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="manual/containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/iterators.html">10. 
   Iterators
   
 </a></span></dt><dd><dl><dt><span class="section"><a href="manual/iterators.html#std.iterators.predefined">Predefined</a></span></dt><dd><dl><dt><span class="section"><a href="manual/iterators.html#iterators.predefined.vs_pointers">Iterators vs. Pointers</a></span></dt><dt><span class="section"><a href="manual/iterators.html#iterators.predefined.end">One Past the End</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/algorithms.html">11. 
Index: libstdc++-v3/doc/html/manual/status.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/status.html	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/doc/html/manual/status.html	(.../branches/gcc-4_9-branch)
@@ -170,7 +170,7 @@
 	<span class="emphasis"><em>20</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>General utilities</em></span>
-      </td></tr><tr><td align="left">20.1</td><td align="left">General</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.2</td><td align="left">Utility components</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.2.1</td><td align="left">Operators</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.2.2</td><td align="left">Swap</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.2.3</td><td align="left"><code class="code">forward</code> and <code class="code">move</code> helpers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.2.4</td><td align="left">Function template <code class="code">declval</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3</td><td align="left">Pairs</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.3.1</td><td align="left">In general</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.3.2</td><td align="left">Class template <code class="code">pair</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3.3</td><td align="left">Specialized algorithms</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3.4</td><td align="left">Tuple-like access to <code class="code">pair</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3.5</td><td align="left">Piecewise construction</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4</td><td align="left">Tuples</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.4.1</td><td align="left">In general</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.4.2</td><td align="left">Class template <code class="code">tuple</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.4.2.1</td><td align="left">Construction</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.2</td><td align="left">Assignment</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.3</td><td align="left">Swap</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.4</td><td align="left">Tuple creation functions</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.5</td><td align="left">Tuple helper classes</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.6</td><td align="left">Element access</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.7</td><td align="left">Relational operators</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.8</td><td align="left">Tuple traits</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.9</td><td align="left">Tuple specialized algorithms</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5</td><td align="left">Class template <code class="code">bitset</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.1</td><td align="left"><code class="code">bitset</code> constructors</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.2</td><td align="left"><code class="code">bitset</code> members</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.3</td><td align="left"><code class="code">bitset</code> hash support</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.4</td><td align="left"><code class="code">bitset</code> operators</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6</td><td align="left">Memory</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.1</td><td align="left">In general</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.2</td><td align="left">Header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.3</td><td align="left">Pointer traits</td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">20.6.4</td><td align="left">Pointer safety</td><td align="left">Partial</td><td align="left"></td></tr><tr bgcolor="#C8B0B0"><td align="left">20.6.5</td><td align="left">Align</td><td align="left">N</td><td align="left"></td></tr><tr><td align="left">20.6.6</td><td align="left">Allocator argument tag</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.7</td><td align="left"><code class="code">uses_allocator</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.8</td><td align="left">Allocator traits</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.9</td><td align="left">The default allocator</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.10</td><td align="left">Raw storage iterator</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.11</td><td align="left">Temporary buffers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.12</td><td align="left">Specialized algorithms</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.12.1</td><td align="left"><code class="code">addressof</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.12.2</td><td align="left"><code class="code">uninitialized_copy</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.12.3</td><td align="left"><code class="code">uninitialized_fill</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.12.4</td><td align="left"><code class="code">uninitialized_fill_n</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.13</td><td align="left">C library</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7</td><td align="left">Smart pointers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.7.1</td><td align="left">Class template <code class="code">unique_ptr</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7.2</td><td align="left">Shared-ownership pointers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7.2.1</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7.2.2</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left">Y</td><td align="left">
+      </td></tr><tr><td align="left">20.1</td><td align="left">General</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.2</td><td align="left">Utility components</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.2.1</td><td align="left">Operators</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.2.2</td><td align="left">Swap</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.2.3</td><td align="left"><code class="code">forward</code> and <code class="code">move</code> helpers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.2.4</td><td align="left">Function template <code class="code">declval</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3</td><td align="left">Pairs</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.3.1</td><td align="left">In general</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.3.2</td><td align="left">Class template <code class="code">pair</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3.3</td><td align="left">Specialized algorithms</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3.4</td><td align="left">Tuple-like access to <code class="code">pair</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.3.5</td><td align="left">Piecewise construction</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4</td><td align="left">Tuples</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.4.1</td><td align="left">In general</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.4.2</td><td align="left">Class template <code class="code">tuple</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.4.2.1</td><td align="left">Construction</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.2</td><td align="left">Assignment</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.3</td><td align="left">Swap</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.4</td><td align="left">Tuple creation functions</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.5</td><td align="left">Tuple helper classes</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.6</td><td align="left">Element access</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.7</td><td align="left">Relational operators</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.8</td><td align="left">Tuple traits</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.4.2.9</td><td align="left">Tuple specialized algorithms</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5</td><td align="left">Class template <code class="code">bitset</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.1</td><td align="left"><code class="code">bitset</code> constructors</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.2</td><td align="left"><code class="code">bitset</code> members</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.3</td><td align="left"><code class="code">bitset</code> hash support</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.5.4</td><td align="left"><code class="code">bitset</code> operators</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6</td><td align="left">Memory</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.1</td><td align="left">In general</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.2</td><td align="left">Header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.3</td><td align="left">Pointer traits</td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">20.6.4</td><td align="left">Pointer safety</td><td align="left">Partial</td><td align="left"></td></tr><tr bgcolor="#C8B0B0"><td align="left">20.6.5</td><td align="left">Align</td><td align="left">N</td><td align="left"></td></tr><tr><td align="left">20.6.6</td><td align="left">Allocator argument tag</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.7</td><td align="left"><code class="code">uses_allocator</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.8</td><td align="left">Allocator traits</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.9</td><td align="left">The default allocator</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.10</td><td align="left">Raw storage iterator</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.11</td><td align="left">Temporary buffers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.12</td><td align="left">Specialized algorithms</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.6.12.1</td><td align="left"><code class="code">addressof</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.12.2</td><td align="left"><code class="code">uninitialized_copy</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.6.12.3</td><td align="left"><code class="code">uninitialized_fill</code></td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">20.6.12.4</td><td align="left"><code class="code">uninitialized_fill_n</code></td><td align="left">Partial</td><td align="left">Returns <code class="code">void</code>.</td></tr><tr><td align="left">20.6.13</td><td align="left">C library</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7</td><td align="left">Smart pointers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20.7.1</td><td align="left">Class template <code class="code">unique_ptr</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7.2</td><td align="left">Shared-ownership pointers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7.2.1</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">20.7.2.2</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left">Y</td><td align="left">
 	<p>
 	  Uses code from
 	  <a class="link" href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm" target="_top">boost::shared_ptr</a>.
@@ -190,7 +190,7 @@
       	<span class="emphasis"><em>22</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Localization</em></span>
-      </td></tr><tr><td align="left">22.1</td><td align="left">General</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.2</td><td align="left">Header <code class="code">&lt;locale&gt;</code> synopsis</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.3</td><td align="left">Locales</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22.3.1</td><td align="left">Class <code class="code">locale</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.3.2</td><td align="left"><code class="code">locale</code> globals</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.3.3</td><td align="left">Convenience interfaces</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22.3.3.1</td><td align="left">Character classification</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.3.3.2</td><td align="left">Conversions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22.3.3.2.1</td><td align="left">Character conversions</td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#C8B0B0"><td align="left">22.3.3.2.2</td><td align="left"><code class="code">string</code> conversions</td><td align="left">N</td><td align="left"></td></tr><tr bgcolor="#C8B0B0"><td align="left">22.3.3.2.3</td><td align="left">Buffer conversions</td><td align="left">N</td><td align="left"></td></tr><tr><td align="left">22.4</td><td align="left">Standard <code class="code">locale</code> categories</td><td align="left"></td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">22.4.1</td><td align="left">The <code class="code">ctype</code> category</td><td align="left">Partial</td><td align="left">Missing <code class="code">codecvt&lt;char16_t&gt;</code> and
+      </td></tr><tr><td align="left">22.1</td><td align="left">General</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.2</td><td align="left">Header <code class="code">&lt;locale&gt;</code> synopsis</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.3</td><td align="left">Locales</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22.3.1</td><td align="left">Class <code class="code">locale</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.3.2</td><td align="left"><code class="code">locale</code> globals</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.3.3</td><td align="left">Convenience interfaces</td><td align="left"></td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">22.3.3.1</td><td align="left">Character classification</td><td align="left">Partial</td><td align="left">Missing <code class="code">isblank</code>.</td></tr><tr><td align="left">22.3.3.2</td><td align="left">Conversions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22.3.3.2.1</td><td align="left">Character conversions</td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#C8B0B0"><td align="left">22.3.3.2.2</td><td align="left"><code class="code">string</code> conversions</td><td align="left">N</td><td align="left"></td></tr><tr bgcolor="#C8B0B0"><td align="left">22.3.3.2.3</td><td align="left">Buffer conversions</td><td align="left">N</td><td align="left"></td></tr><tr><td align="left">22.4</td><td align="left">Standard <code class="code">locale</code> categories</td><td align="left"></td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">22.4.1</td><td align="left">The <code class="code">ctype</code> category</td><td align="left">Partial</td><td align="left">Missing <code class="code">codecvt&lt;char16_t&gt;</code> and
              <code class="code">codecvt&lt;char32_t&gt;</code></td></tr><tr><td align="left">22.4.2</td><td align="left">The numeric category</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22.4.2.1</td><td align="left"><code class="code">num_get</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.2.2</td><td align="left"><code class="code">num_put</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.3</td><td align="left">The numeric punctuation facet</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.4</td><td align="left">The collate category</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.5</td><td align="left">The time category</td><td align="left"></td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">22.4.5.1</td><td align="left">Class template <code class="code">time_get</code></td><td align="left">Partial</td><td align="left">Missing <code class="code">get</code> and <code class="code">do_get</code></td></tr><tr bgcolor="#B0B0B0"><td align="left">22.4.5.2</td><td align="left">Class template <code class="code">time_get_byname</code></td><td align="left">Partial</td><td align="left">Likewise</td></tr><tr><td align="left">22.4.5.3</td><td align="left">Class template <code class="code">time_put</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.5.3</td><td align="left">Class template <code class="code">time_put_byname</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.6</td><td align="left">The monetary category</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">22.4.6.1</td><td align="left">Class template <code class="code">money_get</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.6.2</td><td align="left">Class template <code class="code">money_put</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.6.3</td><td align="left">Class template <code class="code">money_punct</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.6.4</td><td align="left">Class template <code class="code">money_punct_byname</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.7</td><td align="left">The message retrieval category</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">22.4.8</td><td align="left">Program-defined facets</td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#C8B0B0"><td align="left">22.5</td><td align="left">Standard code conversion facets</td><td align="left">N</td><td align="left"></td></tr><tr><td align="left">22.6</td><td align="left">C Library Locales</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">
 	<span class="emphasis"><em>23</em></span>
       </td><td colspan="3" align="left">
@@ -197,7 +197,7 @@
 	<span class="emphasis"><em>Containers</em></span>
       </td></tr><tr><td align="left">23.1</td><td align="left">General</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.2</td><td align="left">Container requirements</td><td align="left"></td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">23.2.1</td><td align="left">General container requirements</td><td align="left">Partial</td><td align="left"><code class="code">deque</code> and <code class="code">list</code> do not
              meet the requirements
-             relating to allocator use and propagation.</td></tr><tr><td align="left">23.2.2</td><td align="left">Container data races</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.2.3</td><td align="left">Sequence containers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.2.4</td><td align="left">Associative containers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.2.5</td><td align="left">Unordered associative containers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.3</td><td align="left">Sequence containers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.3.2</td><td align="left">Class template <code class="code">array</code></td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">23.3.3</td><td align="left">Class template <code class="code">deque</code></td><td align="left">Partial</td><td align="left">Incomplete allocator support.</td></tr><tr><td align="left">23.3.4</td><td align="left">Class template <code class="code">forward_list</code></td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">23.3.5</td><td align="left">Class template <code class="code">list</code></td><td align="left">Partial</td><td align="left">Incomplete allocator support.</td></tr><tr><td align="left">23.3.6</td><td align="left">Class template <code class="code">vector</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.3.7</td><td align="left">Class <code class="code">vector&lt;bool&gt;</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4</td><td align="left">Associative containers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.4.4</td><td align="left">Class template <code class="code">map</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4.5</td><td align="left">Class template <code class="code">multimap</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4.6</td><td align="left">Class template <code class="code">set</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4.7</td><td align="left">Class template <code class="code">multiset</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5</td><td align="left">Unordered associative containers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.5.4</td><td align="left">Class template <code class="code">unordered_map</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5.5</td><td align="left">Class template <code class="code">unordered_multimap</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5.6</td><td align="left">Class template <code class="code">unordered_set</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5.7</td><td align="left">Class template <code class="code">unordered_multiset</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.6</td><td align="left">Container adaptors</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.6.1</td><td align="left">Class template <code class="code">queue</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.6.2</td><td align="left">Class template <code class="code">priority_queue</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.6.3</td><td align="left">Class template <code class="code">stack</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">
+             relating to allocator use and propagation.</td></tr><tr><td align="left">23.2.2</td><td align="left">Container data races</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.2.3</td><td align="left">Sequence containers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.2.4</td><td align="left">Associative containers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.2.5</td><td align="left">Unordered associative containers</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.3</td><td align="left">Sequence containers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.3.2</td><td align="left">Class template <code class="code">array</code></td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">23.3.3</td><td align="left">Class template <code class="code">deque</code></td><td align="left">Partial</td><td align="left">Incomplete allocator support.</td></tr><tr><td align="left">23.3.4</td><td align="left">Class template <code class="code">forward_list</code></td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">23.3.5</td><td align="left">Class template <code class="code">list</code></td><td align="left">Partial</td><td align="left">O(N) size. Incomplete allocator support.</td></tr><tr><td align="left">23.3.6</td><td align="left">Class template <code class="code">vector</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.3.7</td><td align="left">Class <code class="code">vector&lt;bool&gt;</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4</td><td align="left">Associative containers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.4.4</td><td align="left">Class template <code class="code">map</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4.5</td><td align="left">Class template <code class="code">multimap</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4.6</td><td align="left">Class template <code class="code">set</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.4.7</td><td align="left">Class template <code class="code">multiset</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5</td><td align="left">Unordered associative containers</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.5.4</td><td align="left">Class template <code class="code">unordered_map</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5.5</td><td align="left">Class template <code class="code">unordered_multimap</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5.6</td><td align="left">Class template <code class="code">unordered_set</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.5.7</td><td align="left">Class template <code class="code">unordered_multiset</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.6</td><td align="left">Container adaptors</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">23.6.1</td><td align="left">Class template <code class="code">queue</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.6.2</td><td align="left">Class template <code class="code">priority_queue</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">23.6.3</td><td align="left">Class template <code class="code">stack</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">
 	<span class="emphasis"><em>24</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Iterators</em></span>
@@ -205,11 +205,13 @@
 	<span class="emphasis"><em>25</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Algorithms</em></span>
-      </td></tr><tr><td align="left">25.1</td><td align="left">General</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">25.2</td><td align="left">Non-modifying sequence operations</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">25.3</td><td align="left">Mutating sequence operations</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">25.4</td><td align="left">Sorting and related operations</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">25.5</td><td align="left">C library algorithms</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">25.1</td><td align="left">General</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">25.2</td><td align="left">Non-modifying sequence operations</td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">25.3</td><td align="left">Mutating sequence operations</td><td align="left">Partial</td><td align="left"><code class="code">rotate</code> returns <code class="code">void</code>.</td></tr><tr><td align="left">25.4</td><td align="left">Sorting and related operations</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">25.5</td><td align="left">C library algorithms</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">
       <span class="emphasis"><em>26</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Numerics</em></span>
-      </td></tr><tr><td align="left">26.1</td><td align="left">General</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.2</td><td align="left">Numeric type requirements</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.3</td><td align="left">The floating-point environment</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.4</td><td align="left">Complex numbers</td><td align="left">Partial</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5</td><td align="left">Random number generation</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.1</td><td align="left">Requirements</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.2</td><td align="left">Header <code class="code">&lt;random&gt;</code> synopsis</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.3</td><td align="left">Random number engine class templates</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.3.1</td><td align="left">Class template <code class="code">linear_congruential_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.3.2</td><td align="left">Class template <code class="code">mersenne_twister_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.3.3</td><td align="left">Class template <code class="code">subtract_with_carry_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.4</td><td align="left">Random number engine adaptor class templates</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.4.2</td><td align="left">Class template <code class="code">discard_block_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.4.3</td><td align="left">Class template <code class="code">independent_bits_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.4.4</td><td align="left">Class template <code class="code">shuffle_order_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.5</td><td align="left">Engines and engine adaptors with predefined parameters</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.6</td><td align="left">Class <code class="code">random_device</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.7</td><td align="left">Utilities</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.7.1</td><td align="left">Class <code class="code">seed_seq</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.7.2</td><td align="left">Function template <code class="code">generate_canonical</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8</td><td align="left">Random number distribution class templates</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.2</td><td align="left">Uniform distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.2.1</td><td align="left">Class template <code class="code">uniform_int_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.2.2</td><td align="left">Class template <code class="code">uniform_real_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3</td><td align="left">Bernoulli distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.3.1</td><td align="left">Class <code class="code">bernoulli_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3.2</td><td align="left">Class template <code class="code">binomial_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3.3</td><td align="left">Class template <code class="code">geometric_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3.4</td><td align="left">Class template <code class="code">negative_binomial_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4</td><td align="left">Poisson distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.4.1</td><td align="left">Class template <code class="code">poisson_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.2</td><td align="left">Class template <code class="code">exponential_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.3</td><td align="left">Class template <code class="code">gamma_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.4</td><td align="left">Class template <code class="code">weibull_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.5</td><td align="left">Class template <code class="code">extreme_value_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5</td><td align="left">Normal distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.5.1</td><td align="left">Class template <code class="code">normal_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.2</td><td align="left">Class template <code class="code">lognormal_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.3</td><td align="left">Class template <code class="code">chi_squared_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.4</td><td align="left">Class template <code class="code">cauchy_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.5</td><td align="left">Class template <code class="code">fisher_f_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.6</td><td align="left">Class template <code class="code">student_t_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.6</td><td align="left">Sampling distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.6.1</td><td align="left">Class template <code class="code">discrete_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.6.2</td><td align="left">Class template <code class="code">piecewise_constant_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.6.3</td><td align="left">Class template <code class="code">piecewise_linear_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6</td><td align="left">Numeric arrays</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.6.1</td><td align="left">Header <code class="code">&lt;valarray&gt;</code> synopsis</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.2</td><td align="left">Class template <code class="code">valarray</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.3</td><td align="left"><code class="code">valarray</code> non-member operations</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.4</td><td align="left">Class <code class="code">slice</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.5</td><td align="left">Class template <code class="code">slice_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.6</td><td align="left">The <code class="code">gslice</code> class</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.7</td><td align="left">Class template <code class="code">gslice_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.8</td><td align="left">Class template <code class="code">mask_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.9</td><td align="left">Class template <code class="code">indirect_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.10</td><td align="left"><code class="code">valarray</code> range access</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7</td><td align="left">Generalized numeric operations</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.7.1</td><td align="left">Header <code class="code">&lt;numeric&gt;</code> synopsis</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.2</td><td align="left"><code class="code">accumulate</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.3</td><td align="left"><code class="code">inner_product</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.4</td><td align="left"><code class="code">partial_sum</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.5</td><td align="left"><code class="code">adjacent_difference</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.6</td><td align="left">iota</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.8</td><td align="left">C Library</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">26.1</td><td align="left">General</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.2</td><td align="left">Numeric type requirements</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.3</td><td align="left">The floating-point environment</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.4</td><td align="left">Complex numbers</td><td align="left">Partial</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5</td><td align="left">Random number generation</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.1</td><td align="left">Requirements</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.2</td><td align="left">Header <code class="code">&lt;random&gt;</code> synopsis</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.3</td><td align="left">Random number engine class templates</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.3.1</td><td align="left">Class template <code class="code">linear_congruential_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.3.2</td><td align="left">Class template <code class="code">mersenne_twister_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.3.3</td><td align="left">Class template <code class="code">subtract_with_carry_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.4</td><td align="left">Random number engine adaptor class templates</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.4.2</td><td align="left">Class template <code class="code">discard_block_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.4.3</td><td align="left">Class template <code class="code">independent_bits_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.4.4</td><td align="left">Class template <code class="code">shuffle_order_engine</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.5</td><td align="left">Engines and engine adaptors with predefined parameters</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.6</td><td align="left">Class <code class="code">random_device</code></td><td align="left">Y</td><td align="left">Missing constexpr</td></tr><tr><td align="left">26.5.7</td><td align="left">Utilities</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.7.1</td><td align="left">Class <code class="code">seed_seq</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.7.2</td><td align="left">Function template <code class="code">generate_canonical</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8</td><td align="left">Random number distribution class templates</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.2</td><td align="left">Uniform distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.2.1</td><td align="left">Class template <code class="code">uniform_int_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.2.2</td><td align="left">Class template <code class="code">uniform_real_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3</td><td align="left">Bernoulli distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.3.1</td><td align="left">Class <code class="code">bernoulli_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3.2</td><td align="left">Class template <code class="code">binomial_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3.3</td><td align="left">Class template <code class="code">geometric_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.3.4</td><td align="left">Class template <code class="code">negative_binomial_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4</td><td align="left">Poisson distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.4.1</td><td align="left">Class template <code class="code">poisson_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.2</td><td align="left">Class template <code class="code">exponential_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.3</td><td align="left">Class template <code class="code">gamma_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.4</td><td align="left">Class template <code class="code">weibull_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.4.5</td><td align="left">Class template <code class="code">extreme_value_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5</td><td align="left">Normal distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.5.1</td><td align="left">Class template <code class="code">normal_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.2</td><td align="left">Class template <code class="code">lognormal_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.3</td><td align="left">Class template <code class="code">chi_squared_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.4</td><td align="left">Class template <code class="code">cauchy_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.5</td><td align="left">Class template <code class="code">fisher_f_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.5.6</td><td align="left">Class template <code class="code">student_t_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.6</td><td align="left">Sampling distributions</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.5.8.6.1</td><td align="left">Class template <code class="code">discrete_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.6.2</td><td align="left">Class template <code class="code">piecewise_constant_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.5.8.6.3</td><td align="left">Class template <code class="code">piecewise_linear_distribution</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6</td><td align="left">Numeric arrays</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.6.1</td><td align="left">Header <code class="code">&lt;valarray&gt;</code> synopsis</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.2</td><td align="left">Class template <code class="code">valarray</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.3</td><td align="left"><code class="code">valarray</code> non-member operations</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.4</td><td align="left">Class <code class="code">slice</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.5</td><td align="left">Class template <code class="code">slice_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.6</td><td align="left">The <code class="code">gslice</code> class</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.7</td><td align="left">Class template <code class="code">gslice_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.8</td><td align="left">Class template <code class="code">mask_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.9</td><td align="left">Class template <code class="code">indirect_array</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.6.10</td><td align="left"><code class="code">valarray</code> range access</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7</td><td align="left">Generalized numeric operations</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">26.7.1</td><td align="left">Header <code class="code">&lt;numeric&gt;</code> synopsis</td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.2</td><td align="left"><code class="code">accumulate</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.3</td><td align="left"><code class="code">inner_product</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.4</td><td align="left"><code class="code">partial_sum</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.5</td><td align="left"><code class="code">adjacent_difference</code></td><td align="left">Y</td><td align="left"></td></tr><tr><td align="left">26.7.6</td><td align="left">iota</td><td align="left">Y</td><td align="left"></td></tr><tr bgcolor="#B0B0B0"><td align="left">26.8</td><td align="left">C Library</td><td align="left">Partial</td><td align="left"><code class="code">&lt;ctgmath&gt;</code> doesn't include
+	<code class="code">&lt;ccomplex&gt;</code>
+      </td></tr><tr><td align="left">
 	<span class="emphasis"><em>27</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Input/output library</em></span>
Index: libstdc++-v3/doc/html/manual/std_contents.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/std_contents.html	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/doc/html/manual/std_contents.html	(.../branches/gcc-4_9-branch)
@@ -21,7 +21,7 @@
 </a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#std.localization.locales">Locales</a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#std.localization.locales.locale">locale</a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#locales.locale.req">Requirements</a></span></dt><dt><span class="section"><a href="localization.html#locales.locale.design">Design</a></span></dt><dt><span class="section"><a href="localization.html#locales.locale.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#locale.impl.c">Interacting with "C" locales</a></span></dt></dl></dd><dt><span class="section"><a href="localization.html#locales.locale.future">Future</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="facets.html">Facets</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#std.localization.facet.ctype">ctype</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#facet.ctype.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#idm269891548288">Specializations</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#facet.ctype.future">Future</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#std.localization.facet.codecvt">codecvt</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#facet.codecvt.req">Requirements</a></span></dt><dt><span class="section"><a href="facets.html#facet.codecvt.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#codecvt.design.wchar_t_size"><span class="type">wchar_t</span> Size</a></span></dt><dt><span class="section"><a href="facets.html#codecvt.design.unicode">Support for Unicode</a></span></dt><dt><span class="section"><a href="facets.html#codecvt.design.issues">Other Issues</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#facet.codecvt.impl">Implementation</a></span></dt><dt><span class="section"><a href="facets.html#facet.codecvt.use">Use</a></span></dt><dt><span class="section"><a href="facets.html#facet.codecvt.future">Future</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#manual.localization.facet.messages">messages</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#facet.messages.req">Requirements</a></span></dt><dt><span class="section"><a href="facets.html#facet.messages.design">Design</a></span></dt><dt><span class="section"><a href="facets.html#facet.messages.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#messages.impl.models">Models</a></span></dt><dt><span class="section"><a href="facets.html#messages.impl.gnu">The GNU Model</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#facet.messages.use">Use</a></span></dt><dt><span class="section"><a href="facets.html#facet.messages.future">Future</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="containers.html">9. 
   Containers
   
-</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd><dt><span class="section"><a href="containers.html#containers.sequences.vector">vector</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.vector.management">Space Overhead Management</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="iterators.html">10. 
+</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="iterators.html">10. 
   Iterators
   
 </a></span></dt><dd><dl><dt><span class="section"><a href="iterators.html#std.iterators.predefined">Predefined</a></span></dt><dd><dl><dt><span class="section"><a href="iterators.html#iterators.predefined.vs_pointers">Iterators vs. Pointers</a></span></dt><dt><span class="section"><a href="iterators.html#iterators.predefined.end">One Past the End</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="algorithms.html">11. 
Index: libstdc++-v3/doc/html/manual/containers.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/containers.html	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/doc/html/manual/containers.html	(.../branches/gcc-4_9-branch)
@@ -7,9 +7,10 @@
   </th><td width="20%" align="right"><a accesskey="n" href="associative.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="std.containers"></a>Chapter9.
   Containers
   <a id="idm269891262400" class="indexterm"></a>
-</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd><dt><span class="section"><a href="containers.html#containers.sequences.vector">vector</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.vector.management">Space Overhead Management</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="std.containers.sequences"></a>Sequences</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="containers.sequences.list"></a>list</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="sequences.list.size"></a>list::size() is O(n)</h4></div></div></div><p>
-     Yes it is, and that's okay.  This is a decision that we preserved
-     when we imported SGI's STL implementation.  The following is
+</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="std.containers.sequences"></a>Sequences</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="containers.sequences.list"></a>list</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="sequences.list.size"></a>list::size() is O(n)</h4></div></div></div><p>
+     Yes it is, and that was okay until the 2011 edition of the C++ standard.
+     In future GCC will change it to O(1) but O(N) was a decision that we
+     preserved when we imported SGI's STL implementation.  The following is
      quoted from <a class="link" href="http://www.sgi.com/tech/stl/FAQ.html" target="_top">their FAQ</a>:
    </p><div class="blockquote"><blockquote class="blockquote"><p>
        The size() member function, for list and slist, takes time
@@ -41,14 +42,4 @@
 	 </p><pre class="programlisting">
 	 if (L.empty())
 	     ...
-	 </pre></blockquote></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="containers.sequences.vector"></a>vector</h3></div></div></div><p>
-  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="sequences.vector.management"></a>Space Overhead Management</h4></div></div></div><p>
-     In <a class="link" href="http://gcc.gnu.org/ml/libstdc++/2002-04/msg00105.html" target="_top">this
-     message to the list</a>, Daniel Kostecky announced work on an
-     alternate form of <code class="code">std::vector</code> that would support
-     hints on the number of elements to be over-allocated.  The design
-     was also described, along with possible implementation choices.
-   </p><p>
-     The first two alpha releases were announced <a class="link" href="http://gcc.gnu.org/ml/libstdc++/2002-07/msg00048.html" target="_top">here</a>
-     and <a class="link" href="http://gcc.gnu.org/ml/libstdc++/2002-07/msg00111.html" target="_top">here</a>.
-   </p></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="facets.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="std_contents.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="associative.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Facets</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top">Associative</td></tr></table></div></body></html>
\ No newline at end of file
+	 </pre></blockquote></div></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="facets.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="std_contents.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="associative.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Facets</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top">Associative</td></tr></table></div></body></html>
\ No newline at end of file
Index: libstdc++-v3/doc/html/manual/index.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/index.html	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/doc/html/manual/index.html	(.../branches/gcc-4_9-branch)
@@ -24,7 +24,7 @@
 </a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#std.localization.locales">Locales</a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#std.localization.locales.locale">locale</a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#locales.locale.req">Requirements</a></span></dt><dt><span class="section"><a href="localization.html#locales.locale.design">Design</a></span></dt><dt><span class="section"><a href="localization.html#locales.locale.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="localization.html#locale.impl.c">Interacting with "C" locales</a></span></dt></dl></dd><dt><span class="section"><a href="localization.html#locales.locale.future">Future</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="facets.html">Facets</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#std.localization.facet.ctype">ctype</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#facet.ctype.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#idm269891548288">Specializations</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#facet.ctype.future">Future</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#std.localization.facet.codecvt">codecvt</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#facet.codecvt.req">Requirements</a></span></dt><dt><span class="section"><a href="facets.html#facet.codecvt.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#codecvt.design.wchar_t_size"><span class="type">wchar_t</span> Size</a></span></dt><dt><span class="section"><a href="facets.html#codecvt.design.unicode">Support for Unicode</a></span></dt><dt><span class="section"><a href="facets.html#codecvt.design.issues">Other Issues</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#facet.codecvt.impl">Implementation</a></span></dt><dt><span class="section"><a href="facets.html#facet.codecvt.use">Use</a></span></dt><dt><span class="section"><a href="facets.html#facet.codecvt.future">Future</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#manual.localization.facet.messages">messages</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#facet.messages.req">Requirements</a></span></dt><dt><span class="section"><a href="facets.html#facet.messages.design">Design</a></span></dt><dt><span class="section"><a href="facets.html#facet.messages.impl">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="facets.html#messages.impl.models">Models</a></span></dt><dt><span class="section"><a href="facets.html#messages.impl.gnu">The GNU Model</a></span></dt></dl></dd><dt><span class="section"><a href="facets.html#facet.messages.use">Use</a></span></dt><dt><span class="section"><a href="facets.html#facet.messages.future">Future</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="containers.html">9. 
   Containers
   
-</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd><dt><span class="section"><a href="containers.html#containers.sequences.vector">vector</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.vector.management">Space Overhead Management</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="iterators.html">10. 
+</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#std.containers.sequences">Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#containers.sequences.list">list</a></span></dt><dd><dl><dt><span class="section"><a href="containers.html#sequences.list.size">list::size() is O(n)</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="associative.html">Associative</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#containers.associative.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="associative.html#containers.associative.bitset">bitset</a></span></dt><dd><dl><dt><span class="section"><a href="associative.html#associative.bitset.size_variable">Size Variable</a></span></dt><dt><span class="section"><a href="associative.html#associative.bitset.type_string">Type String</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="unordered_associative.html">Unordered Associative</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.insert_hints">Insertion Hints</a></span></dt><dt><span class="section"><a href="unordered_associative.html#containers.unordered.hash">Hash Code</a></span></dt><dd><dl><dt><span class="section"><a href="unordered_associative.html#containers.unordered.cache">Hash Code Caching Policy</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="containers_and_c.html">Interacting with C</a></span></dt><dd><dl><dt><span class="section"><a href="containers_and_c.html#containers.c.vs_array">Containers vs. Arrays</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="iterators.html">10. 
   Iterators
   
 </a></span></dt><dd><dl><dt><span class="section"><a href="iterators.html#std.iterators.predefined">Predefined</a></span></dt><dd><dl><dt><span class="section"><a href="iterators.html#iterators.predefined.vs_pointers">Iterators vs. Pointers</a></span></dt><dt><span class="section"><a href="iterators.html#iterators.predefined.end">One Past the End</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="algorithms.html">11. 
Index: libstdc++-v3/include/std/shared_mutex
===================================================================
--- a/src/libstdc++-v3/include/std/shared_mutex	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/shared_mutex	(.../branches/gcc-4_9-branch)
@@ -52,6 +52,9 @@
    */
 
 #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
+
+#define __cpp_lib_shared_timed_mutex 201402
+
   /// shared_timed_mutex
   class shared_timed_mutex
   {
Index: libstdc++-v3/include/std/tuple
===================================================================
--- a/src/libstdc++-v3/include/std/tuple	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/tuple	(.../branches/gcc-4_9-branch)
@@ -774,6 +774,9 @@
 	tuple<_Elements...>>::type&&>(get<__i>(__t)); }
 
 #if __cplusplus > 201103L
+
+#define __cpp_lib_tuples_by_type 201304
+
   template<typename _Head, size_t __i, typename... _Tail>
     constexpr typename __add_ref<_Head>::type
     __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
Index: libstdc++-v3/include/std/iomanip
===================================================================
--- a/src/libstdc++-v3/include/std/iomanip	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/iomanip	(.../branches/gcc-4_9-branch)
@@ -339,6 +339,8 @@
 
 #if __cplusplus > 201103L
 
+#define __cpp_lib_quoted_string_io 201304
+
 _GLIBCXX_END_NAMESPACE_VERSION
   namespace __detail {
   _GLIBCXX_BEGIN_NAMESPACE_VERSION
Index: libstdc++-v3/include/std/utility
===================================================================
--- a/src/libstdc++-v3/include/std/utility	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/utility	(.../branches/gcc-4_9-branch)
@@ -70,6 +70,7 @@
 #include <bits/stl_pair.h>
 
 #if __cplusplus >= 201103L
+
 #include <bits/move.h>
 #include <initializer_list>
 
@@ -153,6 +154,9 @@
     { return __pair_get<_Int>::__const_get(__in); }
 
 #if __cplusplus > 201103L
+
+#define __cpp_lib_tuples_by_type 201304
+
   template <typename _Tp, typename _Up>
     constexpr _Tp&
     get(pair<_Tp, _Up>& __p) noexcept
@@ -183,6 +187,8 @@
     get(pair<_Up, _Tp>&& __p) noexcept
     { return std::move(__p.second); }
 
+#define __cpp_lib_exchange_function 201304
+
   /// Assign @p __new_val to @p __obj and return its previous value.
   template <typename _Tp, typename _Up = _Tp>
     inline _Tp
@@ -216,6 +222,9 @@
     };
 
 #if __cplusplus > 201103L
+
+#define __cpp_lib_integer_sequence 201304
+
   /// Class template integer_sequence
   template<typename _Tp, _Tp... _Idx>
     struct integer_sequence
Index: libstdc++-v3/include/std/type_traits
===================================================================
--- a/src/libstdc++-v3/include/std/type_traits	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/type_traits	(.../branches/gcc-4_9-branch)
@@ -73,6 +73,9 @@
       typedef integral_constant<_Tp, __v>   type;
       constexpr operator value_type() const { return value; }
 #if __cplusplus > 201103L
+
+#define __cpp_lib_integral_constant_callable 201304
+
       constexpr value_type operator()() const { return value; }
 #endif
     };
@@ -480,6 +483,8 @@
     struct is_function<_Res(_ArgTypes......) const volatile &&>
     : public true_type { };
 
+#define __cpp_lib_is_null_pointer 201309
+
   template<typename>
     struct __is_null_pointer_helper
     : public false_type { };
@@ -634,6 +639,15 @@
     : public integral_constant<bool, __is_polymorphic(_Tp)>
     { };
 
+#if __cplusplus > 201103L
+  /// is_final
+  #define __cpp_lib_is_final 201402L
+  template<typename _Tp>
+    struct is_final
+    : public integral_constant<bool, __is_final(_Tp)>
+    { };
+#endif
+
   /// is_abstract
   template<typename _Tp>
     struct is_abstract
@@ -1451,6 +1465,9 @@
     };
 
 #if __cplusplus > 201103L
+
+#define __cpp_lib_transformation_trait_aliases 201304
+
   /// Alias template for remove_const
   template<typename _Tp>
     using remove_const_t = typename remove_const<_Tp>::type;
@@ -2044,6 +2061,8 @@
 
   // Sfinae-friendly result_of implementation:
 
+#define __cpp_lib_result_of_sfinae 201210
+
   // [func.require] paragraph 1 bullet 1:
   struct __result_of_memfun_ref_impl
   {
Index: libstdc++-v3/include/std/future
===================================================================
--- a/src/libstdc++-v3/include/std/future	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/future	(.../branches/gcc-4_9-branch)
@@ -1240,6 +1240,10 @@
 	  {
 	    _M_result->_M_set(_M_fn());
 	  }
+	__catch(const __cxxabiv1::__forced_unwind&)
+	  {
+	    __throw_exception_again; // will cause broken_promise
+	  }
 	__catch(...)
 	  {
 	    _M_result->_M_error = current_exception();
@@ -1259,6 +1263,10 @@
 	  {
 	    _M_fn();
 	  }
+	__catch(const __cxxabiv1::__forced_unwind&)
+	  {
+	    __throw_exception_again; // will cause broken_promise
+	  }
 	__catch(...)
 	  {
 	    _M_result->_M_error = current_exception();
@@ -1519,7 +1527,17 @@
       : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))
       {
 	_M_thread = std::thread{ [this] {
-	  _M_set_result(_S_task_setter(_M_result, _M_fn));
+	    __try
+	      {
+		_M_set_result(_S_task_setter(_M_result, _M_fn));
+	      }
+	    __catch (const __cxxabiv1::__forced_unwind&)
+	      {
+		// make the shared state ready on thread cancellation
+		if (static_cast<bool>(_M_result))
+		  this->_M_break_promise(std::move(_M_result));
+		__throw_exception_again;
+	      }
         } };
       }
 
Index: libstdc++-v3/include/std/chrono
===================================================================
--- a/src/libstdc++-v3/include/std/chrono	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/chrono	(.../branches/gcc-4_9-branch)
@@ -782,6 +782,8 @@
 
 #if __cplusplus > 201103L
 
+#define __cpp_lib_chrono_udls 201304
+
   inline namespace literals
   {
   inline namespace chrono_literals
Index: libstdc++-v3/include/std/condition_variable
===================================================================
--- a/src/libstdc++-v3/include/std/condition_variable	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/condition_variable	(.../branches/gcc-4_9-branch)
@@ -189,7 +189,14 @@
 	~_Unlock() noexcept(false)
 	{
 	  if (uncaught_exception())
-	    __try { _M_lock.lock(); } __catch(...) { }
+	    {
+	      __try
+	      { _M_lock.lock(); }
+	      __catch(const __cxxabiv1::__forced_unwind&)
+	      { __throw_exception_again; }
+	      __catch(...)
+	      { }
+	    }
 	  else
 	    _M_lock.lock();
 	}
Index: libstdc++-v3/include/std/mutex
===================================================================
--- a/src/libstdc++-v3/include/std/mutex	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/mutex	(.../branches/gcc-4_9-branch)
@@ -44,6 +44,7 @@
 #include <bits/functexcept.h>
 #include <bits/gthr.h>
 #include <bits/move.h> // for std::swap
+#include <bits/cxxabi_forced.h>
 
 #ifdef _GLIBCXX_USE_C99_STDINT_TR1
 
@@ -647,10 +648,7 @@
     {
       int __idx;
       auto __locks = std::tie(__l1, __l2, __l3...);
-      __try
-      { __try_lock_impl<0>::__do_try_lock(__locks, __idx); }
-      __catch(...)
-      { }
+      __try_lock_impl<0>::__do_try_lock(__locks, __idx);
       return __idx;
     }
 
Index: libstdc++-v3/include/std/complex
===================================================================
--- a/src/libstdc++-v3/include/std/complex	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/std/complex	(.../branches/gcc-4_9-branch)
@@ -1929,6 +1929,8 @@
 inline namespace literals {
 inline namespace complex_literals {
 
+#define __cpp_lib_complex_udls 201309
+
   constexpr std::complex<float>
   operator""if(long double __num)
   { return std::complex<float>{0.0F, static_cast<float>(__num)}; }
Index: libstdc++-v3/include/experimental/string_view
===================================================================
--- a/src/libstdc++-v3/include/experimental/string_view	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/experimental/string_view	(.../branches/gcc-4_9-branch)
@@ -39,7 +39,6 @@
 # include <bits/c++14_warning.h>
 #else
 
-#include <debug/debug.h>
 #include <string>
 #include <limits>
 
@@ -66,18 +65,10 @@
    *    _CharT*    _M_str
    *    size_t     _M_len
    *  @endcode
-   *
-   *  A basic_string_view represents an empty string with a static constexpr
-   *  length one string:
-   *
-   *  @code
-   *    static constexpr value_type _S_empty_str[1]{0};
-   *  @endcode
    */
-  template<typename _CharT, typename _Traits = char_traits<_CharT>>
+  template<typename _CharT, typename _Traits = std::char_traits<_CharT>>
     class basic_string_view
     {
-
     public:
 
       // types
@@ -99,7 +90,7 @@
 
       constexpr
       basic_string_view() noexcept
-      : _M_len{0}, _M_str{_S_empty_str}
+      : _M_len{0}, _M_str{nullptr}
       { }
 
       constexpr basic_string_view(const basic_string_view&) noexcept = default;
@@ -112,12 +103,12 @@
 
       constexpr basic_string_view(const _CharT* __str)
       : _M_len{__str == nullptr ? 0 : traits_type::length(__str)},
-	_M_str{__str == nullptr ? _S_empty_str : __str}
+	_M_str{__str}
       { }
 
       constexpr basic_string_view(const _CharT* __str, size_type __len)
-      : _M_len{__str == nullptr ? 0 :__len},
-        _M_str{__str == nullptr ? _S_empty_str : __str}
+      : _M_len{__len},
+        _M_str{__str}
       { }
 
       basic_string_view&
@@ -143,19 +134,19 @@
 
       const_reverse_iterator
       rbegin() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->end()); }
+      { return const_reverse_iterator(this->end()); }
 
       const_reverse_iterator
       rend() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->begin()); }
+      { return const_reverse_iterator(this->begin()); }
 
       const_reverse_iterator
       crbegin() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->end()); }
+      { return const_reverse_iterator(this->end()); }
 
       const_reverse_iterator
       crend() const noexcept
-      { return std::reverse_iterator<const_iterator>(this->begin()); }
+      { return const_reverse_iterator(this->begin()); }
 
       // [string.view.capacity], capacity
 
@@ -169,8 +160,10 @@
 
       constexpr size_type
       max_size() const noexcept
-      { return ((npos - sizeof(size_type) - sizeof(void*))
-		/ sizeof(value_type) / 4); }
+      {
+	return (npos - sizeof(size_type) - sizeof(void*))
+		/ sizeof(value_type) / 4;
+      }
 
       constexpr bool
       empty() const noexcept
@@ -195,7 +188,7 @@
 					     "(which is %zu) >= this->size() "
 					     "(which is %zu)"),
 					 __pos, this->size()),
-		_S_empty_str[0]);
+		*this->_M_str);
       }
 
       constexpr const _CharT&
@@ -219,11 +212,12 @@
       { return this->_M_str; }
 
       // [string.view.modifiers], modifiers:
+
       void
       clear() noexcept
       {
 	this->_M_len = 0;
-	this->_M_str = _S_empty_str;
+	this->_M_str = nullptr;
       }
 
       void
@@ -251,10 +245,16 @@
       template<typename _Allocator>
         explicit operator basic_string<_CharT, _Traits, _Allocator>() const
         {
-	  return basic_string<_CharT, _Traits, _Allocator>
-					(this->_M_len, this->_M_str);
+	  return { this->_M_str, this->_M_len };
 	}
 
+      template<typename _Allocator = std::allocator<_CharT>>
+	basic_string<_CharT, _Traits, _Allocator>
+	to_string(const _Allocator& __alloc = _Allocator()) const
+	{
+	  return { this->_M_str, this->_M_len, __alloc };
+	}
+
       size_type
       copy(_CharT* __str, size_type __n, size_type __pos = 0) const
       {
@@ -329,7 +329,7 @@
       find(_CharT __c, size_type __pos=0) const noexcept;
 
       size_type
-      find(const _CharT* __str, size_type __pos, size_type __n) const;
+      find(const _CharT* __str, size_type __pos, size_type __n) const noexcept;
 
       size_type
       find(const _CharT* __str, size_type __pos=0) const noexcept
@@ -343,7 +343,7 @@
       rfind(_CharT __c, size_type __pos = npos) const noexcept;
 
       size_type
-      rfind(const _CharT* __str, size_type __pos, size_type __n) const;
+      rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept;
 
       size_type
       rfind(const _CharT* __str, size_type __pos = npos) const noexcept
@@ -431,8 +431,6 @@
 	     : static_cast<int>(difference_type{__n1 - __n2});
       }
 
-      static constexpr value_type _S_empty_str[1]{};
-
       size_t	    _M_len;
       const _CharT* _M_str;
     };
@@ -456,131 +454,119 @@
   }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator==(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) == 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator==(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) == 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator==(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) == 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator!=(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return !(__x == __y); }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator!=(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return !(__x == __y); }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator!=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return !(__x == __y); }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator< (basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) < 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator< (basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) < 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator< (__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) < 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator> (basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) > 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator> (basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) > 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator> (__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) > 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator<=(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) <= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator<=(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) <= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator<=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) <= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator>=(basic_string_view<_CharT, _Traits> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) >= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator>=(basic_string_view<_CharT, _Traits> __x,
                __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
     { return __x.compare(__y) >= 0; }
 
   template<typename _CharT, typename _Traits>
-    bool
+    inline bool
     operator>=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
                basic_string_view<_CharT, _Traits> __y) noexcept
     { return __x.compare(__y) >= 0; }
 
-  // [string.view.comparison], sufficient additional overloads of comparison functions
-
-  // [string.view.nonmem], other non-member basic_string_view functions
-  template<typename _CharT, typename _Traits = char_traits<_CharT>,
-           typename _Allocator = allocator<_CharT>>
-    basic_string<_CharT, _Traits, _Allocator>
-    to_string(basic_string_view<_CharT, _Traits> __str,
-	      const _Allocator& __alloc = _Allocator())
-    {
-      return basic_string<_CharT, _Traits, _Allocator>
-			(__str.begin(), __str.end(), __alloc);
-    }
-
+  // [string.view.io], Inserters and extractors
   template<typename _CharT, typename _Traits>
-    basic_ostream<_CharT, _Traits>&
-      operator<<(basic_ostream<_CharT, _Traits>& __os,
-                 basic_string_view<_CharT,_Traits> __str)
-      { return __ostream_insert(__os, __str.data(), __str.size()); }
+    inline basic_ostream<_CharT, _Traits>&
+    operator<<(basic_ostream<_CharT, _Traits>& __os,
+	       basic_string_view<_CharT,_Traits> __str)
+    { return __ostream_insert(__os, __str.data(), __str.size()); }
 
 
   // basic_string_view typedef names
Index: libstdc++-v3/include/experimental/string_view.tcc
===================================================================
--- a/src/libstdc++-v3/include/experimental/string_view.tcc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/experimental/string_view.tcc	(.../branches/gcc-4_9-branch)
@@ -47,10 +47,6 @@
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _CharT, typename _Traits>
-    constexpr _CharT
-    basic_string_view<_CharT, _Traits>::_S_empty_str[1];
-
-  template<typename _CharT, typename _Traits>
     typename basic_string_view<_CharT, _Traits>::size_type
     basic_string_view<_CharT, _Traits>::
     find(const _CharT* __str, size_type __pos, size_type __n) const noexcept
Index: libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp
===================================================================
--- a/src/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/ext/pb_ds/detail/bin_search_tree_/traits.hpp	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
 	     class Cmp_Fn,
 	     template<typename Node_CItr,
 		      class Node_Itr,
-		      class Cmp_Fn,
+		      class _Cmp_Fn,
 		      typename _Alloc>
 	     class Node_Update,
 	     class Node,
@@ -161,7 +161,7 @@
 	     class Cmp_Fn,
 	     template<typename Node_CItr,
 		      class Node_Itr,
-		      class Cmp_Fn,
+		      class _Cmp_Fn,
 		      typename _Alloc>
 	     class Node_Update,
 	     class Node,
Index: libstdc++-v3/include/ext/random.tcc
===================================================================
--- a/src/libstdc++-v3/include/ext/random.tcc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/ext/random.tcc	(.../branches/gcc-4_9-branch)
@@ -1314,7 +1314,7 @@
       operator()(_UniformRandomNumberGenerator& __urng,
 		 const param_type& __param)
       {
-	std::__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
+	std::__detail::_Adaptor<_UniformRandomNumberGenerator, double>
 	  __aurng(__urng);
 
 	result_type __a = __param.successful_size();
Index: libstdc++-v3/include/ext/rope
===================================================================
--- a/src/libstdc++-v3/include/ext/rope	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/ext/rope	(.../branches/gcc-4_9-branch)
@@ -1544,7 +1544,7 @@
       typedef typename _Base::allocator_type allocator_type;
       using _Base::_M_tree_ptr;
       using _Base::get_allocator;
-      using _Base::_M_get_allocator;      
+      using _Base::_M_get_allocator;
       typedef __GC_CONST _CharT* _Cstrptr;
       
       static _CharT _S_empty_c_str[1];
@@ -1876,8 +1876,9 @@
 	   const allocator_type& __a = allocator_type())
       : _Base(__a)
       {
-	this->_M_tree_ptr = (0 == __len) ?
-	  0 : _S_new_RopeFunction(__fn, __len, __delete_fn, __a);
+	this->_M_tree_ptr = (0 == __len)
+	  ? 0
+	  : _S_new_RopeFunction(__fn, __len, __delete_fn, _M_get_allocator());
       }
 
       rope(const rope& __x, const allocator_type& __a = allocator_type())
Index: libstdc++-v3/include/bits/hashtable.h
===================================================================
--- a/src/libstdc++-v3/include/bits/hashtable.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/hashtable.h	(.../branches/gcc-4_9-branch)
@@ -326,7 +326,7 @@
 
       bool
       _M_uses_single_bucket(__bucket_type* __bkts) const
-      { return __builtin_expect(_M_buckets == &_M_single_bucket, false); }
+      { return __builtin_expect(__bkts == &_M_single_bucket, false); }
 
       bool
       _M_uses_single_bucket() const
@@ -1281,10 +1281,10 @@
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
     __rehash_policy(const _RehashPolicy& __pol)
     {
-      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);
-      __n_bkt = __pol._M_next_bkt(__n_bkt);
-      if (__n_bkt != _M_bucket_count)
-	_M_rehash(__n_bkt, _M_rehash_policy._M_state());
+      auto __do_rehash =
+	__pol._M_need_rehash(_M_bucket_count, _M_element_count, 0);
+      if (__do_rehash.first)
+	_M_rehash(__do_rehash.second, _M_rehash_policy._M_state());
       _M_rehash_policy = __pol;
     }
 
Index: libstdc++-v3/include/bits/stl_algobase.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_algobase.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/stl_algobase.h	(.../branches/gcc-4_9-branch)
@@ -1091,6 +1091,9 @@
     }
 
 #if __cplusplus > 201103L
+
+#define __cpp_lib_robust_nonmodifying_seq_ops 201304
+
   /**
    *  @brief Tests a range for element-wise equality.
    *  @ingroup non_mutating_algorithms
Index: libstdc++-v3/include/bits/stl_queue.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_queue.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/stl_queue.h	(.../branches/gcc-4_9-branch)
@@ -58,6 +58,9 @@
 
 #include <bits/concept_check.h>
 #include <debug/debug.h>
+#if __cplusplus >= 201103L
+# include <bits/uses_allocator.h>
+#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
Index: libstdc++-v3/include/bits/stl_stack.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_stack.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/stl_stack.h	(.../branches/gcc-4_9-branch)
@@ -58,6 +58,9 @@
 
 #include <bits/concept_check.h>
 #include <debug/debug.h>
+#if __cplusplus >= 201103L
+# include <bits/uses_allocator.h>
+#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
Index: libstdc++-v3/include/bits/unique_ptr.h
===================================================================
--- a/src/libstdc++-v3/include/bits/unique_ptr.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/unique_ptr.h	(.../branches/gcc-4_9-branch)
@@ -743,6 +743,9 @@
     };
 
 #if __cplusplus > 201103L
+
+#define __cpp_lib_make_unique 201304
+
   template<typename _Tp>
     struct _MakeUniq
     { typedef unique_ptr<_Tp> __single_object; };
Index: libstdc++-v3/include/bits/atomic_base.h
===================================================================
--- a/src/libstdc++-v3/include/bits/atomic_base.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/atomic_base.h	(.../branches/gcc-4_9-branch)
@@ -675,10 +675,10 @@
 
       // Factored out to facilitate explicit specialization.
       constexpr ptrdiff_t
-      _M_type_size(ptrdiff_t __d) { return __d * sizeof(_PTp); }
+      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }
 
       constexpr ptrdiff_t
-      _M_type_size(ptrdiff_t __d) volatile { return __d * sizeof(_PTp); }
+      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }
 
     public:
       __atomic_base() noexcept = default;
Index: libstdc++-v3/include/bits/basic_string.h
===================================================================
--- a/src/libstdc++-v3/include/bits/basic_string.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/basic_string.h	(.../branches/gcc-4_9-branch)
@@ -2811,8 +2811,24 @@
     inline basic_istream<_CharT, _Traits>&
     getline(basic_istream<_CharT, _Traits>& __is,
 	    basic_string<_CharT, _Traits, _Alloc>& __str)
-    { return getline(__is, __str, __is.widen('\n')); }
+    { return std::getline(__is, __str, __is.widen('\n')); }
 
+#if __cplusplus >= 201103L
+  /// Read a line from an rvalue stream into a string.
+  template<typename _CharT, typename _Traits, typename _Alloc>
+    inline basic_istream<_CharT, _Traits>&
+    getline(basic_istream<_CharT, _Traits>&& __is,
+	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
+    { return std::getline(__is, __str, __delim); }
+
+  /// Read a line from an rvalue stream into a string.
+  template<typename _CharT, typename _Traits, typename _Alloc>
+    inline basic_istream<_CharT, _Traits>&
+    getline(basic_istream<_CharT, _Traits>&& __is,
+	    basic_string<_CharT, _Traits, _Alloc>& __str)
+    { return std::getline(__is, __str); }
+#endif
+
   template<>
     basic_istream<char>&
     getline(basic_istream<char>& __in, basic_string<char>& __str,
@@ -3124,6 +3140,8 @@
 
 #if __cplusplus > 201103L
 
+#define __cpp_lib_string_udls 201304
+
   inline namespace literals
   {
   inline namespace string_literals
Index: libstdc++-v3/include/bits/stl_algo.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_algo.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/stl_algo.h	(.../branches/gcc-4_9-branch)
@@ -4430,7 +4430,12 @@
 
       if (__first != __last)
 	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
-	  std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
+	  {
+	    _RandomAccessIterator __j = __first
+					+ std::rand() % ((__i - __first) + 1);
+	    if (__i != __j)
+	      std::iter_swap(__i, __j);
+	  }
     }
 
   /**
@@ -4464,7 +4469,11 @@
       if (__first == __last)
 	return;
       for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
-	std::iter_swap(__i, __first + __rand((__i - __first) + 1));
+	{
+	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
+	  if (__i != __j)
+	    std::iter_swap(__i, __j);
+	}
     }
 
 
Index: libstdc++-v3/include/bits/vector.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/vector.tcc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/vector.tcc	(.../branches/gcc-4_9-branch)
@@ -228,7 +228,7 @@
       if (__n > capacity())
 	{
 	  vector __tmp(__n, __val, _M_get_Tp_allocator());
-	  __tmp.swap(*this);
+	  __tmp._M_impl._M_swap_data(this->_M_impl);
 	}
       else if (__n > size())
 	{
Index: libstdc++-v3/include/bits/random.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/random.tcc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/random.tcc	(.../branches/gcc-4_9-branch)
@@ -3463,6 +3463,9 @@
     _RealType
     generate_canonical(_UniformRandomNumberGenerator& __urng)
     {
+      static_assert(std::is_floating_point<_RealType>::value,
+		    "template argument not a floating point type");
+
       const size_t __b
 	= std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                    __bits);
Index: libstdc++-v3/include/bits/stl_function.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_function.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/stl_function.h	(.../branches/gcc-4_9-branch)
@@ -217,6 +217,10 @@
     };
 
 #if __cplusplus > 201103L
+
+#define __cpp_lib_transparent_operators 201210
+//#define __cpp_lib_generic_associative_lookup 201304
+
   template<>
     struct plus<void>
     {
Index: libstdc++-v3/include/bits/regex.h
===================================================================
--- a/src/libstdc++-v3/include/bits/regex.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/regex.h	(.../branches/gcc-4_9-branch)
@@ -474,17 +474,25 @@
        *
        * @param __rhs A @p regex object.
        */
-      basic_regex(const basic_regex& __rhs) = default;
+      basic_regex(const basic_regex& __rhs)
+      : _M_flags(__rhs._M_flags), _M_original_str(__rhs._M_original_str)
+      { this->imbue(__rhs.getloc()); }
 
       /**
        * @brief Move-constructs a basic regular expression.
        *
        * @param __rhs A @p regex object.
+       *
+       * The implementation is a workaround concerning ABI compatibility. See:
+       * https://gcc.gnu.org/ml/libstdc++/2014-09/msg00067.html
        */
-      basic_regex(const basic_regex&& __rhs) noexcept
-      : _M_flags(__rhs._M_flags), _M_traits(__rhs._M_traits),
-	_M_automaton(std::move(__rhs._M_automaton))
-      { }
+      basic_regex(basic_regex&& __rhs)
+      : _M_flags(__rhs._M_flags),
+      _M_original_str(std::move(__rhs._M_original_str))
+      {
+	this->imbue(__rhs.getloc());
+	__rhs._M_automaton.reset();
+      }
 
       /**
        * @brief Constructs a basic regular expression from the string
@@ -555,9 +563,12 @@
 
       /**
        * @brief Move-assigns one regular expression to another.
+       *
+       * The implementation is a workaround concerning ABI compatibility. See:
+       * https://gcc.gnu.org/ml/libstdc++/2014-09/msg00067.html
        */
       basic_regex&
-      operator=(basic_regex&& __rhs) noexcept
+      operator=(basic_regex&& __rhs)
       { return this->assign(std::move(__rhs)); }
 
       /**
@@ -591,8 +602,9 @@
       basic_regex&
       assign(const basic_regex& __rhs)
       {
-	basic_regex __tmp(__rhs);
-	this->swap(__tmp);
+	_M_flags = __rhs._M_flags;
+	_M_original_str = __rhs._M_original_str;
+	this->imbue(__rhs.getloc());
 	return *this;
       }
 
@@ -600,13 +612,17 @@
        * @brief The move-assignment operator.
        *
        * @param __rhs Another regular expression object.
+       *
+       * The implementation is a workaround concerning ABI compatibility. See:
+       * https://gcc.gnu.org/ml/libstdc++/2014-09/msg00067.html
        */
       basic_regex&
-      assign(basic_regex&& __rhs) noexcept
+      assign(basic_regex&& __rhs)
       {
-	basic_regex __tmp(std::move(__rhs));
-	this->swap(__tmp);
-	return *this;
+	_M_flags = __rhs._M_flags;
+	_M_original_str = std::move(__rhs._M_original_str);
+	__rhs._M_automaton.reset();
+	this->imbue(__rhs.getloc());
       }
 
       /**
@@ -751,8 +767,8 @@
       swap(basic_regex& __rhs)
       {
 	std::swap(_M_flags, __rhs._M_flags);
-	std::swap(_M_traits, __rhs._M_traits);
-	std::swap(_M_automaton, __rhs._M_automaton);
+	std::swap(_M_original_str, __rhs._M_original_str);
+	this->imbue(__rhs.imbue(this->getloc()));
       }
 
 #ifdef _GLIBCXX_DEBUG
@@ -1814,7 +1830,7 @@
       /**
        * @pre   ready() == true
        */
-      template<typename _Out_iter, typename _St, typename _Sa>
+      template<typename _St, typename _Sa>
 	basic_string<char_type, _St, _Sa>
 	format(const basic_string<char_type, _St, _Sa>& __fmt,
 	       match_flag_type __flags = regex_constants::format_default) const
@@ -2687,7 +2703,7 @@
       }
 
       constexpr bool
-      _M_end_of_seq()
+      _M_end_of_seq() const
       { return _M_result == nullptr; }
 
       _Position         _M_position;
Index: libstdc++-v3/include/bits/random.h
===================================================================
--- a/src/libstdc++-v3/include/bits/random.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/include/bits/random.h	(.../branches/gcc-4_9-branch)
@@ -164,6 +164,8 @@
     template<typename _Engine, typename _DInputType>
       struct _Adaptor
       {
+	static_assert(std::is_floating_point<_DInputType>::value,
+		      "template argument not a floating point type");
 
       public:
 	_Adaptor(_Engine& __g)
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,226 @@
+2014-10-08  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	Implement SD-6: SG10 Feature Test Recommendations
+	* include/bits/basic_string.h: Add __cpp_lib feature test macro.
+	* include/bits/stl_algobase.h: Ditto.
+	* include/bits/stl_function.h: Ditto.
+	* include/bits/unique_ptr.h: Ditto.
+	* include/std/chrono: Ditto.
+	* include/std/complex: Ditto.
+	* include/std/iomanip: Ditto.
+	* include/std/shared_mutex: Ditto.
+	* include/std/tuple: Ditto.
+	* include/std/type_traits: Ditto.
+	* include/std/utility: Ditto.
+	* testsuite/experimental/feat-cxx14.cc: New.
+	* testsuite/experimental/feat-lib-fund.cc: New.
+	* testsuite/20_util/declval/requirements/1_neg.cc: Adjust.
+	* testsuite/20_util/duration/literals/range.cc: Adjust.
+	* testsuite/20_util/duration/requirements/typedefs_neg1.cc: Adjust.
+	* testsuite/20_util/duration/requirements/typedefs_neg2.cc: Adjust.
+	* testsuite/20_util/duration/requirements/typedefs_neg3.cc: Adjust.
+	* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust.
+	* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc: Adjust.
+	* testsuite/23_containers/array/tuple_interface/get_neg.cc: Adjust.
+	* testsuite/23_containers/array/tuple_interface/tuple_element_neg.cc:
+	Adjust.
+
+2014-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (regex_token_iterator::_M_end_of_seq): Add
+	const qualifier.
+
+2014-10-05  Franois Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/63456
+	* include/bits/hashtable.h (_M_uses_single_bucket(__bucket_type*)): Test
+	the parameter.
+	* testsuite/23_containers/unordered_set/63456.cc: New.
+
+2014-10-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/63449
+	* doc/xml/manual/containers.xml: Remove outdated section. Update
+	std::list notes.
+	* doc/html/*: Regenerate.
+
+2014-10-03  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	* include/std/type_traits: Add is_final<> type trait for C++14.
+	* testsuite/util/testsuite_tr1.h: Add FinalType.
+	* testsuite/20_util/is_final/requirements/
+	explicit_instantiation.cc: New.
+	* testsuite/20_util/is_final/requirements/typedefs.cc: New.
+	* testsuite/20_util/is_final/value.cc: New.
+	* testsuite/20_util/declval/requirements/1_neg.cc: Adjust.
+	* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust.
+	* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc: Adjust.
+
+2014-10-02  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/63199
+	* include/bits/regex.h (basic_regex::basic_regex, basic_regex::assign,
+	basic_regex::swap): Fix dangling _M_traits reference problem.
+	* testsuite/28_regex/algorithms/regex_match/ecma/wchar_t/63199.cc:
+	New test case.
+
+2014-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2011.xml: Corrections.
+	* doc/html/manual/status.html: Regenerate.
+
+2014-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/vector.tcc (vector::_M_fill_assign): Use _M_swap_data.
+
+2014-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_queue.h: Include missing header.
+	* include/bits/stl_stack.h: Likewise.
+	* testsuite/23_containers/priority_queue/requirements/
+	uses_allocator.cc: New.
+	* testsuite/23_containers/queue/requirements/uses_allocator.cc: New.
+	* testsuite/23_containers/stack/requirements/uses_allocator.cc: New.
+
+2014-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/mutex (try_lock): Do not swallow exceptions.
+	* testsuite/30_threads/try_lock/4.cc: Fix test.
+
+2014-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/59603
+	* include/bits/stl_algo.h (random_shuffle): Prevent self-swapping.
+	* testsuite/25_algorithms/random_shuffle/59603.cc: New.
+
+2014-09-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/63219
+	* include/bits/regex.h (match_results::format): Remove stray template
+	parameter.
+
+2014-08-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2014-08-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/basic_string.h (getline): Qualify call to prevent ADL
+	and add overloads for rvalue streams.
+	* testsuite/21_strings/basic_string/inserters_extractors/char/12.cc:
+	New.
+	* testsuite/21_strings/basic_string/inserters_extractors/wchar_t/12.cc:
+	New.
+
+2014-08-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/62264
+	* include/experimental/string_view: Fix inconsistent exception specs.
+
+2014-08-09  Franois Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/61667
+	* include/bits/hashtable.h (_Hashtable<>::__rehash_policy): Use
+	_M_need_rehash to initialize the rehash policy and check if a rehash is
+	needed.
+	* testsuite/23_containers/unordered_map/modifiers/61667.cc: New.
+
+2014-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2014-07-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/61946
+	* include/ext/rope (rope::rope(char_producer<_CharT>*, size_t, bool,
+	const allocator_type&)): Pass non-const allocator to
+	_S_new_RopeFunction.
+	* testsuite/ext/rope/61946.cc: New.
+
+2014-08-04  Zifei Tong  <zifeitong@gmail.com>
+
+	* libsupc++/atexit_thread.cc (HAVE___CXA_THREAD_ATEXIT_IMPL): Add
+	_GLIBCXX_ prefix to macro.
+
+2014-08-04  Samuel Bronson  <naesten@gmail.com>
+
+	Backport r212453 from trunk
+	2014-07-11  Samuel Bronson  <naesten@gmail.com>
+		    Matthias Klose  <doko@ubuntu.com>
+
+	PR libstdc++/58962
+	* python/libstdcxx/v6/printers.py: Port to Python 2+3
+	(imap): New compat function.
+	(izip): Likewise.
+	(Iterator): New mixin to allow writing iterators in Python 3 style
+	regardless of which version we're running on.
+	[Python3] (long) New compat alias for "int".
+	* testsuite/lib/gdb-test.exp: Port to Python 2+3 (print syntax)
+
+	Backport r210625 from trunk
+	2014-05-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py: Use Python3 raise syntax.
+
+2014-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2014-06-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/61390
+	* include/ext/pb_ds/detail/bin_search_tree_/traits.hpp
+	(bin_search_tree_traits): Do not redeclare template-parameters.
+	* testsuite/util/testsuite_iterators.h (test_container): Likewise.
+
+	Backported from mainline
+	2014-06-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/condition_variable (condition_variable_any::_Unlock): Do
+	not swallow __forced_unwind.
+	* include/std/future (__future_base::_Task_setter): Likewise.
+	(__future_base::_Async_state_impl): Turn __forced_unwind into broken
+	promise and rethrow.
+	* include/std/mutex (try_lock): Likewise.
+	* testsuite/30_threads/async/forced_unwind.cc: New.
+	* testsuite/30_threads/packaged_task/forced_unwind.cc: New.
+
+	Backported from mainline
+	2014-06-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/61374
+	* include/experimental/string_view (operator basic_string): Correct
+	order of arguments.
+	(to_string): Replace with member function.
+	Add inline specifiers. Remove unused header. Remove _S_empty_rep and
+	allow _M_str to be null.
+	* testsuite/experimental/string_view/cons/char/1.cc: Adjust to new
+	default constructor semantics.
+	* testsuite/experimental/string_view/cons/wchar_t/1.cc: Likewise.
+	* testsuite/experimental/string_view/operations/copy/char/1.cc: Fix
+	copyright dates. Remove unused header.
+	* testsuite/experimental/string_view/operations/copy/wchar_t/1.cc:
+	Likewise.
+	* testsuite/experimental/string_view/operations/data/char/1.cc:
+	Fix copyright dates. Adjust to new default constructor semantics.
+	* testsuite/experimental/string_view/operations/data/wchar_t/1.cc:
+	Likewise.
+	* testsuite/experimental/string_view/operations/to_string/1.cc: New.
+
+	Backported from mainline
+	2014-04-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/atomic_base.h (__atomic_base<_PTp*>::_M_type_size): Add
+	const to constexpr member functions.
+
+2014-07-29  Ed Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/60037 - SIGFPE in std::generate_canonical<unsigned int...>
+	* include/bits/random.h (_Adaptor): static_assert for non floating-point
+	result type.
+	* include/bits/random.tcc (generate_canonical): Ditto.
+	* include/ext/random.tcc (hypergeometric_distribution::operator()):
+	Use double as a rng result type.
+	* testsuite/26_numerics/random/pr60037-neg.cc: New.
+	* testsuite/ext/random/hypergeometric_distribution/pr60037.cc: New.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libstdc++-v3/libsupc++/atexit_thread.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/atexit_thread.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/libsupc++/atexit_thread.cc	(.../branches/gcc-4_9-branch)
@@ -26,7 +26,7 @@
 #include <new>
 #include "bits/gthr.h"
 
-#if HAVE___CXA_THREAD_ATEXIT_IMPL
+#if _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL
 
 extern "C" int __cxa_thread_atexit_impl (void (*func) (void *),
 					 void *arg, void *d);
@@ -38,7 +38,7 @@
   return __cxa_thread_atexit_impl (dtor, obj, dso_handle);
 }
 
-#else /* HAVE___CXA_THREAD_ATEXIT_IMPL */
+#else /* _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL */
 
 namespace {
   // One element in a singly-linked stack of cleanups.
@@ -142,4 +142,4 @@
   return 0;
 }
 
-#endif /* HAVE___CXA_THREAD_ATEXIT_IMPL */
+#endif /* _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL */
Index: libstdc++-v3/testsuite/25_algorithms/random_shuffle/59603.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/25_algorithms/random_shuffle/59603.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/25_algorithms/random_shuffle/59603.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-require-debug-mode "" }
+
+// libstdc++/59603
+
+#include <algorithm>
+#include <vector>
+
+struct C {
+    std::vector<int> v;
+    C (int a) : v{a} {};
+};
+
+int main () {
+    std::vector<C> cs { {1}, {2}, {3}, {4} };
+    std::random_shuffle(cs.begin(), cs.end());
+}
Index: libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/wchar_t/63199.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/wchar_t/63199.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/wchar_t/63199.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,69 @@
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <regex>
+#include <testsuite_hooks.h>
+#include <testsuite_regex.h>
+
+using namespace __gnu_test;
+using namespace std;
+
+// libstdc++/63199
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::setlocale(LC_ALL, "");
+
+  std::wstring current_token(L"II.");
+
+  std::vector<std::wregex> regex_vector;
+
+  for (int i = 0; i < 4; ++i)
+  {
+    std::regex_constants::syntax_option_type flag;
+    flag = std::regex_constants::ECMAScript | std::regex_constants::icase;
+
+    std::wregex reg;
+    reg.imbue(std::locale(""));
+    reg.assign(L"^(M*(?:CM|DC{1,3}|D|CD|C{1,3}){0,1}(?:XC|LX{1,3}|L|XL|X{1,3}){0,1}(?:IX|VI{0,3}|IV|I{1,3}){0,1}\\.)$", flag);
+
+    regex_vector.emplace_back(reg);
+  }
+
+  for (auto cit = regex_vector.cbegin(); cit != regex_vector.cend(); ++cit)
+  {
+    std::wstring::const_iterator it1 = current_token.begin();
+    std::wstring::const_iterator it2 = current_token.end();
+    std::wsmatch current_token_match;
+
+    regex_match_debug(it1, it2, current_token_match, *cit);
+    VERIFY(current_token_match[0] == current_token);
+    VERIFY(current_token_match[1] == current_token);
+  }
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/wchar_t/12.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/wchar_t/12.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/wchar_t/12.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,38 @@
+// { dg-options "-std=gnu++11" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <string>
+#include <sstream>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::wstring s;
+  getline(std::wistringstream(L"First line\nSecond line\n"), s);
+  VERIFY( s == L"First line" );
+  getline(std::wistringstream(L"Third line\nFourth line\n"), s, L'r');
+  VERIFY( s == L"Thi" );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/char/12.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/char/12.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/char/12.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,38 @@
+// { dg-options "-std=gnu++11" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <string>
+#include <sstream>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::string s;
+  getline(std::istringstream("First line\nSecond line\n"), s);
+  VERIFY( s == "First line" );
+  getline(std::istringstream("Third line\nFourth line\n"), s, 'r');
+  VERIFY( s == "Thi" );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/26_numerics/random/pr60037-neg.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+// { dg-do compile }
+// { dg-options "-std=gnu++11" }
+
+#include <random>
+
+std::mt19937 urng;
+
+std::__detail::_Adaptor<std::mt19937, unsigned long> aurng(urng);
+
+auto x = std::generate_canonical<std::size_t,
+			std::numeric_limits<std::size_t>::digits>(urng);
+
+// { dg-error "static assertion failed: template argument not a floating point type" "" { target *-*-* } 167 }
+
+// { dg-error "static assertion failed: template argument not a floating point type" "" { target *-*-* } 3466 }
Index: libstdc++-v3/testsuite/30_threads/packaged_task/forced_unwind.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/packaged_task/forced_unwind.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/packaged_task/forced_unwind.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,48 @@
+// { dg-do run { target *-*-linux* *-*-gnu* } }
+// { dg-options " -std=gnu++11 -pthread" { target *-*-linux* *-*-gnu* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// Test (non-standard) handling of __forced_unwind exception.
+
+#include <future>
+#include <stdexcept>
+#include <pthread.h>
+#include <testsuite_hooks.h>
+
+void f() { pthread_exit(nullptr); }
+
+int main()
+{
+  std::packaged_task<void()> p(f);
+  auto fut = p.get_future();
+  std::thread t(std::move(p));
+  try
+  {
+    fut.get();
+    throw std::logic_error("Unreachable");
+  }
+  catch (const std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::broken_promise );
+  }
+  t.join();
+}
Index: libstdc++-v3/testsuite/30_threads/try_lock/4.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/try_lock/4.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/try_lock/4.cc	(.../branches/gcc-4_9-branch)
@@ -133,8 +133,15 @@
       while (unreliable_lock::throw_on < 3)
       {
         unreliable_lock::count = 0;
-        int failed = std::try_lock(l1, l2, l3);
-        VERIFY( failed == unreliable_lock::throw_on );
+        try
+          {
+            std::try_lock(l1, l2, l3);
+            VERIFY( false );
+          }
+        catch (int e)
+          {
+            VERIFY( e == unreliable_lock::throw_on );
+          }
         ++unreliable_lock::throw_on;
       }
     }
Index: libstdc++-v3/testsuite/30_threads/async/forced_unwind.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/async/forced_unwind.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/async/forced_unwind.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,45 @@
+// { dg-do run { target *-*-linux* *-*-gnu* } }
+// { dg-options " -std=gnu++11 -pthread" { target *-*-linux* *-*-gnu* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// Test (non-standard) handling of __forced_unwind exception.
+
+#include <future>
+#include <stdexcept>
+#include <pthread.h>
+#include <testsuite_hooks.h>
+
+void f() { pthread_exit(nullptr); }
+
+int main()
+{
+  auto fut = std::async(std::launch::async, f);
+  try
+  {
+    fut.get();
+    throw std::logic_error("Unreachable");
+  }
+  catch (const std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::broken_promise );
+  }
+}
Index: libstdc++-v3/testsuite/experimental/string_view/cons/wchar_t/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/cons/wchar_t/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/cons/wchar_t/1.cc	(.../branches/gcc-4_9-branch)
@@ -33,7 +33,7 @@
   // basic_string_view()
   const std::experimental::wstring_view str00{};
   VERIFY( str00.length() == 0 );
-  VERIFY( str00.data() != nullptr );
+  VERIFY( str00.data() == nullptr );
 
   // basic_string_view(const char*)
   const wchar_t str_lit01[] = L"rodeo beach, marin";
@@ -54,11 +54,6 @@
   VERIFY( str05.length() == len_lit01 );
   VERIFY( str05.data() == str_lit01 );
 
-  //  basic_string_view(const wchar_t* s, std::size_t l)
-  std::experimental::wstring_view str06{nullptr, len_lit01};
-  VERIFY( str06.length() == 0 );
-  VERIFY( str06.data() != nullptr );
-
   // basic_string_view(basic_string& s)
   std::wstring istr07(10, L'z');
   std::experimental::wstring_view str07{istr07};
Index: libstdc++-v3/testsuite/experimental/string_view/cons/char/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/cons/char/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/cons/char/1.cc	(.../branches/gcc-4_9-branch)
@@ -33,7 +33,7 @@
   // basic_string_view()
   const std::experimental::string_view str00{};
   VERIFY( str00.length() == 0 );
-  VERIFY( str00.data() != nullptr );
+  VERIFY( str00.data() == nullptr );
 
   // basic_string_view(const char*)
   const char str_lit01[] = "rodeo beach, marin";
@@ -54,11 +54,6 @@
   VERIFY( str05.length() == len_lit01 );
   VERIFY( str05.data() == str_lit01 );
 
-  //  basic_string_view(const char* s, std::size_t l)
-  std::experimental::string_view str06{nullptr, len_lit01};
-  VERIFY( str06.length() == 0 );
-  VERIFY( str06.data() != nullptr );
-
   // basic_string_view(basic_string& s)
   std::string istr07(10, 'z');
   std::experimental::string_view str07{istr07};
Index: libstdc++-v3/testsuite/experimental/string_view/operations/to_string/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/to_string/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/to_string/1.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++1y" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// basic_string_view::to_string
+
+#include <experimental/string_view>
+#include <algorithm>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+bool
+test01()
+{
+  bool test [[gnu::unused]] = true;
+
+  const char str_lit[] = "123456789A";
+  const std::experimental::string_view sv(str_lit);
+  char buffer[4] = { 0 };
+
+  auto s1 = sv.to_string();
+  VERIFY( s1 == str_lit );
+  using test_alloc = __gnu_test::tracker_allocator<char>;
+  auto s2 = sv.to_string( test_alloc{} );
+  static_assert( std::is_same<decltype(s2)::allocator_type, test_alloc>::value,
+                 "to_string() uses custom allocator" );
+  VERIFY( std::equal(s1.begin(), s1.end(), s2.begin(), s2.end()) );
+  auto s3 = static_cast<std::string>(sv);
+  VERIFY( s3 == s1 );
+
+  return test;
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/experimental/string_view/operations/data/wchar_t/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/wchar_t/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/wchar_t/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -29,10 +29,9 @@
 
   std::experimental::wstring_view empty;
 
-  // data() for size == 0 is non-NULL.
   VERIFY( empty.size() == 0 );
   const std::experimental::wstring_view::value_type* p = empty.data();
-  VERIFY( p );
+  VERIFY( p == nullptr );
 
   return 0;
 }
Index: libstdc++-v3/testsuite/experimental/string_view/operations/data/char/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/char/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/data/char/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -29,10 +29,9 @@
 
   std::experimental::string_view empty;
 
-  // data() for size == 0 is non-NULL.
   VERIFY( empty.size() == 0 );
   const std::experimental::string_view::value_type* p = empty.data();
-  VERIFY( p );
+  VERIFY( p == nullptr );
 
   return 0;
 }
Index: libstdc++-v3/testsuite/experimental/string_view/operations/copy/wchar_t/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/wchar_t/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/wchar_t/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -20,7 +20,6 @@
 // basic_string_view::copy
 
 #include <experimental/string_view>
-#include <stdexcept>
 #include <testsuite_hooks.h>
 
 bool
Index: libstdc++-v3/testsuite/experimental/string_view/operations/copy/char/1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/char/1.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/string_view/operations/copy/char/1.cc	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 // { dg-options "-std=gnu++1y" }
 
-// Copyright (C) 2013 Free Software Foundation, Inc.
+// Copyright (C) 2013-2014 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -20,7 +20,6 @@
 // basic_string_view::copy
 
 #include <experimental/string_view>
-#include <stdexcept>
 #include <testsuite_hooks.h>
 
 bool
Index: libstdc++-v3/testsuite/experimental/feat-lib-fund.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/feat-lib-fund.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/feat-lib-fund.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,25 @@
+// { dg-options "-std=gnu++14" }
+// { dg-do compile }
+
+#include <experimental/optional>
+#include <experimental/string_view>
+
+#if !__has_include(<experimental/optional>)
+#  error "<experimental/optional>"
+#endif
+
+//#if !__has_include(<experimental/net>)
+//#  error "<experimental/net>"
+//#endif
+
+//#if !__has_include(<experimental/any>)
+//#  error "<experimental/any>"
+//#endif
+
+//#if !__has_include(<experimental/memory_resource>)
+//#  error "<experimental/memory_resource>"
+//#endif
+
+#if !__has_include(<experimental/string_view>)
+#  error "<experimental/string_view>"
+#endif
Index: libstdc++-v3/testsuite/experimental/feat-cxx14.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/feat-cxx14.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/experimental/feat-cxx14.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,119 @@
+// { dg-options "-std=gnu++14" }
+// { dg-do compile }
+
+#include <utility>
+#include <tuple>
+#include <memory>
+#include <functional>
+#include <type_traits>
+#include <chrono>
+#include <string>
+#include <complex>
+#include <iomanip>
+#include <shared_mutex>
+
+#ifndef  __cpp_lib_integer_sequence
+#  error "__cpp_lib_integer_sequence"
+#elif  __cpp_lib_integer_sequence != 201304
+#  error "__cpp_lib_integer_sequence != 201304"
+#endif
+
+#ifndef  __cpp_lib_exchange_function
+#  error "__cpp_lib_exchange_function"
+#elif  __cpp_lib_exchange_function != 201304
+#  error "__cpp_lib_exchange_function != 201304"
+#endif
+
+#ifndef  __cpp_lib_tuples_by_type
+#  error "__cpp_lib_tuples_by_type"
+#elif  __cpp_lib_tuples_by_type != 201304
+#  error "__cpp_lib_tuples_by_type != 201304"
+#endif
+
+#ifndef  __cpp_lib_make_unique
+#  error "__cpp_lib_make_unique"
+#elif  __cpp_lib_make_unique != 201304
+#  error "__cpp_lib_make_unique != 201304"
+#endif
+
+#ifndef  __cpp_lib_transparent_operators
+#  error "__cpp_lib_transparent_operators"
+#elif  __cpp_lib_transparent_operators != 201210
+#  error "__cpp_lib_transparent_operators != 201210"
+#endif
+
+#ifndef  __cpp_lib_result_of_sfinae
+#  error "__cpp_lib_result_of_sfinae"
+#elif  __cpp_lib_result_of_sfinae != 201210
+#  error "__cpp_lib_result_of_sfinae != 201210"
+#endif
+
+#ifndef  __cpp_lib_integral_constant_callable
+#  error "__cpp_lib_integral_constant_callable"
+#elif  __cpp_lib_integral_constant_callable != 201304
+#  error "__cpp_lib_integral_constant_callable != 201304"
+#endif
+
+#ifndef  __cpp_lib_transformation_trait_aliases
+#  error "__cpp_lib_transformation_trait_aliases"
+#elif  __cpp_lib_transformation_trait_aliases != 201304
+#  error "__cpp_lib_transformation_trait_aliases != 201304"
+#endif
+
+#ifndef  __cpp_lib_chrono_udls
+#  error "__cpp_lib_chrono_udls"
+#elif  __cpp_lib_chrono_udls != 201304
+#  error "__cpp_lib_chrono_udls != 201304"
+#endif
+
+#ifndef  __cpp_lib_string_udls
+#  error "__cpp_lib_string_udls"
+#elif  __cpp_lib_string_udls != 201304
+#  error "__cpp_lib_string_udls != 201304"
+#endif
+
+#ifndef __cpp_lib_complex_udls
+#  error "__cpp_lib_complex_udls"
+#elif  __cpp_lib_complex_udls != 201309
+#  error "__cpp_lib_complex_udls != 201309"
+#endif
+
+//#ifndef  __cpp_lib_generic_associative_lookup
+//#  error "__cpp_lib_generic_associative_lookup"
+//#elif  __cpp_lib_generic_associative_lookup != 201304
+//#  error "__cpp_lib_generic_associative_lookup != 201304"
+//#endif
+
+//#ifndef  __cpp_lib_null_iterators
+//#  error "__cpp_lib_null_iterators"
+//#elif  __cpp_lib_null_iterators != 201304
+//#  error "__cpp_lib_null_iterators != 201304"
+//#endif
+
+#ifndef  __cpp_lib_robust_nonmodifying_seq_ops
+#  error "__cpp_lib_robust_nonmodifying_seq_ops"
+#elif  __cpp_lib_robust_nonmodifying_seq_ops != 201304
+#  error "__cpp_lib_robust_nonmodifying_seq_ops != 201304"
+#endif
+
+#ifndef  __cpp_lib_quoted_string_io
+#  error "__cpp_lib_quoted_string_io"
+#elif  __cpp_lib_quoted_string_io != 201304
+#  error "__cpp_lib_quoted_string_io != 201304"
+#endif
+
+#if !__has_include(<shared_mutex>)
+#  error "<shared_mutex>"
+#endif
+
+#ifndef  __cpp_lib_shared_timed_mutex
+#  error "__cpp_lib_shared_timed_mutex"
+#elif  __cpp_lib_shared_timed_mutex != 201402
+#  error "__cpp_lib_shared_timed_mutex != 201402"
+#endif
+
+#ifndef  __cpp_lib_is_final
+#  error "__cpp_lib_is_final"
+#elif  __cpp_lib_is_final != 201402
+#  error "__cpp_lib_is_final != 201402"
+#endif
Index: libstdc++-v3/testsuite/ext/random/hypergeometric_distribution/pr60037.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/ext/random/hypergeometric_distribution/pr60037.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/ext/random/hypergeometric_distribution/pr60037.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+// { dg-options "-std=gnu++11 -O0" }
+// { dg-require-cstdint "" }
+// { dg-require-cmath "" }
+
+#include <ext/random>
+#include <functional>
+
+void
+hyperplot(unsigned int N, unsigned int K, unsigned int n)
+{
+  std::mt19937 re; // the default engine
+  __gnu_cxx::hypergeometric_distribution<> hd(N, K, n);
+  auto gen = std::bind(hd, re);
+  gen();
+}
+
+int
+main()
+{
+  hyperplot(15, 3, 2);
+  hyperplot(500, 50, 30);
+  hyperplot(100, 20, 5);
+}
Index: libstdc++-v3/testsuite/ext/rope/61946.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/ext/rope/61946.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/ext/rope/61946.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+
+#include <ext/rope>
+
+struct empty_char_prod : __gnu_cxx::char_producer<char>
+{
+  virtual void operator()(size_t, size_t, char*) {}
+};
+
+int main ()
+{
+  empty_char_prod* ecp = new empty_char_prod;
+  __gnu_cxx::crope excrope( ecp, 10L, true );
+}
Index: libstdc++-v3/testsuite/lib/gdb-test.exp
===================================================================
--- a/src/libstdc++-v3/testsuite/lib/gdb-test.exp	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/lib/gdb-test.exp	(.../branches/gcc-4_9-branch)
@@ -91,7 +91,7 @@
 	}
     }
 
-    set do_whatis_tests [gdb_batch_check "python print gdb.type_printers" \
+    set do_whatis_tests [gdb_batch_check "python print(gdb.type_printers)" \
 			   "\\\[\\\]"]
     if {!$do_whatis_tests} {
 	send_log "skipping 'whatis' tests - gdb too old"
@@ -252,6 +252,6 @@
 # but not earlier versions.
 # Return 1 if the version is ok, 0 otherwise.
 proc gdb_version_check {} {
-    return [gdb_batch_check "python print gdb.lookup_global_symbol" \
+    return [gdb_batch_check "python print(gdb.lookup_global_symbol)" \
 	      "<built-in function lookup_global_symbol>"]
 }
Index: libstdc++-v3/testsuite/23_containers/queue/requirements/uses_allocator.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/queue/requirements/uses_allocator.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/queue/requirements/uses_allocator.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include <queue>
+
+template<typename A>
+  using uses_allocator = std::uses_allocator<std::queue<int>, A>;
+
+static_assert( uses_allocator<std::allocator<int>>::value, "valid allocator" );
+
+struct X { };
+static_assert( !uses_allocator<X>::value, "invalid allocator" );
Index: libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/61667.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/61667.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/61667.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,44 @@
+// { dg-options "-std=gnu++11" }
+
+// Copyright (C) 2011-2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+
+bool test __attribute__((unused)) = true;
+
+void test01()
+{
+  std::unordered_map<int, int> um(20);
+
+  std::size_t bkt_count = um.bucket_count();
+
+  um.max_load_factor(um.max_load_factor());
+
+  VERIFY( um.bucket_count() >= bkt_count );
+
+  um.max_load_factor(um.max_load_factor() * 2.f);
+
+  VERIFY( um.bucket_count() >= bkt_count );
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/23_containers/priority_queue/requirements/uses_allocator.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/priority_queue/requirements/uses_allocator.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/priority_queue/requirements/uses_allocator.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include <queue>
+
+template<typename A>
+  using uses_allocator = std::uses_allocator<std::priority_queue<int>, A>;
+
+static_assert( uses_allocator<std::allocator<int>>::value, "valid allocator" );
+
+struct X { };
+static_assert( !uses_allocator<X>::value, "invalid allocator" );
Index: libstdc++-v3/testsuite/23_containers/unordered_set/63456.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_set/63456.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_set/63456.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <unordered_set>
+
+void test01()
+{
+  std::unordered_set<int> s1, s2;
+  s2.insert(2);
+
+  s1 = s2;
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/23_containers/stack/requirements/uses_allocator.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/stack/requirements/uses_allocator.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/stack/requirements/uses_allocator.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include <stack>
+
+template<typename A>
+  using uses_allocator = std::uses_allocator<std::stack<int>, A>;
+
+static_assert( uses_allocator<std::allocator<int>>::value, "valid allocator" );
+
+struct X { };
+static_assert( !uses_allocator<X>::value, "invalid allocator" );
Index: libstdc++-v3/testsuite/util/testsuite_tr1.h
===================================================================
--- a/src/libstdc++-v3/testsuite/util/testsuite_tr1.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/util/testsuite_tr1.h	(.../branches/gcc-4_9-branch)
@@ -100,6 +100,10 @@
 
   class DerivedType : public ClassType { };
 
+#if __cplusplus >= 201103L
+  class FinalType final : public DerivedType { };
+#endif
+
   enum EnumType { e0 };
 
   struct ConvType
Index: libstdc++-v3/testsuite/util/testsuite_iterators.h
===================================================================
--- a/src/libstdc++-v3/testsuite/util/testsuite_iterators.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/util/testsuite_iterators.h	(.../branches/gcc-4_9-branch)
@@ -518,7 +518,7 @@
    * It takes two pointers representing a range and presents them as 
    * a container of iterators.
    */
-  template <class T, template<class T> class ItType>
+  template <class T, template<class TT> class ItType>
   struct test_container
   {
     typename ItType<T>::ContainerType bounds;
Index: libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc	(.../branches/gcc-4_9-branch)
@@ -48,5 +48,5 @@
 // { dg-error "required from here" "" { target *-*-* } 40 }
 // { dg-error "required from here" "" { target *-*-* } 42 }
 
-// { dg-error "invalid use of incomplete type" "" { target *-*-* } 1747 }
-// { dg-error "declaration of" "" { target *-*-* } 1711 }
+// { dg-error "invalid use of incomplete type" "" { target *-*-* } 1764 }
+// { dg-error "declaration of" "" { target *-*-* } 1728 }
Index: libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc	(.../branches/gcc-4_9-branch)
@@ -48,5 +48,5 @@
 // { dg-error "required from here" "" { target *-*-* } 40 }
 // { dg-error "required from here" "" { target *-*-* } 42 }
 
-// { dg-error "invalid use of incomplete type" "" { target *-*-* } 1650 }
-// { dg-error "declaration of" "" { target *-*-* } 1614 }
+// { dg-error "invalid use of incomplete type" "" { target *-*-* } 1667 }
+// { dg-error "declaration of" "" { target *-*-* } 1631 }
Index: libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc	(.../branches/gcc-4_9-branch)
@@ -19,7 +19,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-error "static assertion failed" "" { target *-*-* } 2036 }
+// { dg-error "static assertion failed" "" { target *-*-* } 2053 }
 
 #include <utility>
 
Index: libstdc++-v3/testsuite/20_util/is_final/value.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/is_final/value.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/20_util/is_final/value.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+// { dg-options "-std=gnu++14" }
+// { dg-do compile }
+
+// Copyright (C) 2011-2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <type_traits>
+#include <testsuite_tr1.h>
+
+void test01()
+{
+  using std::is_final;
+  using namespace __gnu_test;
+
+  // Positive test.
+  static_assert(test_category<is_final, FinalType>(true), "");
+
+  // Negative tests.
+  static_assert(test_category<is_final, ClassType>(false), "");
+  static_assert(test_category<is_final, DerivedType>(false), "");
+}
Index: libstdc++-v3/testsuite/20_util/is_final/requirements/typedefs.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/is_final/requirements/typedefs.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/20_util/is_final/requirements/typedefs.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+// { dg-options "-std=gnu++14" }
+// { dg-do compile }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 
+// NB: This file is for testing type_traits with NO OTHER INCLUDES.
+
+#include <type_traits>
+
+void test01()
+{
+  // Check for required typedefs
+  typedef std::is_final<int> test_type;
+  typedef test_type::value_type               value_type;
+  typedef test_type::type                     type;
+  typedef test_type::type::value_type         type_value_type;
+  typedef test_type::type::type               type_type;
+}
Index: libstdc++-v3/testsuite/20_util/is_final/requirements/explicit_instantiation.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/is_final/requirements/explicit_instantiation.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/libstdc++-v3/testsuite/20_util/is_final/requirements/explicit_instantiation.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// { dg-options "-std=gnu++14" }
+// { dg-do compile }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// NB: This file is for testing type_traits with NO OTHER INCLUDES.
+
+#include <type_traits>
+
+namespace std
+{
+  typedef short test_type;
+  template struct is_final<test_type>;
+}
Index: configure.ac
===================================================================
--- a/src/configure.ac	(.../tags/gcc_4_9_1_release)
+++ b/src/configure.ac	(.../branches/gcc-4_9-branch)
@@ -1177,6 +1177,9 @@
   *-mingw*)
     host_makefile_frag="config/mh-mingw"
     ;;
+  alpha*-*-linux*)
+    host_makefile_frag="config/mh-alpha-linux"
+    ;;
   hppa*-hp-hpux10*)
     host_makefile_frag="config/mh-pa-hpux10"
     ;;
Index: ChangeLog
===================================================================
--- a/src/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,9 @@
+2014-07-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/47230
+	* configure.ac (alpha*-*-linux*): Use mh-alpha-linux.
+	* configure: Regenerate.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
@@ -9,7 +15,7 @@
 2014-04-04  Eric Botcazou  <ebotcazou@adacore.com>
 
 	PR bootstrap/60620
-	* Makefile.def (dependencies): Make gnattools depend on libstdc++-v3. 
+	* Makefile.def (dependencies): Make gnattools depend on libstdc++-v3.
 	* Makefile.in: Regenerate.
 
 2014-03-28  Yaakov Selkowitz  <yselkowitz@users.sourceforge.net>
@@ -47,7 +53,8 @@
 
 2014-03-07  Denis Chertykov  <chertykov@gmail.com>
 
-	* MAINTAINERS: Remove avr maintainers: Anatoly Sokolov and Eric Weddington
+	* MAINTAINERS: Remove avr maintainers: Anatoly Sokolov
+	and Eric Weddington
 
 2014-03-07  Jakub Jelinek  <jakub@redhat.com>
 
Index: contrib/config-list.mk
===================================================================
--- a/src/contrib/config-list.mk	(.../tags/gcc_4_9_1_release)
+++ b/src/contrib/config-list.mk	(.../branches/gcc-4_9-branch)
@@ -68,7 +68,7 @@
   sparc-wrs-vxworks sparc64-elf sparc64-rtems sparc64-linux sparc64-freebsd6 \
   sparc64-netbsd sparc64-openbsd spu-elf \
   tilegx-linux-gnu tilegxbe-linux-gnu tilepro-linux-gnu \
-  v850e-elf v850-elf vax-linux-gnu \
+  v850e-elf v850-elf v850-rtems vax-linux-gnu \
   vax-netbsdelf vax-openbsd x86_64-apple-darwin \
   x86_64-pc-linux-gnuOPT-with-fpmath=avx \
   x86_64-elfOPT-with-fpmath=sse x86_64-freebsd6 x86_64-netbsd \
Index: contrib/ChangeLog
===================================================================
--- a/src/contrib/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/contrib/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,12 @@
+2014-09-18  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* config-list.mk (LIST): Add v850-rtems.
+
+2014-09-18  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config-list.mk (LIST): Add arm-rtems.
+	Add nios2-rtems.  Remove extra option from powerpc-rtems.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: config/mh-alpha-linux
===================================================================
--- a/src/config/mh-alpha-linux	(.../tags/gcc_4_9_1_release)
+++ b/src/config/mh-alpha-linux	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+# Prevent GPREL16 relocation truncation
+LDFLAGS += -Wl,--no-relax
+BOOT_LDFLAGS += -Wl,--no-relax
Index: config/ChangeLog
===================================================================
--- a/src/config/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/config/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2014-07-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/47230
+	* mh-alpha-linux: New file.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libjava/classpath
===================================================================
--- a/src/libjava/classpath	(.../tags/gcc_4_9_1_release)
+++ b/src/libjava/classpath	(.../branches/gcc-4_9-branch)

Property changes on: libjava/classpath
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/libjava/classpath:r214798,215049,215136,215176
Index: configure
===================================================================
--- a/src/configure	(.../tags/gcc_4_9_1_release)
+++ b/src/configure	(.../branches/gcc-4_9-branch)
@@ -3868,6 +3868,9 @@
   *-mingw*)
     host_makefile_frag="config/mh-mingw"
     ;;
+  alpha*-*-linux*)
+    host_makefile_frag="config/mh-alpha-linux"
+    ;;
   hppa*-hp-hpux10*)
     host_makefile_frag="config/mh-pa-hpux10"
     ;;
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,27 @@
+2014-09-18  Joseph Myers  <joseph@codesourcery.com>
+
+	* config/i386/sfp-machine.h (FP_TRAPPING_EXCEPTIONS): Treat clear
+	bits not set bits as indicating trapping exceptions.
+
+2014-09-11  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2014-09-11 trunk r215152.
+
+	PR target/63223
+	* config/avr/libgcc.S (__tablejump2__): Rewrite to use RAMPZ, ELPM
+	and R24 as needed.  Make work for all devices and .text locations.
+	(__do_global_ctors, __do_global_dtors): Use word addresses.
+	(__tablejump__, __tablejump_elpm__): Remove functions.
+	* t-avr (LIB1ASMFUNCS): Remove _tablejump, _tablejump_elpm.
+	Add _tablejump2.
+	(XICALL, XIJMP): New macros.
+
+2014-08-04  Rohit  <rohitarulraj@freescale.com>
+
+	PR target/60102
+	* config/rs6000/linux-unwind.h (ppc_fallback_frame_state): Update
+	based on change in SPE high register numbers and 3 HTM registers.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgcc/config/i386/sfp-machine.h
===================================================================
--- a/src/libgcc/config/i386/sfp-machine.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libgcc/config/i386/sfp-machine.h	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,7 @@
       __sfp_handle_exceptions (_fex);		\
   } while (0);
 
-#define FP_TRAPPING_EXCEPTIONS ((_fcw >> FP_EX_SHIFT) & FP_EX_ALL)
+#define FP_TRAPPING_EXCEPTIONS ((~_fcw >> FP_EX_SHIFT) & FP_EX_ALL)
 
 #define FP_ROUNDMODE		(_fcw & FP_RND_MASK)
 #endif
Index: libgcc/config/rs6000/linux-unwind.h
===================================================================
--- a/src/libgcc/config/rs6000/linux-unwind.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libgcc/config/rs6000/linux-unwind.h	(.../branches/gcc-4_9-branch)
@@ -274,8 +274,8 @@
 #ifdef __SPE__
   for (i = 14; i < 32; i++)
     {
-      fs->regs.reg[i + FIRST_PSEUDO_REGISTER - 1].how = REG_SAVED_OFFSET;
-      fs->regs.reg[i + FIRST_PSEUDO_REGISTER - 1].loc.offset
+      fs->regs.reg[i + FIRST_SPE_HIGH_REGNO - 4].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i + FIRST_SPE_HIGH_REGNO - 4].loc.offset
 	= (long) &regs->vregs - new_cfa + 4 * i;
     }
 #endif
Index: libgcc/config/avr/lib1funcs.S
===================================================================
--- a/src/libgcc/config/avr/lib1funcs.S	(.../tags/gcc_4_9_1_release)
+++ b/src/libgcc/config/avr/lib1funcs.S	(.../branches/gcc-4_9-branch)
@@ -46,6 +46,10 @@
            input sections together are small enough to reach every
            location with a RCALL/RJMP instruction.  */
 
+#if defined (__AVR_HAVE_EIJMP_EICALL__) && !defined (__AVR_HAVE_ELPMX__)
+#error device not supported
+#endif
+
 	.macro	mov_l  r_dest, r_src
 #if defined (__AVR_HAVE_MOVW__)
 	movw	\r_dest, \r_src
@@ -79,6 +83,14 @@
 #define XJMP  rjmp
 #endif
 
+#if defined (__AVR_HAVE_EIJMP_EICALL__)
+#define XICALL eicall
+#define XIJMP  eijmp
+#else
+#define XICALL icall
+#define XIJMP  ijmp
+#endif
+
 ;; Prologue stuff
 
 .macro do_prologue_saves n_pushed n_frame=0
@@ -2127,11 +2139,7 @@
 	out	__SP_L__,r28
 #endif /* #SP = 8/16 */
 
-#if defined (__AVR_HAVE_EIJMP_EICALL__)
-	eijmp
-#else
-	ijmp
-#endif
+	XIJMP
 
 ENDF __prologue_saves__
 #endif /* defined (L_prologue) */
@@ -2213,38 +2221,54 @@
 
 .section .text.libgcc, "ax", @progbits
 
-#ifdef L_tablejump
+#ifdef L_tablejump2
 DEFUN __tablejump2__
-	lsl	r30
-	rol	r31
-    ;; FALLTHRU
-ENDF __tablejump2__
-
-DEFUN __tablejump__
-#if defined (__AVR_HAVE_LPMX__)
-	lpm __tmp_reg__, Z+
-	lpm r31, Z
-	mov r30, __tmp_reg__
+    lsl     r30
+    rol     r31
 #if defined (__AVR_HAVE_EIJMP_EICALL__)
-	eijmp
-#else
-	ijmp
+    ;; Word address of gs() jumptable entry in R24:Z
+    rol     r24
+    out     __RAMPZ__, r24
+#elif defined (__AVR_HAVE_ELPM__)
+    ;; Word address of jumptable entry in Z
+    clr     __tmp_reg__
+    rol     __tmp_reg__
+    out     __RAMPZ__, __tmp_reg__
 #endif
 
-#else /* !HAVE_LPMX */
-	lpm
-	adiw r30, 1
-	push r0
-	lpm
-	push r0
-#if defined (__AVR_HAVE_EIJMP_EICALL__)
-	in   __tmp_reg__, __EIND__
-	push __tmp_reg__
+    ;; Read word address from jumptable and jump
+
+#if defined (__AVR_HAVE_ELPMX__)
+    elpm    __tmp_reg__, Z+
+    elpm    r31, Z
+    mov     r30, __tmp_reg__
+#ifdef __AVR_HAVE_RAMPD__
+    ;; Reset RAMPZ to 0 so that EBI devices don't read garbage from RAM
+    out     __RAMPZ__, __zero_reg__
+#endif /* RAMPD */
+    XIJMP
+#elif defined (__AVR_HAVE_ELPM__)
+    elpm
+    push    r0
+    adiw    r30, 1
+    elpm
+    push    r0
+    ret
+#elif defined (__AVR_HAVE_LPMX__)
+    lpm     __tmp_reg__, Z+
+    lpm     r31, Z
+    mov     r30, __tmp_reg__
+    ijmp
+#else
+    lpm
+    push    r0
+    adiw    r30, 1
+    lpm
+    push    r0
+    ret
 #endif
-	ret
-#endif /* !HAVE_LPMX */
-ENDF __tablejump__
-#endif /* defined (L_tablejump) */
+ENDF __tablejump2__
+#endif /* L_tablejump2 */
 
 #ifdef L_copy_data
 	.section .init4,"ax",@progbits
@@ -2336,40 +2360,30 @@
 #ifdef L_ctors
 	.section .init6,"ax",@progbits
 DEFUN __do_global_ctors
-#if defined(__AVR_HAVE_ELPM__)
-	ldi	r17, hi8(__ctors_start)
-	ldi	r28, lo8(__ctors_end)
-	ldi	r29, hi8(__ctors_end)
-	ldi	r16, hh8(__ctors_end)
-	rjmp	.L__do_global_ctors_start
+    ldi     r17, pm_hi8(__ctors_start)
+    ldi     r28, pm_lo8(__ctors_end)
+    ldi     r29, pm_hi8(__ctors_end)
+#ifdef __AVR_HAVE_EIJMP_EICALL__
+    ldi     r16, pm_hh8(__ctors_end)
+#endif /* HAVE_EIJMP */
+    rjmp    .L__do_global_ctors_start
 .L__do_global_ctors_loop:
-	sbiw	r28, 2
-	sbc     r16, __zero_reg__
-	mov_h	r31, r29
-	mov_l	r30, r28
-	out     __RAMPZ__, r16
-	XCALL	__tablejump_elpm__
+    sbiw    r28, 1
+#ifdef __AVR_HAVE_EIJMP_EICALL__
+    sbc     r16, __zero_reg__
+    mov     r24, r16
+#endif /* HAVE_EIJMP */
+    mov_h   r31, r29
+    mov_l   r30, r28
+    XCALL   __tablejump2__
 .L__do_global_ctors_start:
-	cpi	r28, lo8(__ctors_start)
-	cpc	r29, r17
-	ldi	r24, hh8(__ctors_start)
-	cpc	r16, r24
-	brne	.L__do_global_ctors_loop
-#else
-	ldi	r17, hi8(__ctors_start)
-	ldi	r28, lo8(__ctors_end)
-	ldi	r29, hi8(__ctors_end)
-	rjmp	.L__do_global_ctors_start
-.L__do_global_ctors_loop:
-	sbiw	r28, 2
-	mov_h	r31, r29
-	mov_l	r30, r28
-	XCALL	__tablejump__
-.L__do_global_ctors_start:
-	cpi	r28, lo8(__ctors_start)
-	cpc	r29, r17
-	brne	.L__do_global_ctors_loop
-#endif /* defined(__AVR_HAVE_ELPM__) */
+    cpi     r28, pm_lo8(__ctors_start)
+    cpc     r29, r17
+#ifdef __AVR_HAVE_EIJMP_EICALL__
+    ldi     r24, pm_hh8(__ctors_start)
+    cpc     r16, r24
+#endif /* HAVE_EIJMP */
+    brne    .L__do_global_ctors_loop
 ENDF __do_global_ctors
 #endif /* L_ctors */
 
@@ -2376,76 +2390,35 @@
 #ifdef L_dtors
 	.section .fini6,"ax",@progbits
 DEFUN __do_global_dtors
-#if defined(__AVR_HAVE_ELPM__)
-	ldi	r17, hi8(__dtors_end)
-	ldi	r28, lo8(__dtors_start)
-	ldi	r29, hi8(__dtors_start)
-	ldi	r16, hh8(__dtors_start)
-	rjmp	.L__do_global_dtors_start
+    ldi     r17, pm_hi8(__dtors_start)
+    ldi     r28, pm_lo8(__dtors_end)
+    ldi     r29, pm_hi8(__dtors_end)
+#ifdef __AVR_HAVE_EIJMP_EICALL__
+    ldi     r16, pm_hh8(__dtors_end)
+#endif /* HAVE_EIJMP */
+    rjmp    .L__do_global_dtors_start
 .L__do_global_dtors_loop:
-	sbiw	r28, 2
-	sbc     r16, __zero_reg__
-	mov_h	r31, r29
-	mov_l	r30, r28
-	out     __RAMPZ__, r16
-	XCALL	__tablejump_elpm__
+    sbiw    r28, 1
+#ifdef __AVR_HAVE_EIJMP_EICALL__
+    sbc     r16, __zero_reg__
+    mov     r24, r16
+#endif /* HAVE_EIJMP */
+    mov_h   r31, r29
+    mov_l   r30, r28
+    XCALL   __tablejump2__
 .L__do_global_dtors_start:
-	cpi	r28, lo8(__dtors_end)
-	cpc	r29, r17
-	ldi	r24, hh8(__dtors_end)
-	cpc	r16, r24
-	brne	.L__do_global_dtors_loop
-#else
-	ldi	r17, hi8(__dtors_end)
-	ldi	r28, lo8(__dtors_start)
-	ldi	r29, hi8(__dtors_start)
-	rjmp	.L__do_global_dtors_start
-.L__do_global_dtors_loop:
-	mov_h	r31, r29
-	mov_l	r30, r28
-	XCALL	__tablejump__
-	adiw	r28, 2
-.L__do_global_dtors_start:
-	cpi	r28, lo8(__dtors_end)
-	cpc	r29, r17
-	brne	.L__do_global_dtors_loop
-#endif /* defined(__AVR_HAVE_ELPM__) */
+    cpi     r28, pm_lo8(__dtors_start)
+    cpc     r29, r17
+#ifdef __AVR_HAVE_EIJMP_EICALL__
+    ldi     r24, pm_hh8(__dtors_start)
+    cpc     r16, r24
+#endif /* HAVE_EIJMP */
+    brne    .L__do_global_dtors_loop
 ENDF __do_global_dtors
 #endif /* L_dtors */
 
 .section .text.libgcc, "ax", @progbits
 
-#ifdef L_tablejump_elpm
-DEFUN __tablejump_elpm__
-#if defined (__AVR_HAVE_ELPMX__)
-	elpm	__tmp_reg__, Z+
-	elpm	r31, Z
-	mov	r30, __tmp_reg__
-#if defined (__AVR_HAVE_RAMPD__)
-	;; Reset RAMPZ to 0 so that EBI devices don't read garbage from RAM
-	out	__RAMPZ__, __zero_reg__
-#endif /* RAMPD */
-#if defined (__AVR_HAVE_EIJMP_EICALL__)
-	eijmp
-#else
-	ijmp
-#endif
-
-#elif defined (__AVR_HAVE_ELPM__)
-	elpm
-	adiw	r30, 1
-	push	r0
-	elpm
-	push	r0
-#if defined (__AVR_HAVE_EIJMP_EICALL__)
-	in      __tmp_reg__, __EIND__
-	push    __tmp_reg__
-#endif
-	ret
-#endif
-ENDF __tablejump_elpm__
-#endif /* defined (L_tablejump_elpm) */
-
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Loading n bytes from Flash; n = 3,4
 ;; R22... = Flash[Z]
Index: libgcc/config/avr/t-avr
===================================================================
--- a/src/libgcc/config/avr/t-avr	(.../tags/gcc_4_9_1_release)
+++ b/src/libgcc/config/avr/t-avr	(.../branches/gcc-4_9-branch)
@@ -26,8 +26,7 @@
 	_epilogue \
 	_exit \
 	_cleanup \
-	_tablejump \
-	_tablejump_elpm \
+	_tablejump2 \
 	_load_3 _load_4 \
 	_xload_1 _xload_2 _xload_3 _xload_4 \
 	_movmemx \
Index: gcc/tree-ssa-tail-merge.c
===================================================================
--- a/src/gcc/tree-ssa-tail-merge.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-tail-merge.c	(.../branches/gcc-4_9-branch)
@@ -312,9 +312,9 @@
   tree val;
   def_operand_p def_p;
 
-  if (gimple_has_side_effects (stmt)
-      || stmt_could_throw_p (stmt)
-      || gimple_vdef (stmt) != NULL_TREE)
+  if (gimple_vdef (stmt) != NULL_TREE
+      || gimple_has_side_effects (stmt)
+      || gimple_could_trap_p_1 (stmt, false, false))
     return false;
 
   def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);
@@ -1159,17 +1159,9 @@
       lhs2 = gimple_get_lhs (s2);
       if (TREE_CODE (lhs1) != SSA_NAME
 	  && TREE_CODE (lhs2) != SSA_NAME)
-	{
-	  /* If the vdef is the same, it's the same statement.  */
-	  if (vn_valueize (gimple_vdef (s1))
-	      == vn_valueize (gimple_vdef (s2)))
-	    return true;
-
-	  /* Test for structural equality.  */
-	  return (operand_equal_p (lhs1, lhs2, 0)
-		  && gimple_operand_equal_value_p (gimple_assign_rhs1 (s1),
-						   gimple_assign_rhs1 (s2)));
-	}
+	return (operand_equal_p (lhs1, lhs2, 0)
+		&& gimple_operand_equal_value_p (gimple_assign_rhs1 (s1),
+						 gimple_assign_rhs1 (s2)));
       else if (TREE_CODE (lhs1) == SSA_NAME
 	       && TREE_CODE (lhs2) == SSA_NAME)
 	return vn_valueize (lhs1) == vn_valueize (lhs2);
Index: gcc/tree-ssa-loop-niter.c
===================================================================
--- a/src/gcc/tree-ssa-loop-niter.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-loop-niter.c	(.../branches/gcc-4_9-branch)
@@ -1636,6 +1636,9 @@
 
     case PLUS_EXPR:
     case MINUS_EXPR:
+      if (TYPE_OVERFLOW_TRAPS (TREE_TYPE (expr)))
+	return expr;
+      /* Fallthru.  */
     case POINTER_PLUS_EXPR:
       /* And increments and decrements by a constant are simple.  */
       e1 = gimple_assign_rhs2 (stmt);
Index: gcc/c-family/c-cppbuiltin.c
===================================================================
--- a/src/gcc/c-family/c-cppbuiltin.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/c-cppbuiltin.c	(.../branches/gcc-4_9-branch)
@@ -794,6 +794,12 @@
   /* For stddef.h.  They require macros defined in c-common.c.  */
   c_stddef_cpp_builtins ();
 
+  /* Set include test macros for all C/C++ (not for just C++11 etc.)
+     the builtins __has_include__ and __has_include_next__ are defined
+     in libcpp.  */
+  cpp_define (pfile, "__has_include(STR)=__has_include__(STR)");
+  cpp_define (pfile, "__has_include_next(STR)=__has_include_next__(STR)");
+
   if (c_dialect_cxx ())
     {
       if (flag_weak && SUPPORTS_ONE_ONLY)
@@ -800,12 +806,54 @@
 	cpp_define (pfile, "__GXX_WEAK__=1");
       else
 	cpp_define (pfile, "__GXX_WEAK__=0");
+
       if (warn_deprecated)
 	cpp_define (pfile, "__DEPRECATED");
+
       if (flag_rtti)
 	cpp_define (pfile, "__GXX_RTTI");
+
       if (cxx_dialect >= cxx11)
         cpp_define (pfile, "__GXX_EXPERIMENTAL_CXX0X__");
+
+      /* Binary literals have been allowed in g++ before C++11
+	 and were standardized for C++14.  */
+      if (!pedantic || cxx_dialect > cxx11)
+	cpp_define (pfile, "__cpp_binary_literals=201304");
+      if (cxx_dialect >= cxx11)
+	{
+	  /* Set feature test macros for C++11  */
+	  cpp_define (pfile, "__cpp_unicode_characters=200704");
+	  cpp_define (pfile, "__cpp_raw_strings=200710");
+	  cpp_define (pfile, "__cpp_unicode_literals=200710");
+	  cpp_define (pfile, "__cpp_user_defined_literals=200809");
+	  cpp_define (pfile, "__cpp_lambdas=200907");
+	  cpp_define (pfile, "__cpp_constexpr=200704");
+	  cpp_define (pfile, "__cpp_static_assert=200410");
+	  cpp_define (pfile, "__cpp_decltype=200707");
+	  cpp_define (pfile, "__cpp_attributes=200809");
+	  cpp_define (pfile, "__cpp_rvalue_reference=200610");
+	  cpp_define (pfile, "__cpp_variadic_templates=200704");
+	  cpp_define (pfile, "__cpp_alias_templates=200704");
+	}
+      if (cxx_dialect > cxx11)
+	{
+	  /* Set feature test macros for C++14  */
+	  cpp_define (pfile, "__cpp_return_type_deduction=201304");
+	  cpp_define (pfile, "__cpp_init_captures=201304");
+	  cpp_define (pfile, "__cpp_generic_lambdas=201304");
+	  //cpp_undef (pfile, "__cpp_constexpr");
+	  //cpp_define (pfile, "__cpp_constexpr=201304");
+	  cpp_define (pfile, "__cpp_decltype_auto=201304");
+	  //cpp_define (pfile, "__cpp_aggregate_nsdmi=201304");
+	  //cpp_define (pfile, "__cpp_variable_templates=201304");
+	  cpp_define (pfile, "__cpp_digit_separators=201309");
+	  cpp_define (pfile, "__cpp_attribute_deprecated=201309");
+	  //cpp_define (pfile, "__cpp_sized_deallocation=201309");
+	  /* We'll have to see where runtime arrays wind up.
+	     Let's put it in C++14 for now.  */
+	  cpp_define (pfile, "__cpp_runtime_arrays=201304");
+	}
     }
   /* Note that we define this for C as well, so that we know if
      __attribute__((cleanup)) will interface with EH.  */
Index: gcc/c-family/c-gimplify.c
===================================================================
--- a/src/gcc/c-family/c-gimplify.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/c-gimplify.c	(.../branches/gcc-4_9-branch)
@@ -199,9 +199,7 @@
 	tree type = TREE_TYPE (TREE_OPERAND (*expr_p, 0));
 	if (INTEGRAL_TYPE_P (type) && c_promoting_integer_type_p (type))
 	  {
-	    if (TYPE_OVERFLOW_UNDEFINED (type)
-		|| ((flag_sanitize & SANITIZE_SI_OVERFLOW)
-		    && !TYPE_OVERFLOW_WRAPS (type)))
+	    if (!TYPE_OVERFLOW_WRAPS (type))
 	      type = unsigned_type_for (type);
 	    return gimplify_self_mod_expr (expr_p, pre_p, post_p, 1, type);
 	  }
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,38 @@
+2014-10-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/63495
+	* c-common.c (min_align_of_type): Don't decrease alignment
+	through BIGGEST_FIELD_ALIGNMENT or ADJUST_FIELD_ALIGN if
+	TYPE_USER_ALIGN is set.
+
+2014-10-08  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	Implement SD-6: SG10 Feature Test Recommendations
+	* c-cppbuiltin.c (c_cpp_builtins()): Define language feature
+	macros and the __has_header macro.
+
+2014-08-12  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61962
+	* array-notation-common.c (find_rank): Added handling for other
+	types of references.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* array-notation-common.c (extract_array_notation_exprs): Handling
+	of DECL_EXPR added.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-09  Richard Biener  <rguenther@suse.de>
+
+	PR c-family/61741
+	* c-gimplify.c (c_gimplify_expr): Gimplify self-modify expressions
+	using unsigned arithmetic if overflow does not wrap instead of
+	if overflow is undefined.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/c-family/c-common.c
===================================================================
--- a/src/gcc/c-family/c-common.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/c-common.c	(.../branches/gcc-4_9-branch)
@@ -4934,16 +4934,18 @@
 {
   unsigned int align = TYPE_ALIGN (type);
   align = MIN (align, BIGGEST_ALIGNMENT);
+  if (!TYPE_USER_ALIGN (type))
+    {
 #ifdef BIGGEST_FIELD_ALIGNMENT
-  align = MIN (align, BIGGEST_FIELD_ALIGNMENT);
+      align = MIN (align, BIGGEST_FIELD_ALIGNMENT);
 #endif
-  unsigned int field_align = align;
+      unsigned int field_align = align;
 #ifdef ADJUST_FIELD_ALIGN
-  tree field = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,
-			   type);
-  field_align = ADJUST_FIELD_ALIGN (field, field_align);
+      tree field = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE, type);
+      field_align = ADJUST_FIELD_ALIGN (field, field_align);
 #endif
-  align = MIN (align, field_align);
+      align = MIN (align, field_align);
+    }
   return align / BITS_PER_UNIT;
 }
 
Index: gcc/c-family/array-notation-common.c
===================================================================
--- a/src/gcc/c-family/array-notation-common.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c-family/array-notation-common.c	(.../branches/gcc-4_9-branch)
@@ -221,11 +221,14 @@
 	      current_rank++;
 	      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);
 	    }
-	  else if (TREE_CODE (ii_tree) == ARRAY_REF)
+	  else if (handled_component_p (ii_tree)
+		   || TREE_CODE (ii_tree) == INDIRECT_REF)
 	    ii_tree = TREE_OPERAND (ii_tree, 0);
 	  else if (TREE_CODE (ii_tree) == PARM_DECL
 		   || TREE_CODE (ii_tree) == VAR_DECL)
 	    break;
+	  else
+	    gcc_unreachable ();
 	}
       if (*rank == 0)
 	/* In this case, all the expressions this function has encountered thus
@@ -329,6 +332,14 @@
       vec_safe_push (*array_list, node);
       return;
     }
+  if (TREE_CODE (node) == DECL_EXPR)
+    {
+      tree x = DECL_EXPR_DECL (node);
+      if (DECL_INITIAL (x))
+	extract_array_notation_exprs (DECL_INITIAL (x),
+				      ignore_builtin_fn,
+				      array_list);
+    }
   else if (TREE_CODE (node) == STATEMENT_LIST)
     {
       tree_stmt_iterator ii_tsi;
Index: gcc/c/ChangeLog
===================================================================
--- a/src/gcc/c/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,30 @@
+2014-09-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR c++/63249
+	* c-parser.c (c_parser_omp_variable_list): Call mark_exp_read
+	on low_bound and length.
+
+2014-09-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c/62294
+	* c-typeck.c (convert_arguments): Get location of a parameter.  Change
+	error and warning calls to error_at and warning_at.  Pass location of
+	a parameter to it.
+	(convert_for_assignment): Add parameter to WARN_FOR_ASSIGNMENT and
+	WARN_FOR_QUALIFIERS.  Pass expr_loc to those.
+
+2014-08-22  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/62008
+	* c-parser.c (c_parser_array_notation): Check for correct
+	type of an array added.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* c-array-notation.c (expand_array_notations): Handling
+	of DECL_EXPR added.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/c/c-parser.c
===================================================================
--- a/src/gcc/c/c-parser.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c/c-parser.c	(.../branches/gcc-4_9-branch)
@@ -9764,7 +9764,10 @@
 
 		  c_parser_consume_token (parser);
 		  if (!c_parser_next_token_is (parser, CPP_COLON))
-		    low_bound = c_parser_expression (parser).value;
+		    {
+		      low_bound = c_parser_expression (parser).value;
+		      mark_exp_read (low_bound);
+		    }
 		  if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))
 		    length = integer_one_node;
 		  else
@@ -9777,7 +9780,10 @@
 			  break;
 			}
 		      if (!c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))
-			length = c_parser_expression (parser).value;
+			{
+			  length = c_parser_expression (parser).value;
+			  mark_exp_read (length);
+			}
 		    }
 		  /* Look for the closing `]'.  */
 		  if (!c_parser_require (parser, CPP_CLOSE_SQUARE,
@@ -14074,6 +14080,13 @@
   
   array_type = TREE_TYPE (array_value);
   gcc_assert (array_type);
+  if (TREE_CODE (array_type) != ARRAY_TYPE
+      && TREE_CODE (array_type) != POINTER_TYPE)
+    {
+      error_at (loc, "base of array section must be pointer or array type");
+      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);
+      return error_mark_node;
+    }
   type = TREE_TYPE (array_type);
   token = c_parser_peek_token (parser);
    
Index: gcc/c/c-typeck.c
===================================================================
--- a/src/gcc/c/c-typeck.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c/c-typeck.c	(.../branches/gcc-4_9-branch)
@@ -3071,6 +3071,12 @@
       bool excess_precision = false;
       bool npc;
       tree parmval;
+      /* Some __atomic_* builtins have additional hidden argument at
+	 position 0.  */
+      location_t ploc
+	= !arg_loc.is_empty () && values->length () == arg_loc.length ()
+	  ? expansion_point_location_if_in_system_header (arg_loc[parmnum])
+	  : input_location;
 
       if (type == void_type_node)
 	{
@@ -3113,7 +3119,8 @@
 
 	  if (type == error_mark_node || !COMPLETE_TYPE_P (type))
 	    {
-	      error ("type of formal parameter %d is incomplete", parmnum + 1);
+	      error_at (ploc, "type of formal parameter %d is incomplete",
+			parmnum + 1);
 	      parmval = val;
 	    }
 	  else
@@ -3128,34 +3135,34 @@
 
 		  if (INTEGRAL_TYPE_P (type)
 		      && TREE_CODE (valtype) == REAL_TYPE)
-		    warning (0, "passing argument %d of %qE as integer "
-			     "rather than floating due to prototype",
-			     argnum, rname);
+		    warning_at (ploc, 0, "passing argument %d of %qE as "
+				"integer rather than floating due to "
+				"prototype", argnum, rname);
 		  if (INTEGRAL_TYPE_P (type)
 		      && TREE_CODE (valtype) == COMPLEX_TYPE)
-		    warning (0, "passing argument %d of %qE as integer "
-			     "rather than complex due to prototype",
-			     argnum, rname);
+		    warning_at (ploc, 0, "passing argument %d of %qE as "
+				"integer rather than complex due to "
+				"prototype", argnum, rname);
 		  else if (TREE_CODE (type) == COMPLEX_TYPE
 			   && TREE_CODE (valtype) == REAL_TYPE)
-		    warning (0, "passing argument %d of %qE as complex "
-			     "rather than floating due to prototype",
-			     argnum, rname);
+		    warning_at (ploc, 0, "passing argument %d of %qE as "
+				"complex rather than floating due to "
+				"prototype", argnum, rname);
 		  else if (TREE_CODE (type) == REAL_TYPE
 			   && INTEGRAL_TYPE_P (valtype))
-		    warning (0, "passing argument %d of %qE as floating "
-			     "rather than integer due to prototype",
-			     argnum, rname);
+		    warning_at (ploc, 0, "passing argument %d of %qE as "
+				"floating rather than integer due to "
+				"prototype", argnum, rname);
 		  else if (TREE_CODE (type) == COMPLEX_TYPE
 			   && INTEGRAL_TYPE_P (valtype))
-		    warning (0, "passing argument %d of %qE as complex "
-			     "rather than integer due to prototype",
-			     argnum, rname);
+		    warning_at (ploc, 0, "passing argument %d of %qE as "
+				"complex rather than integer due to "
+				"prototype", argnum, rname);
 		  else if (TREE_CODE (type) == REAL_TYPE
 			   && TREE_CODE (valtype) == COMPLEX_TYPE)
-		    warning (0, "passing argument %d of %qE as floating "
-			     "rather than complex due to prototype",
-			     argnum, rname);
+		    warning_at (ploc, 0, "passing argument %d of %qE as "
+				"floating rather than complex due to "
+				"prototype", argnum, rname);
 		  /* ??? At some point, messages should be written about
 		     conversions between complex types, but that's too messy
 		     to do now.  */
@@ -3166,9 +3173,10 @@
 			 since without a prototype it would be `double'.  */
 		      if (formal_prec == TYPE_PRECISION (float_type_node)
 			  && type != dfloat32_type_node)
-			warning (0, "passing argument %d of %qE as %<float%> "
-				 "rather than %<double%> due to prototype",
-				 argnum, rname);
+			warning_at (ploc, 0,
+				    "passing argument %d of %qE as %<float%> "
+				    "rather than %<double%> due to prototype",
+				    argnum, rname);
 
 		      /* Warn if mismatch between argument and prototype
 			 for decimal float types.  Warn of conversions with
@@ -3191,9 +3199,10 @@
 				   || (type == dfloat64_type_node
 				       && (valtype
 					   != dfloat32_type_node))))
-			warning (0, "passing argument %d of %qE as %qT "
-				 "rather than %qT due to prototype",
-				 argnum, rname, type, valtype);
+			warning_at (ploc, 0,
+				    "passing argument %d of %qE as %qT "
+				    "rather than %qT due to prototype",
+				    argnum, rname, type, valtype);
 
 		    }
 		  /* Detect integer changing in width or signedness.
@@ -3212,10 +3221,10 @@
 			   and the actual arg is that enum type.  */
 			;
 		      else if (formal_prec != TYPE_PRECISION (type1))
-			warning (OPT_Wtraditional_conversion,
-				 "passing argument %d of %qE "
-				 "with different width due to prototype",
-				 argnum, rname);
+			warning_at (ploc, OPT_Wtraditional_conversion,
+				    "passing argument %d of %qE "
+				    "with different width due to prototype",
+				    argnum, rname);
 		      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))
 			;
 		      /* Don't complain if the formal parameter type
@@ -3236,14 +3245,15 @@
 			       && TYPE_UNSIGNED (valtype))
 			;
 		      else if (TYPE_UNSIGNED (type))
-			warning (OPT_Wtraditional_conversion,
-				 "passing argument %d of %qE "
-				 "as unsigned due to prototype",
-				 argnum, rname);
+			warning_at (ploc, OPT_Wtraditional_conversion,
+				    "passing argument %d of %qE "
+				    "as unsigned due to prototype",
+				    argnum, rname);
 		      else
-			warning (OPT_Wtraditional_conversion,
-				 "passing argument %d of %qE "
-				 "as signed due to prototype", argnum, rname);
+			warning_at (ploc, OPT_Wtraditional_conversion,
+				    "passing argument %d of %qE "
+				    "as signed due to prototype",
+				    argnum, rname);
 		    }
 		}
 
@@ -3252,13 +3262,7 @@
 	      if (excess_precision)
 		val = build1 (EXCESS_PRECISION_EXPR, valtype, val);
 	      origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];
-	      bool arg_loc_ok = !arg_loc.is_empty ()
-				/* Some __atomic_* builtins have additional
-				   hidden argument at position 0.  */
-				&& values->length () == arg_loc.length ();
-	      parmval = convert_for_assignment (loc,
-						arg_loc_ok ? arg_loc[parmnum]
-						: UNKNOWN_LOCATION, type,
+	      parmval = convert_for_assignment (loc, ploc, type,
 						val, origtype, ic_argpass,
 						npc, fundecl, function,
 						parmnum + 1);
@@ -3282,10 +3286,10 @@
 	    {
 	      /* Convert `float' to `double'.  */
 	      if (warn_double_promotion && !c_inhibit_evaluation_warnings)
-		warning_at (arg_loc[parmnum], OPT_Wdouble_promotion,
-			 "implicit conversion from %qT to %qT when passing "
-			 "argument to function",
-			 valtype, double_type_node);
+		warning_at (ploc, OPT_Wdouble_promotion,
+			    "implicit conversion from %qT to %qT when passing "
+			    "argument to function",
+			    valtype, double_type_node);
 	      parmval = convert (double_type_node, val);
 	    }
 	}
@@ -5591,14 +5595,14 @@
   /* This macro is used to emit diagnostics to ensure that all format
      strings are complete sentences, visible to gettext and checked at
      compile time.  */
-#define WARN_FOR_ASSIGNMENT(LOCATION, OPT, AR, AS, IN, RE)             	 \
+#define WARN_FOR_ASSIGNMENT(LOCATION, PLOC, OPT, AR, AS, IN, RE)	 \
   do {                                                                   \
     switch (errtype)                                                     \
       {                                                                  \
       case ic_argpass:                                                   \
-        if (pedwarn (LOCATION, OPT, AR, parmnum, rname))                 \
+        if (pedwarn (PLOC, OPT, AR, parmnum, rname))			 \
           inform ((fundecl && !DECL_IS_BUILTIN (fundecl))	         \
-	      	  ? DECL_SOURCE_LOCATION (fundecl) : LOCATION,		 \
+		  ? DECL_SOURCE_LOCATION (fundecl) : PLOC,		 \
                   "expected %qT but argument is of type %qT",            \
                   type, rhstype);                                        \
         break;                                                           \
@@ -5621,22 +5625,22 @@
      compile time.  It is the same as WARN_FOR_ASSIGNMENT but with an
      extra parameter to enumerate qualifiers.  */
 
-#define WARN_FOR_QUALIFIERS(LOCATION, OPT, AR, AS, IN, RE, QUALS)        \
+#define WARN_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS)  \
   do {                                                                   \
     switch (errtype)                                                     \
       {                                                                  \
       case ic_argpass:                                                   \
-        if (pedwarn (LOCATION, OPT, AR, parmnum, rname, QUALS))          \
+        if (pedwarn (PLOC, OPT, AR, parmnum, rname, QUALS))		 \
           inform ((fundecl && !DECL_IS_BUILTIN (fundecl))	         \
-	      	  ? DECL_SOURCE_LOCATION (fundecl) : LOCATION,		 \
+		  ? DECL_SOURCE_LOCATION (fundecl) : PLOC,		 \
                   "expected %qT but argument is of type %qT",            \
                   type, rhstype);                                        \
         break;                                                           \
       case ic_assign:                                                    \
-        pedwarn (LOCATION, OPT, AS, QUALS);                          \
+        pedwarn (LOCATION, OPT, AS, QUALS);				 \
         break;                                                           \
       case ic_init:                                                      \
-        pedwarn (LOCATION, OPT, IN, QUALS);                          \
+        pedwarn (LOCATION, OPT, IN, QUALS);				 \
         break;                                                           \
       case ic_return:                                                    \
         pedwarn (LOCATION, OPT, RE, QUALS);                        	 \
@@ -5688,7 +5692,7 @@
 	  && TREE_CODE (type) == ENUMERAL_TYPE
 	  && TYPE_MAIN_VARIANT (checktype) != TYPE_MAIN_VARIANT (type))
 	{
-	  WARN_FOR_ASSIGNMENT (input_location, OPT_Wc___compat,
+	  WARN_FOR_ASSIGNMENT (input_location, expr_loc, OPT_Wc___compat,
 			       G_("enum conversion when passing argument "
 				  "%d of %qE is invalid in C++"),
 			       G_("enum conversion in assignment is "
@@ -5851,7 +5855,7 @@
 		     vice-versa.  */
 		  if (TYPE_QUALS_NO_ADDR_SPACE (ttl)
 		      & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))
-		    WARN_FOR_QUALIFIERS (location, 0,
+		    WARN_FOR_QUALIFIERS (location, expr_loc, 0,
 					 G_("passing argument %d of %qE "
 					    "makes %q#v qualified function "
 					    "pointer from unqualified"),
@@ -5867,7 +5871,7 @@
 		}
 	      else if (TYPE_QUALS_NO_ADDR_SPACE (ttr)
 		       & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))
-		WARN_FOR_QUALIFIERS (location, 0,
+		WARN_FOR_QUALIFIERS (location, expr_loc, 0,
 				     G_("passing argument %d of %qE discards "
 					"%qv qualifier from pointer target type"),
 				     G_("assignment discards %qv qualifier "
@@ -6029,7 +6033,7 @@
 		  (VOID_TYPE_P (ttr)
 		   && !null_pointer_constant
 		   && TREE_CODE (ttl) == FUNCTION_TYPE)))
-	    WARN_FOR_ASSIGNMENT (location, OPT_Wpedantic,
+	    WARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpedantic,
 				 G_("ISO C forbids passing argument %d of "
 				    "%qE between function pointer "
 				    "and %<void *%>"),
@@ -6048,7 +6052,7 @@
 	      if (TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)
 		  & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl))
 		{
-		  WARN_FOR_QUALIFIERS (location, 0,
+		  WARN_FOR_QUALIFIERS (location, expr_loc, 0,
 				       G_("passing argument %d of %qE discards "
 					  "%qv qualifier from pointer target type"),
 				       G_("assignment discards %qv qualifier "
@@ -6066,7 +6070,7 @@
 		;
 	      /* If there is a mismatch, do warn.  */
 	      else if (warn_pointer_sign)
-		WARN_FOR_ASSIGNMENT (location, OPT_Wpointer_sign,
+		WARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpointer_sign,
 				     G_("pointer targets in passing argument "
 					"%d of %qE differ in signedness"),
 				     G_("pointer targets in assignment "
@@ -6085,7 +6089,7 @@
 		 where an ordinary one is wanted, but not vice-versa.  */
 	      if (TYPE_QUALS_NO_ADDR_SPACE (ttl)
 		  & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))
-		WARN_FOR_QUALIFIERS (location, 0,
+		WARN_FOR_QUALIFIERS (location, expr_loc, 0,
 				     G_("passing argument %d of %qE makes "
 					"%q#v qualified function pointer "
 					"from unqualified"),
@@ -6101,7 +6105,7 @@
       else
 	/* Avoid warning about the volatile ObjC EH puts on decls.  */
 	if (!objc_ok)
-	  WARN_FOR_ASSIGNMENT (location, 0,
+	  WARN_FOR_ASSIGNMENT (location, expr_loc, 0,
 			       G_("passing argument %d of %qE from "
 				  "incompatible pointer type"),
 			       G_("assignment from incompatible pointer type"),
@@ -6124,7 +6128,7 @@
 	 or one that results from arithmetic, even including
 	 a cast to integer type.  */
       if (!null_pointer_constant)
-	WARN_FOR_ASSIGNMENT (location, 0,
+	WARN_FOR_ASSIGNMENT (location, expr_loc, 0,
 			     G_("passing argument %d of %qE makes "
 				"pointer from integer without a cast"),
 			     G_("assignment makes pointer from integer "
@@ -6138,7 +6142,7 @@
     }
   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)
     {
-      WARN_FOR_ASSIGNMENT (location, 0,
+      WARN_FOR_ASSIGNMENT (location, expr_loc, 0,
 			   G_("passing argument %d of %qE makes integer "
 			      "from pointer without a cast"),
 			   G_("assignment makes integer from pointer "
Index: gcc/c/c-array-notation.c
===================================================================
--- a/src/gcc/c/c-array-notation.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/c/c-array-notation.c	(.../branches/gcc-4_9-branch)
@@ -1265,6 +1265,25 @@
 					 rhs_loc, rhs, TREE_TYPE (rhs));
       }
       break;
+    case DECL_EXPR:
+      {
+	tree x = DECL_EXPR_DECL (*tp);
+	if (DECL_INITIAL (x))
+	  {
+	    location_t loc = DECL_SOURCE_LOCATION (x);
+	    tree lhs = x;
+	    tree rhs = DECL_INITIAL (x);
+	    DECL_INITIAL (x) = NULL;
+	    tree new_modify_expr = build_modify_expr (loc, lhs,
+						      TREE_TYPE (lhs),
+						      NOP_EXPR,
+						      loc, rhs,
+						      TREE_TYPE(rhs));
+	    expand_array_notations (&new_modify_expr, walk_subtrees, NULL);
+	    *tp = new_modify_expr;
+	  }
+      }
+      break;
     case CALL_EXPR:
       *tp = fix_array_notation_call_expr (*tp);
       break;
Index: gcc/cgraph.h
===================================================================
--- a/src/gcc/cgraph.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cgraph.h	(.../branches/gcc-4_9-branch)
@@ -797,6 +797,7 @@
 
 enum availability cgraph_function_body_availability (struct cgraph_node *);
 void cgraph_add_new_function (tree, bool);
+void cgraph_analyze_function (struct cgraph_node *);
 const char* cgraph_inline_failed_string (cgraph_inline_failed_t);
 cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);
 
Index: gcc/optabs.c
===================================================================
--- a/src/gcc/optabs.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/optabs.c	(.../branches/gcc-4_9-branch)
@@ -7334,7 +7334,10 @@
      perform the operation.  */
   if (!ret)
     {
-      emit_move_insn (subtarget, mem);
+      /* If the result is ignored skip the move to target.  */
+      if (subtarget != const0_rtx)
+        emit_move_insn (subtarget, mem);
+
       emit_move_insn (mem, trueval);
       ret = subtarget;
     }
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-4_9-branch)
@@ -1 +1 @@
-20140716
+20141011
Index: gcc/ipa-cp.c
===================================================================
--- a/src/gcc/ipa-cp.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ipa-cp.c	(.../branches/gcc-4_9-branch)
@@ -3032,6 +3032,11 @@
 		intersect_with_agg_replacements (cs->caller, src_idx,
 						 &inter, 0);
 	    }
+	  else
+	    {
+	      inter.release ();
+	      return vNULL;
+	    }
 	}
       else
 	{
@@ -3047,6 +3052,11 @@
 	      else
 		intersect_with_plats (src_plats, &inter, 0);
 	    }
+	  else
+	    {
+	      inter.release ();
+	      return vNULL;
+	    }
 	}
     }
   else if (jfunc->type == IPA_JF_ANCESTOR
@@ -3130,7 +3140,8 @@
 					  vec<cgraph_edge_p> callers)
 {
   struct ipa_node_params *dest_info = IPA_NODE_REF (node);
-  struct ipa_agg_replacement_value *res = NULL;
+  struct ipa_agg_replacement_value *res;
+  struct ipa_agg_replacement_value **tail = &res;
   struct cgraph_edge *cs;
   int i, j, count = ipa_get_param_count (dest_info);
 
@@ -3174,8 +3185,8 @@
 	  v->offset = item->offset;
 	  v->value = item->value;
 	  v->by_ref = plats->aggs_by_ref;
-	  v->next = res;
-	  res = v;
+	  *tail = v;
+	  tail = &v->next;
 	}
 
     next_param:
@@ -3182,6 +3193,7 @@
       if (inter.exists ())
 	inter.release ();
     }
+  *tail = NULL;
   return res;
 }
 
@@ -3190,7 +3202,8 @@
 static struct ipa_agg_replacement_value *
 known_aggs_to_agg_replacement_list (vec<ipa_agg_jump_function> known_aggs)
 {
-  struct ipa_agg_replacement_value *res = NULL;
+  struct ipa_agg_replacement_value *res;
+  struct ipa_agg_replacement_value **tail = &res;
   struct ipa_agg_jump_function *aggjf;
   struct ipa_agg_jf_item *item;
   int i, j;
@@ -3204,9 +3217,10 @@
 	v->offset = item->offset;
 	v->value = item->value;
 	v->by_ref = aggjf->by_ref;
-	v->next = res;
-	res = v;
+	*tail = v;
+	tail = &v->next;
       }
+  *tail = NULL;
   return res;
 }
 
Index: gcc/configure
===================================================================
--- a/src/gcc/configure	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/configure	(.../branches/gcc-4_9-branch)
@@ -919,6 +919,7 @@
 enable_gnu_indirect_function
 enable_initfini_array
 enable_comdat
+enable_fix_cortex_a53_835769
 with_glibc_version
 enable_gnu_unique_object
 enable_linker_build_id
@@ -1635,6 +1636,14 @@
                           glibc systems
   --enable-initfini-array	use .init_array/.fini_array sections
   --enable-comdat         enable COMDAT group support
+
+  --enable-fix-cortex-a53-835769
+                          enable workaround for AArch64 Cortex-A53 erratum
+                          835769 by default
+  --disable-fix-cortex-a53-835769
+                          disable workaround for AArch64 Cortex-A53 erratum
+                          835769 by default
+
   --enable-gnu-unique-object
                           enable the use of the @gnu_unique_object ELF
                           extension on glibc systems
@@ -17927,7 +17936,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17930 "configure"
+#line 17939 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18033,7 +18042,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18036 "configure"
+#line 18045 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -24004,6 +24013,25 @@
         done
       fi
     fi
+    # Enable default workaround for AArch64 Cortex-A53 erratum 835769.
+    # Check whether --enable-fix-cortex-a53-835769 was given.
+if test "${enable_fix_cortex_a53_835769+set}" = set; then :
+  enableval=$enable_fix_cortex_a53_835769;
+        case $enableval in
+          yes)
+            tm_defines="${tm_defines} TARGET_FIX_ERR_A53_835769_DEFAULT=1"
+            ;;
+          no)
+            ;;
+          *)
+            as_fn_error "'$enableval' is an invalid value for --enable-fix-cortex-a53-835769.\
+  Valid choices are 'yes' and 'no'." "$LINENO" 5
+            ;;
+
+        esac
+
+fi
+
     ;;
 
   # All TARGET_ABI_OSF targets.
Index: gcc/gcc.c
===================================================================
--- a/src/gcc/gcc.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/gcc.c	(.../branches/gcc-4_9-branch)
@@ -576,15 +576,21 @@
 #ifndef LIBLSAN_SPEC
 #define STATIC_LIBLSAN_LIBS \
   " %{static-liblsan:%:include(libsanitizer.spec)%(link_liblsan)}"
-#ifdef HAVE_LD_STATIC_DYNAMIC
-#define LIBLSAN_SPEC "%{!shared:%{static-liblsan:" LD_STATIC_OPTION \
+#ifdef LIBLSAN_EARLY_SPEC
+#define LIBLSAN_SPEC STATIC_LIBLSAN_LIBS
+#elif defined(HAVE_LD_STATIC_DYNAMIC)
+#define LIBLSAN_SPEC "%{static-liblsan:" LD_STATIC_OPTION \
 		     "} -llsan %{static-liblsan:" LD_DYNAMIC_OPTION "}" \
-		     STATIC_LIBLSAN_LIBS "}"
+		     STATIC_LIBLSAN_LIBS
 #else
-#define LIBLSAN_SPEC "%{!shared:-llsan" STATIC_LIBLSAN_LIBS "}"
+#define LIBLSAN_SPEC "-llsan" STATIC_LIBLSAN_LIBS
 #endif
 #endif
 
+#ifndef LIBLSAN_EARLY_SPEC
+#define LIBLSAN_EARLY_SPEC ""
+#endif
+
 #ifndef LIBUBSAN_SPEC
 #define STATIC_LIBUBSAN_LIBS \
   " %{static-libubsan:%:include(libsanitizer.spec)%(link_libubsan)}"
@@ -720,7 +726,8 @@
 #ifndef SANITIZER_EARLY_SPEC
 #define SANITIZER_EARLY_SPEC "\
 %{!nostdlib:%{!nodefaultlibs:%{%:sanitize(address):" LIBASAN_EARLY_SPEC "} \
-    %{%:sanitize(thread):" LIBTSAN_EARLY_SPEC "}}}"
+    %{%:sanitize(thread):" LIBTSAN_EARLY_SPEC "} \
+    %{%:sanitize(leak):" LIBLSAN_EARLY_SPEC "}}}"
 #endif
 
 /* Linker command line options for -fsanitize= late on the command line.  */
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-4_9-branch)
@@ -204,6 +204,7 @@
 static int target_nesting_level;
 static struct omp_region *root_omp_region;
 static bitmap task_shared_vars;
+static vec<omp_context *> taskreg_contexts;
 
 static void scan_omp (gimple_seq *, omp_context *);
 static tree scan_omp_1_op (tree *, int *, void *);
@@ -1872,7 +1873,6 @@
   TREE_STATIC (decl) = 1;
   TREE_USED (decl) = 1;
   DECL_ARTIFICIAL (decl) = 1;
-  DECL_NAMELESS (decl) = 1;
   DECL_IGNORED_P (decl) = 0;
   TREE_PUBLIC (decl) = 0;
   DECL_UNINLINABLE (decl) = 1;
@@ -2025,6 +2025,7 @@
     }
 
   ctx = new_omp_context (stmt, outer_ctx);
+  taskreg_contexts.safe_push (ctx);
   if (taskreg_nesting_level > 1)
     ctx->is_nested = true;
   ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);
@@ -2044,11 +2045,6 @@
 
   if (TYPE_FIELDS (ctx->record_type) == NULL)
     ctx->record_type = ctx->receiver_decl = NULL;
-  else
-    {
-      layout_type (ctx->record_type);
-      fixup_child_record_type (ctx);
-    }
 }
 
 /* Scan an OpenMP task directive.  */
@@ -2059,7 +2055,6 @@
   omp_context *ctx;
   tree name, t;
   gimple stmt = gsi_stmt (*gsi);
-  location_t loc = gimple_location (stmt);
 
   /* Ignore task directives with empty bodies.  */
   if (optimize > 0
@@ -2070,6 +2065,7 @@
     }
 
   ctx = new_omp_context (stmt, outer_ctx);
+  taskreg_contexts.safe_push (ctx);
   if (taskreg_nesting_level > 1)
     ctx->is_nested = true;
   ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);
@@ -2107,8 +2103,71 @@
       t = build_int_cst (long_integer_type_node, 1);
       gimple_omp_task_set_arg_align (stmt, t);
     }
+}
+
+
+/* If any decls have been made addressable during scan_omp,
+   adjust their fields if needed, and layout record types
+   of parallel/task constructs.  */
+
+static void
+finish_taskreg_scan (omp_context *ctx)
+{
+  if (ctx->record_type == NULL_TREE)
+    return;
+
+  /* If any task_shared_vars were needed, verify all
+     OMP_CLAUSE_SHARED clauses on GIMPLE_OMP_{PARALLEL,TASK}
+     statements if use_pointer_for_field hasn't changed
+     because of that.  If it did, update field types now.  */
+  if (task_shared_vars)
+    {
+      tree c;
+
+      for (c = gimple_omp_taskreg_clauses (ctx->stmt);
+	   c; c = OMP_CLAUSE_CHAIN (c))
+	if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED)
+	  {
+	    tree decl = OMP_CLAUSE_DECL (c);
+
+	    /* Global variables don't need to be copied,
+	       the receiver side will use them directly.  */
+	    if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))
+	      continue;
+	    if (!bitmap_bit_p (task_shared_vars, DECL_UID (decl))
+		|| !use_pointer_for_field (decl, ctx))
+	      continue;
+	    tree field = lookup_field (decl, ctx);
+	    if (TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE
+		&& TREE_TYPE (TREE_TYPE (field)) == TREE_TYPE (decl))
+	      continue;
+	    TREE_TYPE (field) = build_pointer_type (TREE_TYPE (decl));
+	    TREE_THIS_VOLATILE (field) = 0;
+	    DECL_USER_ALIGN (field) = 0;
+	    DECL_ALIGN (field) = TYPE_ALIGN (TREE_TYPE (field));
+	    if (TYPE_ALIGN (ctx->record_type) < DECL_ALIGN (field))
+	      TYPE_ALIGN (ctx->record_type) = DECL_ALIGN (field);
+	    if (ctx->srecord_type)
+	      {
+		tree sfield = lookup_sfield (decl, ctx);
+		TREE_TYPE (sfield) = TREE_TYPE (field);
+		TREE_THIS_VOLATILE (sfield) = 0;
+		DECL_USER_ALIGN (sfield) = 0;
+		DECL_ALIGN (sfield) = DECL_ALIGN (field);
+		if (TYPE_ALIGN (ctx->srecord_type) < DECL_ALIGN (sfield))
+		  TYPE_ALIGN (ctx->srecord_type) = DECL_ALIGN (sfield);
+	      }
+	  }
+    }
+
+  if (gimple_code (ctx->stmt) == GIMPLE_OMP_PARALLEL)
+    {
+      layout_type (ctx->record_type);
+      fixup_child_record_type (ctx);
+    }
   else
     {
+      location_t loc = gimple_location (ctx->stmt);
       tree *p, vla_fields = NULL_TREE, *q = &vla_fields;
       /* Move VLA fields to the end.  */
       p = &TYPE_FIELDS (ctx->record_type);
@@ -2128,12 +2187,12 @@
       fixup_child_record_type (ctx);
       if (ctx->srecord_type)
 	layout_type (ctx->srecord_type);
-      t = fold_convert_loc (loc, long_integer_type_node,
-			TYPE_SIZE_UNIT (ctx->record_type));
-      gimple_omp_task_set_arg_size (stmt, t);
+      tree t = fold_convert_loc (loc, long_integer_type_node,
+				 TYPE_SIZE_UNIT (ctx->record_type));
+      gimple_omp_task_set_arg_size (ctx->stmt, t);
       t = build_int_cst (long_integer_type_node,
 			 TYPE_ALIGN_UNIT (ctx->record_type));
-      gimple_omp_task_set_arg_align (stmt, t);
+      gimple_omp_task_set_arg_align (ctx->stmt, t);
     }
 }
 
@@ -9828,6 +9887,9 @@
 		  continue;
 	      }
 
+	    unsigned int talign = TYPE_ALIGN_UNIT (TREE_TYPE (ovar));
+	    if (DECL_P (ovar) && DECL_ALIGN_UNIT (ovar) > talign)
+	      talign = DECL_ALIGN_UNIT (ovar);
 	    if (nc)
 	      {
 		tree var = lookup_decl_in_outer_ctx (ovar, ctx);
@@ -9842,6 +9904,7 @@
 		      = create_tmp_var (TREE_TYPE (TREE_TYPE (x)), NULL);
 		    mark_addressable (avar);
 		    gimplify_assign (avar, build_fold_addr_expr (var), &ilist);
+		    talign = DECL_ALIGN_UNIT (avar);
 		    avar = build_fold_addr_expr (avar);
 		    gimplify_assign (x, avar, &ilist);
 		  }
@@ -9894,9 +9957,6 @@
 	      default:
 		gcc_unreachable ();
 	      }
-	    unsigned int talign = TYPE_ALIGN_UNIT (TREE_TYPE (ovar));
-	    if (DECL_P (ovar) && DECL_ALIGN_UNIT (ovar) > talign)
-	      talign = DECL_ALIGN_UNIT (ovar);
 	    talign = ceil_log2 (talign);
 	    tkind |= talign << 3;
 	    CONSTRUCTOR_APPEND_ELT (vkind, purpose,
@@ -10270,6 +10330,8 @@
 execute_lower_omp (void)
 {
   gimple_seq body;
+  int i;
+  omp_context *ctx;
 
   /* This pass always runs, to provide PROP_gimple_lomp.
      But there is nothing to do unless -fopenmp is given.  */
@@ -10282,6 +10344,9 @@
   body = gimple_body (current_function_decl);
   scan_omp (&body, NULL);
   gcc_assert (taskreg_nesting_level == 0);
+  FOR_EACH_VEC_ELT (taskreg_contexts, i, ctx)
+    finish_taskreg_scan (ctx);
+  taskreg_contexts.release ();
 
   if (all_contexts->root)
     {
@@ -11437,9 +11502,22 @@
   if (tp != orig_tp)
     {
       repl = build_fold_addr_expr (repl);
-      gimple stmt
-	= gimple_build_assign (make_ssa_name (TREE_TYPE (repl), NULL), repl);
-      repl = gimple_assign_lhs (stmt);
+      gimple stmt;
+      if (is_gimple_debug (info->stmt))
+	{
+	  tree vexpr = make_node (DEBUG_EXPR_DECL);
+	  stmt = gimple_build_debug_source_bind (vexpr, repl, NULL);
+	  DECL_ARTIFICIAL (vexpr) = 1;
+	  TREE_TYPE (vexpr) = TREE_TYPE (repl);
+	  DECL_MODE (vexpr) = TYPE_MODE (TREE_TYPE (repl));
+	  repl = vexpr;
+	}
+      else
+	{
+	  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl),
+						     NULL), repl);
+	  repl = gimple_assign_lhs (stmt);
+	}
       gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);
       gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
       *orig_tp = repl;
Index: gcc/toplev.c
===================================================================
--- a/src/gcc/toplev.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/toplev.c	(.../branches/gcc-4_9-branch)
@@ -1052,16 +1052,19 @@
 
   if (warn_stack_usage >= 0)
     {
+      const location_t loc = DECL_SOURCE_LOCATION (current_function_decl);
+
       if (stack_usage_kind == DYNAMIC)
-	warning (OPT_Wstack_usage_, "stack usage might be unbounded");
+	warning_at (loc, OPT_Wstack_usage_, "stack usage might be unbounded");
       else if (stack_usage > warn_stack_usage)
 	{
 	  if (stack_usage_kind == DYNAMIC_BOUNDED)
-	    warning (OPT_Wstack_usage_, "stack usage might be %wd bytes",
-		     stack_usage);
+	    warning_at (loc,
+			OPT_Wstack_usage_, "stack usage might be %wd bytes",
+			stack_usage);
 	  else
-	    warning (OPT_Wstack_usage_, "stack usage is %wd bytes",
-		     stack_usage);
+	    warning_at (loc, OPT_Wstack_usage_, "stack usage is %wd bytes",
+			stack_usage);
 	}
     }
 }
Index: gcc/cgraphunit.c
===================================================================
--- a/src/gcc/cgraphunit.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cgraphunit.c	(.../branches/gcc-4_9-branch)
@@ -219,7 +219,6 @@
 static void expand_all_functions (void);
 static void mark_functions_to_output (void);
 static void expand_function (struct cgraph_node *);
-static void analyze_function (struct cgraph_node *);
 static void handle_alias_pairs (void);
 
 FILE *cgraph_dump_file;
@@ -331,7 +330,7 @@
 
 	  gimple_register_cfg_hooks ();
 	  if (!node->analyzed)
-	    analyze_function (node);
+	    cgraph_analyze_function (node);
 	  push_cfun (DECL_STRUCT_FUNCTION (fndecl));
 	  if (cgraph_state == CGRAPH_STATE_IPA_SSA
 	      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))
@@ -541,7 +540,7 @@
 	if (lowered)
 	  node->lowered = true;
 	node->definition = true;
-	analyze_function (node);
+	cgraph_analyze_function (node);
 	push_cfun (DECL_STRUCT_FUNCTION (fndecl));
 	gimple_register_cfg_hooks ();
 	bitmap_obstack_initialize (NULL);
@@ -598,8 +597,8 @@
 }
 
 /* Analyze the function scheduled to be output.  */
-static void
-analyze_function (struct cgraph_node *node)
+void
+cgraph_analyze_function (struct cgraph_node *node)
 {
   tree decl = node->decl;
   location_t saved_loc = input_location;
@@ -1014,7 +1013,7 @@
 		}
 
 	      if (!cnode->analyzed)
-		analyze_function (cnode);
+		cgraph_analyze_function (cnode);
 
 	      for (edge = cnode->callees; edge; edge = edge->next_callee)
 		if (edge->callee->definition)
@@ -1039,7 +1038,7 @@
 	      if (DECL_ABSTRACT_ORIGIN (decl))
 		{
 		  struct cgraph_node *origin_node
-	    	  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));
+		    = cgraph_get_create_node (DECL_ABSTRACT_ORIGIN (decl));
 		  origin_node->used_as_abstract_origin = true;
 		}
 	    }
@@ -1170,7 +1169,7 @@
 	  /* We use local aliases for C++ thunks to force the tailcall
 	     to bind locally.  This is a hack - to keep it working do
 	     the following (which is not strictly correct).  */
-	  && (! TREE_CODE (target_node->decl) == FUNCTION_DECL
+	  && (TREE_CODE (target_node->decl) != FUNCTION_DECL
 	      || ! DECL_VIRTUAL_P (target_node->decl))
 	  && ! lookup_attribute ("weakref", DECL_ATTRIBUTES (p->decl)))
 	{
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,1217 @@
+2014-10-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63379
+	* tree-vect-slp.c (vect_get_constant_vectors): Do not compute
+	a neutral operand for min/max when it is not a reduction chain.
+
+2014-10-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2014-10-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* configure.ac: Add --enable-fix-cortex-a53-835769 option.
+	* configure: Regenerate.
+	* config/aarch64/aarch64.c (aarch64_override_options): Handle
+	TARGET_FIX_ERR_A53_835769_DEFAULT.
+	* config/aarch64/aarch64.opt (mfix-cortex-a53-835769): Set Init
+	value to 2.
+	* doc/install.texi (aarch64*-*-*): Document new
+	--enable-fix-cortex-a53-835769 option.
+
+2014-10-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2014-10-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+	            Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* config/aarch64/aarch64.h (FINAL_PRESCAN_INSN): Define.
+	(ADJUST_INSN_LENGTH): Define.
+	* config/aarch64/aarch64.opt (mfix-cortex-a53-835769): New option.
+	* config/aarch64/aarch64.c (is_mem_p): New function.
+	(is_memory_op): Likewise.
+	(aarch64_prev_real_insn): Likewise.
+	(is_madd_op): Likewise.
+	(dep_between_memop_and_curr): Likewise.
+	(aarch64_madd_needs_nop): Likewise.
+	(aarch64_final_prescan_insn): Likewise.
+	* doc/invoke.texi (AArch64 Options): Document -mfix-cortex-a53-835769
+	and -mno-fix-cortex-a53-835769 options.
+
+2014-10-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63380
+	* tree-ssa-tail-merge.c (stmt_local_def): Exclude stmts that
+	may trap.
+
+2014-10-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61969
+	* tree-nrv.c (pass_nrv::execute): Properly test for automatic
+	variables.
+
+2014-10-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-10-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/57003
+	* regcprop.c (copyprop_hardreg_forward_1): If ksvd.ignore_set_reg,
+	also check CALL_INSN_FUNCTION_USAGE for clobbers again after
+	killing regs_invalidated_by_call.
+
+2014-10-08  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-10-08  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/52941
+	* config/sh/sync.md (atomic_exchangesi_hard, atomic_exchange<mode>_hard,
+	atomic_fetch_<fetchop_name>si_hard,
+	atomic_fetch_<fetchop_name><mode>_hard, atomic_fetch_nandsi_hard,
+	atomic_fetch_nand<mode>_hard, atomic_<fetchop_name>_fetchsi_hard,
+	atomic_<fetchop_name>_fetch<mode>_hard, atomic_nand_fetchsi_hard,
+	atomic_nand_fetch<mode>_hard): Add missing set of T_REG.
+
+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/61144
+	* varpool.c (ctor_for_folding): Do not fold WEAK symbols.
+
+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/62121
+	* ipa-devirt.c (restrict_to_inner_class): Do not ICE when type is
+	unknown.
+
+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/62026
+	* lto-streamer-out.c (lto_output): Handle thunks correctly.
+	* cgraphclones.c (duplicate_thunk_for_node): Get thunk's arguments.
+
+2014-10-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/61200
+	* omp-low.c (taskreg_contexts): New variable.
+	(scan_omp_parallel): Push newly created context into taskreg_contexts
+	vector and move record layout code to finish_taskreg_scan.
+	(scan_omp_task): Likewise.
+	(finish_taskreg_scan): New function.
+	(execute_lower_omp): Call finish_taskreg_scan on all taskreg_contexts
+	vector elements and release it.
+
+2014-10-02  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/63375
+	* tree-sra.c (build_access_from_expr_1): Disqualify volatile
+	references.
+
+2014-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/63342
+	* dwarf2out.c (loc_list_from_tree): Handle TARGET_MEM_REF and
+	SSA_NAME.
+
+	PR target/63428
+	* config/i386/i386.c (expand_vec_perm_pshufb): Fix up rperm[0]
+	argument to avx2_permv2ti.
+
+	PR c++/63306
+	Backported from mainline
+	2014-08-01  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	PR regression/61510
+	* cgraphunit.c (analyze_functions): Use get_create rather than get
+	for decls which are clones of abstract functions.
+
+2014-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-09-18  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR debug/63285
+	* haifa-sched.c (schedule_block): Advance cycle at the end of BB
+	if advance != 0.
+
+	2014-09-10  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR tree-optimization/63186
+	* ipa-split.c (test_nonssa_use): Skip nonforced labels.
+	(mark_nonssa_use): Likewise.
+	(verify_non_ssa_vars): Verify all header blocks for label
+	definitions.
+
+2014-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2014-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/arm/arm.md (*store_minmaxsi): Disable for arm_restrict_it.
+
+2014-10-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-09-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (fmodxf3): Enable for flag_finite_math_only only.
+	(fmod<mode>3): Ditto.
+	(fpremxf4_i387): Ditto.
+	(reminderxf3): Ditto.
+	(reminder<mode>3): Ditto.
+	(fprem1xf4_i387): Ditto.
+
+2014-09-30  David Malcolm  <dmalcolm@redhat.com>
+
+	PR plugins/63410
+	* Makefile.in (PLUGIN_HEADERS): Add pass-instances.def.
+
+2014-09-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/63282
+	* ifcvt.c (dead_or_predicable): Don't call redirect_jump_1
+	or invert_jump_1 if jump isn't any_condjump_p.
+
+2014-09-29  James Clarke  <jrtc27@jrtc27.com>
+	    Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR target/61407
+	* config/darwin-c.c (version_as_macro): Added extra 0 for OS X 10.10
+	and above.
+	* config/darwin-driver.c (darwin_find_version_from_kernel): Removed
+	kernel version check to avoid incrementing it after every major OS X
+	release.
+	(darwin_default_min_version): Avoid static memory buffer.
+
+2014-09-29  Charles Baylis  <charles.baylis@linaro.org>
+
+	Backport from mainline r212303
+	PR target/49423
+	* config/arm/arm-protos.h (arm_legitimate_address_p,
+	arm_is_constant_pool_ref): Add prototypes.
+	* config/arm/arm.c (arm_legitimate_address_p): Remove static.
+	(arm_is_constant_pool_ref) New function.
+	* config/arm/arm.md (unaligned_loadhis, arm_zero_extendhisi2_v6,
+	arm_zero_extendqisi2_v6): Use Uh constraint for memory operand.
+	(arm_extendhisi2, arm_extendhisi2_v6): Use Uh constraint for memory
+	operand and remove pool_range and neg_pool_range attributes.
+	(arm_extendqihi_insn, arm_extendqisi, arm_extendqisi_v6): Remove
+	pool_range and neg_pool_range attributes.
+	* config/arm/constraints.md (Uh): New constraint. (Uq): Don't allow
+	constant pool references.
+
+2014-09-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/63247
+	* omp-low.c (lower_omp_target): For OMP_CLAUSE_MAP_POINTER
+	of ARRAY_TYPE, if not OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION
+	use the alignment of avar rather than ovar.
+
+2014-09-28  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_function_epilogue): Only update
+	last_address when a nonnote insn is found.
+
+2014-09-25  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-09-25  Nick Clifton  <nickc@redhat.com>
+	2014-09-25  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/62218
+	* config/sh/sync.md (atomic_fetch_nand<mode>_soft_imask,
+	atomic_test_and_set_soft_imask): Fix typo in instruction sequence.
+
+2014-09-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline r215559
+	2014-09-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/63335
+	* config/rs6000/rs6000-c.c (altivec_build_resolved_builtin):
+	Exclude VSX_BUILTIN_XVCMPGEDP_P from special handling.
+
+2014-09-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63341
+	* tree-vectorizer.h (vect_create_data_ref_ptr,
+	vect_create_addr_base_for_vector_ref): Add another tree argument
+	defaulting to NULL_TREE.
+	* tree-vect-data-refs.c (vect_create_data_ref_ptr): Add byte_offset
+	argument, pass it down to vect_create_addr_base_for_vector_ref.
+	(vect_create_addr_base_for_vector_ref): Add byte_offset argument,
+	add that to base_offset too if non-NULL.
+	* tree-vect-stmts.c (vectorizable_load): Add byte_offset variable,
+	for dr_explicit_realign_optimized set it to vector byte size
+	- 1 instead of setting offset, pass byte_offset down to
+	vect_create_data_ref_ptr.
+
+2014-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2014-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000.md (f32_vsx): New mode attributes to
+	refine the constraints used on 32/64-bit floating point moves.
+	(f32_av): Likewise.
+	(f64_vsx): Likewise.
+	(f64_dm): Likewise.
+	(f64_av): Likewise.
+	(BOOL_REGS_OUTPUT): Use wt constraint for TImode instead of wa.
+	(BOOL_REGS_OP1): Likewise.
+	(BOOL_REGS_OP2): Likewise.
+	(BOOL_REGS_UNARY): Likewise.
+	(mov<mode>_hardfloat, SFmode/SDmode): Tighten down constraints for
+	32/64-bit floating point moves.  Do not use wa, instead use ww/ws
+	for moves involving VSX registers.  Do not use constraints that
+	target VSX registers for decimal types.
+	(mov<mode>_hardfloat32, DFmode/DDmode): Likewise.
+	(mov<mode>_hardfloat64, DFmode/DDmode): Likewise.
+
+2014-09-22  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-05-21  Marek Polacek  <polacek@redhat.com>
+
+	PR sanitizer/61272
+	* ubsan.c (is_ubsan_builtin_p): Turn assert into a condition.
+
+2014-09-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/63328
+	* omp-low.c (ipa_simd_modify_stmt_ops): For debug stmts
+	insert a debug source bind stmt setting DEBUG_EXPR_DECL
+	instead of a normal gimple assignment stmt.
+
+2014-09-19  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk:
+	2014-09-19  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/predicates.md (fusion_gpr_mem_load): Move testing
+	for base_reg_operand to be common between LO_SUM and PLUS.
+	(fusion_gpr_mem_combo): New predicate to match a fused address
+	that combines the addis and memory offset address.
+
+	* config/rs6000/rs6000-protos.h (fusion_gpr_load_p): Change
+	calling signature.
+	(emit_fusion_gpr_load): Likewise.
+
+	* config/rs6000/rs6000.c (fusion_gpr_load_p): Change calling
+	signature to pass each argument separately, rather than
+	using an operands array.  Rewrite the insns found by peephole2 to
+	be a single insn, rather than hoping the insns will still be
+	together when the peephole pass is done.  Drop being called via a
+	normal peephole.
+	(emit_fusion_gpr_load): Change calling signature to be called from
+	the fusion_gpr_load_<mode> insns with a combined memory address
+	instead of the peephole pass passing the addis and offset
+	separately.
+
+	* config/rs6000/rs6000.md (UNSPEC_FUSION_GPR): New unspec for GPR
+	fusion.
+	(power8 fusion peephole): Drop support for doing power8 via a
+	normal peephole that was created by the peephole2 pass.
+	(power8 fusion peephole2): Create a new insn with the fused
+	address, so that the fused operation is kept together after
+	register allocation is done.
+	(fusion_gpr_load_<mode>): Likewise.
+
+2014-09-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/62017
+	* asan.c (transform_statements): Don't instrument clobber statements.
+
+2014-09-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/63284
+	* tree-cfgcleanup.c (fixup_noreturn_call): Don't split block
+	if there are only debug stmts after the noreturn call, instead
+	remove the debug stmts.
+
+2014-09-17  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config.gcc (*-*-rtems*): Default to 'rtems' thread model.
+	Enable selection of 'posix' or no thread model.
+
+2014-09-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/61853
+	* config/pa/pa.c (pa_function_value): Directly handle aggregates
+	that fit exactly in a word or double word.
+
+2014-09-15  Markus Trippelsdorf  <markus@trippelsdorf.de>
+
+	* doc/install.texi (Options specification): add
+	--disable-libsanitizer item.
+
+2014-09-12  DJ Delorie  <dj@redhat.com>
+
+	* config/msp430/msp430.md (extendhipsi2): Use 20-bit form of RLAM/RRAM.
+	(extend_and_shift1_hipsi2): Likewise.
+	(extend_and_shift2_hipsi2): Likewise.
+
+2014-09-12  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61654
+	* cgraph.h (cgraph_analyze_function): Declare.
+	* cgraphunit.c: (analyze_function): Remove forward declaration,
+	rename to cgraph_analyze_function, made external.
+	* cgraphclones.c (duplicate_thunk_for_node): Copy arguments of the
+        new decl properly.  Analyze the new thunk if it is expanded.
+
+2014-09-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-09-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/63228
+	* config/i386/i386.c (ix86_option_override_internal): Also turn
+	off OPTION_MASK_ABI_X32 for -m16.
+
+2014-09-11  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline.
+	2014-09-11  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	* config/aarch64/arm_neon.h (vmull_high_lane_s16): Fix argument
+	types.
+	(vmull_high_lane_s32): Likewise.
+	(vmull_high_lane_u16): Likewise.
+	(vmull_high_lane_u32): Likewise.
+
+2014-09-11  Alan Lawrence  <alan.lawrence@arm.com>
+
+	Backport r214946 from mainline
+	2014-09-05  Alan Lawrence  <alan.lawrence@arm.com>
+
+	* config/aarch64/aarch64.md (adddi3_aarch64): Set type to neon_add.
+
+2014-09-11  Alan Lawrence  <alan.lawrence@arm.com>
+
+	Backport r214953 from mainline
+	2014-09-05  Alan Lawrence  <alan.lawrence@arm.com>
+
+	* config/aarch64/arm_neon.h (int32x1_t, int16x1_t, int8x1_t,
+	uint32x1_t, uint16x1_t, uint8x1_t): Remove typedefs.
+
+	(vqabsb_s8, vqabsh_s16, vqabss_s32, vqaddb_s8, vqaddh_s16, vqadds_s32,
+	vqaddb_u8, vqaddh_u16, vqadds_u32, vqdmlalh_s16, vqdmlalh_lane_s16,
+	vqdmlals_s32, vqdmlslh_s16, vqdmlslh_lane_s16, vqdmlsls_s32,
+	vqdmulhh_s16, vqdmulhh_lane_s16, vqdmulhs_s32, vqdmulhs_lane_s32,
+	vqdmullh_s16, vqdmullh_lane_s16, vqdmulls_s32, vqdmulls_lane_s32,
+	vqmovnh_s16, vqmovns_s32, vqmovnd_s64, vqmovnh_u16, vqmovns_u32,
+	vqmovnd_u64, vqmovunh_s16, vqmovuns_s32, vqmovund_s64, vqnegb_s8,
+	vqnegh_s16, vqnegs_s32, vqrdmulhh_s16, vqrdmulhh_lane_s16,
+	vqrdmulhs_s32, vqrdmulhs_lane_s32, vqrshlb_s8, vqrshlh_s16,
+	vqrshls_s32, vqrshlb_u8, vqrshlh_u16, vqrshls_u32, vqrshrnh_n_s16,
+	vqrshrns_n_s32, vqrshrnd_n_s64, vqrshrnh_n_u16, vqrshrns_n_u32,
+	vqrshrnd_n_u64, vqrshrunh_n_s16, vqrshruns_n_s32, vqrshrund_n_s64,
+	vqshlb_s8, vqshlh_s16, vqshls_s32, vqshlb_u8, vqshlh_u16, vqshls_u32,
+	vqshlb_n_s8, vqshlh_n_s16, vqshls_n_s32, vqshlb_n_u8, vqshlh_n_u16,
+	vqshls_n_u32, vqshlub_n_s8, vqshluh_n_s16, vqshlus_n_s32,
+	vqshrnh_n_s16, vqshrns_n_s32, vqshrnd_n_s64, vqshrnh_n_u16,
+	vqshrns_n_u32, vqshrnd_n_u64, vqshrunh_n_s16, vqshruns_n_s32,
+	vqshrund_n_s64, vqsubb_s8, vqsubh_s16, vqsubs_s32, vqsubb_u8,
+	vqsubh_u16, vqsubs_u32, vsqaddb_u8, vsqaddh_u16, vsqadds_u32,
+	vuqaddb_s8, vuqaddh_s16, vuqadds_s32): Replace all int{32,16,8}x1_t
+	with int{32,16,8}_t.
+
+2014-09-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/58678
+	* ipa-devirt.c (ipa_devirt): Don't check DECL_COMDAT.
+
+2014-09-11  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2014-09-11 trunk r215152.
+
+	PR target/63223
+	* config/avr/avr.md (*tablejump.3byte-pc): New insn.
+	(*tablejump): Restrict to !AVR_HAVE_EIJMP_EICALL.  Add void clobber.
+	(casesi): Expand to *tablejump.3byte-pc if AVR_HAVE_EIJMP_EICALL.
+
+2014-09-10  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2014-09-10  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/vsx.md (vsx_fmav4sf4): Use correct constraints for
+	V2DF, V4SF, DF, and DI modes.
+	(vsx_fmav2df2): Likewise.
+	(vsx_float_fix_<mode>2): Likewise.
+	(vsx_reduc_<VEC_reduc_name>_v2df_scalar): Likewise.
+
+2014-09-10  Xinliang David Li  <davidxl@google.com>
+
+	Backport from mainline
+	PR target/63209
+	* config/arm/arm.md (movcond_addsi): Handle case where source
+	and target operands are the same.
+
+2014-09-10  Alan Modra  <amodra@gmail.com>
+
+	PR debug/60655
+	* dwarf2out.c (mem_loc_descriptor <PLUS>): Return NULL if addend
+	can't be output.
+
+2014-09-09  Bill Schmidt  <wschmidt@us.ibm.com>
+
+	Backported from mainline
+	2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/vsx.md (*vsx_extract_<mode>_load): Always match
+	selection of 0th memory doubleword, regardless of endianness.
+
+2014-09-09  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline
+	2014-09-09  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	* doc/invoke.texi (-march): Use GNU/Linux rather than Linux.
+	(-mtune): Likewise.
+	(-mcpu): Likewise.
+
+2014-09-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/61214
+	PR c++/62224
+	* gimple-fold.c (can_refer_decl_in_current_unit_p): Don't allow
+	reference to a DECL_EXTERNAL COMDAT.
+
+2014-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-08-05  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/61672
+	* emit-rtl.h (mem_attrs_eq_p): Declare.
+	* emit-rtl.c (mem_attrs_eq_p): Export.  Handle NULL mem-attrs.
+	* cse.c (exp_equiv_p): Use mem_attrs_eq_p.
+	* cfgcleanup.c (merge_memattrs): Likewise.
+	Include emit-rtl.h.
+
+	2014-08-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62075
+	* tree-vect-slp.c (vect_detect_hybrid_slp_stmts): Properly
+	handle uses in patterns.
+
+	2014-08-14  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/62079
+	* recog.c (peephole2_optimize): If peep2_do_cleanup_cfg
+	run cleanup_cfg.
+
+	2014-08-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62175
+	* tree-ssa-loop-niter.c (expand_simple_operations): Do not
+	expand possibly trapping operations.
+
+2014-09-08  DJ Delorie  <dj@redhat.com>
+
+	* doc/invoke.texi (MSP430 Options): Add -minrt.
+
+2014-09-05  Easwaran Raman  <eraman@google.com>
+
+	Backport from mainline
+	PR rtl-optimization/62146
+	* ifcvt.c (dead_or_predicable): Make removal of REG_EQUAL note of
+	hoisted instruction unconditional.
+
+2014-09-04  Guozhi Wei  <carrot@google.com>
+
+	PR target/62040
+	* config/aarch64/iterators.md (VQ_NO2E, VQ_2E): New iterators.
+	* config/aarch64/aarch64-simd.md (move_lo_quad_internal_<mode>): Split
+	it into two patterns.
+	(move_lo_quad_internal_be_<mode>): Likewise.
+
+2014-09-03  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/62015
+	* ipa-cp.c (intersect_aggregates_with_edge): Handle impermissible
+	pass-trough jump functions correctly.
+
+2014-09-03  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61986
+	* ipa-cp.c (find_aggregate_values_for_callers_subset): Chain
+	created replacements in ascending order of offsets.
+	(known_aggs_to_agg_replacement_list): Likewise.
+
+2014-09-02  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2014-08-27  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+        PR target/62261
+        * config/sh/sh.md (ashlsi3): Handle negative shift count for
+	TARGET_SHMEDIA.
+	(ashldi3, ashrsi3, ashrdi3, lshrsi3, lshrdi3): Likewise.
+
+2014-09-02  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2014-08-25  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/62111
+	* config/sh/predicates.md (general_extend_operand): Disable
+	TRUNCATE before reload completes.
+
+2014-09-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-09-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/62312
+	* config/sh/sh.md (*cmp_div0s_0): Add missing constraints.
+
+2014-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/62025
+	* sched-deps.c (add_or_update_dep_1): If ask_dependency_caches
+	returned DEP_PRESENT, make sure to set DEP_MULTIPLE on present_dep.
+	(find_inc): Revert 2014-08-12 change.
+
+	* config/gnu-user.h (LIBLSAN_EARLY_SPEC): Define.
+	* gcc.c (LIBLSAN_SPEC, LIBLSAN_EARLY_SPEC): Follow LIBTSAN*_SPEC.
+	(SANITIZER_EARLY_SPEC): Include LIBLSAN_EARLY_SPEC for -fsanitize=leak.
+
+2014-09-01  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-08-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c/61271
+	* expr.c (is_aligning_offset): Remove logical not.
+
+2014-09-01  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-08-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c/61271
+	* cgraphunit.c (handle_alias_pairs): Fix condition.
+
+2014-08-30  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_assemble_integer): Don't add PLABEL relocation
+	prefix to function labels when generating fast indirect calls.
+
+2014-08-29  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from mainline
+	2014-08-27  Yvan Roux  <yvan.roux@linaro.org>
+
+	PR other/62248
+	* config.gcc (arm*-*-*): Check --with-fpu against arm-fpus.def.
+
+2014-08-27  Guozhi Wei  <carrot@google.com>
+
+	PR target/62262
+	* config/aarch64/aarch64.md (*andim_ashift<mode>_bfiz): Check the shift
+	amount before using it.
+
+2014-08-26  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* doc/invoke.texi: -fno-cxa-atexit should be -fno-use-cxa-atexit.
+
+2014-08-26  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-08-26  Marek Polacek  <polacek@redhat.com>
+
+	PR c/61271
+	* tree-vectorizer.h (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT,
+	LOOP_REQUIRES_VERSIONING_FOR_ALIAS): Wrap in parens.
+
+2014-08-24  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-08-24  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/61996
+	* config/sh/sh.opt (musermode): Allow negative form.
+	* config/sh/sh.c (sh_option_override): Disable TARGET_USERMODE for
+	targets that don't support it.
+	* doc/invoke.texi (SH Options): Rename sh-*-linux* to sh*-*-linux*.
+	Document -mno-usermode option.
+
+2014-08-23  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/62038
+	* config/pa/pa.c (pa_output_function_epilogue): Don't set
+	last_address when the current function is a thunk.
+	(pa_asm_output_mi_thunk): When we don't have named sections or they
+	are not being used, check that thunk can reach the stub table with a
+	short branch.
+
+2014-08-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2014-08-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/62195
+	* doc/md.texi (Machine Constraints): Update PowerPC wi constraint
+	documentation to state it is only for VSX operations.
+
+	* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Make wi
+	constraint only active if VSX.
+
+	* config/rs6000/rs6000.md (lfiwax): Use wj constraint instead of
+	wi cosntraint for ISA 2.07 lxsiwax/lxsiwzx instructions.
+	(lfiwzx): Likewise.
+
+2014-08-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-08-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.md (*ctz<mode>2_falsedep_1): Don't clear
+	destination if it is used in source.
+	(*clz<mode>2_lzcnt_falsedep_1): Likewise.
+	(*popcount<mode>2_falsedep_1): Likewise.
+
+	Backport from mainline
+	2014-08-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/62011
+	* config/i386/x86-tune.def (X86_TUNE_AVOID_FALSE_DEP_FOR_BMI):
+	New tune flag.
+	* config/i386/i386.h (TARGET_AVOID_FALSE_DEP_FOR_BMI): New define.
+	* config/i386/i386.md (unspec) <UNSPEC_INSN_FALSE_DEP>: New unspec.
+	(ffs<mode>2): Do not expand with tzcnt for
+	TARGET_AVOID_FALSE_DEP_FOR_BMI.
+	(ffssi2_no_cmove): Ditto.
+	(*tzcnt<mode>_1): Disable for TARGET_AVOID_FALSE_DEP_FOR_BMI.
+	(ctz<mode>2): New expander.
+	(*ctz<mode>2_falsedep_1): New insn_and_split pattern.
+	(*ctz<mode>2_falsedep): New insn.
+	(*ctz<mode>2): Rename from ctz<mode>2.
+	(clz<mode>2_lzcnt): New expander.
+	(*clz<mode>2_lzcnt_falsedep_1): New insn_and_split pattern.
+	(*clz<mode>2_lzcnt_falsedep): New insn.
+	(*clz<mode>2): Rename from ctz<mode>2.
+	(popcount<mode>2): New expander.
+	(*popcount<mode>2_falsedep_1): New insn_and_split pattern.
+	(*popcount<mode>2_falsedep): New insn.
+	(*popcount<mode>2): Rename from ctz<mode>2.
+	(*popcount<mode>2_cmp): Remove.
+	(*popcountsi2_cmp_zext): Ditto.
+
+2014-08-20  Martin Jambor  <mjambor@suse.cz>
+	    Wei Mi  <wmi@google.com>
+
+	PR ipa/60449
+	PR middle-end/61776
+	* tree-ssa-operands.c (update_stmt_operands): Remove
+	MODIFIED_NORETURN_CALLS.
+	* tree-cfgcleanup.c (cleanup_call_ctrl_altering_flag): New func.
+	(cleanup_control_flow_bb): Use cleanup_call_ctrl_altering_flag.
+	(split_bb_on_noreturn_calls): Renamed from split_bbs_on_noreturn_calls.
+	(cleanup_tree_cfg_1): Use split_bb_on_noreturn_calls.
+	* tree-ssanames.h: Remove MODIFIED_NORETURN_CALLS.
+	* gimple.h (enum gf_mask): Add GF_CALL_CTRL_ALTERING.
+	(gimple_call_set_ctrl_altering): New func.
+	(gimple_call_ctrl_altering_p): Ditto.
+	* tree-cfg.c (gimple_call_initialize_ctrl_altering): Ditto.
+	(make_blocks): Use gimple_call_initialize_ctrl_altering.
+	(is_ctrl_altering_stmt): Use gimple_call_ctrl_altering_p.
+	(execute_fixup_cfg): Use gimple_call_ctrl_altering_p and
+	remove MODIFIED_NORETURN_CALLS.
+
+2014-08-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2014-08-12  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/62098
+	* config/arm/vfp.md (*combine_vcvtf2i): Fix constraint.
+	Remove unnecessary attributes.
+
+2014-08-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/61641
+	* config/pa/pa-protos.h (pa_output_addr_vec, pa_output_addr_diff_vec):
+	Declare.
+	* config/pa/pa.c (pa_reorg): Remove code to insert brtab marker insns.
+	(pa_output_addr_vec, pa_output_addr_diff_vec): New.
+	* config/pa/pa.h (ASM_OUTPUT_ADDR_VEC, ASM_OUTPUT_ADDR_DIFF_VEC):
+	Define.
+	* config/pa/pa.md (begin_brtab): Delete insn.
+	(end_brtab): Likewise.
+
+2014-08-15  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline:
+	2014-08-15  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	* doc/invoke.texi (SH options): Document missing processor variant
+	options.  Remove references to Hitachi.  Undocument deprecated mspace
+	option.
+
+2014-08-15  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline:
+	2014-08-14  Tom de Vries  <tom@codesourcery.com>
+
+	PR rtl-optimization/62004
+	PR rtl-optimization/62030
+	* ifcvt.c (rtx_interchangeable_p): New function.
+	(noce_try_move, noce_process_if_block): Use rtx_interchangeable_p.
+
+	2014-08-05  Richard Biener  <rguenther@suse.de>
+
+	* emit-rtl.h (mem_attrs_eq_p): Declare.
+	* emit-rtl.c (mem_attrs_eq_p): Export.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/62092
+	* gimplify.c (gimplify_adjust_omp_clauses_1): Don't remove
+	OMP_CLAUSE_SHARED for global vars if the global var is mentioned
+	in OMP_CLAUSE_MAP in some outer target region.
+
+2014-08-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2014-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/61713
+	* gcc/optabs.c (expand_atomic_test_and_set): Do not try to emit
+	move to subtarget in serial version if result is ignored.
+
+2014-08-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-08-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR middle-end/62103
+	* gimple-fold.c (fold_ctor_reference): Don't fold in presence of
+	bitfields, that is when size doesn't match the size of type or the
+	size of the constructor.
+
+2014-08-12  Felix Yang  <fei.yang0953@gmail.com>
+
+	PR tree-optimization/62073
+	* tree-vect-loop.c (vect_is_simple_reduction_1): Check that DEF1 has
+	a basic block.
+
+2014-08-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/62025
+	* sched-deps.c (find_inc): Check if inc_insn doesn't clobber
+	any registers that are used in mem_insn.
+
+2014-08-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport patch from mainline
+	2014-08-11  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/constraints.md (wh constraint): New constraint,
+	for FP registers if direct move is available.
+	(wi constraint): New constraint, for VSX/FP registers that can
+	handle 64-bit integers.
+	(wj constraint): New constraint for VSX/FP registers that can
+	handle 64-bit integers for direct moves.
+	(wk constraint): New constraint for VSX/FP registers that can
+	handle 64-bit doubles for direct moves.
+	(wy constraint): Make documentation match implementation.
+
+	* config/rs6000/rs6000.c (struct rs6000_reg_addr): Add
+	scalar_in_vmx_p field to simplify tests of whether SFmode or
+	DFmode can go in the Altivec registers.
+	(rs6000_hard_regno_mode_ok): Use scalar_in_vmx_p field.
+	(rs6000_setup_reg_addr_masks): Likewise.
+	(rs6000_debug_print_mode): Add debug support for scalar_in_vmx_p
+	field, and wh/wi/wj/wk constraints.
+	(rs6000_init_hard_regno_mode_ok): Setup scalar_in_vmx_p field, and
+	the wh/wi/wj/wk constraints.
+	(rs6000_preferred_reload_class): If SFmode/DFmode can go in the
+	upper registers, prefer VSX registers unless the operation is a
+	memory operation with REG+OFFSET addressing.
+
+	* config/rs6000/vsx.md (VSr mode attribute): Add support for
+	DImode.  Change SFmode to use ww constraint instead of d to allow
+	SF registers in the upper registers.
+	(VSr2): Likewise.
+	(VSr3): Likewise.
+	(VSr5): Fix thinko in comment.
+	(VSa): New mode attribute that is an alternative to wa, that
+	returns the VSX register class that a mode can go in, but may not
+	be the preferred register class.
+	(VS_64dm): New mode attribute for appropriate register classes for
+	referencing 64-bit elements of vectors for direct moves and normal
+	moves.
+	(VS_64reg): Likewise.
+	(vsx_mov<mode>): Change wa constraint to <VSa> to limit the
+	register allocator to only registers the data type can handle.
+	(vsx_le_perm_load_<mode>): Likewise.
+	(vsx_le_perm_store_<mode>): Likewise.
+	(vsx_xxpermdi2_le_<mode>): Likewise.
+	(vsx_xxpermdi4_le_<mode>): Likewise.
+	(vsx_lxvd2x2_le_<mode>): Likewise.
+	(vsx_lxvd2x4_le_<mode>): Likewise.
+	(vsx_stxvd2x2_le_<mode>): Likewise.
+	(vsx_add<mode>3): Likewise.
+	(vsx_sub<mode>3): Likewise.
+	(vsx_mul<mode>3): Likewise.
+	(vsx_div<mode>3): Likewise.
+	(vsx_tdiv<mode>3_internal): Likewise.
+	(vsx_fre<mode>2): Likewise.
+	(vsx_neg<mode>2): Likewise.
+	(vsx_abs<mode>2): Likewise.
+	(vsx_nabs<mode>2): Likewise.
+	(vsx_smax<mode>3): Likewise.
+	(vsx_smin<mode>3): Likewise.
+	(vsx_sqrt<mode>2): Likewise.
+	(vsx_rsqrte<mode>2): Likewise.
+	(vsx_tsqrt<mode>2_internal): Likewise.
+	(vsx_fms<mode>4): Likewise.
+	(vsx_nfma<mode>4): Likewise.
+	(vsx_eq<mode>): Likewise.
+	(vsx_gt<mode>): Likewise.
+	(vsx_ge<mode>): Likewise.
+	(vsx_eq<mode>_p): Likewise.
+	(vsx_gt<mode>_p): Likewise.
+	(vsx_ge<mode>_p): Likewise.
+	(vsx_xxsel<mode>): Likewise.
+	(vsx_xxsel<mode>_uns): Likewise.
+	(vsx_copysign<mode>3): Likewise.
+	(vsx_float<VSi><mode>2): Likewise.
+	(vsx_floatuns<VSi><mode>2): Likewise.
+	(vsx_fix_trunc<mode><VSi>2): Likewise.
+	(vsx_fixuns_trunc<mode><VSi>2): Likewise.
+	(vsx_x<VSv>r<VSs>i): Likewise.
+	(vsx_x<VSv>r<VSs>ic): Likewise.
+	(vsx_btrunc<mode>2): Likewise.
+	(vsx_b2trunc<mode>2): Likewise.
+	(vsx_floor<mode>2): Likewise.
+	(vsx_ceil<mode>2): Likewise.
+	(vsx_<VS_spdp_insn>): Likewise.
+	(vsx_xscvspdp): Likewise.
+	(vsx_xvcvspuxds): Likewise.
+	(vsx_float_fix_<mode>2): Likewise.
+	(vsx_set_<mode>): Likewise.
+	(vsx_extract_<mode>_internal1): Likewise.
+	(vsx_extract_<mode>_internal2): Likewise.
+	(vsx_extract_<mode>_load): Likewise.
+	(vsx_extract_<mode>_store): Likewise.
+	(vsx_splat_<mode>): Likewise.
+	(vsx_xxspltw_<mode>): Likewise.
+	(vsx_xxspltw_<mode>_direct): Likewise.
+	(vsx_xxmrghw_<mode>): Likewise.
+	(vsx_xxmrglw_<mode>): Likewise.
+	(vsx_xxsldwi_<mode>): Likewise.
+	(vsx_xscvdpspn): Tighten constraints to only use register classes
+	the types use.
+	(vsx_xscvspdpn): Likewise.
+	(vsx_xscvdpspn_scalar): Likewise.
+
+	* config/rs6000/rs6000.h (enum rs6000_reg_class_enum): Add wh, wi,
+	wj, and wk constraints.
+	(GPR_REG_CLASS_P): New helper macro for register classes targeting
+	general purpose registers.
+
+	* config/rs6000/rs6000.md (f32_dm): Use wh constraint for SDmode
+	direct moves.
+	(zero_extendsidi2_lfiwz): Use wj constraint for direct move of
+	DImode instead of wm.  Use wk constraint for direct move of DFmode
+	instead of wm.
+	(extendsidi2_lfiwax): Likewise.
+	(lfiwax): Likewise.
+	(lfiwzx): Likewise.
+	(movdi_internal64): Likewise.
+
+	* doc/md.texi (PowerPC and IBM RS6000): Document wh, wi, wj, and
+	wk constraints. Make the wy constraint documentation match them
+	implementation.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-08-04 Ganesh Gopalasubramanian
+		   <Ganesh.Gopalasubramanian@amd.com>
+
+	* config/i386/i386.c (ix86_option_override_internal): Add
+	PTA_RDRND and PTA_MOVBE for bdver4.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-08-04  Ganesh Gopalasubramanian 
+		    <Ganesh.Gopalasubramanian@amd.com>
+
+	* config/i386/driver-i386.c (host_detect_local_cpu): Handle AMD's extended
+	family information. Handle BTVER2 cpu with cpuid family value.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-06-16  Ganesh Gopalasubramanian 
+		    <Ganesh.Gopalasubramanian@amd.com>
+
+	* config/i386/i386.c (ix86_expand_sse2_mulvxdi3): Issue
+	instructions "vpmuludq" and "vpaddq" instead of "vpmacsdql" for
+	handling 32-bit multiplication.
+
+2014-08-08  Guozhi Wei  <carrot@google.com>
+
+	* config/rs6000/rs6000.md (*movdi_internal64): Add a new constraint.
+
+2014-08-07  Ilya Tocar  <ilya.tocar@intel.com>
+
+	* config/i386/sse.md (vec_extract_lo_<mode><mask_name>): Fix
+	constraint.
+
+2014-08-06  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR debug/61923
+	* haifa-sched.c (advance_one_cycle): Fix dump.
+	(schedule_block): Don't advance cycle if we are already at the
+	beginning of the cycle.
+
+2014-08-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61320
+	* tree-ssa-loop-ivopts.c (may_be_unaligned_p): Properly
+	handle misaligned loads.
+
+2014-08-04  Rohit  <rohitarulraj@freescale.com>
+
+	PR target/60102
+	* config/rs6000/rs6000.c
+	(rs6000_reg_names): Add SPE high register names.
+	(alt_reg_names): Likewise.
+	(rs6000_dwarf_register_span): For SPE high registers, replace
+	dwarf register numbers with GCC hard register numbers.
+	(rs6000_init_dwarf_reg_sizes_extra): Likewise.
+	(rs6000_dbx_register_number): For SPE high registers, return dwarf
+	register number for the corresponding GCC hard register number.
+	* config/rs6000/rs6000.h
+	(FIRST_PSEUDO_REGISTER): Update based on 32 newly added GCC hard
+	register numbers for SPE high registers.
+	(DWARF_FRAME_REGISTERS):  Likewise.
+	(DWARF_REG_TO_UNWIND_COLUMN): Likewise.
+	(DWARF_FRAME_REGNUM): Likewise.
+	(FIXED_REGISTERS): Likewise.
+	(CALL_USED_REGISTERS): Likewise.
+	(CALL_REALLY_USED_REGISTERS): Likewise.
+	(REG_ALLOC_ORDER): Likewise.
+	(enum reg_class): Likewise.
+	(REG_CLASS_NAMES): Likewise.
+	(REG_CLASS_CONTENTS): Likewise.
+	(SPE_HIGH_REGNO_P): New macro to identify SPE high registers.
+
+2014-08-01  Vladimir Makarov  <vmakarov@redhat.com>
+
+	* lra-constraints.c (remove_inheritance_pseudos): Process
+	destination pseudo too.
+
+2014-08-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-06-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/61375
+	* tree-ssa-math-opts.c (find_bswap_or_nop_1): Cancel optimization if
+	symbolic number cannot be represented in an unsigned HOST_WIDE_INT.
+	(execute_optimize_bswap): Cancel optimization if CHAR_BIT != 8.
+
+2014-08-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61964
+	* tree-ssa-tail-merge.c (gimple_equal_p): Handle non-SSA LHS solely
+	by structural equality.
+
+2014-07-31  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-07-31  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/61844
+	* config/sh/sh.c (sh_legitimate_address_p,
+	sh_legitimize_reload_address): Handle reg+reg address modes when
+	ALLOW_INDEXED_ADDRESS is false.
+	* config/sh/predicates.md (general_movsrc_operand,
+	general_movdst_operand): Likewise.
+
+2014-07-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/61656
+	* config/i386/i386.c (classify_argument): Don't merge classes above
+	number of words.
+
+2014-07-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/elf.h: Define TARGET_UNWIND_TABLES_DEFAULT.
+
+2014-07-24  Kyle McMartin  <kyle@redhat.com>
+
+        * config/aarch64/aarch64-linux.h (TARGET_ASM_FILE_END): Define.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/rs6000/rs6000-protos.h (rs6000_special_adjust_field_align_p):
+	Add prototype.
+	* config/rs6000/rs6000.c (rs6000_special_adjust_field_align_p): New
+	function.  Issue -Wpsabi warning if future GCC releases will use
+	different field alignment rules for this type.
+	* config/rs6000/sysv4.h (ADJUST_FIELD_ALIGN): Call it.
+	* config/rs6000/linux64.h (ADJUST_FIELD_ALIGN): Likewise.
+	* config/rs6000/freebsd64.h (ADJUST_FIELD_ALIGN): Likewise.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_function_arg_boundary): Issue
+	-Wpsabi note when encountering a type where future GCC releases
+	will apply different alignment requirements.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_function_arg): If a float argument
+	does not fit fully into floating-point registers, and there is still
+	space in the register parameter area, issue -Wpsabi note that the ABI
+	will change in a future GCC release.
+
+2014-07-23  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/arm/t-rtems-eabi: Add
+	mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard,
+	mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard,
+	mbig-endian/mthumb/march=armv7-r, and
+	mbig-endian/mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+	multilibs.
+
+2014-07-23  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+	    Chris Johns <chrisj@rtems.org>
+	    Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* config.gcc: Add nios2-*-rtems*.
+	* config/nios2/rtems.h: New file.
+	* gcc/config/nios2/t-rtems: New file.
+
+2014-07-21  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* config/rs6000/sysv4.h (LIBASAN_EARLY_SPEC): Define.
+	(LIBTSAN_EARLY_SPEC): Likewise.
+
+2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61855
+	* config/i386/avx512fintrin.h: Move constants for mantissa extraction
+	out of #ifdef __OPTIMIZE__.
+
+2014-07-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* expr.c (store_field): Handle VOIDmode for calls that return values
+	in multiple locations.
+
+2014-07-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* toplev.c (output_stack_usage): Adjust the location of the warning.
+
+2014-07-19  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sync.md (*membar_storeload_leon3): New insn.
+	(*membar_storeload): Disable for LEON3.
+
+2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-16  David Wohlferd  <dw@LimeGreenSocks.com>
+
+	PR target/61662
+	* config/i386/ia32intrin.h: Use __LP64__ to determine size of long.
+
+2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61794
+	* config/i386/sse.md (avx512f_vextract<shuffletype>32x4_1_maskm):
+	Fix instruction constraint.
+	(<mask_codefor>avx512f_vextract<shuffletype>32x4_1<mask_name>): Ditto.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61779
+	* tree-ssa-copy.c (copy_prop_visit_cond_stmt): Always try
+	simplifying a condition.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/61801
+	* sched-deps.c (sched_analyze_2): For ASM_OPERANDS and ASM_INPUT
+	don't set reg_pending_barrier if it appears in a debug-insn.
+
+2014-07-17  Hans-Peter Nilsson  <hp@axis.com>
+
+	Backport from trunk.
+	PR target/61737.
+	* config/cris/cris.c (TARGET_LEGITIMATE_CONSTANT_P)
+	(TARGET_CANNOT_FORCE_CONST_MEM): Define.
+	(cris_cannot_force_const_mem, cris_legitimate_constant_p): New
+	functions.
+	(cris_print_index, cris_print_operand, cris_constant_index_p)
+	(cris_side_effect_mode_ok): Replace CONSTANT_P with CRIS_CONSTANT_P.
+	(cris_address_cost): Ditto last CONSTANT_P.
+	(cris_symbol_type_of): Rename from cris_pic_symbol_type_of.  All
+	callers changed.  Yield cris_offsettable_symbol for non-PIC
+	constant symbolic expressions including labels.  Yield cris_unspec
+	for all unspecs.
+	(cris_expand_pic_call_address): New parameter MARKERP.  Set its
+	target to pic_offset_table_rtx for calls that will likely go
+	through PLT, const0_rtx when they can't.  All callers changed.
+	Assert flag_pic.  Use CONSTANT_P, not CONSTANT_ADDRESS_P, for
+	symbolic expressions to be PICified.  Remove second, redundant,
+	assert on can_create_pseudo_p returning non-zero.  Use
+	replace_equiv_address_nv, not replace_equiv_address, for final
+	operand update.
+	* config/cris/cris.md ("movsi"): Move variable t to pattern
+	toplevel. Adjust assert for new cris_symbol_type member.  Use
+	CONSTANT_P instead of CONSTANT_ADDRESS_P.
+	("*movsi_internal") <case 9>: Make check for valid unspec operands
+	for lapc stricter.
+	<case CRIS_UNSPEC_PCREL, CRIS_UNSPEC_PLT_PCREL>: Clear condition codes.
+	("call", "call_value"): Use second incoming operand as a marker
+	for pic-offset-table-register being used.
+	("*expanded_call_non_v32", "*expanded_call_v32")
+	("*expanded_call_value_non_v32", "*expanded_call_value_v32"): For
+	second incoming operand to CALL, match cris_call_type_marker.
+	("*expanded_call_value_side"): Ditto.  Disable before reload_completed.
+	("*expanded_call_side"): Ditto.  Fix typo in comment.
+	(moverside, movemside peepholes): Check for CRIS_CONSTANT_P, not
+	CONSTANT_P.
+	* config/cris/predicates.md ("cris_call_type_marker"): New predicate.
+	* config/cris/cris.h (CRIS_CONSTANT_P): New macro.
+	(enum cris_symbol_type): Rename from cris_pic_symbol_type.  All
+	users changed.  Add members cris_offsettable_symbol and cris_unspec.
+	(cris_symbol_type): Rename from cris_pic_symbol_type.
+	* config/cris/constraints.md ("T"): Use CRIS_CONSTANT_P, not
+	just CONSTANT_P.
+	* config/cris/cris-protos.h (cris_symbol_type_of,
+	cris_expand_pic_call_address): Adjust prototypes.
+	(cris_legitimate_constant_p): New prototype.
+
+	* config.gcc (crisv32-*-linux* | cris-*-linux*): Do not override
+	an existing tmake_file.  Don't add t-slibgcc and t-linux.
+
+2014-07-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* omp-low.c (create_omp_child_function): Don't set DECL_NAMELESS
+	on the FUNCTION_DECL.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
@@ -4,14 +1221,14 @@
 
 2014-07-10  Cary Coutant  <ccoutant@google.com>
 
-        Backport from trunk at r212211.
+	Backport from trunk at r212211.
 
 	* dwarf2out.c (remove_addr_table_entry): Remove unnecessary hash table
-        lookup.
+	lookup.
 	(resolve_addr_in_expr): When replacing the rtx in a location list
-        entry, get a new address table entry.
+	entry, get a new address table entry.
 	(dwarf2out_finish): Call index_location_lists even if there are no
-        addr_index_table entries yet.
+	addr_index_table entries yet.
 
 2014-07-10  Tom G. Christensen  <tgc@jupiterrise.com>
 
@@ -33,13 +1250,13 @@
 	PR target/61062
 	* config/arm/arm_neon.h (vtrn_s8, vtrn_s16, vtrn_u8, vtrn_u16, vtrn_p8,
 	vtrn_p16, vtrn_s32, vtrn_f32, vtrn_u32, vtrnq_s8, vtrnq_s16, vtrnq_s32,
-	vtrnq_f32, vtrnq_u8, vtrnq_u16, vtrnq_u32, vtrnq_p8, vtrnq_p16, vzip_s8,
-	vzip_s16, vzip_u8, vzip_u16, vzip_p8, vzip_p16, vzip_s32, vzip_f32,
-	vzip_u32, vzipq_s8, vzipq_s16, vzipq_s32, vzipq_f32, vzipq_u8,
-	vzipq_u16, vzipq_u32, vzipq_p8, vzipq_p16, vuzp_s8, vuzp_s16, vuzp_s32,
-	vuzp_f32, vuzp_u8, vuzp_u16, vuzp_u32, vuzp_p8, vuzp_p16, vuzpq_s8,
-	vuzpq_s16, vuzpq_s32, vuzpq_f32, vuzpq_u8, vuzpq_u16, vuzpq_u32,
-	vuzpq_p8, vuzpq_p16): Correct mask for bigendian.
+	vtrnq_f32, vtrnq_u8, vtrnq_u16, vtrnq_u32, vtrnq_p8, vtrnq_p16,
+	vzip_s8, vzip_s16, vzip_u8, vzip_u16, vzip_p8, vzip_p16, vzip_s32,
+	vzip_f32, vzip_u32, vzipq_s8, vzipq_s16, vzipq_s32, vzipq_f32,
+	vzipq_u8, vzipq_u16, vzipq_u32, vzipq_p8, vzipq_p16, vuzp_s8, vuzp_s16,
+	vuzp_s32, vuzp_f32, vuzp_u8, vuzp_u16, vuzp_u32, vuzp_p8, vuzp_p16,
+	vuzpq_s8, vuzpq_s16, vuzpq_s32, vuzpq_f32, vuzpq_u8, vuzpq_u16,
+	vuzpq_u32, vuzpq_p8, vuzpq_p16): Correct mask for bigendian.
 
 
 2014-07-09  Alan Lawrence  <alan.lawrence@arm.com>
@@ -157,11 +1374,9 @@
 	2014-06-24  Jakub Jelinek  <jakub@redhat.com>
 
 	* gimplify.c (gimplify_scan_omp_clauses) <case OMP_CLAUSE_MAP,
-	OMP_CLAUSE_TO, OMP_CLAUSE_FROM): Make sure OMP_CLAUSE_SIZE is
-	non-NULL.
+	OMP_CLAUSE_TO, OMP_CLAUSE_FROM): Make sure OMP_CLAUSE_SIZE is non-NULL.
 	<case OMP_CLAUSE_ALIGNED>: Gimplify OMP_CLAUSE_ALIGNED_ALIGNMENT.
-	(gimplify_adjust_omp_clauses_1): Make sure OMP_CLAUSE_SIZE is
-	non-NULL.
+	(gimplify_adjust_omp_clauses_1): Make sure OMP_CLAUSE_SIZE is non-NULL.
 	(gimplify_adjust_omp_clauses): Likewise.
 	* omp-low.c (lower_rec_simd_input_clauses,
 	lower_rec_input_clauses, expand_omp_simd): Handle non-constant
@@ -176,9 +1391,8 @@
 
 	2014-06-18  Jakub Jelinek  <jakub@redhat.com>
 
-	* gimplify.c (omp_notice_variable): If n is non-NULL
-	and no flags change in ORT_TARGET region, don't jump to
-	do_outer.
+	* gimplify.c (omp_notice_variable): If n is non-NULL and no flags
+	change in ORT_TARGET region, don't jump to do_outer.
 	(struct gimplify_adjust_omp_clauses_data): New type.
 	(gimplify_adjust_omp_clauses_1): Adjust for data being
 	a struct gimplify_adjust_omp_clauses_data pointer instead
@@ -196,14 +1410,12 @@
 	gimple_seq * argument to omp_finish_clause hook.
 	* omp-low.c (scan_sharing_clauses): Call scan_omp_op on
 	non-DECL_P OMP_CLAUSE_DECL if ctx->outer.
-	(scan_omp_parallel, lower_omp_for): When adding
-	_LOOPTEMP_ clause var, add it to outer ctx's decl_map
-	as identity.
+	(scan_omp_parallel, lower_omp_for): When adding _LOOPTEMP_ clause var,
+	add it to outer ctx's decl_map as identity.
 	* tree-core.h (OMP_CLAUSE_MAP_TO_PSET): New map kind.
 	* tree-nested.c (convert_nonlocal_omp_clauses,
 	convert_local_omp_clauses): Handle various OpenMP 4.0 clauses.
-	* tree-pretty-print.c (dump_omp_clause): Handle
-	OMP_CLAUSE_MAP_TO_PSET.
+	* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE_MAP_TO_PSET.
 
 	2014-06-10  Jakub Jelinek  <jakub@redhat.com>
 
@@ -227,8 +1439,7 @@
 	OMP_CLAUSE_LINEAR_STMT.
 	* omp-low.c (lower_rec_input_clauses): Fix typo.
 	(maybe_add_implicit_barrier_cancel, lower_omp_1): Add
-	cast between Fortran boolean_type_node and C _Bool if
-	needed.
+	cast between Fortran boolean_type_node and C _Bool if needed.
 
 2014-06-30  Jason Merrill  <jason@redhat.com>
 
@@ -279,8 +1490,7 @@
 	(aarch64_sqdmlsl_lane<mode>): Likewise.
 	(aarch64_sqdmull_lane<mode>): Likewise.
 	(aarch64_sqdmull2_lane<mode>): Likewise.
-	(aarch64_sqdmlal_laneq<mode>):
-	Replace VCON usage with VCONQ.
+	(aarch64_sqdmlal_laneq<mode>): Replace VCON usage with VCONQ.
 	Emit aarch64_sqdmlal_laneq<mode>_internal insn.
 	(aarch64_sqdmlal2_laneq<mode>): Emit
 	aarch64_sqdmlal2_laneq<mode>_internal insn.
Index: gcc/testsuite/gcc.target/powerpc/pr63335.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr63335.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr63335.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-do run { target { powerpc64*-*-* } } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+#include <altivec.h>
+
+void abort (void);
+
+vector double vec = (vector double) {99.0, 99.0};
+
+int main() {
+
+  int actual = vec_all_nge(vec, vec);
+  if ( actual != 0)
+    abort();
+
+  actual = vec_all_nle(vec, vec);
+  if ( actual != 0)
+    abort();
+
+  actual = vec_any_nge(vec, vec);
+  if ( actual != 0)
+    abort();
+
+  actual = vec_any_nle(vec, vec);
+  if ( actual != 0)
+    abort();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
+/* { dg-options "-mabi=elfv2" } */
+
+struct f8
+  {
+    float x[8];
+  };
+
+void test (struct f8 a, struct f8 b) /* { dg-message "note: the ABI of passing homogeneous float aggregates will change" } */
+{
+}
+
Index: gcc/testsuite/gcc.target/powerpc/vsx-extract-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-extract-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-extract-1.c	(.../branches/gcc-4_9-branch)
@@ -7,10 +7,4 @@
 
 #include <altivec.h>
 
-#if __LITTLE_ENDIAN__
-#define OFFSET 1
-#else
-#define OFFSET 0
-#endif
-
-double get_value (vector double *p) { return vec_extract (*p, OFFSET); }
+double get_value (vector double *p) { return vec_extract (*p, 0); }
Index: gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
+
+struct test
+  {
+    long a __attribute__((aligned (16)));
+  };
+
+void test (struct test a) /* { dg-message "note: the ABI of passing aggregates with 16-byte alignment will change" } */
+{
+}
+
Index: gcc/testsuite/gcc.target/powerpc/pr60102.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr60102.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr60102.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-skip-if "not an SPE target" { ! powerpc_spe_nocache } { "*" } { "" } } */
+/* { dg-options "-mcpu=8548 -mspe -mabi=spe -g -mfloat-gprs=double" } */
+
+double
+pr60102 (double x, int m)
+{
+  double y;
+  y =  m % 2 ? x : 1;
+  return y;
+}
Index: gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-3.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+struct test
+  {
+    int a __attribute__((vector_size (8)));
+  }; /* { dg-message "note: the layout of aggregates containing vectors with 8-byte alignment will change" } */
+
Index: gcc/testsuite/gcc.target/arm/pr59985.C
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr59985.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr59985.C	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { arm_thumb1 } { "*" } { "" } } */
 /* { dg-options "-g -fcompare-debug -O2 -march=armv7-a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mfloat-abi=hard" } */
 
 extern void *f1 (unsigned long, unsigned long);
Index: gcc/testsuite/gcc.target/arm/thumb-find-work-register.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/thumb-find-work-register.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/thumb-find-work-register.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,6 @@
 /* Wrong method to get number of arg reg will cause argument corruption.  */
 /* { dg-do run } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-require-effective-target arm_eabi } */
 /* { dg-options "-mthumb -O1" } */
 
Index: gcc/testsuite/gcc.target/arm/pr58784.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr58784.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr58784.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { arm_thumb1 } { "*" } { "" } } */
 /* { dg-options "-march=armv7-a -mfloat-abi=hard -mfpu=neon -marm -O2" } */
 
 typedef struct __attribute__ ((__packed__))
Index: gcc/testsuite/gcc.target/arm/pr59896.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr59896.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr59896.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-mthumb -O2" } */
 
 typedef unsigned int size_t;
Index: gcc/testsuite/gcc.target/arm/frame-pointer-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/frame-pointer-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/frame-pointer-1.c	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,7 @@
 /* Check local register variables using a register conventionally 
    used as the frame pointer aren't clobbered under high register pressure.  */
 /* { dg-do run } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-Os -mthumb -fomit-frame-pointer" } */
 
 #include <stdlib.h>
Index: gcc/testsuite/gcc.target/arm/stack-red-zone.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/stack-red-zone.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/stack-red-zone.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* No stack red zone.  PR38644.  */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-mthumb -O2" } */
 /* { dg-final { scan-assembler "ldrb\[^\n\]*\\n\[\t \]*add\[\t \]*sp" } } */
 
Index: gcc/testsuite/gcc.target/arm/neon-vext-execute.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/neon-vext-execute.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vext-execute.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-require-effective-target arm_neon_ok } */
+/* { dg-require-effective-target arm_neon_hw } */
 /* { dg-require-effective-target arm_little_endian } */
 /* { dg-options "-O2" } */
 /* { dg-add-options arm_neon } */
Index: gcc/testsuite/gcc.target/arm/pr56184.C
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr56184.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr56184.C	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "incompatible options" { ! { arm_thumb1_ok || arm_thumb2_ok } } { "*" } { "" } } */
 /* { dg-options "-fno-short-enums -O2 -mthumb -march=armv7-a -mfpu=neon -mfloat-abi=softfp -mtune=cortex-a9 -fno-section-anchors" } */
 
 typedef unsigned int size_t;
Index: gcc/testsuite/gcc.target/aarch64/vqdmullh_lane_s16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/vqdmullh_lane_s16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqdmullh_lane_s16.c	(.../branches/gcc-4_9-branch)
@@ -5,8 +5,8 @@
 
 #include "arm_neon.h"
 
-int32x1_t
-t_vqdmullh_lane_s16 (int16x1_t a, int16x4_t b)
+int32_t
+t_vqdmullh_lane_s16 (int16_t a, int16x4_t b)
 {
   return vqdmullh_lane_s16 (a, b, 0);
 }
Index: gcc/testsuite/gcc.target/aarch64/vqdmlalh_lane_s16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/vqdmlalh_lane_s16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqdmlalh_lane_s16.c	(.../branches/gcc-4_9-branch)
@@ -5,8 +5,8 @@
 
 #include "arm_neon.h"
 
-int32x1_t
-t_vqdmlalh_lane_s16 (int32x1_t a, int16x1_t b, int16x4_t c)
+int32_t
+t_vqdmlalh_lane_s16 (int32_t a, int16_t b, int16x4_t c)
 {
   return vqdmlalh_lane_s16 (a, b, c, 0);
 }
Index: gcc/testsuite/gcc.target/aarch64/vqdmlsls_lane_s32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/vqdmlsls_lane_s32.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqdmlsls_lane_s32.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include "arm_neon.h"
 
 int64x1_t
-t_vqdmlsls_lane_s32 (int64x1_t a, int32x1_t b, int32x2_t c)
+t_vqdmlsls_lane_s32 (int64x1_t a, int32_t b, int32x2_t c)
 {
   return vqdmlsls_lane_s32 (a, b, c, 0);
 }
Index: gcc/testsuite/gcc.target/aarch64/vqdmulls_lane_s32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/vqdmulls_lane_s32.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqdmulls_lane_s32.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include "arm_neon.h"
 
 int64x1_t
-t_vqdmulls_lane_s32 (int32x1_t a, int32x2_t b)
+t_vqdmulls_lane_s32 (int32_t a, int32x2_t b)
 {
   return vqdmulls_lane_s32 (a, b, 0);
 }
Index: gcc/testsuite/gcc.target/aarch64/pr62040.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr62040.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr62040.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-g -Os" } */
+
+#include "arm_neon.h"
+
+extern void bar (int32x4_t);
+
+void
+foo ()
+{
+  int32x4x4_t rows;
+  uint64x2x2_t row01;
+
+  row01.val[0] = vreinterpretq_u64_s32 (rows.val[0]);
+  row01.val[1] = vreinterpretq_u64_s32 (rows.val[1]);
+  uint64x1_t row3l = vget_low_u64 (row01.val[0]);
+  row01.val[0] = vcombine_u64 (vget_low_u64 (row01.val[1]), row3l);
+  int32x4_t xxx = vreinterpretq_s32_u64 (row01.val[0]);
+  int32x4_t out = vtrn1q_s32 (xxx, xxx);
+  bar (out);
+}
Index: gcc/testsuite/gcc.target/aarch64/vqdmlals_lane_s32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/vqdmlals_lane_s32.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqdmlals_lane_s32.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include "arm_neon.h"
 
 int64x1_t
-t_vqdmlals_lane_s32 (int64x1_t a, int32x1_t b, int32x2_t c)
+t_vqdmlals_lane_s32 (int64x1_t a, int32_t b, int32x2_t c)
 {
   return vqdmlals_lane_s32 (a, b, c, 0);
 }
Index: gcc/testsuite/gcc.target/aarch64/pr62262.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr62262.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr62262.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fprofile-use" } */
+
+static inline int CLZ(int mask) {
+   return mask ? __builtin_clz(mask) : 32;
+}
+
+int foo(int value)
+{
+    if (value == 0)
+        return 0;
+
+    int bias = CLZ(value);
+    value >>= bias;
+    int zeros = CLZ(value << 1);
+    value <<= zeros;
+
+    int packed = (unsigned)(value << 9) >> 9;
+    return packed;
+}
Index: gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c	(.../branches/gcc-4_9-branch)
@@ -195,10 +195,10 @@
 
 /* { dg-final { scan-assembler-times "aarch64_get_lanev16qi" 2 } } */
 
-int8x1_t
+int8_t
 test_vdupb_lane_s8 (int8x16_t a)
 {
-  int8x1_t res;
+  int8_t res;
   force_simd (a);
   res = vdupb_laneq_s8 (a, 2);
   force_simd (res);
@@ -205,10 +205,10 @@
   return res;
 }
 
-uint8x1_t
+uint8_t
 test_vdupb_lane_u8 (uint8x16_t a)
 {
-  uint8x1_t res;
+  uint8_t res;
   force_simd (a);
   res = vdupb_laneq_u8 (a, 2);
   force_simd (res);
@@ -217,10 +217,10 @@
 
 /* { dg-final { scan-assembler-times "aarch64_get_lanev8hi" 2 } } */
 
-int16x1_t
+int16_t
 test_vduph_lane_s16 (int16x8_t a)
 {
-  int16x1_t res;
+  int16_t res;
   force_simd (a);
   res = vduph_laneq_s16 (a, 2);
   force_simd (res);
@@ -227,10 +227,10 @@
   return res;
 }
 
-uint16x1_t
+uint16_t
 test_vduph_lane_u16 (uint16x8_t a)
 {
-  uint16x1_t res;
+  uint16_t res;
   force_simd (a);
   res = vduph_laneq_u16 (a, 2);
   force_simd (res);
@@ -239,10 +239,10 @@
 
 /* { dg-final { scan-assembler-times "aarch64_get_lanev4si" 2 } } */
 
-int32x1_t
+int32_t
 test_vdups_lane_s32 (int32x4_t a)
 {
-  int32x1_t res;
+  int32_t res;
   force_simd (a);
   res = vdups_laneq_s32 (a, 2);
   force_simd (res);
@@ -249,10 +249,10 @@
   return res;
 }
 
-uint32x1_t
+uint32_t
 test_vdups_lane_u32 (uint32x4_t a)
 {
-  uint32x1_t res;
+  uint32_t res;
   force_simd (a);
   res = vdups_laneq_u32 (a, 2);
   force_simd (res);
@@ -322,8 +322,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqadd\\ts\[0-9\]+" 1 } } */
 
-uint32x1_t
-test_vqadds_u32 (uint32x1_t a, uint32x1_t b)
+uint32_t
+test_vqadds_u32 (uint32_t a, uint32_t b)
 {
   return vqadds_u32 (a, b);
 }
@@ -330,8 +330,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqadd\\th\[0-9\]+" 1 } } */
 
-uint16x1_t
-test_vqaddh_u16 (uint16x1_t a, uint16x1_t b)
+uint16_t
+test_vqaddh_u16 (uint16_t a, uint16_t b)
 {
   return vqaddh_u16 (a, b);
 }
@@ -338,8 +338,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqadd\\tb\[0-9\]+" 1 } } */
 
-uint8x1_t
-test_vqaddb_u8 (uint8x1_t a, uint8x1_t b)
+uint8_t
+test_vqaddb_u8 (uint8_t a, uint8_t b)
 {
   return vqaddb_u8 (a, b);
 }
@@ -354,8 +354,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqadd\\ts\[0-9\]+, s\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqadds_s32 (int32x1_t a, int32x1_t b)
+int32_t
+test_vqadds_s32 (int32_t a, int32_t b)
 {
   return vqadds_s32 (a, b);
 }
@@ -362,8 +362,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqadd\\th\[0-9\]+, h\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqaddh_s16 (int16x1_t a, int16x1_t b)
+int16_t
+test_vqaddh_s16 (int16_t a, int16_t b)
 {
   return vqaddh_s16 (a, b);
 }
@@ -370,8 +370,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqadd\\tb\[0-9\]+, b\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqaddb_s8 (int8x1_t a, int8x1_t b)
+int8_t
+test_vqaddb_s8 (int8_t a, int8_t b)
 {
   return vqaddb_s8 (a, b);
 }
@@ -378,8 +378,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmlal\\ts\[0-9\]+, h\[0-9\]+, h\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqdmlalh_s16 (int32x1_t a, int16x1_t b, int16x1_t c)
+int32_t
+test_vqdmlalh_s16 (int32_t a, int16_t b, int16_t c)
 {
   return vqdmlalh_s16 (a, b, c);
 }
@@ -386,8 +386,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmlal\\ts\[0-9\]+, h\[0-9\]+, v" 1 } } */
 
-int32x1_t
-test_vqdmlalh_lane_s16 (int32x1_t a, int16x1_t b, int16x4_t c)
+int32_t
+test_vqdmlalh_lane_s16 (int32_t a, int16_t b, int16x4_t c)
 {
   return vqdmlalh_lane_s16 (a, b, c, 3);
 }
@@ -395,7 +395,7 @@
 /* { dg-final { scan-assembler-times "\\tsqdmlal\\td\[0-9\]+, s\[0-9\]+, s\[0-9\]+" 1 } } */
 
 int64x1_t
-test_vqdmlals_s32 (int64x1_t a, int32x1_t b, int32x1_t c)
+test_vqdmlals_s32 (int64x1_t a, int32_t b, int32_t c)
 {
   return vqdmlals_s32 (a, b, c);
 }
@@ -403,7 +403,7 @@
 /* { dg-final { scan-assembler-times "\\tsqdmlal\\td\[0-9\]+, s\[0-9\]+, v" 1 } } */
 
 int64x1_t
-test_vqdmlals_lane_s32 (int64x1_t a, int32x1_t b, int32x2_t c)
+test_vqdmlals_lane_s32 (int64x1_t a, int32_t b, int32x2_t c)
 {
   return vqdmlals_lane_s32 (a, b, c, 1);
 }
@@ -410,8 +410,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmlsl\\ts\[0-9\]+, h\[0-9\]+, h\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqdmlslh_s16 (int32x1_t a, int16x1_t b, int16x1_t c)
+int32_t
+test_vqdmlslh_s16 (int32_t a, int16_t b, int16_t c)
 {
   return vqdmlslh_s16 (a, b, c);
 }
@@ -418,8 +418,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmlsl\\ts\[0-9\]+, h\[0-9\]+, v" 1 } } */
 
-int32x1_t
-test_vqdmlslh_lane_s16 (int32x1_t a, int16x1_t b, int16x4_t c)
+int32_t
+test_vqdmlslh_lane_s16 (int32_t a, int16_t b, int16x4_t c)
 {
   return vqdmlslh_lane_s16 (a, b, c, 3);
 }
@@ -427,7 +427,7 @@
 /* { dg-final { scan-assembler-times "\\tsqdmlsl\\td\[0-9\]+, s\[0-9\]+, s\[0-9\]+" 1 } } */
 
 int64x1_t
-test_vqdmlsls_s32 (int64x1_t a, int32x1_t b, int32x1_t c)
+test_vqdmlsls_s32 (int64x1_t a, int32_t b, int32_t c)
 {
   return vqdmlsls_s32 (a, b, c);
 }
@@ -435,7 +435,7 @@
 /* { dg-final { scan-assembler-times "\\tsqdmlsl\\td\[0-9\]+, s\[0-9\]+, v" 1 } } */
 
 int64x1_t
-test_vqdmlsls_lane_s32 (int64x1_t a, int32x1_t b, int32x2_t c)
+test_vqdmlsls_lane_s32 (int64x1_t a, int32_t b, int32x2_t c)
 {
   return vqdmlsls_lane_s32 (a, b, c, 1);
 }
@@ -442,8 +442,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmulh\\th\[0-9\]+, h\[0-9\]+, h\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqdmulhh_s16 (int16x1_t a, int16x1_t b)
+int16_t
+test_vqdmulhh_s16 (int16_t a, int16_t b)
 {
   return vqdmulhh_s16 (a, b);
 }
@@ -450,8 +450,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmulh\\th\[0-9\]+, h\[0-9\]+, v" 1 } } */
 
-int16x1_t
-test_vqdmulhh_lane_s16 (int16x1_t a, int16x4_t b)
+int16_t
+test_vqdmulhh_lane_s16 (int16_t a, int16x4_t b)
 {
   return vqdmulhh_lane_s16 (a, b, 3);
 }
@@ -458,8 +458,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmulh\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqdmulhs_s32 (int32x1_t a, int32x1_t b)
+int32_t
+test_vqdmulhs_s32 (int32_t a, int32_t b)
 {
   return vqdmulhs_s32 (a, b);
 }
@@ -466,8 +466,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmulh\\ts\[0-9\]+, s\[0-9\]+, v" 1 } } */
 
-int32x1_t
-test_vqdmulhs_lane_s32 (int32x1_t a, int32x2_t b)
+int32_t
+test_vqdmulhs_lane_s32 (int32_t a, int32x2_t b)
 {
   return vqdmulhs_lane_s32 (a, b, 1);
 }
@@ -474,8 +474,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmull\\ts\[0-9\]+, h\[0-9\]+, h\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqdmullh_s16 (int16x1_t a, int16x1_t b)
+int32_t
+test_vqdmullh_s16 (int16_t a, int16_t b)
 {
   return vqdmullh_s16 (a, b);
 }
@@ -482,8 +482,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqdmull\\ts\[0-9\]+, h\[0-9\]+, v" 1 } } */
 
-int32x1_t
-test_vqdmullh_lane_s16 (int16x1_t a, int16x4_t b)
+int32_t
+test_vqdmullh_lane_s16 (int16_t a, int16x4_t b)
 {
   return vqdmullh_lane_s16 (a, b, 3);
 }
@@ -491,7 +491,7 @@
 /* { dg-final { scan-assembler-times "\\tsqdmull\\td\[0-9\]+, s\[0-9\]+, s\[0-9\]+" 1 } } */
 
 int64x1_t
-test_vqdmulls_s32 (int32x1_t a, int32x1_t b)
+test_vqdmulls_s32 (int32_t a, int32_t b)
 {
   return vqdmulls_s32 (a, b);
 }
@@ -499,7 +499,7 @@
 /* { dg-final { scan-assembler-times "\\tsqdmull\\td\[0-9\]+, s\[0-9\]+, v" 1 } } */
 
 int64x1_t
-test_vqdmulls_lane_s32 (int32x1_t a, int32x2_t b)
+test_vqdmulls_lane_s32 (int32_t a, int32x2_t b)
 {
   return vqdmulls_lane_s32 (a, b, 1);
 }
@@ -506,8 +506,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrdmulh\\th\[0-9\]+, h\[0-9\]+, h\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqrdmulhh_s16 (int16x1_t a, int16x1_t b)
+int16_t
+test_vqrdmulhh_s16 (int16_t a, int16_t b)
 {
   return vqrdmulhh_s16 (a, b);
 }
@@ -514,8 +514,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrdmulh\\th\[0-9\]+, h\[0-9\]+, v" 1 } } */
 
-int16x1_t
-test_vqrdmulhh_lane_s16 (int16x1_t a, int16x4_t b)
+int16_t
+test_vqrdmulhh_lane_s16 (int16_t a, int16x4_t b)
 {
   return vqrdmulhh_lane_s16 (a, b, 3);
 }
@@ -522,8 +522,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrdmulh\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqrdmulhs_s32 (int32x1_t a, int32x1_t b)
+int32_t
+test_vqrdmulhs_s32 (int32_t a, int32_t b)
 {
   return vqrdmulhs_s32 (a, b);
 }
@@ -530,8 +530,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrdmulh\\ts\[0-9\]+, s\[0-9\]+, v" 1 } } */
 
-int32x1_t
-test_vqrdmulhs_lane_s32 (int32x1_t a, int32x2_t b)
+int32_t
+test_vqrdmulhs_lane_s32 (int32_t a, int32x2_t b)
 {
   return vqrdmulhs_lane_s32 (a, b, 1);
 }
@@ -538,8 +538,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsuqadd\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vuqaddb_s8 (int8x1_t a, int8x1_t b)
+int8_t
+test_vuqaddb_s8 (int8_t a, int8_t b)
 {
   return vuqaddb_s8 (a, b);
 }
@@ -546,8 +546,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsuqadd\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vuqaddh_s16 (int16x1_t a, int8x1_t b)
+int16_t
+test_vuqaddh_s16 (int16_t a, int8_t b)
 {
   return vuqaddh_s16 (a, b);
 }
@@ -554,8 +554,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsuqadd\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vuqadds_s32 (int32x1_t a, int8x1_t b)
+int32_t
+test_vuqadds_s32 (int32_t a, int8_t b)
 {
   return vuqadds_s32 (a, b);
 }
@@ -563,7 +563,7 @@
 /* { dg-final { scan-assembler-times "\\tsuqadd\\td\[0-9\]+" 1 } } */
 
 int64x1_t
-test_vuqaddd_s64 (int64x1_t a, int8x1_t b)
+test_vuqaddd_s64 (int64x1_t a, int8_t b)
 {
   return vuqaddd_s64 (a, b);
 }
@@ -570,8 +570,8 @@
 
 /* { dg-final { scan-assembler-times "\\tusqadd\\tb\[0-9\]+" 1 } } */
 
-uint8x1_t
-test_vsqaddb_u8 (uint8x1_t a, int8x1_t b)
+uint8_t
+test_vsqaddb_u8 (uint8_t a, int8_t b)
 {
   return vsqaddb_u8 (a, b);
 }
@@ -578,8 +578,8 @@
 
 /* { dg-final { scan-assembler-times "\\tusqadd\\th\[0-9\]+" 1 } } */
 
-uint16x1_t
-test_vsqaddh_u16 (uint16x1_t a, int8x1_t b)
+uint16_t
+test_vsqaddh_u16 (uint16_t a, int8_t b)
 {
   return vsqaddh_u16 (a, b);
 }
@@ -586,8 +586,8 @@
 
 /* { dg-final { scan-assembler-times "\\tusqadd\\ts\[0-9\]+" 1 } } */
 
-uint32x1_t
-test_vsqadds_u32 (uint32x1_t a, int8x1_t b)
+uint32_t
+test_vsqadds_u32 (uint32_t a, int8_t b)
 {
   return vsqadds_u32 (a, b);
 }
@@ -595,7 +595,7 @@
 /* { dg-final { scan-assembler-times "\\tusqadd\\td\[0-9\]+" 1 } } */
 
 uint64x1_t
-test_vsqaddd_u64 (uint64x1_t a, int8x1_t b)
+test_vsqaddd_u64 (uint64x1_t a, int8_t b)
 {
   return vsqaddd_u64 (a, b);
 }
@@ -602,8 +602,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqabs\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqabsb_s8 (int8x1_t a)
+int8_t
+test_vqabsb_s8 (int8_t a)
 {
   return vqabsb_s8 (a);
 }
@@ -610,8 +610,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqabs\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqabsh_s16 (int16x1_t a)
+int16_t
+test_vqabsh_s16 (int16_t a)
 {
   return vqabsh_s16 (a);
 }
@@ -618,8 +618,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqabs\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqabss_s32 (int32x1_t a)
+int32_t
+test_vqabss_s32 (int32_t a)
 {
   return vqabss_s32 (a);
 }
@@ -626,8 +626,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqneg\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqnegb_s8 (int8x1_t a)
+int8_t
+test_vqnegb_s8 (int8_t a)
 {
   return vqnegb_s8 (a);
 }
@@ -634,8 +634,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqneg\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqnegh_s16 (int16x1_t a)
+int16_t
+test_vqnegh_s16 (int16_t a)
 {
   return vqnegh_s16 (a);
 }
@@ -642,8 +642,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqneg\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqnegs_s32 (int32x1_t a)
+int32_t
+test_vqnegs_s32 (int32_t a)
 {
   return vqnegs_s32 (a);
 }
@@ -650,8 +650,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqxtun\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqmovunh_s16 (int16x1_t a)
+int8_t
+test_vqmovunh_s16 (int16_t a)
 {
   return vqmovunh_s16 (a);
 }
@@ -658,8 +658,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqxtun\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqmovuns_s32 (int32x1_t a)
+int16_t
+test_vqmovuns_s32 (int32_t a)
 {
   return vqmovuns_s32 (a);
 }
@@ -666,7 +666,7 @@
 
 /* { dg-final { scan-assembler-times "\\tsqxtun\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
+int32_t
 test_vqmovund_s64 (int64x1_t a)
 {
   return vqmovund_s64 (a);
@@ -674,8 +674,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqxtn\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqmovnh_s16 (int16x1_t a)
+int8_t
+test_vqmovnh_s16 (int16_t a)
 {
   return vqmovnh_s16 (a);
 }
@@ -682,8 +682,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqxtn\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqmovns_s32 (int32x1_t a)
+int16_t
+test_vqmovns_s32 (int32_t a)
 {
   return vqmovns_s32 (a);
 }
@@ -690,7 +690,7 @@
 
 /* { dg-final { scan-assembler-times "\\tsqxtn\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
+int32_t
 test_vqmovnd_s64 (int64x1_t a)
 {
   return vqmovnd_s64 (a);
@@ -698,8 +698,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqxtn\\tb\[0-9\]+" 1 } } */
 
-uint8x1_t
-test_vqmovnh_u16 (uint16x1_t a)
+uint8_t
+test_vqmovnh_u16 (uint16_t a)
 {
   return vqmovnh_u16 (a);
 }
@@ -706,8 +706,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqxtn\\th\[0-9\]+" 1 } } */
 
-uint16x1_t
-test_vqmovns_u32 (uint32x1_t a)
+uint16_t
+test_vqmovns_u32 (uint32_t a)
 {
   return vqmovns_u32 (a);
 }
@@ -714,7 +714,7 @@
 
 /* { dg-final { scan-assembler-times "\\tuqxtn\\ts\[0-9\]+" 1 } } */
 
-uint32x1_t
+uint32_t
 test_vqmovnd_u64 (uint64x1_t a)
 {
   return vqmovnd_u64 (a);
@@ -753,8 +753,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqsub\\ts\[0-9\]+" 1 } } */
 
-uint32x1_t
-test_vqsubs_u32 (uint32x1_t a, uint32x1_t b)
+uint32_t
+test_vqsubs_u32 (uint32_t a, uint32_t b)
 {
   return vqsubs_u32 (a, b);
 }
@@ -761,8 +761,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqsub\\th\[0-9\]+" 1 } } */
 
-uint16x1_t
-test_vqsubh_u16 (uint16x1_t a, uint16x1_t b)
+uint16_t
+test_vqsubh_u16 (uint16_t a, uint16_t b)
 {
   return vqsubh_u16 (a, b);
 }
@@ -769,8 +769,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqsub\\tb\[0-9\]+" 1 } } */
 
-uint8x1_t
-test_vqsubb_u8 (uint8x1_t a, uint8x1_t b)
+uint8_t
+test_vqsubb_u8 (uint8_t a, uint8_t b)
 {
   return vqsubb_u8 (a, b);
 }
@@ -785,8 +785,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqsub\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqsubs_s32 (int32x1_t a, int32x1_t b)
+int32_t
+test_vqsubs_s32 (int32_t a, int32_t b)
 {
   return vqsubs_s32 (a, b);
 }
@@ -793,8 +793,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqsub\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqsubh_s16 (int16x1_t a, int16x1_t b)
+int16_t
+test_vqsubh_s16 (int16_t a, int16_t b)
 {
   return vqsubh_s16 (a, b);
 }
@@ -801,8 +801,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqsub\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqsubb_s8 (int8x1_t a, int8x1_t b)
+int8_t
+test_vqsubb_s8 (int8_t a, int8_t b)
 {
   return vqsubb_s8 (a, b);
 }
@@ -908,8 +908,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshl\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqrshlb_s8 (int8x1_t a, int8x1_t b)
+int8_t
+test_vqrshlb_s8 (int8_t a, int8_t b)
 {
   return vqrshlb_s8 (a, b);
 }
@@ -916,8 +916,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshl\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqrshlh_s16 (int16x1_t a, int16x1_t b)
+int16_t
+test_vqrshlh_s16 (int16_t a, int16_t b)
 {
   return vqrshlh_s16 (a, b);
 }
@@ -924,8 +924,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshl\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqrshls_s32 (int32x1_t a, int32x1_t b)
+int32_t
+test_vqrshls_s32 (int32_t a, int32_t b)
 {
   return vqrshls_s32 (a, b);
 }
@@ -940,8 +940,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqrshl\\tb\[0-9\]+" 1 } } */
 
-uint8x1_t
-test_vqrshlb_u8 (uint8x1_t a, uint8x1_t b)
+uint8_t
+test_vqrshlb_u8 (uint8_t a, uint8_t b)
 {
   return vqrshlb_u8 (a, b);
 }
@@ -948,8 +948,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqrshl\\th\[0-9\]+" 1 } } */
 
-uint16x1_t
-test_vqrshlh_u16 (uint16x1_t a, uint16x1_t b)
+uint16_t
+test_vqrshlh_u16 (uint16_t a, uint16_t b)
 {
   return vqrshlh_u16 (a, b);
 }
@@ -956,8 +956,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqrshl\\ts\[0-9\]+" 1 } } */
 
-uint32x1_t
-test_vqrshls_u32 (uint32x1_t a, uint32x1_t b)
+uint32_t
+test_vqrshls_u32 (uint32_t a, uint32_t b)
 {
   return vqrshls_u32 (a, b);
 }
@@ -972,8 +972,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshlu\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqshlub_n_s8 (int8x1_t a)
+int8_t
+test_vqshlub_n_s8 (int8_t a)
 {
   return vqshlub_n_s8 (a, 3);
 }
@@ -980,8 +980,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshlu\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqshluh_n_s16 (int16x1_t a)
+int16_t
+test_vqshluh_n_s16 (int16_t a)
 {
   return vqshluh_n_s16 (a, 4);
 }
@@ -988,8 +988,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshlu\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
-test_vqshlus_n_s32 (int32x1_t a)
+int32_t
+test_vqshlus_n_s32 (int32_t a)
 {
   return vqshlus_n_s32 (a, 5);
 }
@@ -1004,14 +1004,14 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshl\\tb\[0-9\]+" 2 } } */
 
-int8x1_t
-test_vqshlb_s8 (int8x1_t a, int8x1_t b)
+int8_t
+test_vqshlb_s8 (int8_t a, int8_t b)
 {
   return vqshlb_s8 (a, b);
 }
 
-int8x1_t
-test_vqshlb_n_s8 (int8x1_t a)
+int8_t
+test_vqshlb_n_s8 (int8_t a)
 {
   return vqshlb_n_s8 (a, 2);
 }
@@ -1018,14 +1018,14 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshl\\th\[0-9\]+" 2 } } */
 
-int16x1_t
-test_vqshlh_s16 (int16x1_t a, int16x1_t b)
+int16_t
+test_vqshlh_s16 (int16_t a, int16_t b)
 {
   return vqshlh_s16 (a, b);
 }
 
-int16x1_t
-test_vqshlh_n_s16 (int16x1_t a)
+int16_t
+test_vqshlh_n_s16 (int16_t a)
 {
   return vqshlh_n_s16 (a, 3);
 }
@@ -1032,14 +1032,14 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshl\\ts\[0-9\]+" 2 } } */
 
-int32x1_t
-test_vqshls_s32 (int32x1_t a, int32x1_t b)
+int32_t
+test_vqshls_s32 (int32_t a, int32_t b)
 {
   return vqshls_s32 (a, b);
 }
 
-int32x1_t
-test_vqshls_n_s32 (int32x1_t a)
+int32_t
+test_vqshls_n_s32 (int32_t a)
 {
   return vqshls_n_s32 (a, 4);
 }
@@ -1060,14 +1060,14 @@
 
 /* { dg-final { scan-assembler-times "\\tuqshl\\tb\[0-9\]+" 2 } } */
 
-uint8x1_t
-test_vqshlb_u8 (uint8x1_t a, uint8x1_t b)
+uint8_t
+test_vqshlb_u8 (uint8_t a, uint8_t b)
 {
   return vqshlb_u8 (a, b);
 }
 
-uint8x1_t
-test_vqshlb_n_u8 (uint8x1_t a)
+uint8_t
+test_vqshlb_n_u8 (uint8_t a)
 {
   return vqshlb_n_u8 (a, 2);
 }
@@ -1074,14 +1074,14 @@
 
 /* { dg-final { scan-assembler-times "\\tuqshl\\th\[0-9\]+" 2 } } */
 
-uint16x1_t
-test_vqshlh_u16 (uint16x1_t a, uint16x1_t b)
+uint16_t
+test_vqshlh_u16 (uint16_t a, uint16_t b)
 {
   return vqshlh_u16 (a, b);
 }
 
-uint16x1_t
-test_vqshlh_n_u16 (uint16x1_t a)
+uint16_t
+test_vqshlh_n_u16 (uint16_t a)
 {
   return vqshlh_n_u16 (a, 3);
 }
@@ -1088,14 +1088,14 @@
 
 /* { dg-final { scan-assembler-times "\\tuqshl\\ts\[0-9\]+" 2 } } */
 
-uint32x1_t
-test_vqshls_u32 (uint32x1_t a, uint32x1_t b)
+uint32_t
+test_vqshls_u32 (uint32_t a, uint32_t b)
 {
   return vqshls_u32 (a, b);
 }
 
-uint32x1_t
-test_vqshls_n_u32 (uint32x1_t a)
+uint32_t
+test_vqshls_n_u32 (uint32_t a)
 {
   return vqshls_n_u32 (a, 4);
 }
@@ -1116,8 +1116,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshrun\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqshrunh_n_s16 (int16x1_t a)
+int8_t
+test_vqshrunh_n_s16 (int16_t a)
 {
   return vqshrunh_n_s16 (a, 2);
 }
@@ -1124,8 +1124,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshrun\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqshruns_n_s32 (int32x1_t a)
+int16_t
+test_vqshruns_n_s32 (int32_t a)
 {
   return vqshruns_n_s32 (a, 3);
 }
@@ -1132,7 +1132,7 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshrun\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
+int32_t
 test_vqshrund_n_s64 (int64x1_t a)
 {
   return vqshrund_n_s64 (a, 4);
@@ -1140,8 +1140,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshrun\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqrshrunh_n_s16 (int16x1_t a)
+int8_t
+test_vqrshrunh_n_s16 (int16_t a)
 {
   return vqrshrunh_n_s16 (a, 2);
 }
@@ -1148,8 +1148,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshrun\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqrshruns_n_s32 (int32x1_t a)
+int16_t
+test_vqrshruns_n_s32 (int32_t a)
 {
   return vqrshruns_n_s32 (a, 3);
 }
@@ -1156,7 +1156,7 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshrun\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
+int32_t
 test_vqrshrund_n_s64 (int64x1_t a)
 {
   return vqrshrund_n_s64 (a, 4);
@@ -1164,8 +1164,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshrn\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqshrnh_n_s16 (int16x1_t a)
+int8_t
+test_vqshrnh_n_s16 (int16_t a)
 {
   return vqshrnh_n_s16 (a, 2);
 }
@@ -1172,8 +1172,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshrn\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqshrns_n_s32 (int32x1_t a)
+int16_t
+test_vqshrns_n_s32 (int32_t a)
 {
   return vqshrns_n_s32 (a, 3);
 }
@@ -1180,7 +1180,7 @@
 
 /* { dg-final { scan-assembler-times "\\tsqshrn\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
+int32_t
 test_vqshrnd_n_s64 (int64x1_t a)
 {
   return vqshrnd_n_s64 (a, 4);
@@ -1188,8 +1188,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqshrn\\tb\[0-9\]+" 1 } } */
 
-uint8x1_t
-test_vqshrnh_n_u16 (uint16x1_t a)
+uint8_t
+test_vqshrnh_n_u16 (uint16_t a)
 {
   return vqshrnh_n_u16 (a, 2);
 }
@@ -1196,8 +1196,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqshrn\\th\[0-9\]+" 1 } } */
 
-uint16x1_t
-test_vqshrns_n_u32 (uint32x1_t a)
+uint16_t
+test_vqshrns_n_u32 (uint32_t a)
 {
   return vqshrns_n_u32 (a, 3);
 }
@@ -1204,7 +1204,7 @@
 
 /* { dg-final { scan-assembler-times "\\tuqshrn\\ts\[0-9\]+" 1 } } */
 
-uint32x1_t
+uint32_t
 test_vqshrnd_n_u64 (uint64x1_t a)
 {
   return vqshrnd_n_u64 (a, 4);
@@ -1212,8 +1212,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshrn\\tb\[0-9\]+" 1 } } */
 
-int8x1_t
-test_vqrshrnh_n_s16 (int16x1_t a)
+int8_t
+test_vqrshrnh_n_s16 (int16_t a)
 {
   return vqrshrnh_n_s16 (a, 2);
 }
@@ -1220,8 +1220,8 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshrn\\th\[0-9\]+" 1 } } */
 
-int16x1_t
-test_vqrshrns_n_s32 (int32x1_t a)
+int16_t
+test_vqrshrns_n_s32 (int32_t a)
 {
   return vqrshrns_n_s32 (a, 3);
 }
@@ -1228,7 +1228,7 @@
 
 /* { dg-final { scan-assembler-times "\\tsqrshrn\\ts\[0-9\]+" 1 } } */
 
-int32x1_t
+int32_t
 test_vqrshrnd_n_s64 (int64x1_t a)
 {
   return vqrshrnd_n_s64 (a, 4);
@@ -1236,8 +1236,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqrshrn\\tb\[0-9\]+" 1 } } */
 
-uint8x1_t
-test_vqrshrnh_n_u16 (uint16x1_t a)
+uint8_t
+test_vqrshrnh_n_u16 (uint16_t a)
 {
   return vqrshrnh_n_u16 (a, 2);
 }
@@ -1244,8 +1244,8 @@
 
 /* { dg-final { scan-assembler-times "\\tuqrshrn\\th\[0-9\]+" 1 } } */
 
-uint16x1_t
-test_vqrshrns_n_u32 (uint32x1_t a)
+uint16_t
+test_vqrshrns_n_u32 (uint32_t a)
 {
   return vqrshrns_n_u32 (a, 3);
 }
@@ -1252,7 +1252,7 @@
 
 /* { dg-final { scan-assembler-times "\\tuqrshrn\\ts\[0-9\]+" 1 } } */
 
-uint32x1_t
+uint32_t
 test_vqrshrnd_n_u64 (uint64x1_t a)
 {
   return vqrshrnd_n_u64 (a, 4);
Index: gcc/testsuite/gcc.target/aarch64/vqdmlslh_lane_s16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/vqdmlslh_lane_s16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/vqdmlslh_lane_s16.c	(.../branches/gcc-4_9-branch)
@@ -5,8 +5,8 @@
 
 #include "arm_neon.h"
 
-int32x1_t
-t_vqdmlslh_lane_s16 (int32x1_t a, int16x1_t b, int16x4_t c)
+int32_t
+t_vqdmlslh_lane_s16 (int32_t a, int16_t b, int16x4_t c)
 {
   return vqdmlslh_lane_s16 (a, b, c, 0);
 }
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2pd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2pd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2pd-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (double *dst, double *src1, long long *ind, double *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2d-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2d-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2d-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (int *dst, int *src1, int *ind, int *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2q-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2q-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2q-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (long long *dst, long long *src1, long long *ind, long long *src2)
Index: gcc/testsuite/gcc.target/i386/pr61923.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61923.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61923.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+/* PR debug/61923 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+typedef struct
+{
+  struct
+  {
+    struct
+    {
+      char head;
+    } tickets;
+  };
+} arch_spinlock_t;
+struct ext4_map_blocks
+{
+  int m_lblk;
+  int m_len;
+  int m_flags;
+};
+int ext4_da_map_blocks_ei_0;
+void fn1 (int p1, struct ext4_map_blocks *p2)
+{
+  int ret;
+  if (p2->m_flags)
+    {
+      ext4_da_map_blocks_ei_0++;
+      arch_spinlock_t *lock;
+      switch (sizeof *&lock->tickets.head)
+      case 1:
+      asm("" : "+m"(*&lock->tickets.head) : ""(0));
+      __asm__("");
+      ret = 0;
+    }
+  fn2 (p2->m_lblk, p2->m_len);
+}
Index: gcc/testsuite/gcc.target/i386/xop-imul64-vector.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/xop-imul64-vector.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/xop-imul64-vector.c	(.../branches/gcc-4_9-branch)
@@ -33,4 +33,3 @@
 
 /* { dg-final { scan-assembler "vpmulld" } } */
 /* { dg-final { scan-assembler "vphadddq" } } */
-/* { dg-final { scan-assembler "vpmacsdql" } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2d-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2d-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2d-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (int *dst, int *src1, int *ind, int *src2)
Index: gcc/testsuite/gcc.target/i386/pr61855.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61855.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61855.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512f" } */
+
+#include <x86intrin.h>
+
+__m512 test (__m512 x)
+{
+  return _mm512_getmant_ps(x, _MM_MANT_NORM_1_2, _MM_MANT_SIGN_zero);
+}
+
Index: gcc/testsuite/gcc.target/i386/pr63495.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63495.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63495.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,6 @@
+/* PR c/63495 */
+/* { dg-do compile { target { i?86-*-linux* x86_64-*-linux* } } } */
+/* { dg-options "-std=gnu11" } */
+
+struct __attribute__ ((aligned (8))) S { char c; };
+_Static_assert (_Alignof (struct S) >= 8, "wrong alignment");
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmss-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmss-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmss-2.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include "avx512f-check.h"
 #include "avx512f-helper.h"
 #include <math.h>
-#include <values.h>
+#include <float.h>
 #include "avx512f-mask-type.h"
 
 void
@@ -57,10 +57,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXFLOAT;
+      *r = FLT_MAX;
       break;
     case 15:
-      *r = -MAXFLOAT;
+      *r = -FLT_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/pr61801.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61801.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61801.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/61801 */
+/* { dg-do compile } */
+/* { dg-options "-Os -fcompare-debug" } */
+
+int a, c;
+int bar (void);
+void baz (void);
+
+void
+foo (void)
+{
+  int d;
+  if (bar ())
+    {
+      int e;
+      baz ();
+      asm volatile ("" : "=a" (e) : "0" (a), "i" (0));
+      d = e;
+    }
+  c = d;
+}
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmsd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmsd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmsd-2.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include "avx512f-check.h"
 #include "avx512f-helper.h"
 #include <math.h>
-#include <values.h>
+#include <float.h>
 #include "avx512f-mask-type.h"
 
 void
@@ -57,10 +57,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXDOUBLE;
+      *r = DBL_MAX;
       break;
     case 15:
-      *r = -MAXDOUBLE;
+      *r = -DBL_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2ps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2ps-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2ps-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (float *dst, float *src1, int *ind, float *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermi2pd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2pd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermi2pd-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (double *dst, double *src1, long long *ind, double *src2)
Index: gcc/testsuite/gcc.target/i386/pr63285.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63285.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63285.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+struct S { int a; };
+struct T { int b, c; } a;
+long b;
+int c, d;
+void bar (int, int);
+void baz (void *, int);
+
+void
+foo (struct S *x, int y, int z, void *f, int *p, struct T *e)
+{
+  while (x)
+    {
+      baz (f, &d > p);
+      if (z & 1)
+        bar (f > (void *) &f, z);
+    }
+  if (c)
+    {
+      asm ("" : "+m" (a) : "i" (0));
+      y--;
+    }
+  if (e->b == e->c)
+    c = y;
+  y--;
+}
Index: gcc/testsuite/gcc.target/i386/pr61794.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr61794.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr61794.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512f" } */
+
+#include <x86intrin.h>
+
+__m512i zmm;
+__m128i xmm;
+
+void test (void)
+{
+  xmm = _mm512_extracti32x4_epi32 (zmm, 0);
+}
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmps-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmps-2.c	(.../branches/gcc-4_9-branch)
@@ -10,7 +10,7 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
+#include "float.h"
 
 static void
 CALC (float *r, float src, int tbl)
@@ -60,10 +60,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXFLOAT;
+      *r = FLT_MAX;
       break;
     case 15:
-      *r = -MAXFLOAT;
+      *r = -FLT_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2q-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2q-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2q-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (long long *dst, long long *src1, long long *ind, long long *src2)
Index: gcc/testsuite/gcc.target/i386/avx512f-vfixupimmpd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmpd-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vfixupimmpd-2.c	(.../branches/gcc-4_9-branch)
@@ -10,8 +10,9 @@
 #define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
+#include "float.h"
 
+
 static void
 CALC (double *r, double src, long long tbl)
 {
@@ -60,10 +61,10 @@
       *r = M_PI_2;
       break;
     case 14:
-      *r = MAXDOUBLE;
+      *r = DBL_MAX;
       break;
     case 15:
-      *r = -MAXDOUBLE;
+      *r = -DBL_MAX;
       break;
     default:
       abort ();
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermt2ps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2ps-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-vpermt2ps-2.c	(.../branches/gcc-4_9-branch)
@@ -9,7 +9,6 @@
 #define SIZE (AVX512F_LEN / 32)
 #include "avx512f-mask-type.h"
 #include "math.h"
-#include "values.h"
 
 static void
 CALC (float *dst, float *src1, int *ind, float *src2)
Index: gcc/testsuite/gcc.target/mips/pr62030-octeon.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/pr62030-octeon.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/mips/pr62030-octeon.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-march=octeon" } */
+
+extern void abort (void);
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+static int __attribute__((noinline))
+foo (void)
+{
+  node.prev = (void *)head;
+  head->first = &node;
+
+  struct node *n = head->first;
+  struct head *h = &heads[k];
+  struct node *next = n->next;
+
+  if (n->prev == (void *)h)
+    h->first = next;
+  else
+    n->prev->next = next;
+
+  n->next = h->first;
+  return n->next == &node;
+}
+
+int
+main (void)
+{
+  if (foo ())
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/sh/pr61996.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/pr61996.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.target/sh/pr61996.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* Check that the option -musermode has no effect on targets that do not
+   support user/privileged mode and that it does not interfere with option
+   -matomic-model=soft-imask.  */
+/* { dg-do compile }  */
+/* { dg-options "-matomic-model=soft-imask" }  */
+/* { dg-skip-if "" { "sh*-*-*" } { "*"} { "-m1*" "-m2*" } }  */
+
+int
+test (void)
+{
+  return 0;
+}
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_9-branch)
@@ -2564,6 +2564,9 @@
     if { [check_effective_target_arm32] } {
 	foreach flags {"" "-mfloat-abi=softfp" "-mfpu=neon-fp-armv8" "-mfpu=neon-fp-armv8 -mfloat-abi=softfp"} {
 	    if { [check_no_compiler_messages_nocache arm_v8_neon_ok object {
+		#if __ARM_ARCH < 8
+		#error not armv8 or later
+		#endif
 		#include "arm_neon.h"
 		void
 		foo ()
@@ -2570,7 +2573,7 @@
 		{
 	          __asm__ volatile ("vrintn.f32 q0, q0");
 		}
-	    } "$flags"] } {
+	    } "$flags -march=armv8-a"] } {
 		set et_arm_v8_neon_flags $flags
 		return 1
 	    }
@@ -2747,6 +2750,7 @@
 	#if !defined(__arm__) || !defined(__thumb__) || defined(__thumb2__)
 	#error FOO
 	#endif
+	int foo (int i) { return i; }
     } "-mthumb"]
 }
 
@@ -2758,6 +2762,7 @@
 	#if !defined(__thumb2__)
 	#error FOO
 	#endif
+	int foo (int i) { return i; }
     } "-mthumb"]
 }
 
Index: gcc/testsuite/gfortran.dg/dot_product_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dot_product_3.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/dot_product_3.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR 61999 - this used to ICE.
+! Original test case by A. Kasahara
+program main
+   use, intrinsic:: iso_fortran_env, only: output_unit
+
+   implicit none
+
+   write(output_unit, *) dot_product([1, 2], [2.0, 3.0])
+
+   stop
+end program main
+! { dg-final { scan-tree-dump-times "8\\.0e\\+0" 1 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
Index: gcc/testsuite/gfortran.dg/gomp/pr62131.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr62131.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr62131.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+! PR fortran/62131
+! { dg-do compile }
+! { dg-options "-fopenmp" }
+
+program pr62131
+  integer,allocatable :: nerrs(:,:)
+  allocate(nerrs(10,10))
+  nerrs(:,:) = 0
+!$omp parallel do
+  do k=1,10
+    call uperrs(k,1)
+  end do
+contains
+  subroutine uperrs(i,io)
+    integer,intent(in) :: i,io
+!$omp atomic
+    nerrs(i,io)=nerrs(i,io)+1
+  end subroutine
+end
Index: gcc/testsuite/gfortran.dg/gomp/pr59488-1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr59488-1.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr59488-1.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+! PR fortran/59488
+! { dg-do compile }
+! { dg-options "-fopenmp" }
+
+  implicit none
+  integer, parameter :: p(2) = (/ 11, 12 /)
+  integer :: r
+
+  !$omp parallel do default(none)
+  do r = 1, 2
+    print *, p(r)
+  end do
+end
Index: gcc/testsuite/gfortran.dg/gomp/pr59488-2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr59488-2.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr59488-2.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+! PR fortran/59488
+! { dg-do compile }
+! { dg-options "-fopenmp" }
+
+  implicit none
+  type t
+    integer :: s1, s2, s3
+  end type
+  integer :: r
+  type(t), parameter :: u = t(1, 2, 3)
+
+  !$omp parallel do default(none)
+  do r = 1, 2
+    print *, u
+  end do
+end
Index: gcc/testsuite/gfortran.dg/dependency_44.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dependency_44.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/dependency_44.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+! { dg-do run }
+! Tests fix for PR61780 in which the loop reversal mechanism was
+! not accounting for the first index being an element so that no
+! loop in this dimension is created.
+!
+! Contributed by Manfred Tietze on clf.
+!
+program prgm3
+    implicit none
+    integer, parameter :: n = 10, k = 3
+    integer :: i, j
+    integer, dimension(n,n) :: y
+    integer :: res1(n), res2(n)
+
+1   format(10i5)
+
+!initialize
+    do i=1,n
+        do j=1,n
+            y(i,j) = n*i + j
+        end do
+    end do
+    res2 = y(k,:)
+
+!shift right
+    y(k,4:n) = y(k,3:n-1)
+    y(k,3) = 0
+    res1 = y(k,:)
+    y(k,:) = res2
+    y(k,n:4:-1) = y(k,n-1:3:-1)
+    y(k,3) = 0
+    res2 = y(k,:)
+!    print *, res1
+!    print *, res2
+    if (any(res1 /= res2)) call abort ()
+end program prgm3
Index: gcc/testsuite/gfortran.dg/pointer_intent_7.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_intent_7.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_intent_7.f90	(.../branches/gcc-4_9-branch)
@@ -23,7 +23,7 @@
     call bar2 (c)
     call bar3 (c)
     call bar2p (b) ! { dg-error "INTENT\\(IN\\) in pointer association context \\(actual argument to INTENT = OUT/INOUT" }
-    call bar3p (b) ! { dg-error "INTENT\\(IN\\) in pointer association context \\(actual argument to INTENT = OUT/INOUT" }
+    call bar3p (b) ! { dg-error "Actual argument to .n. at \\(1\\) must be polymorphic" }
     call bar2p (c) ! { dg-error "INTENT\\(IN\\) in pointer association context \\(actual argument to INTENT = OUT/INOUT" }
     call bar3p (c) ! { dg-error "INTENT\\(IN\\) in pointer association context \\(actual argument to INTENT = OUT/INOUT" }
   end subroutine
Index: gcc/testsuite/gfortran.dg/array_constructor_49.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/array_constructor_49.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/array_constructor_49.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+! { dg-do run }
+! { dg-options "-ffrontend-optimize -fdump-tree-original" }
+! PR 62106 - this used to give wrong results because
+! of a bogus extra temporary variable.
+! Original test case by Martien Hulsen
+program t
+  integer :: ndim=2, ndfp=4, i
+  character (len=8) :: line
+  write (unit=line,fmt='(4I2)'), (/ ( i, i = 1, ndfp ) /) + ndim
+  if (line /= ' 3 4 5 6') call abort
+end program t
+! { dg-final { scan-tree-dump-times "__var" 3 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
Index: gcc/testsuite/gfortran.dg/array_assignment_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/array_assignment_5.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/array_assignment_5.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+! { dg-do run }
+! { dg-options "-ffrontend-optimize" }
+! PR 62214 - this used to give the wrong result.
+! Original test case by Oliver Fuhrer
+PROGRAM test
+  IMPLICIT NONE
+  CHARACTER(LEN=20)   :: fullNames(2)
+  CHARACTER(LEN=255)  :: pathName
+  CHARACTER(LEN=5)    :: fileNames(2)
+  
+  pathName = "/dir1/dir2/"
+  fileNames = (/ "file1", "file2" /)
+  fullNames = SPREAD(TRIM(pathName),1,2) // fileNames
+  if (fullNames(1) /= '/dir1/dir2/file1' .or. &
+       & fullnames(2) /= '/dir1/dir2/file2') call abort
+END PROGRAM test
Index: gcc/testsuite/gfortran.dg/pr45636.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr45636.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr45636.f90	(.../branches/gcc-4_9-branch)
@@ -10,5 +10,5 @@
   b = y
   call sub(a, b)
 end program main
-! { dg-final { scan-tree-dump-times "memset" 0 "forwprop2" { xfail { mips*-*-* && { ! nomips16 } } } } }
+! { dg-final { scan-tree-dump-times "memset" 0 "forwprop2" { xfail { { hppa*-*-* && { ! lp64 } } || { mips*-*-* && { ! nomips16 } } } } } }
 ! { dg-final { cleanup-tree-dump "forwprop2" } }
Index: gcc/testsuite/gfortran.dg/bessel_7.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/bessel_7.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/bessel_7.f90	(.../branches/gcc-4_9-branch)
@@ -16,7 +16,7 @@
 implicit none
 real,parameter :: values(*) = [0.0, 0.5, 1.0, 0.9, 1.8,2.0,3.0,4.0,4.25,8.0,34.53, 475.78] 
 real,parameter :: myeps(size(values)) = epsilon(0.0) &
-                  * [2, 3, 4, 5, 8, 2, 12, 6, 7, 6, 36, 168 ]
+                  * [2, 3, 4, 5, 8, 2, 13, 6, 7, 6, 36, 168 ]
 ! The following is sufficient for me - the values above are a bit
 ! more tolerant
 !                  * [0, 0, 0, 3, 3, 0, 9, 0, 2, 1, 22, 130 ]
Index: gcc/testsuite/gfortran.dg/realloc_on_assign_24.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/realloc_on_assign_24.f90	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gfortran.dg/realloc_on_assign_24.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR 62142 - this used to segfault
+! Original test case by Ondej ertk .
+program test_segfault
+  implicit none
+  real, allocatable :: X(:)
+  allocate (x(1))
+  x = 1.
+  X = floor(X)
+end program
Index: gcc/testsuite/gcc.c-torture/execute/pr63209.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr63209.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr63209.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+static int Sub(int a, int b) {
+  return  b -a;
+}
+
+static unsigned Select(unsigned a, unsigned b, unsigned c) {
+  const int pa_minus_pb =
+      Sub((a >>  8) & 0xff, (b >>  8) & 0xff) + 
+      Sub((a >>  0) & 0xff, (b >>  0) & 0xff); 
+  return (pa_minus_pb <= 0) ? a : b;
+}
+
+__attribute__((noinline)) unsigned Predictor(unsigned left, const unsigned* const top) {
+  const unsigned pred = Select(top[1], left, top[0]);
+  return pred;
+}
+
+int main(void) {
+  const unsigned top[2] = {0xff7a7a7a, 0xff7a7a7a};
+  const unsigned left = 0xff7b7b7b;
+  const unsigned pred = Predictor(left, top /*+ 1*/);
+  if (pred == left)
+    return 0;
+  return 1;
+}
+
+
+
Index: gcc/testsuite/gcc.c-torture/execute/pr23135.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr23135.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr23135.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,2 @@
+set additional_flags "-Wno-psabi"
+return 0
Index: gcc/testsuite/gcc.c-torture/execute/bitfld-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/bitfld-6.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/bitfld-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+union U
+{
+  const int a;
+  unsigned b : 20;
+};
+
+static union U u = { 0x12345678 };
+
+/* Constant folding used to fail to account for endianness when folding a
+   union.  */
+
+int
+main (void)
+{
+#ifdef __BYTE_ORDER__
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+  return u.b - 0x45678;
+#else
+  return u.b - 0x12345;
+#endif
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20050604-1.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20050604-1.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20050604-1.x	(.../branches/gcc-4_9-branch)
@@ -6,4 +6,5 @@
 	set additional_flags "-mno-mmx"
 }
 
+set additional_flags "-Wno-psabi"
 return 0
Index: gcc/testsuite/gcc.c-torture/execute/pr61375.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr61375.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr61375.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+#ifdef __UINT64_TYPE__
+typedef __UINT64_TYPE__ uint64_t;
+#else
+typedef unsigned long long uint64_t;
+#endif
+
+#ifndef __SIZEOF_INT128__
+#define __int128 long long
+#endif
+
+/* Some version of bswap optimization would ICE when analyzing a mask constant
+   too big for an HOST_WIDE_INT (PR61375).  */
+
+__attribute__ ((noinline, noclone)) uint64_t
+uint128_central_bitsi_ior (unsigned __int128 in1, uint64_t in2)
+{
+  __int128 mask = (__int128)0xffff << 56;
+  return ((in1 & mask) >> 56) | in2;
+}
+
+int
+main (int argc)
+{
+  __int128 in = 1;
+#ifdef __SIZEOF_INT128__
+  in <<= 64;
+#endif
+  if (sizeof (uint64_t) * __CHAR_BIT__ != 64)
+    return 0;
+  if (sizeof (unsigned __int128) * __CHAR_BIT__ != 128)
+    return 0;
+  if (uint128_central_bitsi_ior (in, 2) != 0x102)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20050316-1.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20050316-1.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20050316-1.x	(.../branches/gcc-4_9-branch)
@@ -4,4 +4,5 @@
 	return 1
 }
 
+set additional_flags "-Wno-psabi"
 return 0;
Index: gcc/testsuite/gcc.c-torture/execute/20050316-3.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20050316-3.x	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20050316-3.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,2 @@
+set additional_flags "-Wno-psabi"
+return 0
Index: gcc/testsuite/gcc.c-torture/compile/pr62312.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr62312.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr62312.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+/* PR target/62312  */
+
+typedef struct { unsigned int arg[100]; } *FunctionCallInfo;
+typedef struct { int day; int month; } Interval;
+void* palloc (unsigned int);
+int bar (void);
+void baz (void);
+
+void
+interval_pl (FunctionCallInfo fcinfo)
+{
+  Interval *span1 = ((Interval *) ((char *) ((fcinfo->arg[0]))));
+  Interval *span2 = ((Interval *) ((char *) ((fcinfo->arg[1]))));
+  Interval *result = (Interval *) palloc (sizeof (Interval));
+
+  if ((((span1->month) < 0) == ((span2->month) < 0))
+      && !(((result->month) < 0) == ((span1->month) < 0)))
+    do {
+      if (bar ())
+	baz ();
+    } while(0);
+  result->day = span1->day + span2->day;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr60655-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr60655-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr60655-1.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,4 @@
-/* { dg-options "-fdata-sections" } */
+/* { dg-options "-fdata-sections" { target { ! { { hppa*-*-hpux* } && { ! lp64 } } } } } */
 
 typedef unsigned char unit;
 typedef unit *unitptr;
Index: gcc/testsuite/gcc.c-torture/compile/pr63282.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr63282.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr63282.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* PR inline-asm/63282 */
+
+void bar (void);
+
+void
+foo (void)
+{
+  asm volatile goto ("" : : : : a, b);
+a:
+  bar ();
+b:
+  return;
+}
Index: gcc/testsuite/gnat.dg/pack20.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/pack20.adb	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gnat.dg/pack20.adb	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+package body Pack20 is
+
+   procedure Proc (A : Rec) is
+      Local : Rec := A;
+   begin
+      Modify (Local.Fixed);
+   end;
+
+end Pack20;
Index: gcc/testsuite/gnat.dg/pack20.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/pack20.ads	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gnat.dg/pack20.ads	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+-- { dg-do compile }
+
+with Pack20_Pkg; use Pack20_Pkg;
+
+package Pack20 is
+
+   type Rec is record
+      Simple_Type  : Integer;
+      Fixed        : String_Ptr;
+   end record;
+   pragma Pack (Rec);
+
+   procedure Proc (A : Rec);
+
+end Pack20;
Index: gcc/testsuite/gnat.dg/pack20_pkg.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/pack20_pkg.ads	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gnat.dg/pack20_pkg.ads	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+package Pack20_Pkg is
+
+   type String_Ptr is access all String;
+
+   procedure Modify (Fixed : in out String_Ptr);
+
+end Pack20_Pkg;
Index: gcc/testsuite/gcc.dg/darwin-minversion-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-minversion-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-minversion-2.c	(.../branches/gcc-4_9-branch)
@@ -2,7 +2,8 @@
 /* { dg-options "-mmacosx-version-min=10.1 -mmacosx-version-min=10.3" } */
 /* { dg-do run { target *-*-darwin* } } */
 
-int main(void)
+int
+main ()
 {
 #if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ != 1030
   fail me;
Index: gcc/testsuite/gcc.dg/pr61756.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr61756.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr61756.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* PR target/61756  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <stdatomic.h>
+
+static volatile atomic_flag guard = ATOMIC_FLAG_INIT;
+
+void
+try_atomic_flag_test_and_set (void)
+{
+  atomic_flag_test_and_set (&guard);
+}
Index: gcc/testsuite/gcc.dg/pr56724-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr56724-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr56724-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* PR c/56724 */
+/* { dg-do compile } */
+/* { dg-options "-Wtraditional-conversion" } */
+
+extern void foo (int p[2][]); /* { dg-error "array type has incomplete element type" } */
+extern void foo_i (int, int);
+extern void foo_u (unsigned int);
+extern void foo_f (int, float);
+extern void foo_ll (long long);
+extern void foo_cd (int, int, __complex__ double);
+extern signed char sc;
+extern int i;
+extern unsigned int u;
+extern float f;
+extern double d;
+extern __complex__ double cd;
+
+void
+fn ()
+{
+  int p[1][1];
+  foo (p); /* { dg-error "8:type of formal parameter" } */
+  foo_i (1, f); /* { dg-warning "13:passing argument" } */
+  foo_i (1, cd); /* { dg-warning "13:passing argument" } */
+  foo_cd (1, 2, f); /* { dg-warning "17:passing argument" } */
+  foo_f (9, i); /* { dg-warning "13:passing argument" } */
+  foo_cd (2, 2, i); /* { dg-warning "17:passing argument" } */
+  foo_f (2, cd); /* { dg-warning "13:passing argument" } */
+  foo_f (2, d); /* { dg-warning "13:passing argument" } */
+  foo_ll (sc); /* { dg-warning "11:passing argument" } */
+  foo_u (i); /* { dg-warning "10:passing argument" } */
+  foo_i (1, u); /* { dg-warning "13:passing argument" } */
+}
Index: gcc/testsuite/gcc.dg/darwin-minversion-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-minversion-3.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-minversion-3.c	(.../branches/gcc-4_9-branch)
@@ -2,7 +2,8 @@
 /* { dg-options "-mmacosx-version-min=10.4.10" } */
 /* { dg-do compile { target *-*-darwin* } } */
 
-int main(void)
+int
+main ()
 {
 #if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ != 1040
   fail me;
Index: gcc/testsuite/gcc.dg/pr63342.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63342.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63342.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+/* PR debug/63342 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+static __thread double u[9], v[9];
+
+void
+foo (double **p, double **q)
+{
+  *p = u;
+  *q = v;
+}
+
+double
+bar (double x)
+{
+  int i;
+  double s = 0.0;
+  for (i = 0; i < 9; i++)
+    {
+      double a = x + v[i];
+      s += u[i] * a * a;
+    }
+  return s;
+}
Index: gcc/testsuite/gcc.dg/pr63284.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63284.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63284.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,42 @@
+/* PR debug/63284 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+int a[10], *b, *d, c, f;
+int fn2 (void);
+void fn3 (void);
+void fn4 (int);
+
+static int
+fn1 (int x)
+{
+  int e = a[0];
+  if (e)
+    return 1;
+  if (b)
+    switch (x)
+      {
+      case 1:
+        if (d)
+          e = fn2 ();
+        else
+          fn3 ();
+        break;
+      case 0:
+        if (d)
+          {
+            fn3 ();
+            if (c)
+              fn4 (1);
+          }
+        else
+          fn4 (0);
+      }
+  return e;
+}
+
+void
+fn6 (void)
+{
+  f = fn1 (0);
+}
Index: gcc/testsuite/gcc.dg/pr63186.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63186.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63186.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-do link } */
+/* { dg-options "-O2" } */
+void *a;
+int b, c, d;
+
+void
+bar ()
+{
+  switch (c)
+    {
+    case 0:
+    lab:
+      __asm__ ("");
+      return;
+    default:
+      break;
+    }
+  b = 0;
+  d = 0;
+  a = &&lab;
+}
+
+void
+foo ()
+{
+  bar ();
+}
+main()
+{
+}
Index: gcc/testsuite/gcc.dg/pr56724-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr56724-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr56724-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+/* PR c/56724 */
+/* { dg-do compile } */
+/* { dg-options "-Wc++-compat -Wpedantic" } */
+
+enum E1 { A };
+enum E2 { B };
+extern void foo_E (enum E1);
+extern void foo_v (void *p);
+extern void foo_sc (int, int, signed char *);
+extern unsigned char *uc;
+extern signed char sc;
+extern const signed char *csc;
+extern float *f;
+
+void
+foo (void)
+{
+  void (*fp)(void);
+  const void (*ffp)(void);
+  foo_v (fp); /* { dg-warning "10:ISO C forbids passing argument" } */
+  foo_E (B); /* { dg-warning "10:enum conversion when passing argument" } */
+  foo_sc (1, 2, uc); /* { dg-warning "17:pointer targets in passing argument" } */
+  foo_sc (1, 2, f); /* { dg-warning "17:passing argument" } */
+  foo_sc (1, 2, sc); /* { dg-warning "17:passing argument" } */
+  foo_sc (uc, 2, &sc); /* { dg-warning "11:passing argument" } */
+  foo_sc (1, 2, csc); /* { dg-warning "17:passing argument" } */
+}
+
+typedef void (*fp)(void);
+typedef void (*nrfp)(void) __attribute__((noreturn));
+void f1 (nrfp); void f2 (fp x) { f1 (x); } extern int e; /* { dg-warning "38:passing argument" } */
Index: gcc/testsuite/gcc.dg/darwin-minversion-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-minversion-4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-minversion-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* Test that major versions greater than 9 work and have the additional 0.  */
+/* { dg-options "-mmacosx-version-min=10.10.0" } */
+/* { dg-do compile { target *-*-darwin* } } */
+
+int
+main ()
+{
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ != 101000
+  fail me;
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr59418.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr59418.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr59418.c	(.../branches/gcc-4_9-branch)
@@ -3,7 +3,7 @@
 
 /* { dg-do compile } */
 /* { dg-options "-Os -g" } */
-/* { dg-options "-march=armv7-a -mfloat-abi=hard -Os -g" { target arm*-*-* } } */
+/* { dg-options "-march=armv7-a -mfloat-abi=hard -Os -g" { target { arm*-*-* && { ! arm_thumb1 } } } } */
 
 extern int printf (const char *__format, ...);
 
Index: gcc/testsuite/gcc.dg/pr62004.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62004.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62004.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-tail-merge" } */
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+int
+main ()
+{
+  struct node *p;
+
+  node.next = (void*)0;
+
+  node.prev = (void *)head;
+
+  head->first = &node;
+
+  struct node *n = head->first;
+
+  struct head *h = &heads[k];
+
+  heads[2].first = n->next;
+
+  if ((void*)n->prev == (void *)h)
+    p = h->first;
+  else
+    /* Dead tbaa-unsafe load from ((struct node *)&heads[2])->next.  */
+    p = n->prev->next;
+
+  return !(p == (void*)0);
+}
Index: gcc/testsuite/gcc.dg/pr51879-18.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr51879-18.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr51879-18.c	(.../branches/gcc-4_9-branch)
@@ -13,5 +13,5 @@
     *q = foo ();
 }
 
-/* { dg-final { scan-tree-dump-times "foo \\(" 1 "pre"} } */
+/* { dg-final { scan-tree-dump-times "foo \\(" 1 "pre" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/lto/pr60449_0.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr60449_0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr60449_0.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-lto-do link } */
+
+extern int printf (const char *__restrict __format, ...);
+typedef long int __time_t;
+typedef long int __suseconds_t;
+
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+typedef struct timezone *__restrict __timezone_ptr_t;
+
+extern int gettimeofday (struct timeval *__restrict __tv, __timezone_ptr_t __tz);
+
+int bar (void)
+{
+  struct timeval tv;
+  struct timezone tz;
+
+  gettimeofday (&tv, &tz);
+  printf ("This is from bar %i\n", tz.tz_dsttime);
+  return 5;
+}
Index: gcc/testsuite/gcc.dg/lto/pr60449_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr60449_1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr60449_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,76 @@
+extern int printf (const char *__restrict __format, ...);
+typedef long int __time_t;
+typedef long int __suseconds_t;
+struct timeval
+  {
+    __time_t tv_sec;
+    __suseconds_t tv_usec;
+  };
+struct timezone
+  {
+    int tz_minuteswest;
+    int tz_dsttime;
+  };
+typedef struct timezone *__restrict __timezone_ptr_t;
+extern int gettimeofday (struct timeval *__restrict __tv,
+    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
+
+typedef long int __jmp_buf[8];
+typedef struct
+  {
+    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
+  } __sigset_t;
+struct __jmp_buf_tag
+  {
+    __jmp_buf __jmpbuf;
+    int __mask_was_saved;
+    __sigset_t __saved_mask;
+  };
+typedef struct __jmp_buf_tag jmp_buf[1];
+
+extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));
+extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
+     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
+
+extern int bar (void);
+
+int __attribute__ ((noinline, noclone))
+get_input (void)
+{
+  return 0;
+}
+
+static jmp_buf buf;
+
+int foo (void)
+{
+  if (get_input ())
+    longjmp(buf, 1);
+  return 0;
+}
+
+volatile int z;
+
+
+int main (void)
+{
+  struct timeval tv;
+  struct timezone tz;
+
+  bar();
+  if (setjmp (buf))
+    return 1;
+
+  if (!get_input ())
+    {
+      gettimeofday (&tv, &tz);
+      z = 0;
+      printf ("This is from main %i\n", tz.tz_dsttime);
+    }
+
+  foo ();
+  bar ();
+  bar ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr57233.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr57233.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr57233.c	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,7 @@
 /* PR tree-optimization/57233 */
 /* { dg-do run { target { ilp32 || lp64 } } } */
 /* { dg-options "-O2" } */
+/* { dg-additional-options "-fno-common" { target hppa*-*-hpux* } } */
 
 typedef unsigned V4 __attribute__((vector_size(4 * sizeof (int))));
 typedef unsigned V8 __attribute__((vector_size(8 * sizeof (int))));
Index: gcc/testsuite/gcc.dg/pr62294.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62294.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62294.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR c/62294 */
+/* { dg-do compile } */
+
+#include "pr62294.h"
+
+void
+fn (int *u)
+{
+  foo (u); /* { dg-error "passing argument 1 of .bar. from incompatible pointer type" } */
+}
Index: gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-4.c	(.../branches/gcc-4_9-branch)
@@ -2,7 +2,7 @@
    operating properly when operations on the same variable are carried
    out in two threads.  */
 /* { dg-do run } */
-/* { dg-options "-std=c11 -pedantic-errors -pthread -D_POSIX_C_SOURCE=200809L" } */
+/* { dg-options "-std=c11 -pedantic-errors -pthread -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L" } */
 /* { dg-additional-options "-D_XOPEN_SOURCE=600" { target *-*-solaris2.1[0-9]* } }
 /* { dg-require-effective-target pthread } */
 
Index: gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c	(.../branches/gcc-4_9-branch)
@@ -3,7 +3,7 @@
    iterations of the compare-and-exchange loop are needed, exceptions
    get properly cleared).  */
 /* { dg-do run } */
-/* { dg-options "-std=c11 -pedantic-errors -pthread -D_POSIX_C_SOURCE=200809L" } */
+/* { dg-options "-std=c11 -pedantic-errors -pthread -U_POSIX_C_SOURCE -D_POSIX_C_SOURCE=200809L" } */
 /* { dg-additional-options "-D_XOPEN_SOURCE=600" { target *-*-solaris2.1[0-9]* } }
 /* { dg-require-effective-target fenv_exceptions } */
 /* { dg-require-effective-target pthread } */
Index: gcc/testsuite/gcc.dg/atomic/stdatomic-flag.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/atomic/stdatomic-flag.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/atomic/stdatomic-flag.c	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,5 @@
 /* Test atomic_flag routines for existence and execution.  */
+/* The test needs a lockless atomic implementation.  */
 /* { dg-do run { xfail hppa*-*-hpux* } } */
 /* { dg-options "-std=c11 -pedantic-errors" } */
 
Index: gcc/testsuite/gcc.dg/pr62294.h
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62294.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62294.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+#pragma GCC system_header
+#define foo bar
+extern void foo (float *);
Index: gcc/testsuite/gcc.dg/torture/pr61964.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr61964.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr61964.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+struct node { struct node *next, *prev; } node;
+struct head { struct node *first; } heads[5];
+int k = 2;
+struct head *head = &heads[2];
+
+static int __attribute__((noinline))
+foo()
+{
+  node.prev = (void *)head;
+  head->first = &node;
+
+  struct node *n = head->first;
+  struct head *h = &heads[k];
+
+  if (n->prev == (void *)h)
+    h->first = n->next;
+  else
+    n->prev->next = n->next;
+
+  n->next = h->first;
+  return n->next == &node;
+}
+
+int main()
+{
+  if (foo ())
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/float128-exact-underflow.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/float128-exact-underflow.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/float128-exact-underflow.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,41 @@
+/* Test that exact underflow in __float128 signals the underflow
+   exception if trapping is enabled, but does not raise the flag
+   otherwise.  */
+
+/* { dg-do run { target i?86-*-*gnu* x86_64-*-*gnu* } } */
+/* { dg-options "-D_GNU_SOURCE" } */
+/* { dg-require-effective-target fenv_exceptions } */
+
+#include <fenv.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdlib.h>
+
+volatile sig_atomic_t caught_sigfpe;
+sigjmp_buf buf;
+
+static void
+handle_sigfpe (int sig)
+{
+  caught_sigfpe = 1;
+  siglongjmp (buf, 1);
+}
+
+int
+main (void)
+{
+  volatile __float128 a = 0x1p-16382q, b = 0x1p-2q;
+  volatile __float128 r;
+  r = a * b;
+  if (fetestexcept (FE_UNDERFLOW))
+    abort ();
+  if (r != 0x1p-16384q)
+    abort ();
+  feenableexcept (FE_UNDERFLOW);
+  signal (SIGFPE, handle_sigfpe);
+  if (sigsetjmp (buf, 1) == 0)
+    r = a * b;
+  if (!caught_sigfpe)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.dg/torture/pr63380-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr63380-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr63380-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* { dg-do run } */
+
+int a = 0, b = 1, c = 0, d = 1, e, f, g, h;
+int
+main ()
+{
+  e = 1 >> d;
+  f = ((31 / (1 > e)) || c) / 2;
+  g = b || a;
+  h = 31 / g;
+  if (!h)
+    __builtin_abort();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr63380-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr63380-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr63380-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+
+int a = 0, b = 0, c = 0, d, e;
+int
+main (void)
+{
+  d = ((20 % (1 != b)) && c) + 2147483647;
+  e = 20 % (a >= 0);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/vshuf-4.inc
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/vshuf-4.inc	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/vshuf-4.inc	(.../branches/gcc-4_9-branch)
@@ -23,7 +23,8 @@
 T (20,	0, 4, 1, 5) \
 T (21,	2, 6, 3, 7) \
 T (22,	1, 2, 3, 0) \
-T (23,	2, 1, 0, 3)
+T (23,	2, 1, 0, 3) \
+T (24,	2, 5, 6, 3)
 #define EXPTESTS \
 T (116,	1, 2, 4, 3) \
 T (117,	7, 3, 3, 0) \
@@ -31,7 +32,6 @@
 T (119,	0, 3, 5, 6) \
 T (120,	0, 0, 1, 5) \
 T (121,	4, 6, 2, 1) \
-T (122,	2, 5, 6, 3) \
 T (123,	4, 6, 3, 2) \
 T (124,	4, 7, 5, 6) \
 T (125,	0, 4, 2, 4) \
Index: gcc/testsuite/gcc.dg/pr61053.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr61053.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr61053.c	(.../branches/gcc-4_9-branch)
@@ -31,10 +31,10 @@
 
 _Alignas (char) long int lic; /* { dg-error "cannot reduce alignment" } */
 _Alignas (short int) long int lis; /* { dg-error "cannot reduce alignment" } */
-_Alignas (int) long int lii; /* { dg-error "cannot reduce alignment" "" { target { ! { ia32 } } } } */
+_Alignas (int) long int lii; /* { dg-error "cannot reduce alignment" "" { target { ! { ilp32 } } } } */
 _Alignas (long int) long int lil;
 _Alignas (long long int) long int lill;
-_Alignas (float) long int lif; /* { dg-error "cannot reduce alignment" "" { target { ! { ia32 } } } } */
+_Alignas (float) long int lif; /* { dg-error "cannot reduce alignment" "" { target { ! { ilp32 } } } } */
 _Alignas (double) long int lid;
 _Alignas (long double) long int lild;
 
@@ -41,7 +41,7 @@
 _Alignas (char) long long int llic; /* { dg-error "cannot reduce alignment" } */
 _Alignas (short int) long long int llis; /* { dg-error "cannot reduce alignment" } */
 _Alignas (int) long long int llii; /* { dg-error "cannot reduce alignment" "" { target { ! { ia32 } } } } */
-_Alignas (long int) long long int llil;
+_Alignas (long int) long long int llil; /* { dg-error "cannot reduce alignment" "" { target { x32 } } } */
 _Alignas (long long int) long long int llill;
 _Alignas (float) long long int llif; /* { dg-error "cannot reduce alignment" "" { target { ! { ia32 } } } } */
 _Alignas (double) long long int llid;
@@ -59,7 +59,7 @@
 _Alignas (char) double dc; /* { dg-error "cannot reduce alignment" } */
 _Alignas (short int) double ds; /* { dg-error "cannot reduce alignment" } */
 _Alignas (int) double di; /* { dg-error "cannot reduce alignment" "" { target { ! { ia32 } } } } */
-_Alignas (long int) double dl;
+_Alignas (long int) double dl; /* { dg-error "cannot reduce alignment" "" { target { x32 } } } */
 _Alignas (long long int) double dll;
 _Alignas (float) double df; /* { dg-error "cannot reduce alignment" "" { target { ! { ia32 } } } } */
 _Alignas (double) double dd;
Index: gcc/testsuite/gcc.dg/tree-ssa/pr61144.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr61144.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr61144.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-require-weak "" } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+static int dummy = 0;
+extern int foo __attribute__((__weak__, __alias__("dummy")));
+int bar() { if (foo) return 1; return 0; }
+/* { dg-final { scan-tree-dump-not "return 0" "optimized"} } */
Index: gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-Og -fdump-tree-optimized" } */
+
+extern long long __sdt_unsp;
+void
+f(void)
+{
+  for (;;)
+    __asm__ ("%0" :: "i" (((!__extension__ (__builtin_constant_p ((((unsigned long long) (__typeof (__builtin_choose_expr (((__builtin_classify_type (0) + 3) & -4) == 4, (0), 0U))) __sdt_unsp) ) == 0) )) ? 1 : -1) ));
+}
+
+/* { dg-final { scan-tree-dump-not "PHI" "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/loop-19.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/loop-19.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/loop-19.c	(.../branches/gcc-4_9-branch)
@@ -4,7 +4,7 @@
  
    The testcase comes from PR 29256 (and originally, the stream benchmark).  */
 
-/* { dg-do compile { target { i?86-*-* || { x86_64-*-* || powerpc_hard_double } } } } */
+/* { dg-do compile { target { i?86-*-* || { x86_64-*-* || { powerpc_hard_double && { ! powerpc_fprs } } } } } } */
 /* { dg-require-effective-target nonpic } */
 /* { dg-options "-O3 -fno-tree-loop-distribute-patterns -fno-prefetch-loop-arrays -fdump-tree-optimized -fno-common" } */
 
Index: gcc/testsuite/gcc.dg/darwin-minversion-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/darwin-minversion-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/darwin-minversion-1.c	(.../branches/gcc-4_9-branch)
@@ -2,7 +2,8 @@
 /* { dg-options "-mmacosx-version-min=10.1" } */
 /* { dg-do run { target *-*-darwin* } } */
 
-int main(void)
+int
+main ()
 {
 #if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ != 1010
   fail me;
Index: gcc/testsuite/gcc.dg/pr61776.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr61776.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr61776.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fprofile-generate" } */
+
+#include <setjmp.h>
+
+int cond1, cond2;
+
+int goo() __attribute__((noinline));
+
+int goo() {
+ if (cond1)
+   return 1;
+ else
+   return 2;
+}
+
+jmp_buf env;
+int foo() {
+ int a;
+
+ setjmp(env);
+ if (cond2)
+   a = goo();
+ else
+   a = 3;
+ return a;
+}
Index: gcc/testsuite/gcc.dg/stack-usage-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/stack-usage-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/stack-usage-2.c	(.../branches/gcc-4_9-branch)
@@ -1,21 +1,21 @@
 /* { dg-do compile } */
 /* { dg-options "-Wstack-usage=512" } */
 
-int foo1 (void)
+int foo1 (void)  /* { dg-bogus "stack usage" } */
 {
   char arr[16];
   arr[0] = 1;
   return 0;
-} /* { dg-bogus "stack usage" } */
+}
 
-int foo2 (void)
+int foo2 (void)  /* { dg-warning "stack usage is \[0-9\]* bytes" } */
 {
   char arr[1024];
   arr[0] = 1;
   return 0;
-} /* { dg-warning "stack usage is \[0-9\]* bytes" } */
+}
 
-int foo3 (void)
+int foo3 (void) /* { dg-warning "stack usage might be \[0-9\]* bytes" } */
 {
   char arr[1024] __attribute__((aligned (512)));
   arr[0] = 1;
@@ -22,12 +22,11 @@
   /* Force dynamic realignment of argument pointer.  */
   __builtin_apply ((void (*)()) foo2, 0, 0);
   return 0;
+}
 
-} /* { dg-warning "stack usage might be \[0-9\]* bytes" } */
-
-int foo4 (int n)
+int foo4 (int n) /* { dg-warning "stack usage might be unbounded" } */
 {
   char arr[n];
   arr[0] = 1;
   return 0;
-} /* { dg-warning "stack usage might be unbounded" } */
+}
Index: gcc/testsuite/gcc.dg/ipa/pr61986.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr61986.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr61986.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,48 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+int a, b, c;
+
+struct S
+{
+  int f0;
+  int f1;
+} d;
+
+static int fn2 (struct S);
+void fn3 (struct S);
+
+void
+fn1 (struct S p)
+{
+  struct S h = { 0, 0 };
+  fn3 (p);
+  fn2 (h);
+}
+
+int
+fn2 (struct S p)
+{
+  struct S j = { 0, 0 };
+  fn3 (p);
+  fn2 (j);
+  return 0;
+}
+
+void
+fn3 (struct S p)
+{
+  for (; b; a++)
+    c = p.f0;
+  fn1 (d);
+}
+
+void
+fn4 ()
+{
+  for (;;)
+    {
+      struct S f = { 0, 0 };
+      fn1 (f);
+    }
+}
Index: gcc/testsuite/gcc.dg/pr62030.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62030.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62030.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+static int __attribute__((noinline))
+foo (void)
+{
+  node.prev = (void *)head;
+  head->first = &node;
+
+  struct node *n = head->first;
+  struct head *h = &heads[k];
+  struct node *next = n->next;
+
+  if (n->prev == (void *)h)
+    h->first = next;
+  else
+    n->prev->next = next;
+
+  n->next = h->first;
+  return n->next == &node;
+}
+
+int
+main (void)
+{
+  if (foo ())
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr63341-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr63341-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63341-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+/* PR tree-optimization/63341 */
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+typedef union U { unsigned short s; unsigned char c; } __attribute__((packed)) U;
+struct S { char e __attribute__((aligned (64))); U s[32]; };
+struct S t = {0, {{0x5010}, {0x5111}, {0x5212}, {0x5313}, {0x5414}, {0x5515}, {0x5616}, {0x5717},
+		  {0x5818}, {0x5919}, {0x5a1a}, {0x5b1b}, {0x5c1c}, {0x5d1d}, {0x5e1e}, {0x5f1f},
+		  {0x6020}, {0x6121}, {0x6222}, {0x6323}, {0x6424}, {0x6525}, {0x6626}, {0x6727},
+		  {0x6828}, {0x6929}, {0x6a2a}, {0x6b2b}, {0x6c2c}, {0x6d2d}, {0x6e2e}, {0x6f2f}}};
+unsigned short d[32] = { 1 };
+
+__attribute__((noinline, noclone)) void
+foo ()
+{
+  int i;
+  for (i = 0; i < 32; i++)
+    d[i] = t.s[i].s + 4;
+  for (i = 0; i < 32; i++)
+    if (d[i] != t.s[i].s + 4)
+      abort ();
+    else
+      asm volatile ("" : : : "memory");
+}
+
+int
+main ()
+{
+  check_vect ();
+  foo ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr63189.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr63189.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63189.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+/* PR tree-optimization/63189 */
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+short int d[16] = { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+__attribute__((noinline, noclone)) void
+foo (void)
+{
+  int j, s = 0;
+  for (j = 0; j < 8; j++)
+    s += d[j] * j;
+  if (s != 7)
+    abort ();
+}
+
+int
+main ()
+{
+  check_vect ();
+  foo ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr59594.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr59594.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59594.c	(.../branches/gcc-4_9-branch)
@@ -3,7 +3,7 @@
 #include "tree-vect.h"
 
 #define N 1024
-int b[N + 1];
+int b[N + 2];
 
 int
 main ()
Index: gcc/testsuite/gcc.dg/vect/pr63379.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr63379.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63379.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+/* PR tree-optimization/63379  */
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+extern void abort (void);
+
+typedef struct {
+    int x;
+    int y;
+} Point;
+
+Point pt_array[25];
+
+void __attribute__((noinline,noclone))
+generate_array(void)
+{
+  unsigned int i;
+  for (i = 0; i<25; i++)
+    {
+      pt_array[i].x = i;
+      pt_array[i].y = 1000+i;
+    }
+}
+
+int main()
+{
+  check_vect ();
+  generate_array ();
+  Point min_pt = pt_array[0];
+  Point *ptr, *ptr_end;
+  for (ptr = pt_array+1, ptr_end = pt_array+25; ptr != ptr_end; ++ptr)
+    {
+      min_pt.x = (min_pt.x < ptr->x) ? min_pt.x : ptr->x;
+      min_pt.y = (min_pt.y < ptr->y) ? min_pt.y : ptr->y;
+    }
+
+  if (min_pt.x != 0 || min_pt.y != 1000)
+    abort ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr62073.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr62073.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62073.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+struct S0
+{
+  int f7;
+};
+struct S0 g_50;
+int g_70;
+int g_76;
+
+int foo (long long p_56, int * p_57)
+{
+  int *l_77;
+  int l_101;
+
+  for (; g_70;)
+    {
+      int **l_78 = &l_77;
+      if (g_50.f7)
+	continue;
+      *l_78 = 0;
+    }
+  for (g_76 = 1; g_76 >= 0; g_76--)
+    {
+      int *l_90;
+      for (l_101 = 4; l_101 >= 0; l_101--)
+	if (l_101)
+	  *l_90 = 0;
+	else
+	  {
+	    int **l_113 = &l_77;
+	    *l_113 = p_57;
+	  }
+    }
+
+  return *l_77;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr60196-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr60196-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60196-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* PR tree-optimization/63189 */
+/* { dg-additional-options "-fwrapv" } */
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+__attribute__((noinline, noclone)) static int
+bar (const short *a, int len)
+{
+  int x;
+  int x1 = 0;
+
+  for (x = 0; x < len; x++)
+    x1 += x * a[x];
+  return x1;
+}
+
+__attribute__((noinline, noclone)) void
+foo (void)
+{
+  short stuff[9] = {1, 1, 1, 1, 1, 1, 1, 1, 1 };
+  if (bar (stuff, 9) != 36)
+    abort ();
+}
+
+int
+main ()
+{
+  check_vect ();
+  foo ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr62075.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr62075.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62075.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+
+int a[16][2];
+struct A
+{
+  int b[16][2];
+  int c[16][1];
+};
+
+void
+foo (struct A *x)
+{
+  int i;
+  for (i = 0; i < 16; ++i)
+    {
+      x->b[i][0] = a[i][0];
+      x->c[i][0] = 0 != a[i][0];
+      x->b[i][1] = a[i][1];
+    }
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr60196-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr60196-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr60196-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* PR tree-optimization/63189 */
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+static const short a[8] = {1, 1, 1, 1, 1, 1, 1, 1 };
+static const unsigned char b[8] = {0, 0, 0, 0, 0, 0, 0, 0 };
+
+__attribute__((noinline, noclone)) static int
+bar (void)
+{
+  int sum = 0, i;
+  for (i = 0; i < 8; ++i)
+    sum += a[i] * b[i];
+  return sum;
+}
+
+__attribute__((noinline, noclone)) void
+foo (void)
+{
+  if (bar () != 0)
+    abort ();
+}
+
+int
+main ()
+{
+  check_vect ();
+  foo ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr63341-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr63341-1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63341-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,32 @@
+/* PR tree-optimization/63341 */
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+typedef union U { unsigned short s; unsigned char c; } __attribute__((packed)) U;
+struct S { char e __attribute__((aligned (64))); U s[32]; };
+struct S t = {0, {{1}, {2}, {3}, {4}, {5}, {6}, {7}, {8},
+		  {9}, {10}, {11}, {12}, {13}, {14}, {15}, {16},
+		  {17}, {18}, {19}, {20}, {21}, {22}, {23}, {24},
+		  {25}, {26}, {27}, {28}, {29}, {30}, {31}, {32}}};
+unsigned short d[32] = { 1 };
+
+__attribute__((noinline, noclone)) void
+foo ()
+{
+  int i;
+  for (i = 0; i < 32; i++)
+    d[i] = t.s[i].s;
+  if (__builtin_memcmp (d, t.s, sizeof d))
+    abort ();
+}
+
+int
+main ()
+{
+  check_vect ();
+  foo ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,603 @@
+2014-10-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/63495
+	* gcc.target/i386/pr63495.c: New test.
+
+2014-10-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63379
+	* gcc.dg/vect/pr63379.c: New testcase.
+
+2014-10-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/59488
+	* gfortran.dg/gomp/pr59488-1.f90: New test.
+	* gfortran.dg/gomp/pr59488-2.f90: New test.
+
+2014-10-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63380
+	* gcc.dg/torture/pr63380-1.c: New testcase.
+	* gcc.dg/torture/pr63380-2.c: Likewise.
+
+2014-10-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	* g++.dg/cpp1y/feat-cxx14.C: Variable templates not in yet.
+	(dg-do): Use c++1y target.
+
+2014-10-08  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	Implement SD-6: SG10 Feature Test Recommendations
+	* g++.dg/cpp1y/feat-cxx11-neg.C: New.
+	* g++.dg/cpp1y/feat-cxx11.C: New.
+	* g++.dg/cpp1y/feat-cxx14.C: New.
+	* g++.dg/cpp1y/feat-cxx98.C: New.
+	* g++.dg/cpp1y/feat-cxx98-neg.C: New.
+	* g++.dg/cpp1y/phoobhar.h: New.
+	* g++.dg/cpp1y/testinc/phoobhar.h: New.
+
+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/61144
+	* gcc.dg/tree-ssa/pr61144.c: New testcase.
+
+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/62121
+	* g++.dg/torture/pr62121.C: New testcase.
+
+2014-10-03  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/62026
+	* g++.dg/lto/pr62026.C: New testcase.
+
+2014-10-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/61200
+	* c-c++-common/gomp/pr61200.c: New test.
+
+2014-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/63342
+	* gcc.dg/pr63342.c: New test.
+
+	PR target/63428
+	* gcc.dg/torture/vshuf-4.inc: Move test 122 from EXPTESTS
+	to test 24 in TESTS.
+
+	PR c++/63306
+	* g++.dg/ipa/pr63306.C: New test.
+
+	2014-09-18  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR debug/63285
+	* gcc.target/i386/pr63285.c: New test.
+
+	2014-09-10  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR tree-optimization/63186
+	* gcc.dg/pr63186.c: New testcase.
+
+2014-09-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/63282
+	* gcc.c-torture/compile/pr63282.c: New test.
+
+2014-09-29  James Clarke  <jrtc27@jrtc27.com>
+
+	PR target/61407
+	* gcc.dg/darwin-minversion-1.c: Fixed formatting.
+	* gcc.dg/darwin-minversion-2.c: Fixed formatting.
+	* gcc.dg/darwin-minversion-3.c: Fixed formatting.
+	* gcc.dg/darwin-minversion-4.c: Added test for OS X 10.10.
+
+2014-09-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/compat/struct-layout-1_generate.c: Add -Wno-abi
+	to default options.
+
+2014-09-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline r215559
+	2014-09-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/63335
+	* gcc.target/powerpc/pr63335.c: New test.
+
+2014-09-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63341
+	* gcc.dg/vect/pr63341-1.c: New test.
+	* gcc.dg/vect/pr63341-2.c: New test.
+
+	PR c++/63249
+	* g++.dg/gomp/pr63249.C: New test.
+	* c-c++-common/gomp/pr63249.c: New test.
+
+2014-09-22  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/62219
+	* g++.dg/cpp0x/lambda/lambda-template14.C: New.
+
+2014-09-22  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-05-21  Marek Polacek  <polacek@redhat.com>
+
+	PR sanitizer/61272
+	* g++.dg/ubsan/pr61272.C: New test.
+
+2014-09-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/63328
+	* c-c++-common/gomp/pr63328.c: New test.
+
+2014-09-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-09-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.dg/pr61053.c: Updated for x32.
+
+2014-09-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/62017
+	* g++.dg/asan/pr62017.C: New test.
+
+	PR testsuite/63292
+	* gcc.dg/vect/pr59594.c (b): Increase size to N + 2 elements.
+
+2014-09-18  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.dg/torture/float128-exact-underflow.c: New test.
+
+2014-09-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/63284
+	* gcc.dg/pr63284.c: New test.
+
+2014-09-17  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/63241
+	* g++.dg/cpp0x/constexpr-63241.C: New.
+
+2014-09-12  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61654
+        * g++.dg/ipa/pr61654.C: New test.
+
+2014-09-11  Alan Lawrence  <alan.lawrence@arm.com>
+
+	Backport r214953 from mainline
+	2014-09-05  Alan Lawrence  <alan.lawrence@arm.com>
+
+	* gcc.target/aarch64/scalar_intrinsics.c (*): Replace all
+	int{32,16,8}x1_t with int{32,16,8}_t.
+	* gcc.target/aarch64/simd/vqdmlalh_lane_s16.c: Likewise.
+	* gcc.target/aarch64/simd/vqdmlslh_lane_s16.c: Likewise.
+	* gcc.target/aarch64/simd/vqdmullh_lane_s16.c: Likewise.
+	* gcc.target/aarch64/simd/vqdmulls_lane_s32.c: Likewise.
+
+2014-09-10  Xinliang David Li  <davidxl@google.com>
+
+	Backport from mainline
+	PR target/63209
+	* gcc.c-torture/execute/pr63209.c: New test.
+
+2014-09-09  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2014-09-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-extract-1.c:  Test 0th doubleword
+	regardless of endianness.
+
+2014-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-08-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62075
+	* gcc.dg/vect/pr62075.c: New testcase.
+
+	2014-08-14  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/62079
+	* g++.dg/pr62079.C: New testcase.
+
+	2014-08-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62175
+	* g++.dg/torture/pr62175.C: New testcase.
+
+2014-09-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/60196
+	PR tree-optimization/63189
+	* gcc.dg/vect/pr63189.c: New test.
+	* gcc.dg/vect/pr60196-1.c: New test.
+	* gcc.dg/vect/pr60196-2.c: New test.
+
+2014-09-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR testsuite/56194
+	* g++.dg/init/const9.C: Skip scan-assembler-not "rodata" on hppa*-*-*.
+
+2014-09-05  Easwaran Raman  <eraman@google.com>
+
+	Backport from mainline
+	PR rtl-optimization/62146
+	* testsuite/g++.dg/opt/pr62146.C: New.
+
+2014-09-04  Guozhi Wei  <carrot@google.com>
+
+	PR target/62040
+	* gcc.target/aarch64/pr62040.c: New test.
+
+2014-09-03  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/62015
+	* g++.dg/ipa/pr62015.C: New test.
+
+2014-09-03  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61986
+	* gcc.dg/ipa/pr61986.c: New test.
+
+2014-09-03  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-09-02  Marek Polacek  <polacek@redhat.com>
+
+	PR fortran/62270
+	* gfortran.dg/pointer_intent_7.f90: Adjust dg-error.
+
+2014-09-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c/62294
+	* gcc.dg/pr56724-1.c: New test.
+	* gcc.dg/pr56724-2.c: New test.
+	* gcc.dg/pr62294.c: New test.
+	* gcc.dg/pr62294.h: New file.
+
+2014-09-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-09-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/62312
+	* gcc.c-torture/compile/pr62312.c: New.
+
+2014-09-01  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	Backport from mainline
+	2014-09-01  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	* gcc.dg/tree-ssa/loop-19.c: Exclude classic FPU Power targets.
+
+2014-08-27  Guozhi Wei  <carrot@google.com>
+
+	PR target/62262
+	* gcc.target/aarch64/pr62262.c: New test.
+
+2014-08-26  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	* gfortran.dg/bessel_7.f90: Bump allowed precision to avoid
+	failure on s390*-*-linux-gnu.
+
+2014-08-24  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-08-24  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/61996
+	* gcc.target/sh/pr61996.c: New.
+
+2014-08-22  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/62008
+	* c-c++-common/cilk-plus/AN/pr62008.c: New test.
+
+2014-08-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62214
+	* gfortran.dg/array_assignment_5.f90:  New test.
+
+2014-08-20  Martin Jambor  <mjambor@suse.cz>
+	    Wei Mi  <wmi@google.com>
+
+	PR ipa/60449
+	PR middle-end/61776
+	* testsuite/gcc.dg/lto/pr60449_1.c: New test.
+	* testsuite/gcc.dg/lto/pr60449_0.c: New test.
+	* testsuite/gcc.dg/pr61776.c: New test.
+
+2014-08-19  Janis Johnson  <janisjo@codesourcery.com>
+
+	Backport from mainline:
+	2014-08-19  Janis Johnson  <janisjo@codesourcery.com>
+
+	* lib/target-supports.exp
+	(check_effective_target_arm_v8_neon_ok_nocache): Add
+	"-march-armv8-a" to compile flags.
+
+2014-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62142
+	* gfortran.dg/realloc_on_assign_24.f90:  New test.
+
+2014-08-15  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline:
+	2014-08-14  Tom de Vries  <tom@codesourcery.com>
+
+	PR rtl-optimization/62004
+	PR rtl-optimization/62030
+	* gcc.dg/pr62004.c: New test.
+	* gcc.dg/pr62030.c: Same.
+	* gcc.target/mips/pr62030-octeon.c: Same.
+
+2014-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62106
+	* gfortran.dg/array_constructor_49.f90:  New test.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+	    Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/62131
+	* gfortran.dg/gomp/pr62131.f90: New test.
+
+2014-08-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2014-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/61713
+	* gcc.dg/pr61756.c: New test.
+
+2014-08-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-08-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR middle-end/62103
+	* gcc.c-torture/execute/bitfld-6.c: New test.
+
+2014-08-12  Felix Yang  <fei.yang0953@gmail.com>
+
+	PR tree-optimization/62073
+	* gcc.dg/vect/pr62073.c: New test.
+
+2014-08-12  Janis Johnson  <janisjo@codesourcery.com>
+
+	Backport from mainline
+	2014-08-12  Janis Johnson  <janisjo@codesourcery.com>
+
+	* lib/target/supports.exp
+	(check_effective_target_arm_v8_neon_ok_nocache): Check for armv8
+	or later.
+
+	* gcc.dg/pr59418.c: Don't add ARM options for a Thumb1 multilib.
+
+	* gcc.target/arm/neon-vext-execute.c: Skip if the test won't run
+	on Neon hardware.
+
+	* gcc.target/arm/pr48784.c: Skip for thumb1 multilib.
+	* gcc.target/arm/pr59985.c: Likewise.
+
+2014-08-12  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61962
+	* c-c++-common/cilk-plus/AN/pr61962.c: New test.
+
+2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
+
+	Backport from mainline
+	2014-06-16  Ganesh Gopalasubramanian
+		    <Ganesh.Gopalasubramanian@amd.com>
+
+	* gcc.target/i386/xop-imul64-vector.c: Remove the check for
+	vpmacsdql instruction.
+
+2014-08-11  Janis Johnson  <janisjo@codesourcery.com>
+
+	Backport from mainline
+	2014-08-11  Janis Johnson  <janisjo@codesourcery.com>
+
+	* lib/target-supports.exp (check_effective_target_arm_thumb1_ok,
+	check_effective_target_arm_thumb2_ok): Test with code that passes
+	an argument and returns a result.
+
+	* gcc.target/arm/frame-pointer-1.c: Skip if Thumb is not supported.
+	* gcc.target/arm/pr56184.C: Likewise.
+	* gcc.target/arm/pr59896.c: Likewise.
+	* gcc.target/arm/stack-red-zone.c: Likewise.
+	* gcc.target/arm/thumb-find-work-register.c: Likewise.
+
+2014-08-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/61999
+	* gfortran.dg/dot_product_3.f90:  New test case.
+
+2014-08-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR tree-optimization/60707
+	* gfortran.dg/pr45636.f90: xfail on 32-bit hppa*-*-*.
+
+	* gcc.dg/atomic/c11-atomic-exec-4.c: Undefine _POSIX_C_SOURCE before
+	defining in dg-options.
+	* gcc.dg/atomic/c11-atomic-exec-5.c: Likewise.
+
+	* gcc.dg/atomic/stdatomic-flag.c: Add xfail comment.
+
+	* gcc.c-torture/compile/pr60655-1.c: Don't add -fdata-sections option
+	on 32-bit hppa-hpux.
+
+	* gcc.dg/pr57233.c: Add -fno-common option on hppa*-*-hpux*.
+
+2014-08-07  Petr Murzin  <petr.murzin@intel.com>
+
+	* gcc.target/i386/avx512f-vfixupimmpd-2.c: Include float.h instead of
+	values.h, change MAXDOUBLE for DBL_MAX.
+	* gcc.target/i386/avx512f-vfixupimmsd-2.c: Ditto.
+	* gcc.target/i386/avx512f-vfixupimmps-2.c: Include float.h instead of
+	values.h, change MAXFLOAT for FLT_MAX.
+	* gcc.target/i386/avx512f-vfixupimmss-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermi2d-2.c: Do not include values.h.
+	* gcc.target/i386/avx512f-vpermi2pd-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermi2ps-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermi2q-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2d-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2pd-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2ps-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermt2q-2.c: Ditto.
+
+2014-08-06  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR debug/61923
+	* gcc.target/i386/pr61923.c: New test.
+
+2014-08-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/61801
+	* gcc.target/i386/pr61801.c: Rewritten.
+
+2014-08-04  Rohit  <rohitarulraj@freescale.com>
+
+	PR target/60102
+	* gcc.target/powerpc/pr60102.c: New testcase.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61963
+	* c-c++-common/cilk-plus/AN/pr61963.c: New test.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* c-c++-common/cilk-plus/AN/pr61455.c: New test.
+	* c-c++-common/cilk-plus/AN/pr61455-2.c: Likewise.
+
+2014-08-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-06-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/61375
+	* gcc.c-torture/execute/pr61375-1.c: New test.
+
+2014-08-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61964
+	* gcc.dg/torture/pr61964.c: New testcase.
+	* gcc.dg/pr51879-18.c: XFAIL.
+
+2014-07-28  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/61801
+	* gcc.target/i386/pr61801.c: Fix testcase.
+
+2014-07-28  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/61801
+	* gcc.target/i386/pr61801.c: New testcase.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* gcc.target/powerpc/ppc64-abi-warn-3.c: New test.
+
+	* gcc.c-torture/execute/20050316-1.x: Add -Wno-psabi.
+	* gcc.c-torture/execute/20050604-1.x: Add -Wno-psabi.
+	* gcc.c-torture/execute/20050316-3.x: New file.  Add -Wno-psabi.
+	* gcc.c-torture/execute/pr23135.x: Likewise.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* gcc.target/powerpc/ppc64-abi-warn-2.c: New test.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* gcc.target/powerpc/ppc64-abi-warn-1.c: New test.
+
+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* g++.dg/compat/struct-layout-1.exp: Load g++-dg.exp.
+
+2014-07-24  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61160
+	* g++.dg/ipa/pr61160-2.C (main): Return zero.
+	* g++.dg/ipa/pr61160-3.C (main): Likewise.
+
+2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61855
+	* gcc.target/i386/pr61855.c: New test.
+
+2014-07-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/pack20.ad[sb]: New test.
+	* gnat.dg/pack20_pkg.ads: New helper.
+
+2014-07-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/stack-usage-2.c: Adjust.
+
+2014-07-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/61780
+	* gfortran.dg/dependency_44.f90 : New test
+
+2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/61794
+	* gcc.target/i386/pr61794.c: New test.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR c-family/61741
+	* c-c++-common/torture/pr61741.c: Use signed char.
+
+	2014-07-09  Richard Biener  <rguenther@suse.de>
+
+	PR c-family/61741
+	* c-c++-common/torture/pr61741.c: New testcase.
+
+2014-07-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61779
+	* gcc.dg/tree-ssa/ssa-copyprop-2.c: New testcase.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
@@ -17,7 +617,8 @@
 	2014-06-09  Alan Lawrence  <alan.lawrence@arm.com>
 
 	PR target/61062
-	* gcc.target/arm/pr48252.c (main): Expect same result as endian-neutral.
+	* gcc.target/arm/pr48252.c (main): Expect same result as
+	endian-neutral.
 
 2014-07-08  Jakub Jelinek  <jakub@redhat.com>
 
@@ -34,8 +635,8 @@
 
 2014-07-08  Alan Lawrence  <alan.lawrence@arm.com>
 
-        Backport r211502 from mainline.
-        2014-06-10  Alan Lawrence  <alan.lawrence@arm.com>
+	Backport r211502 from mainline.
+	2014-06-10  Alan Lawrence  <alan.lawrence@arm.com>
 
 	PR target/59843
 	* gcc.dg/vect/vect-singleton_1.c: New file.
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx98-neg.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,99 @@
+// { dg-do compile { target c++98_only } }
+// { dg-options "-ansi" }
+
+#ifndef __cpp_runtime_arrays
+#  error "__cpp_runtime_arrays" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_unicode_characters
+#  error "__cpp_unicode_characters" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_raw_strings
+#  error "__cpp_raw_strings" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_unicode_literals
+#  error "__cpp_unicode_literals" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_user_defined_literals
+#  error "__cpp_user_defined_literals" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_lambdas
+#  error "__cpp_lambdas" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_constexpr
+#  error "__cpp_constexpr" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_static_assert
+#  error "__cpp_static_assert" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_decltype
+#  error "__cpp_decltype" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_attributes
+#  error "__cpp_attributes" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_rvalue_reference
+#  error "__cpp_rvalue_reference" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_variadic_templates
+#  error "__cpp_variadic_templates" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_alias_templates
+#  error "__cpp_alias_templates" // { dg-error "error" }
+#endif
+
+// C++14
+
+// C++98 gets binary literals.
+//#ifndef __cpp_binary_literals
+//#  error "__cpp_binary_literals"
+//#endif
+
+#ifndef __cpp_init_captures
+#  error "__cpp_init_captures" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_generic_lambdas
+#  error "__cpp_generic_lambdas" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_decltype_auto
+#  error "__cpp_decltype_auto" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_return_type_deduction
+#  error "__cpp_return_type_deduction" // { dg-error "error" }
+#endif
+
+//  Aggregate initializers not in yet.
+//#ifdef __cpp_aggregate_nsdmi
+//#  error "__cpp_aggregate_nsdmi"
+//#endif
+
+#ifndef __cpp_variable_templates
+#  error "__cpp_variable_templates" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_digit_separators
+#  error "__cpp_digit_separators" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_attribute_deprecated
+#  error "__cpp_attribute_deprecated" // { dg-error "error" }
+#endif
+
+//  Sized deallocation not in yet.
+//#ifdef __cpp_sized_deallocation
+//#  error "__cpp_sized_deallocation"
+//#endif
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,81 @@
+// { dg-do compile }
+// { dg-options "-std=gnu++11" }
+
+#ifndef __cpp_unicode_characters
+#  error "__cpp_unicode_characters"
+#elif __cpp_unicode_characters != 200704
+#  error "__cpp_unicode_characters != 200704"
+#endif
+
+#ifndef __cpp_raw_strings
+#  error "__cpp_raw_strings"
+#elif __cpp_raw_strings != 200710
+#  error "__cpp_raw_strings != 200710"
+#endif
+
+#ifndef __cpp_unicode_literals
+#  error "__cpp_unicode_literals"
+#elif __cpp_unicode_literals != 200710
+#  error "__cpp_unicode_literals != 200710"
+#endif
+
+#ifndef __cpp_user_defined_literals
+#  error "__cpp_user_defined_literals"
+#elif __cpp_user_defined_literals != 200809
+#  error "__cpp_user_defined_literals != 200809"
+#endif
+
+#ifndef __cpp_lambdas
+#  error "__cpp_lambdas"
+#elif __cpp_lambdas != 200907
+#  error "__cpp_lambdas != 200907"
+#endif
+
+#ifndef __cpp_constexpr
+#  error "__cpp_constexpr"
+#elif __cpp_constexpr != 200704
+#  error "__cpp_constexpr != 200704"
+#endif
+
+#ifndef __cpp_static_assert
+#  error "__cpp_static_assert"
+#elif __cpp_static_assert != 200410
+#  error "__cpp_static_assert != 200410"
+#endif
+
+#ifndef __cpp_decltype
+#  error "__cpp_decltype"
+#elif __cpp_decltype != 200707
+#  error "__cpp_decltype != 200707"
+#endif
+
+#ifndef __cpp_attributes
+#  error "__cpp_attributes"
+#elif __cpp_attributes != 200809
+#  error "__cpp_attributes != 200809"
+#endif
+
+#ifndef __cpp_rvalue_reference
+#  error "__cpp_rvalue_reference"
+#elif __cpp_rvalue_reference != 200610
+#  error "__cpp_rvalue_reference != 200610"
+#endif
+
+#ifndef __cpp_variadic_templates
+#  error "__cpp_variadic_templates"
+#elif __cpp_variadic_templates != 200704
+#  error "__cpp_variadic_templates != 200704"
+#endif
+
+#ifndef __cpp_alias_templates
+#  error "__cpp_alias_templates"
+#elif __cpp_alias_templates != 200704
+#  error "__cpp_alias_templates != 200704"
+#endif
+
+//  These C++14 features are allowed in C++11 in non-ANSI modes.
+#ifndef __cpp_binary_literals
+#  error "__cpp_binary_literals"
+#elif __cpp_binary_literals != 201304
+#  error "__cpp_binary_literals != 201304"
+#endif
Index: gcc/testsuite/g++.dg/cpp1y/testinc/phoobhar.h
===================================================================
Index: gcc/testsuite/g++.dg/cpp1y/phoobhar.h
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/phoobhar.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/phoobhar.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+
+int
+phoo();
+
+int
+bhar();
+
+#ifndef __has_include_next
+#  error "__has_include_next"
+#else
+#  if __has_include_next("phoobhar.h")
+#    include_next "phoobhar.h"
+#  else
+#    error "__has_include_next(\"phoobhar.h\")"
+#  endif
+#endif
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx11-neg.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx11-neg.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx11-neg.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,40 @@
+// { dg-do compile { target c++11_only } }
+// { dg-options "-pedantic-errors" }
+
+// These *are* defined in C++14 onwards.
+
+#ifndef __cpp_binary_literals
+#  error "__cpp_binary_literals" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_init_captures
+#  error "__cpp_init_captures" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_generic_lambdas
+#  error "__cpp_generic_lambdas" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_decltype_auto
+#  error "__cpp_decltype_auto" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_return_type_deduction
+#  error "__cpp_return_type_deduction" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_variable_templates
+#  error "__cpp_variable_templates" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_digit_separators
+#  error "__cpp_digit_separators" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_attribute_deprecated
+#  error "__cpp_attribute_deprecated" // { dg-error "error" }
+#endif
+
+#ifndef __cpp_runtime_arrays
+#  error "__cpp_runtime_arrays" // { dg-error "error" }
+#endif
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,231 @@
+// { dg-do compile { target c++1y } }
+// { dg-options "-I${srcdir}/g++.dg/cpp1y -I${srcdir}/g++.dg/cpp1y/testinc" }
+
+// Begin C++11 tests.
+
+#ifndef __cpp_unicode_characters
+#  error "__cpp_unicode_characters"
+#elif __cpp_unicode_characters != 200704
+#  error "__cpp_unicode_characters != 200704"
+#endif
+
+#ifndef __cpp_raw_strings
+#  error "__cpp_raw_strings"
+#elif __cpp_raw_strings != 200710
+#  error "__cpp_raw_strings != 200710"
+#endif
+
+#ifndef __cpp_unicode_literals
+#  error "__cpp_unicode_literals"
+#elif __cpp_unicode_literals != 200710
+#  error "__cpp_unicode_literals != 200710"
+#endif
+
+#ifndef __cpp_user_defined_literals
+#  error "__cpp_user_defined_literals"
+#elif __cpp_user_defined_literals != 200809
+#  error "__cpp_user_defined_literals != 200809"
+#endif
+
+#ifndef __cpp_lambdas
+#  error "__cpp_lambdas"
+#elif __cpp_lambdas != 200907
+#  error "__cpp_lambdas != 200907"
+#endif
+
+#ifndef __cpp_constexpr
+#  error "__cpp_constexpr"
+#elif __cpp_constexpr != 200704
+#  error "__cpp_constexpr != 200704"
+#endif
+
+#ifndef __cpp_static_assert
+#  error "__cpp_static_assert"
+#elif __cpp_static_assert != 200410
+#  error "__cpp_static_assert != 200410"
+#endif
+
+#ifndef __cpp_decltype
+#  error "__cpp_decltype"
+#elif __cpp_decltype != 200707
+#  error "__cpp_decltype != 200707"
+#endif
+
+#ifndef __cpp_attributes
+#  error "__cpp_attributes"
+#elif __cpp_attributes != 200809
+#  error "__cpp_attributes != 200809"
+#endif
+
+#ifndef __cpp_rvalue_reference
+#  error "__cpp_rvalue_reference"
+#elif __cpp_rvalue_reference != 200610
+#  error "__cpp_rvalue_reference != 200610"
+#endif
+
+#ifndef __cpp_variadic_templates
+#  error "__cpp_variadic_templates"
+#elif __cpp_variadic_templates != 200704
+#  error "__cpp_variadic_templates != 200704"
+#endif
+
+#ifndef __cpp_alias_templates
+#  error "__cpp_alias_templates"
+#elif __cpp_alias_templates != 200704
+#  error "__cpp_alias_templates != 200704"
+#endif
+
+// Begin C++14 tests.
+
+#ifndef __cpp_binary_literals
+#  error "__cpp_binary_literals"
+#elif __cpp_binary_literals != 201304
+#  error "__cpp_binary_literals != 201304"
+#endif
+
+#ifndef __cpp_init_captures
+#  error "__cpp_init_captures"
+#elif __cpp_init_captures != 201304
+#  error "__cpp_init_captures != 201304"
+#endif
+
+#ifndef __cpp_generic_lambdas
+#  error "__cpp_generic_lambdas"
+#elif __cpp_generic_lambdas != 201304
+#  error "__cpp_generic_lambdas != 201304"
+#endif
+
+//  TODO: Change 200704 to 201304 when C++14 constexpr goes in.
+#ifndef __cpp_constexpr
+#  error "__cpp_constexpr"
+#elif __cpp_constexpr != 200704
+#  error "__cpp_constexpr != 200704"
+#endif
+
+#ifndef __cpp_decltype_auto
+#  error "__cpp_decltype_auto"
+#elif __cpp_decltype_auto != 201304
+#  error "__cpp_decltype_auto != 201304"
+#endif
+
+#ifndef __cpp_return_type_deduction
+#  error "__cpp_return_type_deduction"
+#elif __cpp_return_type_deduction != 201304
+#  error "__cpp_return_type_deduction != 201304"
+#endif
+
+#ifndef __cpp_runtime_arrays
+#  error "__cpp_runtime_arrays"
+#elif __cpp_runtime_arrays != 201304
+#  error "__cpp_runtime_arrays != 201304"
+#endif
+
+//  Aggregate initializers not in yet.
+#ifdef __cpp_aggregate_nsdmi
+#  error "__cpp_aggregate_nsdmi"
+#endif
+
+//  Variable templates not in yet.
+#ifdef __cpp_variable_templates
+#  error "__cpp_variable_templates"
+#endif
+
+#ifndef __cpp_digit_separators
+#  error "__cpp_digit_separators"
+#elif __cpp_digit_separators != 201309
+#  error "__cpp_digit_separators != 201309"
+#endif
+
+#ifndef __cpp_attribute_deprecated
+#  error "__cpp_attribute_deprecated"
+#elif __cpp_attribute_deprecated != 201309
+#  error "__cpp_attribute_deprecated != 201309"
+#endif
+
+//  Sized deallocation not in yet.
+#ifdef __cpp_sized_deallocation
+#  error "__cpp_sized_deallocation"
+#endif
+
+// Begin include checks.
+
+//  Check for __has_include macro.
+#ifndef __has_include
+#  error "__has_include"
+#endif
+
+//  Quoted complex.h should find at least the bracket version (use operator).
+#if __has_include__ "complex.h"
+#else
+#  error "complex.h"
+#endif
+
+//  Try known bracket header (use operator).
+#if __has_include__(<complex>)
+#else
+#  error "<complex>"
+#endif
+
+//  Define and use a macro to invoke the operator.
+#define sluggo(TXT) __has_include__(TXT)
+
+#if sluggo(<complex>)
+#else
+#  error "<complex>"
+#endif
+
+#if ! sluggo(<complex>)
+#  error "<complex>"
+#else
+#endif
+
+//  Quoted complex.h should find at least the bracket version.
+#if __has_include("complex.h")
+#else
+#  error "complex.h"
+#endif
+
+//  Try known local quote header.
+#if __has_include("complex_literals.h")
+#else
+#  error "\"complex_literals.h\""
+#endif
+
+//  Try nonexistent bracket header.
+#if __has_include(<stuff>)
+#  error "<stuff>"
+#else
+#endif
+
+//  Try nonexistent quote header.
+#if __has_include("phlegm")
+#  error "\"phlegm\""
+#else
+#endif
+
+//  Test __has_include_next.
+#if __has_include("phoobhar.h")
+#  include "phoobhar.h"
+#else
+#  error "__has_include(\"phoobhar.h\")"
+#endif
+
+//  Try a macro.
+#define COMPLEX_INC "complex.h"
+#if __has_include(COMPLEX_INC)
+#else
+#  error COMPLEX_INC
+#endif
+
+//  Realistic use of __has_include.
+#if __has_include(<array>)
+#  define STD_ARRAY 1
+#  include <array>
+  template<typename _Tp, size_t _Num>
+    using array = std::array<_Tp, _Num>;
+#elif __has_include(<tr1/array>)
+#  define TR1_ARRAY 1
+#  include <tr1/array>
+  template<typename _Tp, size_t _Num>
+    typedef std::tr1::array<_Tp, _Num> array;
+#endif
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx98.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx98.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx98.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+// { dg-do compile { target c++98_only } }
+// { dg-options "" }
+
+//  These C++14 features are allowed in C++98 in non-ANSI modes.
+#ifndef __cpp_binary_literals
+#  error "__cpp_binary_literals"
+#elif  __cpp_binary_literals != 201304
+#  error "__cpp_binary_literals != 201304"
+#endif
Index: gcc/testsuite/g++.dg/cpp1y/paren1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/paren1.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/paren1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+// PR c++/63437
+// { dg-do compile { target c++11 } }
+
+struct X // movable but not copyable
+{
+    X() = default;
+    X(X &&) = default;
+
+    X(const X &) = delete;
+};
+
+X non_parenthesized()
+{
+    X x;
+    return x; // works
+}
+
+X parenthesized()
+{
+    X x;
+    return (x); // error: use of deleted function 'X::X(const X&)'
+}
+
+template <class T>
+T parenthesized_t()
+{
+  T t;
+  return (t);
+}
+
+template X parenthesized_t<X>();
Index: gcc/testsuite/g++.dg/cpp1y/pr57644.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/pr57644.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/pr57644.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// { dg-do compile { target c++1y } }
+
+struct Foo
+{
+  unsigned i: 32;
+};
+
+int
+main()
+{
+  Foo f{};
+  return f.i;
+}
Index: gcc/testsuite/g++.dg/ext/restrict2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/restrict2.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ext/restrict2.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+// PR c++/60872
+// { dg-options "" }
+
+typedef double *__restrict T;
+void f(T* p)
+{
+  void *p2 = p;
+}
Index: gcc/testsuite/g++.dg/opt/devirt4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/devirt4.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/opt/devirt4.C	(.../branches/gcc-4_9-branch)
@@ -1,8 +1,7 @@
 // PR lto/53808
-// Devirtualization + inlining should produce a non-virtual
-// call to ~foo.
-// { dg-options "-O -fdevirtualize" }
-// { dg-final { scan-assembler "_ZN3fooD2Ev" } }
+// Devirtualization should not produce an external ref to ~bar.
+// { dg-options "-O2" }
+// { dg-final { scan-assembler-not "_ZN3barD0Ev" } }
 
 struct foo {
  virtual ~foo();
Index: gcc/testsuite/g++.dg/opt/pr62146.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr62146.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr62146.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,51 @@
+/* PR rtl-optimization/62146 */
+/* { dg-do compile } */
+/* { dg-options "-O2 " } */
+class F
+{
+public:
+    virtual ~ F ();
+};
+template < class CL > class G:public F
+{
+    int *member_;
+public:
+    G ( int *b): member_ (0)
+    {
+    }
+};
+
+class D
+{
+public:
+    template < class CL > void RegisterNonTagCallback (int,
+            void (CL::
+                  *p3) ())
+    {
+        InternalRegisterNonTag (p3 ? new G < CL > ( 0) : 0);
+    } void InternalRegisterNonTag (F *);
+};
+
+void fn1 ();
+class C1
+{
+    void  foo();
+    class TokenType
+    {
+    public:
+        void AddToken ()
+        {
+        }
+    };
+    C1::TokenType bar_t;
+};
+D a;
+void C1::foo()
+{
+    if (&bar_t)
+        fn1 ();
+    for (int i = 0; i < sizeof 0; ++i)
+        a.RegisterNonTagCallback (0, &TokenType::AddToken);
+}
+
+/* { dg-final { scan-assembler-not "mov.*_ZN2C19TokenType8AddTokenEv, .\\\(" } } */
Index: gcc/testsuite/g++.dg/opt/devirt5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/devirt5.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/opt/devirt5.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+// PR c++/61659
+// { dg-options "-O3" }
+// { dg-final { scan-assembler-not "_ZN6parserIiE9getOptionEv" } }
+
+struct generic_parser_base {
+  virtual void getOption();
+  void getExtraOptionNames() { getOption(); }
+};
+template <class DataType> struct parser : public generic_parser_base {
+  virtual void getOption() {}
+};
+struct PassNameParser : public parser<int> {
+  PassNameParser();
+};
+struct list {
+  PassNameParser Parser;
+  virtual void getExtraOptionNames() { return Parser.getExtraOptionNames(); }
+};
+list PassList;
Index: gcc/testsuite/g++.dg/expr/cond12.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/expr/cond12.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/expr/cond12.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+// PR c++/58714
+// { dg-do run }
+
+struct X {
+    X& operator=(const X&){}
+    X& operator=(X&){__builtin_abort();}
+};
+
+int main(int argv,char**) {
+  X a, b;
+  ((argv > 2) ? a : b) = X();
+}
Index: gcc/testsuite/g++.dg/abi/spec1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/abi/spec1.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/abi/spec1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,4 @@
+// { dg-final { scan-assembler-not "weak" } }
+
+template <class T> struct A { static int i; };
+template<> int A<int>::i = 42;
Index: gcc/testsuite/g++.dg/abi/no-weak1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/abi/no-weak1.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/abi/no-weak1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// { dg-options "-fno-weak" }
+// { dg-final { scan-assembler "local\[ \t\]*_ZZL1fvE1i" { target x86_64-*-*gnu } } }
+
+static inline void f()
+{
+  static int i;
+  ++i;
+};
+
+int main()
+{
+  f();
+}
Index: gcc/testsuite/g++.dg/gomp/pr63249.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/pr63249.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/pr63249.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+// PR c++/63249
+// { dg-do compile }
+// { dg-options "-Wall -W -fopenmp" }
+
+template <int N>
+int
+foo (int *v, int A, int B)	// { dg-bogus "set but not used" }
+{
+  int r = 0;
+  int a = 2;			// { dg-bogus "set but not used" }
+  int b = 4;			// { dg-bogus "set but not used" }
+#pragma omp target map(to: v[a:b])
+  r |= v[3];
+#pragma omp target map(to: v[A:B])
+  r |= v[3];
+  return r;
+}
+
+template <typename T>
+int
+bar (T *v, T A, T B)		// { dg-bogus "set but not used" }
+{
+  T r = 0, a = 2, b = 4;	// { dg-bogus "set but not used" }
+#pragma omp target map(to: v[a:b])
+  r |= v[3];
+#pragma omp target map(to: v[A:B])
+  r |= v[3];
+  return r;
+}
+
+int
+baz (int *v, int A, int B)
+{
+  return foo<0> (v, A, B) + bar (v, A, B);
+}
Index: gcc/testsuite/g++.dg/init/const9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/const9.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/init/const9.C	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 // PR c++/55893
-// { dg-final { scan-assembler-not "rodata" } }
+// { dg-final { scan-assembler-not "rodata" { target { ! hppa*-*-* } } } }
 
 struct foo
 {
Index: gcc/testsuite/g++.dg/init/explicit2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/explicit2.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/init/explicit2.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+// PR c++/60417
+
+struct A { explicit A(int = 0); };
+
+int main()
+{
+  A a[1] = { };
+}
Index: gcc/testsuite/g++.dg/ubsan/pr61272.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ubsan/pr61272.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ubsan/pr61272.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+// PR sanitizer/61272
+// { dg-do compile }
+// { dg-options "-fsanitize=undefined -std=c++11" }
+
+namespace std
+{
+  template < typename _Tp > class allocator;
+  template < typename _Alloc > struct allocator_traits {
+  private:
+      template < typename _Tp > auto construct ( _Alloc & __a, _Tp * __p)-> // { dg-error "is private" }
+      decltype (_S_construct (__a, __p)) { }
+  };
+  namespace __gnu_cxx
+  {
+    template < typename _Alloc > struct __alloc_traits:std::allocator_traits < _Alloc > // { dg-error "within this context" }
+    {
+      typedef std::allocator_traits < _Alloc > _Base_type;
+      using _Base_type::construct;
+    };
+    template < typename _Tp, typename _Alloc > struct _Vector_base { typedef typename __gnu_cxx::__alloc_traits < _Alloc >::template rebind < _Tp >::other _Tp_alloc_type; }; // { dg-error "no class template" }
+    template < typename _Tp, typename _Alloc = std::allocator < _Tp > >class vector : protected _Vector_base < _Tp, _Alloc > { };
+    template < typename NumberT > struct Point2d { };
+    typedef Point2d < int >GdsPoint;
+    class GdsPointList : public vector < GdsPoint > {};}}
Index: gcc/testsuite/g++.dg/lto/pr62026.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lto/pr62026.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/lto/pr62026.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+// { dg-lto-do link }
+// { dg-lto-options {{-flto -O3 -r -nostdlib}} }
+class C;
+class F {
+  virtual C m_fn1();
+};
+class C {
+ public:
+  virtual int *m_fn3(int);
+};
+class G : F, C {
+  int offsets;
+  int *m_fn3(int);
+};
+C *a;
+int *G::m_fn3(int) {
+  if (offsets) return 0;
+}
+
+void fn1() {
+  for (;;) a->m_fn3(0);
+}
Index: gcc/testsuite/g++.dg/tls/thread_local10.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local10.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local10.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+// PR c++/58624
+
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+int i;
+
+template <typename> struct A
+{
+  static thread_local int s;
+
+  A () { i = s; }
+};
+
+int f() { return 42; }
+template <typename T> thread_local int A<T>::s = f();
+
+int main () {
+  A<void> a;
+  if (i != 42)
+    __builtin_abort();
+}
Index: gcc/testsuite/g++.dg/warn/Wunused-parm-6.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/Wunused-parm-6.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/warn/Wunused-parm-6.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+// PR c++/61465
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wunused-but-set-parameter" }
+
+struct Foo {
+  Foo(void* x) : y{static_cast<char*>(x)} {}
+  char* y;
+};
Index: gcc/testsuite/g++.dg/asan/pr62017.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asan/pr62017.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/asan/pr62017.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+// PR c++/62017
+// { dg-do run }
+
+struct A
+{
+  int x;
+  virtual ~A () {}
+};
+struct B : public virtual A {};
+struct C : public virtual A {};
+struct D : public B, virtual public C {};
+
+int
+main ()
+{
+  D d;
+}
Index: gcc/testsuite/g++.dg/compat/struct-layout-1.exp
===================================================================
--- a/src/gcc/testsuite/g++.dg/compat/struct-layout-1.exp	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/compat/struct-layout-1.exp	(.../branches/gcc-4_9-branch)
@@ -89,6 +89,9 @@
 # This must be done after the compat-use-*-compiler definitions.
 load_lib compat.exp
 
+# Provide the g++-dg-prune routine (gcc-dp.exp is loaded by compat.exp)
+load_lib g++-dg.exp
+
 g++_init
 
 # Save variables for the C++ compiler under test, which each test will
Index: gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
===================================================================
--- a/src/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* Structure layout test generator.
-   Copyright (C) 2004, 2005, 2007, 2008, 2009, 2011, 2012
+   Copyright (C) 2004-2014
    Free Software Foundation, Inc.
    Contributed by Jakub Jelinek <jakub@redhat.com>.
 
@@ -44,7 +44,7 @@
 #endif
 
 const char *dg_options[] = {
-"/* { dg-options \"%s-I%s\" } */\n",
+"/* { dg-options \"%s-I%s -Wno-abi\" } */\n",
 "/* { dg-options \"%s-I%s -mno-mmx -Wno-abi\" { target i?86-*-* x86_64-*-* } } */\n",
 "/* { dg-options \"%s-I%s -fno-common\" { target hppa*-*-hpux* powerpc*-*-darwin* *-*-mingw32* *-*-cygwin* } } */\n",
 "/* { dg-options \"%s-I%s -mno-mmx -fno-common -Wno-abi\" { target i?86-*-darwin* x86_64-*-darwin* i?86-*-mingw32* x86_64-*-mingw32* i?86-*-cygwin* } } */\n",
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-empty7.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-empty7.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-empty7.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+// PR c++/61959
+// { dg-do compile { target c++11 } }
+
+template <class Coord> struct BasePoint
+{
+  Coord x, y;
+  constexpr BasePoint (Coord, Coord) : x (0), y (0) {}
+};
+template <class T> struct BaseCoord
+{
+  int value;
+  constexpr BaseCoord (T) : value (1) {}
+};
+template <class units> struct IntCoordTyped : BaseCoord<int>, units
+{
+  typedef BaseCoord Super;
+  constexpr IntCoordTyped (int) : Super (0) {}
+};
+template <class units>
+struct IntPointTyped : BasePoint<IntCoordTyped<units> >, units
+{
+  typedef BasePoint<IntCoordTyped<units> > Super;
+  constexpr IntPointTyped (int, int) : Super (0, 0) {}
+};
+struct A
+{
+};
+IntPointTyped<A> a (0, 0);
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template13.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template13.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template13.C	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,6 @@
 // PR c++/61566
 // { dg-do compile { target c++11 } }
+// { dg-options "-fabi-version=0" }
 
 struct function
 {
@@ -7,6 +8,7 @@
   function (_Functor);
 };
 
+template <class U>
 struct C
 {
   template <typename T>
@@ -15,6 +17,9 @@
 
 void bar ()
 {
-  C c;
+  C<int> c;
   c.foo (1);
 }
+
+// { dg-final { scan-assembler "_ZN8functionC1IZN1CIiE3fooIiEEvT_S_Ed_UlvE_EET_" } }
+// { dg-final { scan-assembler-not "_ZZN1CIiE3fooIiEEvT_8functionEd_NKUlvE_clEv" } }
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template14.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template14.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-template14.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+// PR c++/62219
+// { dg-do compile { target c++11 } }
+
+template< class = void >
+struct S
+{
+  friend void foo( S )
+  {
+    [](){};
+  }
+};
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem3.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem3.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+// PR c++/62129
+// { dg-do compile { target c++11 } }
+
+class Evaluator
+{
+  int MakeChangelist ();
+  typedef int (Evaluator::*fac_t)();
+  struct CreatorEntry
+  {
+    const char *type;
+    fac_t factory;
+  };
+  static constexpr CreatorEntry kCreators[] = { "", &Evaluator::MakeChangelist };
+};
+
+constexpr Evaluator::CreatorEntry Evaluator::kCreators[];
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-initlist8.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-initlist8.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-initlist8.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+// PR c++/63415
+// { dg-do compile { target c++11 } }
+
+template <typename T>
+struct A {
+  static constexpr int value = int(T{});
+};
Index: gcc/testsuite/g++.dg/cpp0x/rv-cond1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/rv-cond1.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/rv-cond1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// PR c++/58714
+// { dg-do compile { target c++11 } }
+
+struct X {
+  X& operator=(const X&) = delete;
+  X& operator=(X&& ) = default;
+};
+
+void f(bool t) {
+  X a, b;
+  *(t ? &a : &b) = X();
+  (t ? a : b) = X();
+}
Index: gcc/testsuite/g++.dg/cpp0x/variadic162.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/variadic162.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/variadic162.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+// PR c++/63405
+// { dg-do compile { target c++11 } }
+
+template <typename _Tp> _Tp forward(_Tp);
+template <typename Args> struct Format { Format(int, Args); };
+template <typename... Args> auto format(Args &&... args) -> Format<Args...> {
+  return {0, args...};
+}
+
+template <typename... Args> void msg(Args... args) {
+  format(forward(args)...);
+}
+
+void some_function() { msg('x'); }
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-array7.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-array7.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-array7.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// PR c++/61994
+// { dg-do compile { target c++11 } }
+
+struct A { int i,j; };
+
+struct X {
+  A a = {1,1};
+};
+
+constexpr X table[1][1] = {{ {} }};
+
+#define SA(X) static_assert(X,#X)
+SA(table[0][0].a.i == 1);
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-63241.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-63241.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-63241.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// PR c++/63241
+// { dg-do compile { target c++11 } }
+
+struct A {
+  constexpr A(int){}
+};
+
+int main() {
+  int i = 1;
+  A array[2][2] =
+    {{{0}, {i}},
+     {{0}, {0}}};
+}
Index: gcc/testsuite/g++.dg/cpp0x/variadic161.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/variadic161.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/variadic161.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,51 @@
+// PR c++/63139
+// { dg-do compile { target c++11 } }
+
+template<typename ...T>
+struct type_list {};
+
+template<typename ...T>
+struct make_type_list
+{
+    using type = type_list<T...>;
+};
+
+// The bug disappears if you use make_type_list directly.
+template<typename ...T>
+using make_type_list_t = typename make_type_list<T...>::type;
+
+
+struct ContainerEndA {};
+
+template<typename ...Ts>
+struct ContainerA
+{
+    using type = make_type_list_t<Ts..., ContainerEndA>;
+};
+
+
+struct ContainerEndB {};
+
+template<typename ...Ts>
+struct ContainerB
+{
+    using type = make_type_list_t<Ts..., ContainerEndB>;
+};
+
+template<typename T, typename U>
+struct is_same
+{
+  static const bool value = false;
+};
+
+template<typename T>
+struct is_same<T, T>
+{
+  static const bool value = true;
+};
+
+#define SA(X) static_assert((X), #X)
+
+SA((is_same<ContainerB<>::type, type_list<ContainerEndB>>::value));
+SA((!is_same<ContainerA<>::type, type_list<ContainerEndB>>::value));
+SA((!is_same<ContainerA<>::type, ContainerB<>::type>::value));
Index: gcc/testsuite/g++.dg/torture/pr62121.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr62121.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr62121.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+// { dg-do compile }
+class A
+{
+  virtual double operator()();
+};
+class B : A
+{
+public:
+  double operator()();
+};
+extern B a[];
+int b = a[0]();
Index: gcc/testsuite/g++.dg/torture/pr62175.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr62175.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr62175.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+// { dg-do compile }
+// { dg-additional-options "-ftrapv" }
+
+struct B {
+    B(int = 0);
+};
+int c;
+int *d;
+struct G {
+    G();
+    int numProcs_;
+};
+int fn1();
+B fn2() {
+    if (c)
+      return 0;
+    return B();
+}
+
+long &fn3(long &p1, long &p2) {
+    if (p2 < p1)
+      return p2;
+    return p1;
+}
+
+void fn4(long p1) {
+    long a = fn1();
+    fn2();
+    int b = fn3(p1, a);
+    for (int i; i < b; ++i)
+      d[0] = 0;
+    for (; a < p1; ++a)
+      d[a] = 0;
+}
+
+G::G() { fn4(numProcs_ + 1); }
Index: gcc/testsuite/g++.dg/ipa/pr61160-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr61160-1.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr61160-1.C	(.../branches/gcc-4_9-branch)
@@ -27,5 +27,6 @@
 int main ()
 {
   CExample c;
-  return (test (c) != &c);
+  test (c);
+  return 0;
 }
Index: gcc/testsuite/g++.dg/ipa/pr62015.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr62015.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr62015.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,55 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -std=c++11"  } */
+
+
+extern "C" int printf(const char *fmt, ...);
+extern "C" void abort(void);
+
+struct Side {
+    enum _Value { Left, Right, Invalid };
+
+    constexpr Side() : _value(Invalid) {}
+    constexpr Side(_Value value) : _value(value) {}
+    operator _Value() const { return (_Value)_value; }
+
+  private:
+    char _value;
+};
+
+struct A {
+    void init();
+    void adjust(Side side, bool final);
+    void move(Side side);
+};
+
+void A::init()
+{
+    adjust(Side::Invalid, false);
+}
+
+static void __attribute__((noinline))
+check (int v, int final)
+{
+    if (v != 0)
+      abort();
+}
+
+
+__attribute__((noinline))
+void A::adjust(Side side, bool final)
+{
+  check ((int)side, final);
+}
+
+void A::move(Side side)
+{
+    adjust(side, false);
+    adjust(side, true);
+}
+
+int main()
+{
+    A t;
+    t.move(Side::Left);
+    return 0;
+}
Index: gcc/testsuite/g++.dg/ipa/pr63306.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr63306.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63306.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+// PR c++/63306
+// { dg-do compile { target c++11 } }
+
+template <typename...>
+class A;
+
+class B
+{
+  B (const int &, const A<int, int> &);
+};
+
+B::B (const int &, const A<int, int> &)
+{
+}
Index: gcc/testsuite/g++.dg/ipa/devirt-39.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-39.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-39.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+// PR c++/61214
+/* { dg-options "-O2"  } */
+
+struct Base
+{
+  virtual ~Base();
+  virtual Base* clone() {
+    return 0;
+  }
+};
+
+struct Foo : Base
+{
+  virtual ~Foo();
+  virtual Base* clone() {
+    return new Foo();
+  }
+};
+
+int main()
+{
+  Base* f = new Foo();
+  f->clone();
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "_ZN3Foo5cloneEv" } } */
Index: gcc/testsuite/g++.dg/ipa/devirt-40.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-40.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-40.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+// PR c++/62224
+// { dg-options "-O2" }
+// For 4.9, we don't want to devirtualize f and thus create a reference to g.
+
+struct A
+{
+  virtual void f () = 0;
+};
+
+class B : A
+{
+  virtual void f () { g(); }
+  void g();
+};
+
+void h (A *a)
+{
+  a->f ();
+}
+
+// { dg-final { scan-assembler-not "_ZN1B1gEv" } }
Index: gcc/testsuite/g++.dg/ipa/devirt-28a.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/devirt-28a.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/devirt-28a.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+// PR c++/58678
+// { dg-options "-O3 -flto -shared -fPIC -Wl,--no-undefined" }
+// { dg-do link { target { gld && fpic } } }
+
+struct A {
+  virtual ~A();
+};
+struct B : A {
+  virtual int m_fn1();
+};
+void fn1(B* b) {
+  delete b;
+}
+
+int main() {}
Index: gcc/testsuite/g++.dg/ipa/pr61654.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr61654.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr61654.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+/* The bug only presented itself on a 32 bit i386 but in theory it might also
+   pop up elsewhere and we do not want to put -m32 options to testcase
+   options.  */
+
+struct A
+{
+  virtual int a (int, int = 0) = 0;
+  void b ();
+  void c ();
+  int d;
+};
+
+struct B : virtual A
+{
+  int a (int, int);
+  int e;
+};
+
+int f;
+
+void
+A::b ()
+{
+  a (0);
+}
+
+void
+A::c ()
+{
+  a (f);
+}
+
+int
+B::a (int, int)
+{
+  return e;
+}
Index: gcc/testsuite/g++.dg/ipa/pr61160-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr61160-2.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr61160-2.C	(.../branches/gcc-4_9-branch)
@@ -39,5 +39,6 @@
 int main ()
 {
   CExample c;
-  return (test (c) != &c);
+  test (c);
+  return 0;
 }
Index: gcc/testsuite/g++.dg/pr62079.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr62079.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/pr62079.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,78 @@
+// { dg-do compile }
+// { dg-options "-std=c++11 -O2 -fnon-call-exceptions" }
+
+template < typename > class allocator;
+
+template < class _CharT > struct char_traits;
+template < typename _CharT, typename _Traits = char_traits < _CharT >,
+  typename _Alloc = allocator < _CharT > >class basic_string;
+typedef basic_string < char >string;
+
+template < typename _Tp > class new_allocator
+{
+  template < typename _Tp1 > struct rebind
+  {
+    typedef new_allocator < _Tp1 > other;
+  };
+};
+
+template < typename _Tp > using __allocator_base = new_allocator < _Tp >;
+template < typename _Tp > class allocator:public __allocator_base < _Tp >
+{
+};
+
+template < typename _CharT, typename _Traits, typename _Alloc >
+  class basic_string
+{
+public:
+  basic_string (const _CharT * __s, const _Alloc & __a = _Alloc ());
+  ~basic_string ()noexcept;
+};
+
+template < typename T > struct add_reference
+{
+  typedef T & type;
+};
+
+template < typename ... Values > class tuple;
+template <> class tuple <>
+{
+};
+
+template < typename Head, typename ... Tail > class tuple < Head, Tail ... >:private tuple <
+  Tail ...
+  >
+{
+  typedef tuple < Tail ... >inherited;
+public:
+  template < typename ... VValues >
+    tuple (const tuple < VValues ... >&other):inherited (other.tail ()),
+    m_head (other.head ())
+  {
+  }
+  typename add_reference < const Head >::type head () const
+  {
+    return m_head;
+  }
+  const inherited & tail () const
+  {
+    return *this;
+  }
+  Head m_head;
+};
+
+template < typename T > struct make_tuple_result
+{
+  typedef T type;
+};
+
+template < typename ... Values >
+  tuple < typename make_tuple_result <
+  Values >::type ... >make_tuple (const Values & ... values);
+
+int
+main ()
+{
+  tuple < int, float, string > t3c =
+    make_tuple (17, 2.718281828, string ("Fun"));
+}
Index: gcc/testsuite/g++.dg/template/friend56.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/friend56.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/template/friend56.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// Make sure we don't mistakenly mark f as DECL_COMDAT.
+// { dg-final { scan-assembler "_Z1fv" } }
+
+void f();
+
+template <class T> struct A
+{
+  friend void f();
+};
+
+A<int> a;
+
+void f() { }
Index: gcc/testsuite/g++.dg/template/spec38.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/spec38.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/template/spec38.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,6 @@
+// PR ipa/61659
+
+// { dg-final { scan-assembler "_Z1fIiEvPT_" } }
+
+template <typename T> inline void f (T *);
+template <> void f (int *) { }
Index: gcc/testsuite/g++.dg/template/ptrmem29.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/ptrmem29.C	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/g++.dg/template/ptrmem29.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+// PR c++/62659
+
+struct D {
+  typedef int (D::*cont_func)();
+  template <cont_func> struct B;
+  template <cont_func cont_f> void wait(B<cont_f> ***);
+
+  int done();
+  template <bool> void fix() { wait<&D::done>(0); }
+};
Index: gcc/testsuite/c-c++-common/pr61741.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr61741.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/pr61741.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+int a = 1, b;
+
+void
+foo (void)
+{
+  signed char c = 0;
+  for (; a; a--)
+    for (; c >= 0; c++);
+  if (!c)
+    b = 1;
+}
+
+int
+main ()
+{
+  foo ();
+  if (b != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61962.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61962.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61962.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* PR other/61962 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+struct FloatStruct
+{
+    float *f;
+};
+
+/* Either SRC or DST must be a struct, otherwise the bug does not occur.  */
+void f (struct FloatStruct* dst, float *src, unsigned int length)
+{
+    dst->f[0:length] = src[0:length];
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61963.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61963.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61963.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR other/61963 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+void f (int * int *a) /* { dg-error "expected" } */
+{
+    a[0:64] = 0; /* { dg-error "was not declared" "" { target c++ } 7 } */
+    a[0:64] = 0;
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr62008.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr62008.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr62008.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR other/62008 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+void f(int *a, int w, int h)
+{
+  int tmp[w][h];
+  tmp[:][:] = a[0:w][0:h]; /* { dg-error "base of array section must be pointer or array type" } */
+  /* { dg-error "start-index and length fields necessary" "" { target c } 8 } */
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455-2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* PR c++/61455 */
+/* { dg-options "-fcilkplus" } */
+
+int a[3] = {2, 3, 4};
+
+int main ()
+{
+  int c = 10;
+  int b = __sec_reduce_add(a[:]);
+  if (b+c != 19)
+    __builtin_abort();
+  return 0;
+}
Index: gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR c++/61455 */
+/* { dg-do compile } */
+/* { dg-options "-fcilkplus" } */
+
+void foo ()
+{
+  int a[2];
+  int b = a[:]; /* { dg-error "cannot be scalar" } */
+}
Index: gcc/testsuite/c-c++-common/gomp/pr61200.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr61200.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr61200.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* PR libgomp/61200 */
+
+int
+main ()
+{
+  int var = 1;
+  #pragma omp parallel
+    if (var != 1)
+      __builtin_abort ();
+  #pragma omp task shared(var)
+    var = 2;
+  return 0;
+}
Index: gcc/testsuite/c-c++-common/gomp/pr63328.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr63328.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr63328.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,5 @@
+/* PR debug/63328 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fopenmp-simd -fno-strict-aliasing -fcompare-debug" } */
+
+#include "pr60823-3.c"
Index: gcc/testsuite/c-c++-common/gomp/pr63249.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr63249.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr63249.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* PR c++/63249 */
+/* { dg-do compile } */
+/* { dg-options "-Wall -W -fopenmp" } */
+
+int
+foo (int *v, int A, int B)	/* { dg-bogus "set but not used" } */
+{
+  int r = 0;
+  int a = 2;			/* { dg-bogus "set but not used" } */
+  int b = 4;			/* { dg-bogus "set but not used" } */
+#pragma omp target map(to: v[a:b])
+  r |= v[3];
+#pragma omp target map(to: v[A:B])
+  r |= v[3];
+  return r;
+}
Index: gcc/cp/typeck.c
===================================================================
--- a/src/gcc/cp/typeck.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/typeck.c	(.../branches/gcc-4_9-branch)
@@ -8579,6 +8579,20 @@
       if (VOID_TYPE_P (functype))
 	return error_mark_node;
 
+      /* If we had an id-expression obfuscated by force_paren_expr, we need
+	 to undo it so we can try to treat it as an rvalue below.  */
+      if (cxx_dialect >= cxx1y
+	  && INDIRECT_REF_P (retval)
+	  && REF_PARENTHESIZED_P (retval))
+	{
+	  retval = TREE_OPERAND (retval, 0);
+	  while (TREE_CODE (retval) == NON_LVALUE_EXPR
+		 || TREE_CODE (retval) == NOP_EXPR)
+	    retval = TREE_OPERAND (retval, 0);
+	  gcc_assert (TREE_CODE (retval) == ADDR_EXPR);
+	  retval = TREE_OPERAND (retval, 0);
+	}
+
       /* Under C++0x [12.8/16 class.copy], a returned lvalue is sometimes
 	 treated as an rvalue for the purposes of overload resolution to
 	 favor move constructors over copy constructors.
Index: gcc/cp/init.c
===================================================================
--- a/src/gcc/cp/init.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/init.c	(.../branches/gcc-4_9-branch)
@@ -3557,19 +3557,11 @@
       try_block = begin_try_block ();
     }
 
-  /* If the initializer is {}, then all elements are initialized from {}.
-     But for non-classes, that's the same as value-initialization.  */
+  bool empty_list = false;
   if (init && BRACE_ENCLOSED_INITIALIZER_P (init)
       && CONSTRUCTOR_NELTS (init) == 0)
-    {
-      if (CLASS_TYPE_P (type))
-	/* Leave init alone.  */;
-      else
-	{
-	  init = NULL_TREE;
-	  explicit_value_init_p = true;
-	}
-    }
+    /* Skip over the handling of non-empty init lists.  */
+    empty_list = true;
 
   /* Maybe pull out constant value when from_array? */
 
@@ -3689,14 +3681,8 @@
 	    vec_free (new_vec);
 	}
 
-      /* Any elements without explicit initializers get {}.  */
-      if (cxx_dialect >= cxx11 && AGGREGATE_TYPE_P (type))
-	init = build_constructor (init_list_type_node, NULL);
-      else
-	{
-	  init = NULL_TREE;
-	  explicit_value_init_p = true;
-	}
+      /* Any elements without explicit initializers get T{}.  */
+      empty_list = true;
     }
   else if (from_array)
     {
@@ -3742,6 +3728,26 @@
 
       to = build1 (INDIRECT_REF, type, base);
 
+      /* If the initializer is {}, then all elements are initialized from T{}.
+	 But for non-classes, that's the same as value-initialization.  */
+      if (empty_list)
+	{
+	  if (cxx_dialect >= cxx11 && AGGREGATE_TYPE_P (type))
+	    {
+	      if (BRACE_ENCLOSED_INITIALIZER_P (init)
+		  && CONSTRUCTOR_NELTS (init) == 0)
+		/* Reuse it.  */;
+	      else
+		init = build_constructor (init_list_type_node, NULL);
+	      CONSTRUCTOR_IS_DIRECT_INIT (init) = true;
+	    }
+	  else
+	    {
+	      init = NULL_TREE;
+	      explicit_value_init_p = true;
+	    }
+	}
+
       if (from_array)
 	{
 	  tree from;
@@ -3846,6 +3852,13 @@
 
   stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);
 
+  current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;
+
+  if (errors)
+    return error_mark_node;
+  if (const_init)
+    return build2 (INIT_EXPR, atype, obase, const_init);
+
   /* Now make the result have the correct type.  */
   if (TREE_CODE (atype) == ARRAY_TYPE)
     {
@@ -3855,12 +3868,6 @@
       TREE_NO_WARNING (stmt_expr) = 1;
     }
 
-  current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;
-
-  if (const_init)
-    return build2 (INIT_EXPR, atype, obase, const_init);
-  if (errors)
-    return error_mark_node;
   return stmt_expr;
 }
 
Index: gcc/cp/class.c
===================================================================
--- a/src/gcc/cp/class.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/class.c	(.../branches/gcc-4_9-branch)
@@ -7251,6 +7251,29 @@
   return NULL_TREE;
 }
 
+/* Return the outermost enclosing class type that is still open, or
+   NULL_TREE.  */
+
+tree
+outermost_open_class (void)
+{
+  if (!current_class_type)
+    return NULL_TREE;
+  tree r = NULL_TREE;
+  if (TYPE_BEING_DEFINED (current_class_type))
+    r = current_class_type;
+  for (int i = current_class_depth - 1; i > 0; --i)
+    {
+      if (current_class_stack[i].hidden)
+	break;
+      tree t = current_class_stack[i].type;
+      if (!TYPE_BEING_DEFINED (t))
+	break;
+      r = t;
+    }
+  return r;
+}
+
 /* Returns the innermost class type which is not a lambda closure type.  */
 
 tree
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-4_9-branch)
@@ -14177,8 +14177,8 @@
 /* VAR is a VAR_DECL.  If its type is incomplete, remember VAR so that
    we can lay it out later, when and if its type becomes complete.
 
-   Also handle constexpr pointer to member variables where the initializer
-   is an unlowered PTRMEM_CST because the class isn't complete yet.  */
+   Also handle constexpr variables where the initializer involves
+   an unlowered PTRMEM_CST because the class isn't complete yet.  */
 
 void
 maybe_register_incomplete_var (tree var)
@@ -14203,12 +14203,13 @@
 	  incomplete_var iv = {var, inner_type};
 	  vec_safe_push (incomplete_vars, iv);
 	}
-      else if (TYPE_PTRMEM_P (inner_type)
-	       && DECL_INITIAL (var)
-	       && TREE_CODE (DECL_INITIAL (var)) == PTRMEM_CST)
+      else if (!(DECL_LANG_SPECIFIC (var) && DECL_TEMPLATE_INFO (var))
+	       && decl_constant_var_p (var)
+	       && (TYPE_PTRMEM_P (inner_type) || CLASS_TYPE_P (inner_type)))
 	{
-	  tree context = TYPE_PTRMEM_CLASS_TYPE (inner_type);
-	  gcc_assert (TYPE_BEING_DEFINED (context));
+	  /* When the outermost open class is complete we can resolve any
+	     pointers-to-members.  */
+	  tree context = outermost_open_class ();
 	  incomplete_var iv = {var, context};
 	  vec_safe_push (incomplete_vars, iv);
 	}
@@ -14232,9 +14233,8 @@
 	  tree var = iv->decl;
 	  tree type = TREE_TYPE (var);
 
-	  if (TYPE_PTRMEM_P (type))
-	    DECL_INITIAL (var) = cplus_expand_constant (DECL_INITIAL (var));
-	  else
+	  if (TYPE_MAIN_VARIANT (strip_array_types (type))
+	      == iv->incomplete_type)
 	    {
 	      /* Complete the type of the variable.  The VAR_DECL itself
 		 will be laid out in expand_expr.  */
@@ -14242,6 +14242,10 @@
 	      cp_apply_type_quals_to_decl (cp_type_quals (type), var);
 	    }
 
+	  if (DECL_INITIAL (var)
+	      && decl_constant_var_p (var))
+	    DECL_INITIAL (var) = cplus_expand_constant (DECL_INITIAL (var));
+
 	  /* Remove this entry from the list.  */
 	  incomplete_vars->unordered_remove (ix);
 	}
Index: gcc/cp/method.c
===================================================================
--- a/src/gcc/cp/method.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/method.c	(.../branches/gcc-4_9-branch)
@@ -1773,6 +1773,7 @@
   DECL_EXTERNAL (fn) = true;
   DECL_NOT_REALLY_EXTERN (fn) = 1;
   DECL_DECLARED_INLINE_P (fn) = 1;
+  note_comdat_fn (fn);
   gcc_assert (!TREE_USED (fn));
 
   /* Restore PROCESSING_TEMPLATE_DECL.  */
Index: gcc/cp/tree.c
===================================================================
--- a/src/gcc/cp/tree.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/tree.c	(.../branches/gcc-4_9-branch)
@@ -3795,6 +3795,10 @@
     {
       init_expr = get_target_expr (exp);
       exp = TARGET_EXPR_SLOT (init_expr);
+      if (CLASS_TYPE_P (TREE_TYPE (exp)))
+	exp = move (exp);
+      else
+	exp = rvalue (exp);
     }
   else
     {
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,149 @@
+2014-10-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63415
+	* pt.c (value_dependent_expression_p) [CONSTRUCTOR]: Check the type.
+	(iterative_hash_template_arg): Likewise.
+
+	PR c++/63437
+	* cp-tree.h (REF_PARENTHESIZED_P): Also allow INDIRECT_REF.
+	* semantics.c (force_paren_expr): And set it.
+	* typeck.c (check_return_expr): And handle it.
+
+2014-10-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63405
+	* pt.c (tsubst_pack_expansion): Limit simple expansion to type packs.
+
+2014-09-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/63249
+	* semantics.c (handle_omp_array_sections_1): Call mark_rvalue_use
+	on low_bound and length.
+
+2014-09-22  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/62219
+	* pt.c (check_default_tmpl_args): Check LAMBDA_FUNCTION_P.
+
+2014-09-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/61465
+	* call.c (convert_like_real) [ck_identity]: Call mark_rvalue_use
+	after pulling out an element from a CONSTRUCTOR.
+
+2014-09-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/63248
+	* semantics.c (finish_omp_clauses): Don't call cp_omp_mappable_type
+	on type of type dependent expressions, and don't call it if
+	handle_omp_array_sections has kept TREE_LIST because something
+	was type dependent.
+	* pt.c (tsubst_expr) <case OMP_TARGET, case OMP_TARGET_DATA>:
+	Use keep_next_level, begin_omp_structured_block and
+	finish_omp_structured_block instead of push_stmt_list and
+	pop_stmt_list.
+
+2014-09-10  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63139
+	* pt.c (tsubst_pack_expansion): Simplify substitution into T....
+
+2014-09-09  Jason Merrill  <jason@redhat.com>
+
+	PR lto/53808
+	PR c++/61659
+	* decl2.c (note_comdat_fn): New.
+	(set_comdat): New.
+	(cp_write_global_declarations): Call set_comdat.
+	* method.c (implicitly_declare_fn): Call note_comdat_fn.
+	* pt.c (tsubst_decl) [FUNCTION_DECL]: Likewise.
+	* decl2.c (mark_needed): Mark clones.
+	(import_export_decl): Not here.
+
+	PR c++/61214
+	PR c++/62224
+	* decl2.c (decl_needed_p): Revert virtual functions change.
+
+2014-09-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/62659
+	* semantics.c (potential_constant_expression_1): Handle un-folded
+	pointer to member constants.
+
+2014-08-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/58624
+	* pt.c (tsubst_copy_and_build) [VAR_DECL]: Use TLS wrapper.
+	* semantics.c (finish_id_expression): Don't call TLS wrapper in a
+	template.
+
+2014-08-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/62129
+	* class.c (outermost_open_class): New.
+	* cp-tree.h: Declare it.
+	* decl.c (maybe_register_incomplete_var): Use it.
+	(complete_vars): Handle any constant variable.
+	* expr.c (cplus_expand_constant): Handle CONSTRUCTOR.
+
+2014-08-22  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/62008
+	* cp-array-notation.c (build_array_notation_ref): Added correct
+	handling of case with incorrect array.
+
+2014-08-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/61214
+	PR tree-optimization/62091
+	* decl2.c (decl_needed_p): Return true for virtual functions when
+	devirtualizing.
+
+	Backport:
+	PR c++/61566
+	* pt.c (instantiate_class_template_1): Ignore lambda on
+	CLASSTYPE_DECL_LIST.
+	(push_template_decl_real): A lambda is not primary.
+	* lambda.c (maybe_add_lambda_conv_op): Distinguish between being
+	currently in a function and the lambda living in a function.
+
+	Backport:
+	PR c++/60417
+	* init.c (build_vec_init): Set CONSTRUCTOR_IS_DIRECT_INIT on
+	init-list for trailing elements.
+	* typeck2.c (process_init_constructor_array): Likewise.
+
+2014-08-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/61959
+	* semantics.c (cxx_eval_bare_aggregate): Handle POINTER_PLUS_EXPR.
+
+	PR c++/61994
+	* init.c (build_vec_init): Leave atype an ARRAY_TYPE
+	if we're just returning an INIT_EXPR.
+
+	PR c++/60872
+	* call.c (standard_conversion): Don't try to apply restrict to void.
+
+	PR c++/58714
+	* tree.c (stabilize_expr): A stabilized prvalue is an xvalue.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	* cp-array-notation.c (expand_an_in_modify_expr): Fix the misprint
+	in error output.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR other/61963
+	* parser.c (cp_parser_array_notation): Added check for array_type.
+
+2014-08-01  Igor Zamyatin  <igor.zamyatin@intel.com>
+
+	PR middle-end/61455
+	* cp-array-notation.c (expand_array_notation_exprs): Handling of
+	DECL_EXPR improved. Changed handling for INIT_EXPR.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/cp/cp-array-notation.c
===================================================================
--- a/src/gcc/cp/cp-array-notation.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/cp-array-notation.c	(.../branches/gcc-4_9-branch)
@@ -607,7 +607,7 @@
     
   if (lhs_rank == 0 && rhs_rank != 0)
     {
-      error_at (location, "%qD cannot be scalar when %qD is not", lhs, rhs);
+      error_at (location, "%qE cannot be scalar when %qE is not", lhs, rhs);
       return error_mark_node;
     }
   if (lhs_rank != 0 && rhs_rank != 0 && lhs_rank != rhs_rank)
@@ -1147,7 +1147,6 @@
     case PARM_DECL:
     case NON_LVALUE_EXPR:
     case NOP_EXPR:
-    case INIT_EXPR:
     case ADDR_EXPR:
     case ARRAY_REF:
     case BIT_FIELD_REF:
@@ -1154,6 +1153,7 @@
     case VECTOR_CST:
     case COMPLEX_CST:
       return t;
+    case INIT_EXPR:
     case MODIFY_EXPR:
       if (contains_array_notation_expr (t))
 	t = expand_an_in_modify_expr (loc, TREE_OPERAND (t, 0), NOP_EXPR, 
@@ -1175,13 +1175,24 @@
 	return t;
       }
     case DECL_EXPR:
-      {
-	tree x = DECL_EXPR_DECL (t);
-	if (t && TREE_CODE (x) != FUNCTION_DECL)
+      if (contains_array_notation_expr (t))
+	{
+	  tree x = DECL_EXPR_DECL (t);
 	  if (DECL_INITIAL (x))
-	    t = expand_unary_array_notation_exprs (t);
+	    {
+	      location_t loc = DECL_SOURCE_LOCATION (x);
+	      tree lhs = x;
+	      tree rhs = DECL_INITIAL (x);
+	      DECL_INITIAL (x) = NULL;
+	      tree new_modify_expr = build_modify_expr (loc, lhs,
+							TREE_TYPE (lhs),
+							NOP_EXPR,
+							loc, rhs,
+							TREE_TYPE(rhs));
+	      t = expand_array_notation_exprs (new_modify_expr);
+	    }
+	}
       return t;
-      }
     case STATEMENT_LIST:
       {
 	tree_stmt_iterator i;
@@ -1392,7 +1403,10 @@
   if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == POINTER_TYPE)
     TREE_TYPE (array_ntn_expr) = TREE_TYPE (type);
   else
-    gcc_unreachable ();
+    {
+      error_at (loc, "base of array section must be pointer or array type");
+      return error_mark_node;
+    }
 
   SET_EXPR_LOCATION (array_ntn_expr, loc);
   return array_ntn_expr;
Index: gcc/cp/expr.c
===================================================================
--- a/src/gcc/cp/expr.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/expr.c	(.../branches/gcc-4_9-branch)
@@ -74,6 +74,14 @@
       }
       break;
 
+    case CONSTRUCTOR:
+      {
+	constructor_elt *elt;
+	unsigned HOST_WIDE_INT idx;
+	FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (cst), idx, elt)
+	  elt->value = cplus_expand_constant (elt->value);
+      }
+
     default:
       /* There's nothing to do.  */
       break;
Index: gcc/cp/typeck2.c
===================================================================
--- a/src/gcc/cp/typeck2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/typeck2.c	(.../branches/gcc-4_9-branch)
@@ -1237,8 +1237,9 @@
 	  {
 	    /* If this type needs constructors run for default-initialization,
 	       we can't rely on the back end to do it for us, so make the
-	       initialization explicit by list-initializing from {}.  */
+	       initialization explicit by list-initializing from T{}.  */
 	    next = build_constructor (init_list_type_node, NULL);
+	    CONSTRUCTOR_IS_DIRECT_INIT (next) = true;
 	    next = massage_init_elt (TREE_TYPE (type), next, complain);
 	    if (initializer_zerop (next))
 	      /* The default zero-initialization is fine for us; don't
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-4_9-branch)
@@ -1601,6 +1601,7 @@
     case CONSTRUCTOR:
       {
 	tree field, value;
+	iterative_hash_template_arg (TREE_TYPE (arg), val);
 	FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (arg), i, field, value)
 	  {
 	    val = iterative_hash_template_arg (field, val);
@@ -4430,9 +4431,11 @@
        local scope.  */
     return true;
 
-  if (TREE_CODE (decl) == TYPE_DECL
-      && TREE_TYPE (decl)
-      && LAMBDA_TYPE_P (TREE_TYPE (decl)))
+  if ((TREE_CODE (decl) == TYPE_DECL
+       && TREE_TYPE (decl)
+       && LAMBDA_TYPE_P (TREE_TYPE (decl)))
+      || (TREE_CODE (decl) == FUNCTION_DECL
+	  && LAMBDA_FUNCTION_P (decl)))
     /* A lambda doesn't have an explicit declaration; don't complain
        about the parms of the enclosing class.  */
     return true;
@@ -4697,6 +4700,9 @@
          template <typename T> friend void A<T>::f();
        is not primary.  */
     is_primary = false;
+  else if (TREE_CODE (decl) == TYPE_DECL
+	   && LAMBDA_TYPE_P (TREE_TYPE (decl)))
+    is_primary = false;
   else
     is_primary = template_parm_scope_p ();
 
@@ -9135,6 +9141,11 @@
 		  && DECL_OMP_DECLARE_REDUCTION_P (r))
 		cp_check_omp_declare_reduction (r);
 	    }
+	  else if (DECL_CLASS_TEMPLATE_P (t)
+		   && LAMBDA_TYPE_P (TREE_TYPE (t)))
+	    /* A closure type for a lambda in a default argument for a
+	       member template.  Ignore it; it will be instantiated with
+	       the default argument.  */;
 	  else
 	    {
 	      /* Build new TYPE_FIELDS.  */
@@ -9808,6 +9819,17 @@
 	}
     }
 
+  /* If the expansion is just T..., return the matching argument pack.  */
+  if (!unsubstituted_packs
+      && TREE_PURPOSE (packs) == pattern)
+    {
+      tree args = ARGUMENT_PACK_ARGS (TREE_VALUE (packs));
+      if (TREE_CODE (t) == TYPE_PACK_EXPANSION
+	  || pack_expansion_args_count (args))
+	return args;
+      /* Otherwise use the normal path so we get convert_from_reference.  */
+    }
+
   /* We cannot expand this expansion expression, because we don't have
      all of the argument packs we need.  */
   if (use_pack_expansion_extra_args_p (packs, len, unsubstituted_packs))
@@ -10669,6 +10691,9 @@
 		 the type earlier (template/friend54.C).  */
 	      RETURN (new_r);
 
+	    if (!DECL_FRIEND_P (r))
+	      note_comdat_fn (r);
+
 	    /* We're not supposed to instantiate default arguments
 	       until they are called, for a template.  But, for a
 	       declaration like:
@@ -13852,8 +13877,6 @@
     case OMP_SECTIONS:
     case OMP_SINGLE:
     case OMP_TEAMS:
-    case OMP_TARGET_DATA:
-    case OMP_TARGET:
       tmp = tsubst_omp_clauses (OMP_CLAUSES (t), false,
 				args, complain, in_decl);
       stmt = push_stmt_list ();
@@ -13866,6 +13889,22 @@
       add_stmt (t);
       break;
 
+    case OMP_TARGET_DATA:
+    case OMP_TARGET:
+      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), false,
+				args, complain, in_decl);
+      keep_next_level (true);
+      stmt = begin_omp_structured_block ();
+
+      RECUR (OMP_BODY (t));
+      stmt = finish_omp_structured_block (stmt);
+
+      t = copy_node (t);
+      OMP_BODY (t) = stmt;
+      OMP_CLAUSES (t) = tmp;
+      add_stmt (t);
+      break;
+
     case OMP_TARGET_UPDATE:
       tmp = tsubst_omp_clauses (OMP_TARGET_UPDATE_CLAUSES (t), false,
 				args, complain, in_decl);
@@ -15185,6 +15224,16 @@
     case PARM_DECL:
       {
 	tree r = tsubst_copy (t, args, complain, in_decl);
+	if (TREE_CODE (r) == VAR_DECL
+	    && !processing_template_decl
+	    && !cp_unevaluated_operand
+	    && DECL_THREAD_LOCAL_P (r))
+	  {
+	    if (tree wrap = get_tls_wrapper_fn (r))
+	      /* Replace an evaluated use of the thread_local variable with
+		 a call to its wrapper.  */
+	      r = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
+	  }
 
 	if (TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)
 	  /* If the original type was a reference, we'll be wrapped in
@@ -20747,6 +20796,8 @@
       {
 	unsigned ix;
 	tree val;
+	if (dependent_type_p (TREE_TYPE (expression)))
+	  return true;
 	FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expression), ix, val)
 	  if (value_dependent_expression_p (val))
 	    return true;
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-4_9-branch)
@@ -1630,6 +1630,8 @@
 	  bool rval = !!(kind & clk_rvalueref);
 	  type = cp_build_reference_type (type, rval);
 	  expr = build_static_cast (type, expr, tf_error);
+	  if (expr != error_mark_node)
+	    REF_PARENTHESIZED_P (expr) = true;
 	}
     }
 
@@ -3490,6 +3492,7 @@
       tree wrap;
       if (VAR_P (decl)
 	  && !cp_unevaluated_operand
+	  && !processing_template_decl
 	  && DECL_THREAD_LOCAL_P (decl)
 	  && (wrap = get_tls_wrapper_fn (decl)))
 	{
@@ -4261,6 +4264,10 @@
 		length);
       return error_mark_node;
     }
+  if (low_bound)
+    low_bound = mark_rvalue_use (low_bound);
+  if (length)
+    length = mark_rvalue_use (length);
   if (low_bound
       && TREE_CODE (low_bound) == INTEGER_CST
       && TYPE_PRECISION (TREE_TYPE (low_bound))
@@ -5626,7 +5633,9 @@
 	      else
 		{
 		  t = OMP_CLAUSE_DECL (c);
-		  if (!cp_omp_mappable_type (TREE_TYPE (t)))
+		  if (TREE_CODE (t) != TREE_LIST
+		      && !type_dependent_expression_p (t)
+		      && !cp_omp_mappable_type (TREE_TYPE (t)))
 		    {
 		      error_at (OMP_CLAUSE_LOCATION (c),
 				"array section does not have mappable type "
@@ -5666,6 +5675,7 @@
 	    remove = true;
 	  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP
 		     && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)
+		   && !type_dependent_expression_p (t)
 		   && !cp_omp_mappable_type ((TREE_CODE (TREE_TYPE (t))
 					      == REFERENCE_TYPE)
 					     ? TREE_TYPE (TREE_TYPE (t))
@@ -8955,7 +8965,9 @@
 	  constructor_elt *inner = base_field_constructor_elt (n, ce->index);
 	  inner->value = elt;
 	}
-      else if (ce->index && TREE_CODE (ce->index) == NOP_EXPR)
+      else if (ce->index
+	       && (TREE_CODE (ce->index) == NOP_EXPR
+		   || TREE_CODE (ce->index) == POINTER_PLUS_EXPR))
 	{
 	  /* This is an initializer for an empty base; now that we've
 	     checked that it's constant, we can ignore it.  */
@@ -10178,6 +10190,11 @@
             designates an object with thread or automatic storage
             duration;  */
       t = TREE_OPERAND (t, 0);
+
+      if (TREE_CODE (t) == OFFSET_REF && PTRMEM_OK_P (t))
+	/* A pointer-to-member constant.  */
+	return true;
+
 #if 0
       /* FIXME adjust when issue 1197 is fully resolved.  For now don't do
          any checking here, as we might dereference the pointer later.  If
Index: gcc/cp/decl2.c
===================================================================
--- a/src/gcc/cp/decl2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/decl2.c	(.../branches/gcc-4_9-branch)
@@ -99,6 +99,10 @@
    may need to emit outline anyway.  */
 static GTY(()) vec<tree, va_gc> *deferred_fns;
 
+/* A list of functions which we might want to set DECL_COMDAT on at EOF.  */
+
+static GTY(()) vec<tree, va_gc> *maybe_comdat_fns;
+
 /* A list of decls that use types with no linkage, which we need to make
    sure are defined.  */
 static GTY(()) vec<tree, va_gc> *no_linkage_decls;
@@ -1896,6 +1900,12 @@
 	 definition.  */
       struct cgraph_node *node = cgraph_get_create_node (decl);
       node->forced_by_abi = true;
+
+      /* #pragma interface and -frepo code can call mark_needed for
+          maybe-in-charge 'tors; mark the clones as well.  */
+      tree clone;
+      FOR_EACH_CLONE (clone, decl)
+	mark_needed (clone);
     }
   else if (TREE_CODE (decl) == VAR_DECL)
     {
@@ -2678,17 +2688,7 @@
     {
       /* The repository indicates that this entity should be defined
 	 here.  Make sure the back end honors that request.  */
-      if (VAR_P (decl))
-	mark_needed (decl);
-      else if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)
-	       || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))
-	{
-	  tree clone;
-	  FOR_EACH_CLONE (clone, decl)
-	    mark_needed (clone);
-	}
-      else
-	mark_needed (decl);
+      mark_needed (decl);
       /* Output the definition as an ordinary strong definition.  */
       DECL_EXTERNAL (decl) = 0;
       DECL_INTERFACE_KNOWN (decl) = 1;
@@ -4231,6 +4231,34 @@
     }
 }
 
+/* Much like the above, but not necessarily defined.  4.9 hack for setting
+   DECL_COMDAT on DECL_EXTERNAL functions, along with set_comdat.  */
+
+void
+note_comdat_fn (tree decl)
+{
+  vec_safe_push (maybe_comdat_fns, decl);
+}
+
+/* DECL is a function with vague linkage that was not
+   instantiated/synthesized in this translation unit.  Set DECL_COMDAT for
+   the benefit of can_refer_decl_in_current_unit_p.  */
+
+static void
+set_comdat (tree decl)
+{
+  DECL_COMDAT (decl) = true;
+
+  tree clone;
+  FOR_EACH_CLONE (clone, decl)
+    set_comdat (clone);
+
+  if (DECL_VIRTUAL_P (decl))
+    for (tree thunk = DECL_THUNKS (decl); thunk;
+	 thunk = DECL_CHAIN (thunk))
+      DECL_COMDAT (thunk) = true;
+}
+
 /* This routine is called at the end of compilation.
    Its job is to create all the code needed to initialize and
    destroy the global aggregates.  We do the destruction
@@ -4608,6 +4636,10 @@
       vtv_build_vtable_verify_fndecl ();
     }
 
+  FOR_EACH_VEC_SAFE_ELT (maybe_comdat_fns, i, decl)
+    if (!DECL_COMDAT (decl) && vague_linkage_p (decl))
+      set_comdat (decl);
+
   finalize_compilation_unit ();
 
   if (flag_vtable_verify)
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-4_9-branch)
@@ -6306,7 +6306,7 @@
   parser->colon_corrects_to_scope_p = saved_colon_corrects;
 
   if (*init_index == error_mark_node || length_index == error_mark_node
-      || stride == error_mark_node)
+      || stride == error_mark_node || array_type == error_mark_node)
     {
       if (cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_SQUARE)
 	cp_lexer_consume_token (parser->lexer);
Index: gcc/cp/call.c
===================================================================
--- a/src/gcc/cp/call.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/call.c	(.../branches/gcc-4_9-branch)
@@ -1208,9 +1208,10 @@
 	       && TREE_CODE (TREE_TYPE (from)) != FUNCTION_TYPE)
 	{
 	  tree nfrom = TREE_TYPE (from);
+	  /* Don't try to apply restrict to void.  */
+	  int quals = cp_type_quals (nfrom) & ~TYPE_QUAL_RESTRICT;
 	  from = build_pointer_type
-	    (cp_build_qualified_type (void_type_node, 
-			              cp_type_quals (nfrom)));
+	    (cp_build_qualified_type (void_type_node, quals));
 	  conv = build_conv (ck_ptr, from, conv);
 	}
       else if (TYPE_PTRDATAMEM_P (from))
@@ -6077,7 +6078,6 @@
 	return expr;
       }
     case ck_identity:
-      expr = mark_rvalue_use (expr);
       if (BRACE_ENCLOSED_INITIALIZER_P (expr))
 	{
 	  int nelts = CONSTRUCTOR_NELTS (expr);
@@ -6088,6 +6088,7 @@
 	  else
 	    gcc_unreachable ();
 	}
+      expr = mark_rvalue_use (expr);
 
       if (type_unknown_p (expr))
 	expr = instantiate_type (totype, expr, complain);
Index: gcc/cp/lambda.c
===================================================================
--- a/src/gcc/cp/lambda.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/lambda.c	(.../branches/gcc-4_9-branch)
@@ -820,6 +820,7 @@
 maybe_add_lambda_conv_op (tree type)
 {
   bool nested = (current_function_decl != NULL_TREE);
+  bool nested_def = decl_function_context (TYPE_MAIN_DECL (type));
   tree callop = lambda_function (type);
 
   if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)
@@ -972,7 +973,7 @@
   DECL_NOT_REALLY_EXTERN (fn) = 1;
   DECL_DECLARED_INLINE_P (fn) = 1;
   DECL_ARGUMENTS (fn) = build_this_parm (fntype, TYPE_QUAL_CONST);
-  if (nested)
+  if (nested_def)
     DECL_INTERFACE_KNOWN (fn) = 1;
 
   if (generic_lambda_p)
@@ -1012,7 +1013,7 @@
       DECL_NAME (arg) = NULL_TREE;
       DECL_CONTEXT (arg) = fn;
     }
-  if (nested)
+  if (nested_def)
     DECL_INTERFACE_KNOWN (fn) = 1;
 
   if (generic_lambda_p)
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-4_9-branch)
@@ -100,7 +100,7 @@
       TARGET_EXPR_DIRECT_INIT_P (in TARGET_EXPR)
       FNDECL_USED_AUTO (in FUNCTION_DECL)
       DECLTYPE_FOR_LAMBDA_PROXY (in DECLTYPE_TYPE)
-      REF_PARENTHESIZED_P (in COMPONENT_REF, SCOPE_REF)
+      REF_PARENTHESIZED_P (in COMPONENT_REF, INDIRECT_REF)
       AGGR_INIT_ZERO_FIRST (in AGGR_INIT_EXPR)
    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).
       ICS_BAD_FLAG (in _CONV)
@@ -3038,11 +3038,12 @@
 #define PAREN_STRING_LITERAL_P(NODE) \
   TREE_LANG_FLAG_0 (STRING_CST_CHECK (NODE))
 
-/* Indicates whether a COMPONENT_REF has been parenthesized.  Currently
-   only set some of the time in C++14 mode.  */
+/* Indicates whether a COMPONENT_REF has been parenthesized, or an
+   INDIRECT_REF comes from parenthesizing a VAR_DECL.  Currently only set
+   some of the time in C++14 mode.  */
 
 #define REF_PARENTHESIZED_P(NODE) \
-  TREE_LANG_FLAG_2 (COMPONENT_REF_CHECK (NODE))
+  TREE_LANG_FLAG_2 (TREE_CHECK2 ((NODE), COMPONENT_REF, INDIRECT_REF))
 
 /* Nonzero if this AGGR_INIT_EXPR provides for initialization via a
    constructor call, rather than an ordinary function call.  */
@@ -5112,6 +5113,7 @@
 extern bool add_method				(tree, tree, tree);
 extern bool currently_open_class		(tree);
 extern tree currently_open_derived_class	(tree);
+extern tree outermost_open_class		(void);
 extern tree current_nonlambda_class_type	(void);
 extern tree finish_struct			(tree, tree);
 extern void finish_struct_1			(tree);
@@ -5351,6 +5353,7 @@
 extern void mark_needed				(tree);
 extern bool decl_needed_p			(tree);
 extern void note_vague_linkage_fn		(tree);
+extern void note_comdat_fn			(tree);
 extern tree build_artificial_parm		(tree, tree);
 extern bool possibly_inlined_p			(tree);
 extern int parm_index                           (tree);
Index: gcc/haifa-sched.c
===================================================================
--- a/src/gcc/haifa-sched.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/haifa-sched.c	(.../branches/gcc-4_9-branch)
@@ -2972,7 +2972,7 @@
 {
   advance_state (curr_state);
   if (sched_verbose >= 6)
-    fprintf (sched_dump, ";;\tAdvanced a state.\n");
+    fprintf (sched_dump, ";;\tAdvance the current state.\n");
 }
 
 /* Update register pressure after scheduling INSN.  */
@@ -6007,6 +6007,7 @@
   modulo_insns_scheduled = 0;
 
   ls.modulo_epilogue = false;
+  ls.first_cycle_insn_p = true;
 
   /* Loop until all the insns in BB are scheduled.  */
   while ((*current_sched_info->schedule_more_p) ())
@@ -6077,7 +6078,6 @@
       if (must_backtrack)
 	goto do_backtrack;
 
-      ls.first_cycle_insn_p = true;
       ls.shadows_only_p = false;
       cycle_issued_insns = 0;
       ls.can_issue_more = issue_rate;
@@ -6363,11 +6363,13 @@
 	      break;
 	    }
 	}
+      ls.first_cycle_insn_p = true;
     }
   if (ls.modulo_epilogue)
     success = true;
  end_schedule:
-  advance_one_cycle ();
+  if (!ls.first_cycle_insn_p || advance)
+    advance_one_cycle ();
   perform_replacements_new_cycle ();
   if (modulo_ii > 0)
     {
Index: gcc/cgraphclones.c
===================================================================
--- a/src/gcc/cgraphclones.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cgraphclones.c	(.../branches/gcc-4_9-branch)
@@ -310,6 +310,11 @@
   if (thunk_of->thunk.thunk_p)
     node = duplicate_thunk_for_node (thunk_of, node);
 
+   /* We need to copy arguments, at LTO these mat not be read from function
+      section.  */
+  if (!DECL_ARGUMENTS (thunk->decl))
+    cgraph_get_body (thunk);
+
   struct cgraph_edge *cs;
   for (cs = node->callers; cs; cs = cs->next_caller)
     if (cs->caller->thunk.thunk_p
@@ -334,6 +339,22 @@
 						node->clone.args_to_skip,
 						false);
     }
+
+  tree *link = &DECL_ARGUMENTS (new_decl);
+  int i = 0;
+  for (tree pd = DECL_ARGUMENTS (thunk->decl); pd; pd = DECL_CHAIN (pd), i++)
+    {
+      if (!node->clone.args_to_skip
+	  || !bitmap_bit_p (node->clone.args_to_skip, i))
+	{
+	  tree nd = copy_node (pd);
+	  DECL_CONTEXT (nd) = new_decl;
+	  *link = nd;
+	  link = &DECL_CHAIN (nd);
+	}
+    }
+  *link = NULL_TREE;
+
   gcc_checking_assert (!DECL_STRUCT_FUNCTION (new_decl));
   gcc_checking_assert (!DECL_INITIAL (new_decl));
   gcc_checking_assert (!DECL_RESULT (new_decl));
@@ -358,6 +379,11 @@
   cgraph_call_edge_duplication_hooks (thunk->callees, e);
   if (!expand_thunk (new_thunk, false))
     new_thunk->analyzed = true;
+  else
+    {
+      new_thunk->thunk.thunk_p = false;
+      cgraph_analyze_function (new_thunk);
+    }
   cgraph_call_node_duplication_hooks (thunk, new_thunk);
   return new_thunk;
 }
Index: gcc/tree-ssa-loop-ivopts.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ivopts.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-loop-ivopts.c	(.../branches/gcc-4_9-branch)
@@ -1679,6 +1679,8 @@
     return false;
 
   unsigned int align = TYPE_ALIGN (TREE_TYPE (ref));
+  if (GET_MODE_ALIGNMENT (TYPE_MODE (TREE_TYPE (ref))) > align)
+    align = GET_MODE_ALIGNMENT (TYPE_MODE (TREE_TYPE (ref)));
 
   unsigned HOST_WIDE_INT bitpos;
   unsigned int ref_align;
Index: gcc/cse.c
===================================================================
--- a/src/gcc/cse.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cse.c	(.../branches/gcc-4_9-branch)
@@ -2680,7 +2680,7 @@
 	     But because really all MEM attributes should be the same for
 	     equivalent MEMs, we just use the invariant that MEMs that have
 	     the same attributes share the same mem_attrs data structure.  */
-	  if (MEM_ATTRS (x) != MEM_ATTRS (y))
+	  if (!mem_attrs_eq_p (MEM_ATTRS (x), MEM_ATTRS (y)))
 	    return 0;
 	}
       break;
Index: gcc/lto-streamer-out.c
===================================================================
--- a/src/gcc/lto-streamer-out.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/lto-streamer-out.c	(.../branches/gcc-4_9-branch)
@@ -2077,7 +2077,10 @@
 #endif
 	      decl_state = lto_new_out_decl_state ();
 	      lto_push_out_decl_state (decl_state);
-	      if (gimple_has_body_p (node->decl) || !flag_wpa)
+	      if (gimple_has_body_p (node->decl) || !flag_wpa
+		  /* Thunks have no body but they may be synthetized
+		     at WPA time.  */
+		  || DECL_ARGUMENTS (node->decl))
 		output_function (node);
 	      else
 		copy_function (node);
Index: gcc/tree-ssa-math-opts.c
===================================================================
--- a/src/gcc/tree-ssa-math-opts.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-math-opts.c	(.../branches/gcc-4_9-branch)
@@ -1749,6 +1749,8 @@
 	  size = TYPE_PRECISION (n->type);
 	  if (size % BITS_PER_UNIT != 0)
 	    return NULL_TREE;
+	  if (size > HOST_BITS_PER_WIDEST_INT)
+	    return NULL_TREE;
 	  size /= BITS_PER_UNIT;
 	  n->n = (sizeof (HOST_WIDEST_INT) < 8 ? 0 :
 		  (unsigned HOST_WIDEST_INT)0x08070605 << 32 | 0x04030201);
@@ -1792,6 +1794,8 @@
 	    type_size = TYPE_PRECISION (type);
 	    if (type_size % BITS_PER_UNIT != 0)
 	      return NULL_TREE;
+	    if (type_size > (int) HOST_BITS_PER_WIDEST_INT)
+	      return NULL_TREE;
 
 	    /* Sign extension: result is dependent on the value.  */
 	    old_type_size = TYPE_PRECISION (n->type);
@@ -1932,7 +1936,7 @@
   bool changed = false;
   tree bswap16_type = NULL_TREE, bswap32_type = NULL_TREE, bswap64_type = NULL_TREE;
 
-  if (BITS_PER_UNIT != 8)
+  if (BITS_PER_UNIT != 8 || CHAR_BIT != 8)
     return 0;
 
   if (sizeof (HOST_WIDEST_INT) < 8)
Index: gcc/tree-nrv.c
===================================================================
--- a/src/gcc/tree-nrv.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-nrv.c	(.../branches/gcc-4_9-branch)
@@ -187,8 +187,7 @@
 		 same type and alignment as the function's result.  */
 	      if (TREE_CODE (found) != VAR_DECL
 		  || TREE_THIS_VOLATILE (found)
-		  || DECL_CONTEXT (found) != current_function_decl
-		  || TREE_STATIC (found)
+		  || !auto_var_in_fn_p (found, current_function_decl)
 		  || TREE_ADDRESSABLE (found)
 		  || DECL_ALIGN (found) > DECL_ALIGN (result)
 		  || !useless_type_conversion_p (result_type,
Index: gcc/ifcvt.c
===================================================================
--- a/src/gcc/ifcvt.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ifcvt.c	(.../branches/gcc-4_9-branch)
@@ -306,6 +306,28 @@
 
   return (e) ? e->dest : NULL_BLOCK;
 }
+
+/* Return true if RTXs A and B can be safely interchanged.  */
+
+static bool
+rtx_interchangeable_p (const_rtx a, const_rtx b)
+{
+  if (!rtx_equal_p (a, b))
+    return false;
+
+  if (GET_CODE (a) != MEM)
+    return true;
+
+  /* A dead type-unsafe memory reference is legal, but a live type-unsafe memory
+     reference is not.  Interchanging a dead type-unsafe memory reference with
+     a live type-safe one creates a live type-unsafe memory reference, in other
+     words, it makes the program illegal.
+     We check here conservatively whether the two memory references have equal
+     memory attributes.  */
+
+  return mem_attrs_eq_p (get_mem_attrs (a), get_mem_attrs (b));
+}
+
 
 /* Go through a bunch of insns, converting them to conditional
    execution format if possible.  Return TRUE if all of the non-note
@@ -1034,6 +1056,9 @@
       || (rtx_equal_p (if_info->a, XEXP (cond, 1))
 	  && rtx_equal_p (if_info->b, XEXP (cond, 0))))
     {
+      if (!rtx_interchangeable_p (if_info->a, if_info->b))
+	return FALSE;
+
       y = (code == EQ) ? if_info->a : if_info->b;
 
       /* Avoid generating the move if the source is the destination.  */
@@ -2504,7 +2529,7 @@
       if (! insn_b
 	  || insn_b != last_active_insn (else_bb, FALSE)
 	  || (set_b = single_set (insn_b)) == NULL_RTX
-	  || ! rtx_equal_p (x, SET_DEST (set_b)))
+	  || ! rtx_interchangeable_p (x, SET_DEST (set_b)))
 	return FALSE;
     }
   else
@@ -2517,7 +2542,7 @@
 	  || BLOCK_FOR_INSN (insn_b) != BLOCK_FOR_INSN (if_info->cond_earliest)
 	  || !NONJUMP_INSN_P (insn_b)
 	  || (set_b = single_set (insn_b)) == NULL_RTX
-	  || ! rtx_equal_p (x, SET_DEST (set_b))
+	  || ! rtx_interchangeable_p (x, SET_DEST (set_b))
 	  || ! noce_operand_ok (SET_SRC (set_b))
 	  || reg_overlap_mentioned_p (x, SET_SRC (set_b))
 	  || modified_between_p (SET_SRC (set_b), insn_b, jump)
@@ -2583,7 +2608,7 @@
 
   /* Look and see if A and B are really the same.  Avoid creating silly
      cmove constructs that no one will fix up later.  */
-  if (rtx_equal_p (a, b))
+  if (rtx_interchangeable_p (a, b))
     {
       /* If we have an INSN_B, we don't have to create any new rtl.  Just
 	 move the instruction that we already have.  If we don't have an
@@ -4312,6 +4337,9 @@
   old_dest = JUMP_LABEL (jump);
   if (other_bb != new_dest)
     {
+      if (!any_condjump_p (jump))
+	goto cancel;
+
       if (JUMP_P (BB_END (dest_edge->src)))
 	new_dest_label = JUMP_LABEL (BB_END (dest_edge->src));
       else if (new_dest == EXIT_BLOCK_PTR_FOR_FN (cfun))
@@ -4362,7 +4390,7 @@
       insn = head;
       do
 	{
-	  rtx note, set;
+	  rtx note;
 
 	  if (! INSN_P (insn))
 	    continue;
@@ -4369,10 +4397,7 @@
 	  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);
 	  if (! note)
 	    continue;
-	  set = single_set (insn);
-	  if (!set || !function_invariant_p (SET_SRC (set))
-	      || !function_invariant_p (XEXP (note, 0)))
-	    remove_note (insn, note);
+	  remove_note (insn, note);
 	} while (insn != end && (insn = NEXT_INSN (insn)));
 
       /* PR46315: when moving insns above a conditional branch, the REG_EQUAL
Index: gcc/dwarf2out.c
===================================================================
--- a/src/gcc/dwarf2out.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/dwarf2out.c	(.../branches/gcc-4_9-branch)
@@ -12561,7 +12561,7 @@
 	      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,
 					VAR_INIT_STATUS_INITIALIZED);
 	      if (op1 == 0)
-		break;
+		return NULL;
 	      add_loc_descr (&mem_loc_result, op1);
 	      add_loc_descr (&mem_loc_result,
 			     new_loc_descr (DW_OP_plus, 0, 0));
@@ -14223,6 +14223,10 @@
       have_address = 1;
       break;
 
+    case TARGET_MEM_REF:
+    case SSA_NAME:
+      return NULL;
+
     case COMPOUND_EXPR:
       return loc_list_from_tree (TREE_OPERAND (loc, 1), want_address);
 
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-4_9-branch)
@@ -6605,7 +6605,7 @@
 	{
 	  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
 	  rtx temp_target;
-	  if (mode == BLKmode)
+	  if (mode == BLKmode || mode == VOIDmode)
 	    mode = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
 	  temp_target = gen_reg_rtx (mode);
 	  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);
@@ -10667,7 +10667,7 @@
       || !tree_fits_uhwi_p (TREE_OPERAND (offset, 1))
       || compare_tree_int (TREE_OPERAND (offset, 1),
 			   BIGGEST_ALIGNMENT / BITS_PER_UNIT) <= 0
-      || !exact_log2 (tree_to_uhwi (TREE_OPERAND (offset, 1)) + 1) < 0)
+      || exact_log2 (tree_to_uhwi (TREE_OPERAND (offset, 1)) + 1) < 0)
     return 0;
 
   /* Look at the first operand of BIT_AND_EXPR and strip any conversion.
Index: gcc/go/gofrontend/gogo.cc
===================================================================
--- a/src/gcc/go/gofrontend/gogo.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/go/gofrontend/gogo.cc	(.../branches/gcc-4_9-branch)
@@ -255,10 +255,7 @@
       char c = s[i];
       if ((c >= 'a' && c <= 'z')
 	  || (c >= 'A' && c <= 'Z')
-	  || (c >= '0' && c <= '9')
-	  || c == '_'
-	  || c == '.'
-	  || c == '$')
+	  || (c >= '0' && c <= '9'))
 	;
       else
 	s[i] = '_';
Index: gcc/go/gofrontend/parse.cc
===================================================================
--- a/src/gcc/go/gofrontend/parse.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/go/gofrontend/parse.cc	(.../branches/gcc-4_9-branch)
@@ -2865,7 +2865,10 @@
   // For a function literal, the next token must be a '{'.  If we
   // don't see that, then we may have a type expression.
   if (!this->peek_token()->is_op(OPERATOR_LCURLY))
-    return Expression::make_type(type, location);
+    {
+      hold_enclosing_vars.swap(this->enclosing_vars_);
+      return Expression::make_type(type, location);
+    }
 
   bool hold_is_erroneous_function = this->is_erroneous_function_;
   if (fntype_is_error)
Index: gcc/go/gofrontend/expressions.cc
===================================================================
--- a/src/gcc/go/gofrontend/expressions.cc	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/go/gofrontend/expressions.cc	(.../branches/gcc-4_9-branch)
@@ -5341,10 +5341,13 @@
   // Lower struct, array, and some interface comparisons.
   if (op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ)
     {
-      if (left->type()->struct_type() != NULL)
+      if (left->type()->struct_type() != NULL
+	  && right->type()->struct_type() != NULL)
 	return this->lower_struct_comparison(gogo, inserter);
       else if (left->type()->array_type() != NULL
-	       && !left->type()->is_slice_type())
+	       && !left->type()->is_slice_type()
+	       && right->type()->array_type() != NULL
+	       && !right->type()->is_slice_type())
 	return this->lower_array_comparison(gogo, inserter);
       else if ((left->type()->interface_type() != NULL
                 && right->type()->interface_type() == NULL)
Index: gcc/recog.c
===================================================================
--- a/src/gcc/recog.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/recog.c	(.../branches/gcc-4_9-branch)
@@ -3659,6 +3659,8 @@
   BITMAP_FREE (live);
   if (peep2_do_rebuild_jump_labels)
     rebuild_jump_labels (get_insns ());
+  if (peep2_do_cleanup_cfg)
+    cleanup_cfg (CLEANUP_CFG_CHANGED);
 }
 #endif /* HAVE_peephole2 */
 
Index: gcc/ada/socket.c
===================================================================
--- a/src/gcc/ada/socket.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/socket.c	(.../branches/gcc-4_9-branch)
@@ -212,7 +212,7 @@
   struct hostent *rh;
   int ri;
 
-#if defined(__linux__) || defined(__GLIBC__)
+#if defined(__linux__) || defined(__GLIBC__) || defined(__rtems__)
   (void) gethostbyname_r (name, ret, buf, buflen, &rh, h_errnop);
 #else
   rh = gethostbyname_r (name, ret, buf, buflen, h_errnop);
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,12 @@
+2014-08-12  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* socket.c: For RTEMS, use correct prototype of gethostbyname_r().
+	* gsocket.h Add include of <unistd.h> on RTEMS.
+
+2014-08-11  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* s-osinte-rtems.adb: Correct formatting of line in license block.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/ada/s-osinte-rtems.adb
===================================================================
--- a/src/gcc/ada/s-osinte-rtems.adb	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/s-osinte-rtems.adb	(.../branches/gcc-4_9-branch)
@@ -22,7 +22,7 @@
 -- You should have received a copy of the GNU General Public License and    --
 -- a copy of the GCC Runtime Library Exception along with this program;     --
 -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
--- <http://www.gnu.org/licenses/>.                                         
+-- <http://www.gnu.org/licenses/>.                                          --
 --                                                                          --
 -- GNARL was developed by the GNARL team at Florida State University. It is --
 -- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
Index: gcc/ada/gsocket.h
===================================================================
--- a/src/gcc/ada/gsocket.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ada/gsocket.h	(.../branches/gcc-4_9-branch)
@@ -183,6 +183,11 @@
 #include <sys/time.h>
 #endif
 
+#if defined(__rtems__)
+#include <unistd.h>
+/* Required, for read(), write(), and close() */
+#endif
+
 /*
  * RTEMS has these .h files but not until you have built and installed RTEMS.
  * When building a C/C++ toolset, you also build the newlib C library, so the
Index: gcc/asan.c
===================================================================
--- a/src/gcc/asan.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/asan.c	(.../branches/gcc-4_9-branch)
@@ -2099,6 +2099,7 @@
 	  if (has_stmt_been_instrumented_p (s))
 	    gsi_next (&i);
 	  else if (gimple_assign_single_p (s)
+		   && !gimple_clobber_p (s)
 		   && maybe_instrument_assignment (&i))
 	    /*  Nothing to do as maybe_instrument_assignment advanced
 		the iterator I.  */;
Index: gcc/fortran/openmp.c
===================================================================
--- a/src/gcc/fortran/openmp.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/openmp.c	(.../branches/gcc-4_9-branch)
@@ -464,7 +464,11 @@
 		      || !gfc_add_intrinsic (&sym->attr, NULL)))
 		rop = OMP_REDUCTION_NONE;
 	    }
-	  gfc_omp_udr *udr = gfc_find_omp_udr (gfc_current_ns, buffer, NULL);
+	  else
+	    buffer[0] = '\0';
+	  gfc_omp_udr *udr
+	    = (buffer[0]
+	       ? gfc_find_omp_udr (gfc_current_ns, buffer, NULL) : NULL);
 	  gfc_omp_namelist **head = NULL;
 	  if (rop == OMP_REDUCTION_NONE && udr)
 	    rop = OMP_REDUCTION_USER;
@@ -1240,6 +1244,7 @@
 	 syntax:
 	  gfc_current_locus = old_loc;
 	  gfc_current_ns = combiner_ns->parent;
+	  gfc_undo_symbols ();
 	  gfc_free_omp_udr (omp_udr);
 	  return MATCH_ERROR;
 	}
@@ -2739,7 +2744,7 @@
       break;
     }
 
-  if (var->attr.allocatable)
+  if (gfc_expr_attr (code->expr1).allocatable)
     {
       gfc_error ("!$OMP ATOMIC with ALLOCATABLE variable at %L",
 		 &code->loc);
Index: gcc/fortran/interface.c
===================================================================
--- a/src/gcc/fortran/interface.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/interface.c	(.../branches/gcc-4_9-branch)
@@ -2014,7 +2014,7 @@
   if (formal->ts.type == BT_CLASS && formal->attr.class_ok
       && actual->expr_type != EXPR_NULL
       && ((CLASS_DATA (formal)->attr.class_pointer
-	   && !formal->attr.intent == INTENT_IN)
+	   && formal->attr.intent != INTENT_IN)
           || CLASS_DATA (formal)->attr.allocatable))
     {
       if (actual->ts.type != BT_CLASS)
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-4_9-branch)
@@ -4409,7 +4409,7 @@
 		      && e->expr_type == EXPR_VARIABLE
 		      && (!e->ref
 			  || (e->ref->type == REF_ARRAY
-			      && !e->ref->u.ar.type != AR_FULL))
+			      && e->ref->u.ar.type != AR_FULL))
 		      && e->symtree->n.sym->attr.optional)
 		    {
 		      tmp = fold_build3_loc (input_location, COND_EXPR,
@@ -7842,7 +7842,7 @@
 	  for (a = expr2->value.function.actual; a != NULL; a = a->next)
 	    {
 	      e1 = a->expr;
-	      if (e1->rank > 0 && !is_runtime_conformable (expr1, e1))
+	      if (e1 && e1->rank > 0 && !is_runtime_conformable (expr1, e1))
 		return false;
 	    }
 	  return true;
@@ -7853,7 +7853,7 @@
 	  for (a = expr2->value.function.actual; a != NULL; a = a->next)
 	    {
 	      e1 = a->expr;
-	      if (e1->rank > 0 && !is_runtime_conformable (expr1, e1))
+	      if (e1 && e1->rank > 0 && !is_runtime_conformable (expr1, e1))
 		return false;
 	    }
 	  return true;
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-4_9-branch)
@@ -135,6 +135,16 @@
   if (GFC_DECL_RESULT (decl) && ! DECL_HAS_VALUE_EXPR_P (decl))
     return OMP_CLAUSE_DEFAULT_SHARED;
 
+  /* These are either array or derived parameters, or vtables.
+     In the former cases, the OpenMP standard doesn't consider them to be
+     variables at all (they can't be redefined), but they can nevertheless appear
+     in parallel/task regions and for default(none) purposes treat them as shared.
+     For vtables likely the same handling is desirable.  */
+  if (TREE_CODE (decl) == VAR_DECL
+      && TREE_READONLY (decl)
+      && TREE_STATIC (decl))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
 
@@ -1022,6 +1032,7 @@
 	  && !GFC_DECL_CRAY_POINTEE (decl)
 	  && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))
 	return;
+      tree orig_decl = decl;
       c4 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);
       OMP_CLAUSE_MAP_KIND (c4) = OMP_CLAUSE_MAP_POINTER;
       OMP_CLAUSE_DECL (c4) = decl;
@@ -1029,6 +1040,17 @@
       decl = build_fold_indirect_ref (decl);
       OMP_CLAUSE_DECL (c) = decl;
       OMP_CLAUSE_SIZE (c) = NULL_TREE;
+      if (TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE
+	  && (GFC_DECL_GET_SCALAR_POINTER (orig_decl)
+	      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))
+	{
+	  c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);
+	  OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;
+	  OMP_CLAUSE_DECL (c3) = unshare_expr (decl);
+	  OMP_CLAUSE_SIZE (c3) = size_int (0);
+	  decl = build_fold_indirect_ref (decl);
+	  OMP_CLAUSE_DECL (c) = decl;
+	}
     }
   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))
     {
@@ -1884,8 +1906,15 @@
 		TREE_ADDRESSABLE (decl) = 1;
 	      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)
 		{
-		  if (POINTER_TYPE_P (TREE_TYPE (decl)))
+		  if (POINTER_TYPE_P (TREE_TYPE (decl))
+		      && (gfc_omp_privatize_by_reference (decl)
+			  || GFC_DECL_GET_SCALAR_POINTER (decl)
+			  || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)
+			  || GFC_DECL_CRAY_POINTEE (decl)
+			  || GFC_DESCRIPTOR_TYPE_P
+					(TREE_TYPE (TREE_TYPE (decl)))))
 		    {
+		      tree orig_decl = decl;
 		      node4 = build_omp_clause (input_location,
 						OMP_CLAUSE_MAP);
 		      OMP_CLAUSE_MAP_KIND (node4) = OMP_CLAUSE_MAP_POINTER;
@@ -1892,6 +1921,17 @@
 		      OMP_CLAUSE_DECL (node4) = decl;
 		      OMP_CLAUSE_SIZE (node4) = size_int (0);
 		      decl = build_fold_indirect_ref (decl);
+		      if (TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE
+			  && (GFC_DECL_GET_SCALAR_POINTER (orig_decl)
+			      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))
+			{
+			  node3 = build_omp_clause (input_location,
+						    OMP_CLAUSE_MAP);
+			  OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;
+			  OMP_CLAUSE_DECL (node3) = decl;
+			  OMP_CLAUSE_SIZE (node3) = size_int (0);
+			  decl = build_fold_indirect_ref (decl);
+			}
 		    }
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))
 		    {
Index: gcc/fortran/gfortran.h
===================================================================
--- a/src/gcc/fortran/gfortran.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/gfortran.h	(.../branches/gcc-4_9-branch)
@@ -724,7 +724,7 @@
     optional:1, pointer:1, target:1, value:1, volatile_:1, temporary:1,
     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,
     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,
-    contiguous:1;
+    contiguous:1, fe_temp: 1;
 
   /* For CLASS containers, the pointer attribute is sometimes set internally
      even though it was not directly specified.  In this case, keep the
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,87 @@
+2014-10-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/59488
+	* trans-openmp.c (gfc_omp_predetermined_sharing): Return
+	OMP_CLAUSE_DEFAULT_SHARED for parameters or vtables.
+
+2014-09-03  Marek Polacek  <polacek@redhat.com>
+
+	Backport from trunk
+	PR fortran/62270
+	* interface.c (compare_parameter): Fix condition.
+	* trans-expr.c (gfc_conv_procedure_call): Likewise.
+
+2014-08-29  Jeffrey Armstrong  <jeffrey.armstrong@approximatrix.com>
+
+	Backport from trunk
+	PR fortran/62215
+	* module.c (gfc_dump_module): Unlink old module file before
+	renaming new one.
+
+2014-08-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62214
+	* frontend-passes.c (optimize_binop_array_assignment):
+	Do not try to optimize the array assignment for string
+	concatenation.
+
+2014-08-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62142
+	* trans-expr.c (is_runtime_conformable):  Add NULL pointer checks.
+
+2014-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/62106
+	* gfortran.h (symbol_attribute):  Add fe_temp flag.
+	* frontend-passes.c (is_fe_temp):  New function.
+	(create_var):  Don't add a temporary for an already
+	created variable or for a constant.
+	(combine_ARRAY_constructor):  Remove special handling
+	for constants.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+	    Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/62131
+	* openmp.c (resolve_omp_atomic): Only complain if code->expr1's attr
+	is allocatable, rather than whenever var->attr.allocatable.
+
+2014-08-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/62107
+	* trans-openmp.c (gfc_omp_finish_clause): Handle scalar pointer
+	or allocatable passed by reference.
+	(gfc_trans_omp_clauses) <case OMP_LIST_MAP>: Likewise.
+
+2014-08-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/62076
+	* openmp.c (gfc_match_omp_clauses): When failed to match
+	operator name, defined op name or name, set buffer to
+	empty string.  Don't call gfc_find_omp_udr if buffer is empty
+	string.
+	(gfc_match_omp_declare_reduction): Call gfc_undo_symbols ()
+	before calling gfc_free_omp_udr.
+
+2014-08-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/61999
+	* simplify.c (gfc_simplify_dot_product): Convert types of
+	vectors before calculating the result.
+
+2014-07-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/61780
+	* dependency.c (gfc_dep_resolver): Index the 'reverse' array so
+	that elements are skipped. This then correctly aligns 'reverse'
+	with the scalarizer loops.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/fortran/module.c
===================================================================
--- a/src/gcc/fortran/module.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/module.c	(.../branches/gcc-4_9-branch)
@@ -6072,7 +6072,10 @@
       || crc_old != crc)
     {
       /* Module file have changed, replace the old one.  */
-      if (rename (filename_tmp, filename))
+      if (unlink (filename) && errno != ENOENT)
+	gfc_fatal_error ("Can't delete module file '%s': %s", filename,
+			 xstrerror (errno));
+       if (rename (filename_tmp, filename))
 	gfc_fatal_error ("Can't rename module file '%s' to '%s': %s",
 			 filename_tmp, filename, xstrerror (errno));
     }
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-4_9-branch)
@@ -430,11 +430,26 @@
   return 0;
 }
 
+/* Auxiliary function to check if an expression is a temporary created by
+   create var.  */
+
+static bool
+is_fe_temp (gfc_expr *e)
+{
+  if (e->expr_type != EXPR_VARIABLE)
+    return false;
+
+  return e->symtree->n.sym->attr.fe_temp;
+}
+
+
 /* Returns a new expression (a variable) to be used in place of the old one,
    with an assignment statement before the current statement to set
    the value of the variable. Creates a new BLOCK for the statement if
    that hasn't already been done and puts the statement, plus the
-   newly created variables, in that block.  */
+   newly created variables, in that block.  Special cases:  If the
+   expression is constant or a temporary which has already
+   been created, just copy it.  */
 
 static gfc_expr*
 create_var (gfc_expr * e)
@@ -448,6 +463,9 @@
   gfc_namespace *ns;
   int i;
 
+  if (e->expr_type == EXPR_CONSTANT || is_fe_temp (e))
+    return gfc_copy_expr (e);
+
   /* If the block hasn't already been created, do so.  */
   if (inserted_block == NULL)
     {
@@ -522,6 +540,7 @@
   symbol->attr.flavor = FL_VARIABLE;
   symbol->attr.referenced = 1;
   symbol->attr.dimension = e->rank > 0;
+  symbol->attr.fe_temp = 1;
   gfc_commit_symbol (symbol);
 
   result = gfc_get_expr ();
@@ -884,6 +903,10 @@
 	    return true;
 	  break;
 
+	case INTRINSIC_CONCAT:
+	  /* Do not do string concatenations.  */
+	  break;
+
 	default:
 	  /* Binary operators.  */
 	  if (optimize_binop_array_assignment (c, &e->value.op.op1, true))
@@ -1082,10 +1105,7 @@
   if (op2->ts.type == BT_CHARACTER)
     return false;
 
-  if (op2->expr_type == EXPR_CONSTANT)
-    scalar = gfc_copy_expr (op2);
-  else
-    scalar = create_var (gfc_copy_expr (op2));
+  scalar = create_var (gfc_copy_expr (op2));
 
   oldbase = op1->value.constructor;
   newbase = NULL;
Index: gcc/fortran/dependency.c
===================================================================
--- a/src/gcc/fortran/dependency.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/dependency.c	(.../branches/gcc-4_9-branch)
@@ -2023,6 +2023,7 @@
 gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 {
   int n;
+  int m;
   gfc_dependency fin_dep;
   gfc_dependency this_dep;
 
@@ -2072,6 +2073,8 @@
 	      break;
 	    }
 
+	  /* Index for the reverse array.  */
+	  m = -1;
 	  for (n=0; n < lref->u.ar.dimen; n++)
 	    {
 	      /* Handle dependency when either of array reference is vector
@@ -2118,31 +2121,37 @@
 		 The ability to reverse or not is set by previous conditions
 		 in this dimension.  If reversal is not activated, the
 		 value GFC_DEP_BACKWARD is reset to GFC_DEP_OVERLAP.  */
+
+	      /* Get the indexing right for the scalarizing loop. If this
+		 is an element, there is no corresponding loop.  */
+	      if (lref->u.ar.dimen_type[n] != DIMEN_ELEMENT)
+		m++;
+
 	      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE
 		    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)
 		{
 		  /* Set reverse if backward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_BACKWARD) ?
-			         GFC_REVERSE_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_BACKWARD) ?
+			         GFC_REVERSE_SET : reverse[m];
 
 		  /* Set forward if forward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_FORWARD) ?
-			         GFC_FORWARD_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_FORWARD) ?
+			         GFC_FORWARD_SET : reverse[m];
 
 		  /* Flag up overlap if dependence not compatible with
 		     the overall state of the expression.  */
-		  if (reverse && reverse[n] == GFC_REVERSE_SET
+		  if (reverse && reverse[m] == GFC_REVERSE_SET
 		        && this_dep == GFC_DEP_FORWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
-		  else if (reverse && reverse[n] == GFC_FORWARD_SET
+		  else if (reverse && reverse[m] == GFC_FORWARD_SET
 		        && this_dep == GFC_DEP_BACKWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
 
@@ -2149,7 +2158,7 @@
 		  /* If no intention of reversing or reversing is explicitly
 		     inhibited, convert backward dependence to overlap.  */
 		  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)
-		      || (reverse != NULL && reverse[n] == GFC_INHIBIT_REVERSE))
+		      || (reverse != NULL && reverse[m] == GFC_INHIBIT_REVERSE))
 		    this_dep = GFC_DEP_OVERLAP;
 		}
 
Index: gcc/fortran/simplify.c
===================================================================
--- a/src/gcc/fortran/simplify.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/fortran/simplify.c	(.../branches/gcc-4_9-branch)
@@ -1878,6 +1878,9 @@
 gfc_expr*
 gfc_simplify_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)
 {
+
+  gfc_expr temp;
+
   if (!is_constant_array_expr (vector_a)
       || !is_constant_array_expr (vector_b))
     return NULL;
@@ -1884,8 +1887,14 @@
 
   gcc_assert (vector_a->rank == 1);
   gcc_assert (vector_b->rank == 1);
-  gcc_assert (gfc_compare_types (&vector_a->ts, &vector_b->ts));
 
+  temp.expr_type = EXPR_OP;
+  gfc_clear_ts (&temp.ts);
+  temp.value.op.op = INTRINSIC_NONE;
+  temp.value.op.op1 = vector_a;
+  temp.value.op.op2 = vector_b;
+  gfc_type_convert_binary (&temp, 1);
+
   return compute_dot_product (vector_a, 1, 0, vector_b, 1, 0, true);
 }
 
Index: gcc/ipa-devirt.c
===================================================================
--- a/src/gcc/ipa-devirt.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ipa-devirt.c	(.../branches/gcc-4_9-branch)
@@ -994,7 +994,8 @@
   if ((TREE_CODE (type) != RECORD_TYPE
        || !TYPE_BINFO (type)
        || !polymorphic_type_binfo_p (TYPE_BINFO (type)))
-      && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST
+      && (!TYPE_SIZE (type)
+	  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST
 	  || (offset + tree_to_uhwi (TYPE_SIZE (expected_type)) <=
 	      tree_to_uhwi (TYPE_SIZE (type)))))
     return true;
@@ -1869,8 +1870,7 @@
 	    /* Don't use an implicitly-declared destructor (c++/58678).  */
 	    struct cgraph_node *non_thunk_target
 	      = cgraph_function_node (likely_target);
-	    if (DECL_ARTIFICIAL (non_thunk_target->decl)
-		&& DECL_COMDAT (non_thunk_target->decl))
+	    if (DECL_ARTIFICIAL (non_thunk_target->decl))
 	      {
 		if (dump_file)
 		  fprintf (dump_file, "Target is artificial\n\n");
Index: gcc/configure.ac
===================================================================
--- a/src/gcc/configure.ac	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/configure.ac	(.../branches/gcc-4_9-branch)
@@ -3541,6 +3541,29 @@
         done
       fi
     fi
+    # Enable default workaround for AArch64 Cortex-A53 erratum 835769.
+    AC_ARG_ENABLE(fix-cortex-a53-835769,
+    [
+AS_HELP_STRING([--enable-fix-cortex-a53-835769],
+        [enable workaround for AArch64 Cortex-A53 erratum 835769 by default])
+AS_HELP_STRING([--disable-fix-cortex-a53-835769],
+        [disable workaround for AArch64 Cortex-A53 erratum 835769 by default])
+    ],
+      [
+        case $enableval in
+          yes)
+            tm_defines="${tm_defines} TARGET_FIX_ERR_A53_835769_DEFAULT=1"
+            ;;
+          no)
+            ;;
+          *)
+            AC_MSG_ERROR(['$enableval' is an invalid value for --enable-fix-cortex-a53-835769.\
+  Valid choices are 'yes' and 'no'.])
+            ;;
+
+        esac
+      ],
+    [])
     ;;
 
   # All TARGET_ABI_OSF targets.
Index: gcc/tree-vectorizer.h
===================================================================
--- a/src/gcc/tree-vectorizer.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-vectorizer.h	(.../branches/gcc-4_9-branch)
@@ -414,9 +414,9 @@
 #define LOOP_VINFO_SCALAR_LOOP(L)	   (L)->scalar_loop
 
 #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \
-  (L)->may_misalign_stmts.length () > 0
+  ((L)->may_misalign_stmts.length () > 0)
 #define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)     \
-  (L)->may_alias_ddrs.length () > 0
+  ((L)->may_alias_ddrs.length () > 0)
 
 #define LOOP_VINFO_NITERS_KNOWN_P(L)          \
   (tree_fits_shwi_p ((L)->num_iters) && tree_to_shwi ((L)->num_iters) > 0)
@@ -1061,7 +1061,8 @@
 				    unsigned *);
 extern tree vect_create_data_ref_ptr (gimple, tree, struct loop *, tree,
 				      tree *, gimple_stmt_iterator *,
-				      gimple *, bool, bool *);
+				      gimple *, bool, bool *,
+				      tree = NULL_TREE);
 extern tree bump_vector_ptr (tree, gimple, gimple_stmt_iterator *, gimple, tree);
 extern tree vect_create_destination_var (tree, tree);
 extern bool vect_grouped_store_supported (tree, unsigned HOST_WIDE_INT);
@@ -1078,7 +1079,8 @@
 extern void vect_record_grouped_load_vectors (gimple, vec<tree> );
 extern tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);
 extern tree vect_create_addr_base_for_vector_ref (gimple, gimple_seq *,
-                                                  tree, struct loop *);
+						  tree, struct loop *,
+						  tree = NULL_TREE);
 
 /* In tree-vect-loop.c.  */
 /* FORNOW: Used in tree-parloops.c.  */
Index: gcc/ipa-split.c
===================================================================
--- a/src/gcc/ipa-split.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ipa-split.c	(.../branches/gcc-4_9-branch)
@@ -167,7 +167,11 @@
       || (TREE_CODE (t) == VAR_DECL
 	  && auto_var_in_fn_p (t, current_function_decl))
       || TREE_CODE (t) == RESULT_DECL
-      || TREE_CODE (t) == LABEL_DECL)
+	 /* Normal labels are part of CFG and will be handled gratefuly.
+	    Forced labels however can be used directly by statements and
+	    need to stay in one partition along with their uses.  */
+      || (TREE_CODE (t) == LABEL_DECL
+	  && FORCED_LABEL (t)))
     return bitmap_bit_p ((bitmap)data, DECL_UID (t));
 
   /* For DECL_BY_REFERENCE, the return value is actually a pointer.  We want
@@ -213,6 +217,7 @@
   edge e;
   edge_iterator ei;
   bool ok = true;
+  basic_block bb;
 
   FOR_EACH_EDGE (e, ei, current->entry_bb->preds)
     if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)
@@ -225,8 +230,8 @@
   while (!worklist.is_empty ())
     {
       gimple_stmt_iterator bsi;
-      basic_block bb = worklist.pop ();
 
+      bb = worklist.pop ();
       FOR_EACH_EDGE (e, ei, bb->preds)
 	if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)
 	    && bitmap_set_bit (seen, e->src->index))
@@ -250,10 +255,10 @@
 	  if (gimple_code (stmt) == GIMPLE_LABEL
 	      && test_nonssa_use (stmt, gimple_label_label (stmt),
 				  NULL_TREE, non_ssa_vars))
-	  {
-	    ok = false;
-	    goto done;
-	  }
+	    {
+	      ok = false;
+	      goto done;
+	    }
 	}
       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))
 	{
@@ -286,6 +291,27 @@
 	    }
 	}
     }
+
+  /* Verify that the rest of function does not define any label
+     used by the split part.  */
+  FOR_EACH_BB_FN (bb, cfun)
+    if (!bitmap_bit_p (current->split_bbs, bb->index)
+	&& !bitmap_bit_p (seen, bb->index))
+      {
+        gimple_stmt_iterator bsi;
+        for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))
+	  if (gimple_code (gsi_stmt (bsi)) == GIMPLE_LABEL
+	      && test_nonssa_use (gsi_stmt (bsi),
+				  gimple_label_label (gsi_stmt (bsi)),
+				  NULL_TREE, non_ssa_vars))
+	    {
+	      ok = false;
+	      goto done;
+	    }
+	  else if (gimple_code (gsi_stmt (bsi)) != GIMPLE_LABEL)
+	    break;
+      }
+    
 done:
   BITMAP_FREE (seen);
   worklist.release ();
@@ -734,7 +760,8 @@
   if ((TREE_CODE (t) == VAR_DECL
        && auto_var_in_fn_p (t, current_function_decl))
       || TREE_CODE (t) == RESULT_DECL
-      || TREE_CODE (t) == LABEL_DECL)
+      || (TREE_CODE (t) == LABEL_DECL
+	  && FORCED_LABEL (t)))
     bitmap_set_bit ((bitmap)data, DECL_UID (t));
 
   /* For DECL_BY_REFERENCE, the return value is actually a pointer.  We want
Index: gcc/tree-vect-loop.c
===================================================================
--- a/src/gcc/tree-vect-loop.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-vect-loop.c	(.../branches/gcc-4_9-branch)
@@ -2321,7 +2321,8 @@
         }
 
       def1 = SSA_NAME_DEF_STMT (op1);
-      if (flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))
+      if (gimple_bb (def1)
+	  && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))
           && loop->inner
           && flow_bb_inside_loop_p (loop->inner, gimple_bb (def1))
           && is_gimple_assign (def1))
Index: gcc/tree-vect-data-refs.c
===================================================================
--- a/src/gcc/tree-vect-data-refs.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-vect-data-refs.c	(.../branches/gcc-4_9-branch)
@@ -3841,6 +3841,9 @@
 	    is as follows:
 	    if LOOP=i_loop:	&in		(relative to i_loop)
 	    if LOOP=j_loop: 	&in+i*2B	(relative to j_loop)
+   BYTE_OFFSET: Optional, defaulted to NULL.  If supplied, it is added to the
+	    initial address.  Unlike OFFSET, which is number of elements to
+	    be added, BYTE_OFFSET is measured in bytes.
 
    Output:
    1. Return an SSA_NAME whose value is the address of the memory location of
@@ -3854,7 +3857,8 @@
 vect_create_addr_base_for_vector_ref (gimple stmt,
 				      gimple_seq *new_stmt_list,
 				      tree offset,
-				      struct loop *loop)
+				      struct loop *loop,
+				      tree byte_offset)
 {
   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);
   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);
@@ -3907,6 +3911,12 @@
       base_offset = fold_build2 (PLUS_EXPR, sizetype,
 				 base_offset, offset);
     }
+  if (byte_offset)
+    {
+      byte_offset = fold_convert (sizetype, byte_offset);
+      base_offset = fold_build2 (PLUS_EXPR, sizetype,
+				 base_offset, byte_offset);
+    }
 
   /* base + base_offset */
   if (loop_vinfo)
@@ -3964,6 +3974,10 @@
    5. BSI: location where the new stmts are to be placed if there is no loop
    6. ONLY_INIT: indicate if ap is to be updated in the loop, or remain
         pointing to the initial address.
+   7. BYTE_OFFSET (optional, defaults to NULL): a byte offset to be added
+	to the initial address accessed by the data-ref in STMT.  This is
+	similar to OFFSET, but OFFSET is counted in elements, while BYTE_OFFSET
+	in bytes.
 
    Output:
    1. Declare a new ptr to vector_type, and have it point to the base of the
@@ -3977,6 +3991,8 @@
          initial_address = &a[init];
       if OFFSET is supplied:
          initial_address = &a[init + OFFSET];
+      if BYTE_OFFSET is supplied:
+	 initial_address = &a[init] + BYTE_OFFSET;
 
       Return the initial_address in INITIAL_ADDRESS.
 
@@ -3994,7 +4010,7 @@
 vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,
 			  tree offset, tree *initial_address,
 			  gimple_stmt_iterator *gsi, gimple *ptr_incr,
-			  bool only_init, bool *inv_p)
+			  bool only_init, bool *inv_p, tree byte_offset)
 {
   const char *base_name;
   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);
@@ -4137,10 +4153,10 @@
   /* (2) Calculate the initial address of the aggregate-pointer, and set
      the aggregate-pointer to point to it before the loop.  */
 
-  /* Create: (&(base[init_val+offset]) in the loop preheader.  */
+  /* Create: (&(base[init_val+offset]+byte_offset) in the loop preheader.  */
 
   new_temp = vect_create_addr_base_for_vector_ref (stmt, &new_stmt_list,
-                                                   offset, loop);
+						   offset, loop, byte_offset);
   if (new_stmt_list)
     {
       if (pe)
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-4_9-branch)
@@ -6263,7 +6263,7 @@
 		= splay_tree_lookup (ctx->variables, (splay_tree_key) decl);
 	      if (on && (on->value & (GOVD_FIRSTPRIVATE | GOVD_LASTPRIVATE
 				      | GOVD_PRIVATE | GOVD_REDUCTION
-				      | GOVD_LINEAR)) != 0)
+				      | GOVD_LINEAR | GOVD_MAP)) != 0)
 		break;
 	      ctx = ctx->outer_context;
 	    }
Index: gcc/lra-constraints.c
===================================================================
--- a/src/gcc/lra-constraints.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/lra-constraints.c	(.../branches/gcc-4_9-branch)
@@ -5752,6 +5752,20 @@
 			SUBREG_REG (SET_SRC (set)) = SET_SRC (prev_set);
 		      else
 			SET_SRC (set) = SET_SRC (prev_set);
+		      /* As we are finishing with processing the insn
+			 here, check the destination too as it might
+			 inheritance pseudo for another pseudo.  */
+		      if (bitmap_bit_p (remove_pseudos, dregno)
+			  && bitmap_bit_p (&lra_inheritance_pseudos, dregno)
+			  && (restore_regno
+			      = lra_reg_info[dregno].restore_regno) >= 0)
+			{
+			  if (GET_CODE (SET_DEST (set)) == SUBREG)
+			    SUBREG_REG (SET_DEST (set))
+			      = regno_reg_rtx[restore_regno];
+			  else
+			    SET_DEST (set) = regno_reg_rtx[restore_regno];
+			}
 		      lra_push_insn_and_update_insn_regno_info (curr_insn);
 		      lra_set_used_insn_alternative_by_uid
 			(INSN_UID (curr_insn), -1);
Index: gcc/emit-rtl.c
===================================================================
--- a/src/gcc/emit-rtl.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/emit-rtl.c	(.../branches/gcc-4_9-branch)
@@ -245,9 +245,13 @@
 
 /* Return true if the given memory attributes are equal.  */
 
-static bool
+bool
 mem_attrs_eq_p (const struct mem_attrs *p, const struct mem_attrs *q)
 {
+  if (p == q)
+    return true;
+  if (!p || !q)
+    return false;
   return (p->alias == q->alias
 	  && p->offset_known_p == q->offset_known_p
 	  && (!p->offset_known_p || p->offset == q->offset)
Index: gcc/gimple-fold.c
===================================================================
--- a/src/gcc/gimple-fold.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/gimple-fold.c	(.../branches/gcc-4_9-branch)
@@ -146,7 +146,8 @@
          The second is important when devirtualization happens during final
          compilation stage when making a new reference no longer makes callee
          to be compiled.  */
-      if (!node || !node->definition || node->global.inlined_to)
+      if (!node || !node->definition
+	  || DECL_EXTERNAL (decl) || node->global.inlined_to)
 	{
 	  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));
 	  return false;
@@ -3104,8 +3105,8 @@
      result.  */
   if (!AGGREGATE_TYPE_P (TREE_TYPE (ctor)) && !offset
       /* VIEW_CONVERT_EXPR is defined only for matching sizes.  */
-      && operand_equal_p (TYPE_SIZE (type),
-			  TYPE_SIZE (TREE_TYPE (ctor)), 0))
+      && !compare_tree_int (TYPE_SIZE (type), size)
+      && !compare_tree_int (TYPE_SIZE (TREE_TYPE (ctor)), size))
     {
       ret = canonicalize_constructor_val (unshare_expr (ctor), from_decl);
       ret = fold_unary (VIEW_CONVERT_EXPR, type, ret);
Index: gcc/emit-rtl.h
===================================================================
--- a/src/gcc/emit-rtl.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/emit-rtl.h	(.../branches/gcc-4_9-branch)
@@ -20,6 +20,9 @@
 #ifndef GCC_EMIT_RTL_H
 #define GCC_EMIT_RTL_H
 
+/* Return whether two MEM_ATTRs are equal.  */
+bool mem_attrs_eq_p (const struct mem_attrs *, const struct mem_attrs *);
+
 /* Set the alias set of MEM to SET.  */
 extern void set_mem_alias_set (rtx, alias_set_type);
 
Index: gcc/tree-cfgcleanup.c
===================================================================
--- a/src/gcc/tree-cfgcleanup.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-cfgcleanup.c	(.../branches/gcc-4_9-branch)
@@ -162,6 +162,23 @@
   return retval;
 }
 
+/* Cleanup the GF_CALL_CTRL_ALTERING flag according to
+   to updated gimple_call_flags.  */
+
+static void
+cleanup_call_ctrl_altering_flag (gimple bb_end)
+{
+  if (!is_gimple_call (bb_end)
+      || !gimple_call_ctrl_altering_p (bb_end))
+    return;
+
+  int flags = gimple_call_flags (bb_end);
+  if (((flags & (ECF_CONST | ECF_PURE))
+       && !(flags & ECF_LOOPING_CONST_OR_PURE))
+      || (flags & ECF_LEAF))
+    gimple_call_set_ctrl_altering (bb_end, false);
+}
+
 /* Try to remove superfluous control structures in basic block BB.  Returns
    true if anything changes.  */
 
@@ -182,6 +199,9 @@
 
   stmt = gsi_stmt (gsi);
 
+  /* Try to cleanup ctrl altering flag for call which ends bb.  */
+  cleanup_call_ctrl_altering_flag (stmt);
+
   if (gimple_code (stmt) == GIMPLE_COND
       || gimple_code (stmt) == GIMPLE_SWITCH)
     retval |= cleanup_control_expr_graph (bb, gsi);
@@ -545,7 +565,20 @@
 
   /* First split basic block if stmt is not last.  */
   if (stmt != gsi_stmt (gsi_last_bb (bb)))
-    split_block (bb, stmt);
+    {
+      if (stmt == gsi_stmt (gsi_last_nondebug_bb (bb)))
+	{
+	  /* Don't split if there are only debug stmts
+	     after stmt, that can result in -fcompare-debug
+	     failures.  Remove the debug stmts instead,
+	     they should be all unreachable anyway.  */
+	  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);
+	  for (gsi_next (&gsi); !gsi_end_p (gsi); )
+	    gsi_remove (&gsi, true);
+	}
+      else
+	split_block (bb, stmt);
+    }
 
   changed |= remove_fallthru_edge (bb->succs);
 
@@ -594,30 +627,24 @@
    known not to return, and remove the unreachable code.  */
 
 static bool
-split_bbs_on_noreturn_calls (void)
+split_bb_on_noreturn_calls (basic_block bb)
 {
   bool changed = false;
-  gimple stmt;
-  basic_block bb;
+  gimple_stmt_iterator gsi;
 
-  /* Detect cases where a mid-block call is now known not to return.  */
-  if (cfun->gimple_df)
-    while (vec_safe_length (MODIFIED_NORETURN_CALLS (cfun)))
-      {
-	stmt = MODIFIED_NORETURN_CALLS (cfun)->pop ();
-	bb = gimple_bb (stmt);
-	/* BB might be deleted at this point, so verify first
-	   BB is present in the cfg.  */
-	if (bb == NULL
-	    || bb->index < NUM_FIXED_BLOCKS
-	    || bb->index >= last_basic_block_for_fn (cfun)
-	    || BASIC_BLOCK_FOR_FN (cfun, bb->index) != bb
-	    || !gimple_call_noreturn_p (stmt))
-	  continue;
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple stmt = gsi_stmt (gsi);
 
+      if (!is_gimple_call (stmt))
+	continue;
+
+      if (gimple_call_noreturn_p (stmt))
 	changed |= fixup_noreturn_call (stmt);
-      }
+    }
 
+  if (changed)
+    bitmap_set_bit (cfgcleanup_altered_bbs, bb->index);
   return changed;
 }
 
@@ -655,8 +682,6 @@
   basic_block bb;
   unsigned i, n;
 
-  retval |= split_bbs_on_noreturn_calls ();
-
   /* Prepare the worklists of altered blocks.  */
   cfgcleanup_altered_bbs = BITMAP_ALLOC (NULL);
 
@@ -672,7 +697,10 @@
     {
       bb = BASIC_BLOCK_FOR_FN (cfun, i);
       if (bb)
-	retval |= cleanup_tree_cfg_bb (bb);
+	{
+	  retval |= cleanup_tree_cfg_bb (bb);
+	  retval |= split_bb_on_noreturn_calls (bb);
+	}
     }
 
   /* Now process the altered blocks, as long as any are available.  */
@@ -689,9 +717,9 @@
 
       retval |= cleanup_tree_cfg_bb (bb);
 
-      /* Rerun split_bbs_on_noreturn_calls, in case we have altered any noreturn
+      /* Rerun split_bb_on_noreturn_calls, in case we have altered any noreturn
 	 calls.  */
-      retval |= split_bbs_on_noreturn_calls ();
+      retval |= split_bb_on_noreturn_calls (bb);
     }
 
   end_recording_case_labels ();
Index: gcc/cfgcleanup.c
===================================================================
--- a/src/gcc/cfgcleanup.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/cfgcleanup.c	(.../branches/gcc-4_9-branch)
@@ -53,6 +53,7 @@
 #include "df.h"
 #include "dce.h"
 #include "dbgcnt.h"
+#include "emit-rtl.h"
 
 #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)
 
@@ -882,7 +883,7 @@
   if (GET_MODE (x) != GET_MODE (y))
     return;
 
-  if (code == MEM && MEM_ATTRS (x) != MEM_ATTRS (y))
+  if (code == MEM && !mem_attrs_eq_p (MEM_ATTRS (x), MEM_ATTRS (y)))
     {
       if (! MEM_ATTRS (x))
 	MEM_ATTRS (y) = 0;
Index: gcc/tree-sra.c
===================================================================
--- a/src/gcc/tree-sra.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-sra.c	(.../branches/gcc-4_9-branch)
@@ -1092,6 +1092,11 @@
 			       "component.");
       return NULL;
     }
+  if (TREE_THIS_VOLATILE (expr))
+    {
+      disqualify_base_of_expr (expr, "part of a volatile reference.");
+      return NULL;
+    }
 
   switch (TREE_CODE (expr))
     {
Index: gcc/ubsan.c
===================================================================
--- a/src/gcc/ubsan.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/ubsan.c	(.../branches/gcc-4_9-branch)
@@ -528,9 +528,9 @@
 bool
 is_ubsan_builtin_p (tree t)
 {
-  gcc_checking_assert (TREE_CODE (t) == FUNCTION_DECL);
-  return strncmp (IDENTIFIER_POINTER (DECL_NAME (t)),
-		  "__builtin___ubsan_", 18) == 0;
+  return TREE_CODE (t) == FUNCTION_DECL
+	 && strncmp (IDENTIFIER_POINTER (DECL_NAME (t)),
+		     "__builtin___ubsan_", 18) == 0;
 }
 
 /* Expand UBSAN_NULL internal call.  */
Index: gcc/lto/ChangeLog
===================================================================
--- a/src/gcc/lto/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/lto/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,11 @@
+2014-08-15  Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline
+	2014-08-08  Bin Cheng  <bin.cheng@arm.com>
+
+	PR lto/62032
+	* lto-lang.c (lto_init): Switch mis-matched arguments.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: gcc/lto/lto-lang.c
===================================================================
--- a/src/gcc/lto/lto-lang.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/lto/lto-lang.c	(.../branches/gcc-4_9-branch)
@@ -1186,10 +1186,10 @@
     }
   else
     {
-      lto_define_builtins (va_list_type_node,
-			   build_reference_type (va_list_type_node));
+      lto_define_builtins (build_reference_type (va_list_type_node),
+			   va_list_type_node);
     }
-  
+
   if (flag_cilkplus)
     cilk_init_builtins ();
 
Index: gcc/tree-ssa-copy.c
===================================================================
--- a/src/gcc/tree-ssa-copy.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-copy.c	(.../branches/gcc-4_9-branch)
@@ -235,38 +235,26 @@
   enum ssa_prop_result retval = SSA_PROP_VARYING;
   location_t loc = gimple_location (stmt);
 
-  tree op0 = gimple_cond_lhs (stmt);
-  tree op1 = gimple_cond_rhs (stmt);
+  tree op0 = valueize_val (gimple_cond_lhs (stmt));
+  tree op1 = valueize_val (gimple_cond_rhs (stmt));
 
-  /* The only conditionals that we may be able to compute statically
-     are predicates involving two SSA_NAMEs.  */
-  if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME)
+  /* See if we can determine the predicate's value.  */
+  if (dump_file && (dump_flags & TDF_DETAILS))
     {
-      op0 = valueize_val (op0);
-      op1 = valueize_val (op1);
+      fprintf (dump_file, "Trying to determine truth value of ");
+      fprintf (dump_file, "predicate ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+    }
 
-      /* See if we can determine the predicate's value.  */
-      if (dump_file && (dump_flags & TDF_DETAILS))
-	{
-	  fprintf (dump_file, "Trying to determine truth value of ");
-	  fprintf (dump_file, "predicate ");
-	  print_gimple_stmt (dump_file, stmt, 0, 0);
-	}
-
-      /* We can fold COND and get a useful result only when we have
-	 the same SSA_NAME on both sides of a comparison operator.  */
-      if (op0 == op1)
-	{
-	  tree folded_cond = fold_binary_loc (loc, gimple_cond_code (stmt),
-                                          boolean_type_node, op0, op1);
-	  if (folded_cond)
-	    {
-	      basic_block bb = gimple_bb (stmt);
-	      *taken_edge_p = find_taken_edge (bb, folded_cond);
-	      if (*taken_edge_p)
-		retval = SSA_PROP_INTERESTING;
-	    }
-	}
+  /* Fold COND and see whether we get a useful result.  */
+  tree folded_cond = fold_binary_loc (loc, gimple_cond_code (stmt),
+				      boolean_type_node, op0, op1);
+  if (folded_cond)
+    {
+      basic_block bb = gimple_bb (stmt);
+      *taken_edge_p = find_taken_edge (bb, folded_cond);
+      if (*taken_edge_p)
+	retval = SSA_PROP_INTERESTING;
     }
 
   if (dump_file && (dump_flags & TDF_DETAILS) && *taken_edge_p)
Index: gcc/sched-deps.c
===================================================================
--- a/src/gcc/sched-deps.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/sched-deps.c	(.../branches/gcc-4_9-branch)
@@ -1233,6 +1233,13 @@
       switch (ask_dependency_caches (new_dep))
 	{
 	case DEP_PRESENT:
+	  dep_t present_dep;
+	  sd_iterator_def sd_it;
+      
+	  present_dep = sd_find_dep_between_no_cache (DEP_PRO (new_dep),
+						      DEP_CON (new_dep),
+						      resolved_p, &sd_it);
+	  DEP_MULTIPLE (present_dep) = 1;
 	  return DEP_PRESENT;
 
 	case DEP_CHANGED:
@@ -2750,7 +2757,8 @@
 	   Consider for instance a volatile asm that changes the fpu rounding
 	   mode.  An insn should not be moved across this even if it only uses
 	   pseudo-regs because it might give an incorrectly rounded result.  */
-	if (code != ASM_OPERANDS || MEM_VOLATILE_P (x))
+	if ((code != ASM_OPERANDS || MEM_VOLATILE_P (x))
+	    && !DEBUG_INSN_P (insn))
 	  reg_pending_barrier = TRUE_BARRIER;
 
 	/* For all ASM_OPERANDS, we must traverse the vector of input operands.
Index: gcc/tree-vect-stmts.c
===================================================================
--- a/src/gcc/tree-vect-stmts.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-vect-stmts.c	(.../branches/gcc-4_9-branch)
@@ -5600,6 +5600,7 @@
   int i, j, group_size, group_gap;
   tree msq = NULL_TREE, lsq;
   tree offset = NULL_TREE;
+  tree byte_offset = NULL_TREE;
   tree realignment_token = NULL_TREE;
   gimple phi = NULL;
   vec<tree> dr_chain = vNULL;
@@ -6261,7 +6262,8 @@
       if (alignment_support_scheme == dr_explicit_realign_optimized)
 	{
 	  phi = SSA_NAME_DEF_STMT (msq);
-	  offset = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);
+	  byte_offset = size_binop (MINUS_EXPR, TYPE_SIZE_UNIT (vectype),
+				    size_one_node);
 	}
     }
   else
@@ -6302,7 +6304,8 @@
 	    dataref_ptr
 	      = vect_create_data_ref_ptr (first_stmt, aggr_type, at_loop,
 					  offset, &dummy, gsi, &ptr_incr,
-					  simd_lane_access_p, &inv_p);
+					  simd_lane_access_p, &inv_p,
+					  byte_offset);
 	}
       else if (dataref_offset)
 	dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset,
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-4_9-branch)
@@ -432,7 +432,7 @@
 nios2-*-*)
 	cpu_type=nios2
 	extra_options="${extra_options} g.opt"
-	;;	
+	;;
 picochip-*-*)
         cpu_type=picochip
         ;;
@@ -791,7 +791,13 @@
   ;;
 *-*-rtems*)
   case ${enable_threads} in
-    yes) thread_file='rtems' ;;
+    "" | yes | rtems) thread_file='rtems' ;;
+    posix) thread_file='posix' ;;
+    no) ;;
+    *)
+      echo 'Unknown thread configuration for RTEMS'
+      exit 1
+      ;;
   esac
   tmake_file="${tmake_file} t-rtems"
   extra_options="${extra_options} rtems.opt"
@@ -1129,8 +1135,7 @@
 	;;
 crisv32-*-linux* | cris-*-linux*)
 	tm_file="dbxelf.h elfos.h ${tm_file} gnu-user.h linux.h glibc-stdint.h cris/linux.h"
-	# We need to avoid using t-linux, so override default tmake_file
-	tmake_file="cris/t-cris cris/t-linux t-slibgcc t-linux"
+	tmake_file="${tmake_file} cris/t-cris cris/t-linux"
 	extra_options="${extra_options} cris/linux.opt"
 	case $target in
 	  cris-*-*)
@@ -2156,6 +2161,10 @@
 		tm_file="${tm_file} newlib-stdint.h nios2/elf.h"
 		extra_options="${extra_options} nios2/elf.opt"
 		;;
+	nios2-*-rtems*)
+		tm_file="${tm_file} newlib-stdint.h nios2/rtems.h rtems.h"
+		tmake_file="${tmake_file} t-rtems nios2/t-rtems"
+		;;
         esac
 	;;
 pdp11-*-*)
@@ -3531,20 +3540,17 @@
 			;;
 		esac
 
-		case "$with_fpu" in
-		"" \
-		| vfp | vfp3 | vfpv3 \
-		| vfpv3-fp16 | vfpv3-d16 | vfpv3-d16-fp16 | vfpv3xd \
-		| vfpv3xd-fp16 | neon | neon-fp16 | vfpv4 | vfpv4-d16 \
-		| fpv4-sp-d16 | neon-vfpv4 | fp-arm-v8 | neon-fp-armv8 \
-                | crypto-neon-fp-armv8)
-			# OK
-			;;
-		*)
-			echo "Unknown fpu used in --with-fpu=$with_fpu" 2>&1
-			exit 1
-			;;
-		esac
+		# see if it matches any of the entries in arm-fpus.def
+		if [ x"$with_fpu" = x ] \
+		    || grep "^ARM_FPU(\"$with_fpu\"," \
+			    ${srcdir}/config/arm/arm-fpus.def \
+			    > /dev/null; then
+		  # OK
+		  true
+		else
+		  echo "Unknown fpu used in --with-fpu=$with_fpu" 1>&2
+		  exit 1
+		fi
 
 		case "$with_abi" in
 		"" \
Index: gcc/Makefile.in
===================================================================
--- a/src/gcc/Makefile.in	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -3132,7 +3132,7 @@
   tree-parloops.h tree-ssa-address.h tree-ssa-coalesce.h tree-ssa-dom.h \
   tree-ssa-loop.h tree-ssa-loop-ivopts.h tree-ssa-loop-manip.h \
   tree-ssa-loop-niter.h tree-ssa-ter.h tree-ssa-threadedge.h \
-  tree-ssa-threadupdate.h
+  tree-ssa-threadupdate.h pass-instances.def
 
 # generate the 'build fragment' b-header-vars
 s-header-vars: Makefile
Index: gcc/gimple.h
===================================================================
--- a/src/gcc/gimple.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/gimple.h	(.../branches/gcc-4_9-branch)
@@ -90,6 +90,7 @@
     GF_CALL_NOTHROW		= 1 << 4,
     GF_CALL_ALLOCA_FOR_VAR	= 1 << 5,
     GF_CALL_INTERNAL		= 1 << 6,
+    GF_CALL_CTRL_ALTERING       = 1 << 7,
     GF_OMP_PARALLEL_COMBINED	= 1 << 0,
     GF_OMP_FOR_KIND_MASK	= 3 << 0,
     GF_OMP_FOR_KIND_FOR		= 0 << 0,
@@ -2447,7 +2448,30 @@
   return static_cast <const gimple_statement_call *> (gs)->u.internal_fn;
 }
 
+/* If CTRL_ALTERING_P is true, mark GIMPLE_CALL S to be a stmt
+   that could alter control flow.  */
 
+static inline void
+gimple_call_set_ctrl_altering (gimple s, bool ctrl_altering_p)
+{
+  GIMPLE_CHECK (s, GIMPLE_CALL);
+  if (ctrl_altering_p)
+    s->subcode |= GF_CALL_CTRL_ALTERING;
+  else
+    s->subcode &= ~GF_CALL_CTRL_ALTERING;
+}
+
+/* Return true if call GS calls an func whose GF_CALL_CTRL_ALTERING
+   flag is set. Such call could not be a stmt in the middle of a bb.  */
+
+static inline bool
+gimple_call_ctrl_altering_p (const_gimple gs)
+{
+  GIMPLE_CHECK (gs, GIMPLE_CALL);
+  return (gs->subcode & GF_CALL_CTRL_ALTERING) != 0;
+}
+
+
 /* Return the function type of the function called by GS.  */
 
 static inline tree
Index: gcc/tree-cfg.c
===================================================================
--- a/src/gcc/tree-cfg.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-cfg.c	(.../branches/gcc-4_9-branch)
@@ -162,6 +162,7 @@
 static void gimple_make_forwarder_block (edge);
 static gimple first_non_label_stmt (basic_block);
 static bool verify_gimple_transaction (gimple);
+static bool call_can_make_abnormal_goto (gimple);
 
 /* Flowgraph optimization and cleanup.  */
 static void gimple_merge_blocks (basic_block, basic_block);
@@ -424,6 +425,32 @@
 }
 
 
+/* Initialize GF_CALL_CTRL_ALTERING flag, which indicates the call
+   could alter control flow except via eh. We initialize the flag at
+   CFG build time and only ever clear it later.  */
+
+static void
+gimple_call_initialize_ctrl_altering (gimple stmt)
+{
+  int flags = gimple_call_flags (stmt);
+
+  /* A call alters control flow if it can make an abnormal goto.  */
+  if (call_can_make_abnormal_goto (stmt)
+      /* A call also alters control flow if it does not return.  */
+      || flags & ECF_NORETURN
+      /* TM ending statements have backedges out of the transaction.
+	 Return true so we split the basic block containing them.
+	 Note that the TM_BUILTIN test is merely an optimization.  */
+      || ((flags & ECF_TM_BUILTIN)
+	  && is_tm_ending_fndecl (gimple_call_fndecl (stmt)))
+      /* BUILT_IN_RETURN call is same as return statement.  */
+      || gimple_call_builtin_p (stmt, BUILT_IN_RETURN))
+    gimple_call_set_ctrl_altering (stmt, true);
+  else
+    gimple_call_set_ctrl_altering (stmt, false);
+}
+
+
 /* Build a flowgraph for the sequence of stmts SEQ.  */
 
 static void
@@ -442,6 +469,9 @@
       prev_stmt = stmt;
       stmt = gsi_stmt (i);
 
+      if (stmt && is_gimple_call (stmt))
+	gimple_call_initialize_ctrl_altering (stmt);
+
       /* If the statement starts a new basic block or if we have determined
 	 in a previous pass that we need to create a new block for STMT, do
 	 so now.  */
@@ -2349,28 +2379,10 @@
   switch (gimple_code (t))
     {
     case GIMPLE_CALL:
-      {
-	int flags = gimple_call_flags (t);
-
-	/* A call alters control flow if it can make an abnormal goto.  */
-	if (call_can_make_abnormal_goto (t))
-	  return true;
-
-	/* A call also alters control flow if it does not return.  */
-	if (flags & ECF_NORETURN)
-	  return true;
-
-	/* TM ending statements have backedges out of the transaction.
-	   Return true so we split the basic block containing them.
-	   Note that the TM_BUILTIN test is merely an optimization.  */
-	if ((flags & ECF_TM_BUILTIN)
-	    && is_tm_ending_fndecl (gimple_call_fndecl (t)))
-	  return true;
-
-	/* BUILT_IN_RETURN call is same as return statement.  */
-	if (gimple_call_builtin_p (t, BUILT_IN_RETURN))
-	  return true;
-      }
+      /* Per stmt call flag indicates whether the call could alter
+	 controlflow.  */
+      if (gimple_call_ctrl_altering_p (t))
+	return true;
       break;
 
     case GIMPLE_EH_DISPATCH:
@@ -8470,6 +8482,8 @@
 		  && (!is_gimple_call (stmt)
 		      || (gimple_call_flags (stmt) & ECF_NORETURN) == 0)))
 	    {
+	      if (stmt && is_gimple_call (stmt))
+		gimple_call_set_ctrl_altering (stmt, false);
 	      stmt = gimple_build_call
 		  (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);
 	      gimple_stmt_iterator gsi = gsi_last_bb (bb);
@@ -8480,10 +8494,6 @@
   if (count_scale != REG_BR_PROB_BASE)
     compute_function_frequency ();
 
-  /* We just processed all calls.  */
-  if (cfun->gimple_df)
-    vec_free (MODIFIED_NORETURN_CALLS (cfun));
-
   /* Dump a textual representation of the flowgraph.  */
   if (dump_file)
     gimple_dump_cfg (dump_file, dump_flags);
Index: gcc/config/alpha/elf.h
===================================================================
--- a/src/gcc/config/alpha/elf.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/alpha/elf.h	(.../branches/gcc-4_9-branch)
@@ -126,6 +126,10 @@
   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
    %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
 
+/* This variable should be set to 'true' if the target ABI requires
+   unwinding tables even when exceptions are not used.  */
+#define TARGET_UNWIND_TABLES_DEFAULT true
+
 /* Select a format to encode pointers in exception handling data.  CODE
    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is
    true if the symbol may be affected by dynamic relocations.
Index: gcc/config/s390/s390.c
===================================================================
--- a/src/gcc/config/s390/s390.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/s390/s390.c	(.../branches/gcc-4_9-branch)
@@ -9130,11 +9130,14 @@
       if (! sibcall)
 	{
 	  /* Fetch return address from stack before load multiple,
-	     this will do good for scheduling.  */
+	     this will do good for scheduling.
 
-	  if (cfun_frame_layout.save_return_addr_p
-	      || (cfun_frame_layout.first_restore_gpr < BASE_REGNUM
-		  && cfun_frame_layout.last_restore_gpr > RETURN_REGNUM))
+	     Only do this if we already decided that r14 needs to be
+	     saved to a stack slot. (And not just because r14 happens to
+	     be in between two GPRs which need saving.)  Otherwise it
+	     would be difficult to take that decision back in
+	     s390_optimize_prologue.  */
+	  if (cfun_gpr_save_slot (RETURN_REGNUM) == -1)
 	    {
 	      int return_regnum = find_unused_clobbered_reg();
 	      if (!return_regnum)
@@ -9149,6 +9152,12 @@
 	      addr = gen_rtx_MEM (Pmode, addr);
 	      set_mem_alias_set (addr, get_frame_alias_set ());
 	      emit_move_insn (return_reg, addr);
+
+	      /* Once we did that optimization we have to make sure
+		 s390_optimize_prologue does not try to remove the
+		 store of r14 since we will not be able to find the
+		 load issued here.  */
+	      cfun_frame_layout.save_return_addr_p = true;
 	    }
 	}
 
Index: gcc/config/sparc/sync.md
===================================================================
--- a/src/gcc/config/sparc/sync.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sparc/sync.md	(.../branches/gcc-4_9-branch)
@@ -64,11 +64,19 @@
   "stbar"
   [(set_attr "type" "multi")])
 
+;; For LEON3, STB has the effect of membar #StoreLoad.
+(define_insn "*membar_storeload_leon3"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_dup 0) (const_int 2)] UNSPEC_MEMBAR))]
+  "TARGET_LEON3"
+  "stb\t%%g0, [%%sp-1]"
+  [(set_attr "type" "store")])
+
 ;; For V8, LDSTUB has the effect of membar #StoreLoad.
 (define_insn "*membar_storeload"
   [(set (match_operand:BLK 0 "" "")
 	(unspec:BLK [(match_dup 0) (const_int 2)] UNSPEC_MEMBAR))]
-  "TARGET_V8"
+  "TARGET_V8 && !TARGET_LEON3"
   "ldstub\t[%%sp-1], %%g0"
   [(set_attr "type" "multi")])
 
Index: gcc/config/darwin-c.c
===================================================================
--- a/src/gcc/config/darwin-c.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/darwin-c.c	(.../branches/gcc-4_9-branch)
@@ -571,21 +571,34 @@
 }
 
 /* Return the value of darwin_macosx_version_min suitable for the
-   __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ macro,
-   so '10.4.2' becomes 1040.  The lowest digit is always zero.
+   __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ macro, so '10.4.2'
+   becomes 1040 and '10.10.0' becomes 101000.  The lowest digit is
+   always zero, as is the second lowest for '10.10.x' and above.
    Print a warning if the version number can't be understood.  */
 static const char *
 version_as_macro (void)
 {
-  static char result[] = "1000";
+  static char result[7] = "1000";
+  int minorDigitIdx;
 
   if (strncmp (darwin_macosx_version_min, "10.", 3) != 0)
     goto fail;
   if (! ISDIGIT (darwin_macosx_version_min[3]))
     goto fail;
-  result[2] = darwin_macosx_version_min[3];
-  if (darwin_macosx_version_min[4] != '\0'
-      && darwin_macosx_version_min[4] != '.')
+
+  minorDigitIdx = 3;
+  result[2] = darwin_macosx_version_min[minorDigitIdx++];
+  if (ISDIGIT (darwin_macosx_version_min[minorDigitIdx]))
+  {
+    /* Starting with OS X 10.10, the macro ends '00' rather than '0',
+       i.e. 10.10.x becomes 101000 rather than 10100.  */
+    result[3] = darwin_macosx_version_min[minorDigitIdx++];
+    result[4] = '0';
+    result[5] = '0';
+    result[6] = '\0';
+  }
+  if (darwin_macosx_version_min[minorDigitIdx] != '\0'
+      && darwin_macosx_version_min[minorDigitIdx] != '.')
     goto fail;
 
   return result;
Index: gcc/config/i386/i386.h
===================================================================
--- a/src/gcc/config/i386/i386.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/i386.h	(.../branches/gcc-4_9-branch)
@@ -457,6 +457,8 @@
 	ix86_tune_features[X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS]
 #define TARGET_ADJUST_UNROLL \
     ix86_tune_features[X86_TUNE_ADJUST_UNROLL]
+#define TARGET_AVOID_FALSE_DEP_FOR_BMI \
+	ix86_tune_features[X86_TUNE_AVOID_FALSE_DEP_FOR_BMI]
 
 /* Feature tests against the various architecture variations.  */
 enum ix86_arch_indices {
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-4_9-branch)
@@ -111,6 +111,7 @@
   UNSPEC_LEA_ADDR
   UNSPEC_XBEGIN_ABORT
   UNSPEC_STOS
+  UNSPEC_INSN_FALSE_DEP
 
   ;; For SSE/MMX support:
   UNSPEC_FIX_NOTRUNC
@@ -11856,7 +11857,8 @@
       DONE;
     }
 
-  flags_mode = TARGET_BMI ? CCCmode : CCZmode;
+  flags_mode
+    = (TARGET_BMI && !TARGET_AVOID_FALSE_DEP_FOR_BMI) ? CCCmode : CCZmode;
 
   operands[2] = gen_reg_rtx (<MODE>mode);
   operands[3] = gen_rtx_REG (flags_mode, FLAGS_REG);
@@ -11882,7 +11884,8 @@
    (parallel [(set (match_dup 0) (plus:SI (match_dup 0) (const_int 1)))
 	      (clobber (reg:CC FLAGS_REG))])]
 {
-  enum machine_mode flags_mode = TARGET_BMI ? CCCmode : CCZmode;
+  enum machine_mode flags_mode
+    = (TARGET_BMI && !TARGET_AVOID_FALSE_DEP_FOR_BMI) ? CCCmode : CCZmode;
 
   operands[3] = gen_lowpart (QImode, operands[2]);
   operands[4] = gen_rtx_REG (flags_mode, FLAGS_REG);
@@ -11897,7 +11900,7 @@
 		     (const_int 0)))
    (set (match_operand:SWI48 0 "register_operand" "=r")
 	(ctz:SWI48 (match_dup 1)))]
-  "TARGET_BMI"
+  "TARGET_BMI && !TARGET_AVOID_FALSE_DEP_FOR_BMI"
   "tzcnt{<imodesuffix>}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
    (set_attr "prefix_0f" "1")
@@ -11918,7 +11921,58 @@
    (set_attr "btver2_decode" "double")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "ctz<mode>2"
+(define_expand "ctz<mode>2"
+  [(parallel
+    [(set (match_operand:SWI248 0 "register_operand")
+	  (ctz:SWI248
+	    (match_operand:SWI248 1 "nonimmediate_operand")))
+     (clobber (reg:CC FLAGS_REG))])])
+
+; False dependency happens when destination is only updated by tzcnt,
+; lzcnt or popcnt.  There is no false dependency when destination is
+; also used in source.
+(define_insn_and_split "*ctz<mode>2_falsedep_1"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(ctz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (clobber (reg:CC FLAGS_REG))]
+  "(TARGET_BMI || TARGET_GENERIC)
+   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)"
+  "#"
+  "&& reload_completed"
+  [(parallel
+    [(set (match_dup 0)
+	  (ctz:SWI48 (match_dup 1)))
+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)
+     (clobber (reg:CC FLAGS_REG))])]
+{
+  if (!reg_mentioned_p (operands[0], operands[1]))
+    ix86_expand_clear (operands[0]);
+})
+
+(define_insn "*ctz<mode>2_falsedep"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(ctz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (unspec [(match_operand:SWI48 2 "register_operand" "0")]
+	   UNSPEC_INSN_FALSE_DEP)
+   (clobber (reg:CC FLAGS_REG))]
+  ""
+{
+  if (TARGET_BMI)
+    return "tzcnt{<imodesuffix>}\t{%1, %0|%0, %1}";
+  else if (TARGET_GENERIC)
+    /* tzcnt expands to 'rep bsf' and we can use it even if !TARGET_BMI.  */
+    return "rep%; bsf{<imodesuffix>}\t{%1, %0|%0, %1}";
+  else
+    gcc_unreachable ();
+}
+  [(set_attr "type" "alu1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "prefix_rep" "1")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*ctz<mode>2"
   [(set (match_operand:SWI248 0 "register_operand" "=r")
 	(ctz:SWI248 (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
    (clobber (reg:CC FLAGS_REG))]
@@ -11965,7 +12019,47 @@
   operands[2] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode)-1);
 })
 
-(define_insn "clz<mode>2_lzcnt"
+(define_expand "clz<mode>2_lzcnt"
+  [(parallel
+    [(set (match_operand:SWI248 0 "register_operand")
+	  (clz:SWI248
+	    (match_operand:SWI248 1 "nonimmediate_operand")))
+     (clobber (reg:CC FLAGS_REG))])]
+  "TARGET_LZCNT")
+
+(define_insn_and_split "*clz<mode>2_lzcnt_falsedep_1"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(clz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_LZCNT
+   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)"
+  "#"
+  "&& reload_completed"
+  [(parallel
+    [(set (match_dup 0)
+	  (clz:SWI48 (match_dup 1)))
+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)
+     (clobber (reg:CC FLAGS_REG))])]
+{
+  if (!reg_mentioned_p (operands[0], operands[1]))
+    ix86_expand_clear (operands[0]);
+})
+
+(define_insn "*clz<mode>2_lzcnt_falsedep"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(clz:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (unspec [(match_operand:SWI48 2 "register_operand" "0")]
+	   UNSPEC_INSN_FALSE_DEP)
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_LZCNT"
+  "lzcnt{<imodesuffix>}\t{%1, %0|%0, %1}"
+  [(set_attr "prefix_rep" "1")
+   (set_attr "type" "bitmanip")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*clz<mode>2_lzcnt"
   [(set (match_operand:SWI248 0 "register_operand" "=r")
 	(clz:SWI248 (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
    (clobber (reg:CC FLAGS_REG))]
@@ -12248,11 +12342,40 @@
    (set_attr "prefix_0f" "1")
    (set_attr "mode" "HI")])
 
-(define_insn "popcount<mode>2"
-  [(set (match_operand:SWI248 0 "register_operand" "=r")
-	(popcount:SWI248
-	  (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
+(define_expand "popcount<mode>2"
+  [(parallel
+    [(set (match_operand:SWI248 0 "register_operand")
+	  (popcount:SWI248
+	    (match_operand:SWI248 1 "nonimmediate_operand")))
+     (clobber (reg:CC FLAGS_REG))])]
+  "TARGET_POPCNT")
+
+(define_insn_and_split "*popcount<mode>2_falsedep_1"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(popcount:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
    (clobber (reg:CC FLAGS_REG))]
+  "TARGET_POPCNT
+   && TARGET_AVOID_FALSE_DEP_FOR_BMI && optimize_function_for_speed_p (cfun)"
+  "#"
+  "&& reload_completed"
+  [(parallel
+    [(set (match_dup 0)
+	  (popcount:SWI48 (match_dup 1)))
+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)
+     (clobber (reg:CC FLAGS_REG))])]
+{
+  if (!reg_mentioned_p (operands[0], operands[1]))
+    ix86_expand_clear (operands[0]);
+})
+
+(define_insn "*popcount<mode>2_falsedep"
+  [(set (match_operand:SWI48 0 "register_operand" "=r")
+	(popcount:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")))
+   (unspec [(match_operand:SWI48 2 "register_operand" "0")]
+	   UNSPEC_INSN_FALSE_DEP)
+   (clobber (reg:CC FLAGS_REG))]
   "TARGET_POPCNT"
 {
 #if TARGET_MACHO
@@ -12265,15 +12388,12 @@
    (set_attr "type" "bitmanip")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "*popcount<mode>2_cmp"
-  [(set (reg FLAGS_REG)
-	(compare
-	  (popcount:SWI248
-	    (match_operand:SWI248 1 "nonimmediate_operand" "rm"))
-	  (const_int 0)))
-   (set (match_operand:SWI248 0 "register_operand" "=r")
-	(popcount:SWI248 (match_dup 1)))]
-  "TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)"
+(define_insn "*popcount<mode>2"
+  [(set (match_operand:SWI248 0 "register_operand" "=r")
+	(popcount:SWI248
+	  (match_operand:SWI248 1 "nonimmediate_operand" "rm")))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_POPCNT"
 {
 #if TARGET_MACHO
   return "popcnt\t{%1, %0|%0, %1}";
@@ -12285,25 +12405,6 @@
    (set_attr "type" "bitmanip")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "*popcountsi2_cmp_zext"
-  [(set (reg FLAGS_REG)
-        (compare
-          (popcount:SI (match_operand:SI 1 "nonimmediate_operand" "rm"))
-          (const_int 0)))
-   (set (match_operand:DI 0 "register_operand" "=r")
-        (zero_extend:DI(popcount:SI (match_dup 1))))]
-  "TARGET_64BIT && TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)"
-{
-#if TARGET_MACHO
-  return "popcnt\t{%1, %0|%0, %1}";
-#else
-  return "popcnt{l}\t{%1, %0|%0, %1}";
-#endif
-}
-  [(set_attr "prefix_rep" "1")
-   (set_attr "type" "bitmanip")
-   (set_attr "mode" "SI")])
-
 (define_expand "bswapdi2"
   [(set (match_operand:DI 0 "register_operand")
 	(bswap:DI (match_operand:DI 1 "nonimmediate_operand")))]
@@ -13395,7 +13496,8 @@
    (set (reg:CCFP FPSR_REG)
 	(unspec:CCFP [(match_dup 2) (match_dup 3)]
 		     UNSPEC_C2_FLAG))]
-  "TARGET_USE_FANCY_MATH_387"
+  "TARGET_USE_FANCY_MATH_387
+   && flag_finite_math_only"
   "fprem"
   [(set_attr "type" "fpspc")
    (set_attr "mode" "XF")])
@@ -13404,7 +13506,8 @@
   [(use (match_operand:XF 0 "register_operand"))
    (use (match_operand:XF 1 "general_operand"))
    (use (match_operand:XF 2 "general_operand"))]
-  "TARGET_USE_FANCY_MATH_387"
+  "TARGET_USE_FANCY_MATH_387
+   && flag_finite_math_only"
 {
   rtx label = gen_label_rtx ();
 
@@ -13427,7 +13530,8 @@
   [(use (match_operand:MODEF 0 "register_operand"))
    (use (match_operand:MODEF 1 "general_operand"))
    (use (match_operand:MODEF 2 "general_operand"))]
-  "TARGET_USE_FANCY_MATH_387"
+  "TARGET_USE_FANCY_MATH_387
+   && flag_finite_math_only"
 {
   rtx (*gen_truncxf) (rtx, rtx);
 
@@ -13466,7 +13570,8 @@
    (set (reg:CCFP FPSR_REG)
 	(unspec:CCFP [(match_dup 2) (match_dup 3)]
 		     UNSPEC_C2_FLAG))]
-  "TARGET_USE_FANCY_MATH_387"
+  "TARGET_USE_FANCY_MATH_387
+   && flag_finite_math_only"
   "fprem1"
   [(set_attr "type" "fpspc")
    (set_attr "mode" "XF")])
@@ -13475,7 +13580,8 @@
   [(use (match_operand:XF 0 "register_operand"))
    (use (match_operand:XF 1 "general_operand"))
    (use (match_operand:XF 2 "general_operand"))]
-  "TARGET_USE_FANCY_MATH_387"
+  "TARGET_USE_FANCY_MATH_387
+   && flag_finite_math_only"
 {
   rtx label = gen_label_rtx ();
 
@@ -13498,7 +13604,8 @@
   [(use (match_operand:MODEF 0 "register_operand"))
    (use (match_operand:MODEF 1 "general_operand"))
    (use (match_operand:MODEF 2 "general_operand"))]
-  "TARGET_USE_FANCY_MATH_387"
+  "TARGET_USE_FANCY_MATH_387
+   && flag_finite_math_only"
 {
   rtx (*gen_truncxf) (rtx, rtx);
 
Index: gcc/config/i386/x86-tune.def
===================================================================
--- a/src/gcc/config/i386/x86-tune.def	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/x86-tune.def	(.../branches/gcc-4_9-branch)
@@ -500,6 +500,11 @@
 DEF_TUNE (X86_TUNE_AVOID_VECTOR_DECODE, "avoid_vector_decode",
           m_K8)
 
+/* X86_TUNE_AVOID_FALSE_DEP_FOR_BMI: Avoid false dependency
+   for bit-manipulation instructions.  */
+DEF_TUNE (X86_TUNE_AVOID_FALSE_DEP_FOR_BMI, "avoid_false_dep_for_bmi",
+	  m_SANDYBRIDGE | m_HASWELL | m_INTEL | m_GENERIC)
+
 /*****************************************************************************/
 /* This never worked well before.                                            */
 /*****************************************************************************/
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-4_9-branch)
@@ -5887,9 +5887,10 @@
 	      (match_operand 5  "const_0_to_15_operand")]))
 	  (match_operand:<ssequartermode> 6 "memory_operand" "0")
 	  (match_operand:QI 7 "register_operand" "Yk")))]
-  "TARGET_AVX512F && (INTVAL (operands[2]) = INTVAL (operands[3]) - 1)
-  && (INTVAL (operands[3]) = INTVAL (operands[4]) - 1)
-  && (INTVAL (operands[4]) = INTVAL (operands[5]) - 1)"
+  "TARGET_AVX512F
+   && (INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)
+       && INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
+       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))"
 {
   operands[2] = GEN_INT ((INTVAL (operands[2])) >> 2);
   return "vextract<shuffletype>32x4\t{%2, %1, %0%{%7%}|%0%{%7%}, %1, %2}";
@@ -5909,9 +5910,10 @@
             (match_operand 3  "const_0_to_15_operand")
             (match_operand 4  "const_0_to_15_operand")
             (match_operand 5  "const_0_to_15_operand")])))]
-  "TARGET_AVX512F && (INTVAL (operands[2]) = INTVAL (operands[3]) - 1)
-  && (INTVAL (operands[3]) = INTVAL (operands[4]) - 1)
-  && (INTVAL (operands[4]) = INTVAL (operands[5]) - 1)"
+  "TARGET_AVX512F
+   && (INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)
+       && INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
+       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))"
 {
   operands[2] = GEN_INT ((INTVAL (operands[2])) >> 2);
   return "vextract<shuffletype>32x4\t{%2, %1, %0<mask_operand6>|%0<mask_operand6>, %1, %2}";
@@ -5992,9 +5994,9 @@
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "vec_extract_lo_<mode><mask_name>"
-  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=<store_mask_constraint>")
+  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=<store_mask_constraint>,v")
 	(vec_select:<ssehalfvecmode>
-	  (match_operand:V8FI 1 "nonimmediate_operand" "vm")
+	  (match_operand:V8FI 1 "nonimmediate_operand" "v,m")
 	  (parallel [(const_int 0) (const_int 1)
             (const_int 2) (const_int 3)])))]
   "TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
Index: gcc/config/i386/avx512fintrin.h
===================================================================
--- a/src/gcc/config/i386/avx512fintrin.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/avx512fintrin.h	(.../branches/gcc-4_9-branch)
@@ -8103,6 +8103,22 @@
   return __builtin_ia32_movntdqa512 ((__v8di *)__P);
 }
 
+/* Constants for mantissa extraction */
+typedef enum
+{
+  _MM_MANT_NORM_1_2,		/* interval [1, 2)      */
+  _MM_MANT_NORM_p5_2,		/* interval [0.5, 2)    */
+  _MM_MANT_NORM_p5_1,		/* interval [0.5, 1)    */
+  _MM_MANT_NORM_p75_1p5		/* interval [0.75, 1.5) */
+} _MM_MANTISSA_NORM_ENUM;
+
+typedef enum
+{
+  _MM_MANT_SIGN_src,		/* sign = sign(SRC)     */
+  _MM_MANT_SIGN_zero,		/* sign = 0             */
+  _MM_MANT_SIGN_nan		/* DEST = NaN if sign(SRC) = 1 */
+} _MM_MANTISSA_SIGN_ENUM;
+
 #ifdef __OPTIMIZE__
 extern __inline __m128
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
@@ -8182,22 +8198,6 @@
 						    (__mmask8) __U, __R);
 }
 
-/* Constants for mantissa extraction */
-typedef enum
-{
-  _MM_MANT_NORM_1_2,		/* interval [1, 2)      */
-  _MM_MANT_NORM_p5_2,		/* interval [0.5, 2)    */
-  _MM_MANT_NORM_p5_1,		/* interval [0.5, 1)    */
-  _MM_MANT_NORM_p75_1p5		/* interval [0.75, 1.5) */
-} _MM_MANTISSA_NORM_ENUM;
-
-typedef enum
-{
-  _MM_MANT_SIGN_src,		/* sign = sign(SRC)     */
-  _MM_MANT_SIGN_zero,		/* sign = 0             */
-  _MM_MANT_SIGN_nan		/* DEST = NaN if sign(SRC) = 1 */
-} _MM_MANTISSA_SIGN_ENUM;
-
 extern __inline __m512d
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm512_getmant_round_pd (__m512d __A, _MM_MANTISSA_NORM_ENUM __B,
Index: gcc/config/i386/ia32intrin.h
===================================================================
--- a/src/gcc/config/i386/ia32intrin.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/ia32intrin.h	(.../branches/gcc-4_9-branch)
@@ -256,11 +256,7 @@
 
 #define _bswap64(a)		__bswapq(a)
 #define _popcnt64(a)		__popcntq(a)
-#define _lrotl(a,b)		__rolq((a), (b))
-#define _lrotr(a,b)		__rorq((a), (b))
 #else
-#define _lrotl(a,b)		__rold((a), (b))
-#define _lrotr(a,b)		__rord((a), (b))
 
 /* Read flags register */
 extern __inline unsigned int
@@ -280,6 +276,16 @@
 
 #endif
 
+/* On LP64 systems, longs are 64-bit.  Use the appropriate rotate
+ * function.  */
+#ifdef __LP64__
+#define _lrotl(a,b)		__rolq((a), (b))
+#define _lrotr(a,b)		__rorq((a), (b))
+#else
+#define _lrotl(a,b)		__rold((a), (b))
+#define _lrotr(a,b)		__rord((a), (b))
+#endif
+
 #define _bit_scan_forward(a)	__bsfd(a)
 #define _bit_scan_reverse(a)	__bsrd(a)
 #define _bswap(a)		__bswapd(a)
Index: gcc/config/i386/driver-i386.c
===================================================================
--- a/src/gcc/config/i386/driver-i386.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/driver-i386.c	(.../branches/gcc-4_9-branch)
@@ -431,7 +431,8 @@
 
   model = (eax >> 4) & 0x0f;
   family = (eax >> 8) & 0x0f;
-  if (vendor == signature_INTEL_ebx)
+  if (vendor == signature_INTEL_ebx
+      || vendor == signature_AMD_ebx)
     {
       unsigned int extended_model, extended_family;
 
@@ -570,7 +571,7 @@
 
       if (name == signature_NSC_ebx)
 	processor = PROCESSOR_GEODE;
-      else if (has_movbe)
+      else if (has_movbe && family == 22)
 	processor = PROCESSOR_BTVER2;
       else if (has_avx2)
         processor = PROCESSOR_BDVER4;
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-4_9-branch)
@@ -3258,12 +3258,13 @@
 	| PTA_FMA | PTA_PRFCHW | PTA_FXSR | PTA_XSAVE 
 	| PTA_XSAVEOPT | PTA_FSGSBASE},
      {"bdver4", PROCESSOR_BDVER4, CPU_BDVER4,
-        PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
-        | PTA_SSE4A | PTA_CX16 | PTA_ABM | PTA_SSSE3 | PTA_SSE4_1
-        | PTA_SSE4_2 | PTA_AES | PTA_PCLMUL | PTA_AVX | PTA_AVX2 
+	PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
+	| PTA_SSE4A | PTA_CX16 | PTA_ABM | PTA_SSSE3 | PTA_SSE4_1
+	| PTA_SSE4_2 | PTA_AES | PTA_PCLMUL | PTA_AVX | PTA_AVX2 
 	| PTA_FMA4 | PTA_XOP | PTA_LWP | PTA_BMI | PTA_BMI2 
 	| PTA_TBM | PTA_F16C | PTA_FMA | PTA_PRFCHW | PTA_FXSR 
-	| PTA_XSAVE | PTA_XSAVEOPT | PTA_FSGSBASE},
+	| PTA_XSAVE | PTA_XSAVEOPT | PTA_FSGSBASE | PTA_RDRND
+	| PTA_MOVBE},
       {"btver1", PROCESSOR_BTVER1, CPU_GENERIC,
 	PTA_64BIT | PTA_MMX |  PTA_SSE  | PTA_SSE2 | PTA_SSE3
 	| PTA_SSSE3 | PTA_SSE4A |PTA_ABM | PTA_CX16 | PTA_PRFCHW
@@ -3331,8 +3332,9 @@
       /* When TARGET_BI_ARCH == 2, by default, OPTION_MASK_ABI_X32 is
 	 on and OPTION_MASK_ABI_64 is off.  We turn off
 	 OPTION_MASK_ABI_X32 if OPTION_MASK_ABI_64 is turned on by
-	 -m64.  */
-      if (TARGET_LP64_P (opts->x_ix86_isa_flags))
+	 -m64 or OPTION_MASK_CODE16 is turned on by -m16.  */
+      if (TARGET_LP64_P (opts->x_ix86_isa_flags)
+	  || TARGET_16BIT_P (opts->x_ix86_isa_flags))
 	opts->x_ix86_isa_flags &= ~OPTION_MASK_ABI_X32;
 #endif
     }
@@ -6552,7 +6554,7 @@
 					   bit_offset);
 		  if (!num)
 		    return 0;
-		  for (i = 0; i < num; i++)
+		  for (i = 0; i < num && i < words; i++)
 		    classes[i] = merge_classes (subclasses[i], classes[i]);
 		}
 	    }
@@ -42699,8 +42701,8 @@
 	      op0 = gen_lowpart (V4DImode, d->op0);
 	      op1 = gen_lowpart (V4DImode, d->op1);
 	      rperm[0]
-		= GEN_INT (((d->perm[0] & (nelt / 2)) ? 1 : 0)
-			   || ((d->perm[nelt / 2] & (nelt / 2)) ? 2 : 0));
+		= GEN_INT ((d->perm[0] / (nelt / 2))
+			   | ((d->perm[nelt / 2] / (nelt / 2)) * 16));
 	      emit_insn (gen_avx2_permv2ti (target, op0, op1, rperm[0]));
 	      if (target != d->target)
 		emit_move_insn (d->target, gen_lowpart (d->vmode, target));
@@ -45092,8 +45094,10 @@
       /* t4: ((B*E)+(A*F))<<32, ((D*G)+(C*H))<<32 */
       emit_insn (gen_ashlv2di3 (t4, t3, GEN_INT (32)));
 
-      /* op0: (((B*E)+(A*F))<<32)+(B*F), (((D*G)+(C*H))<<32)+(D*H) */
-      emit_insn (gen_xop_pmacsdql (op0, op1, op2, t4));
+      /* Multiply lower parts and add all */
+      t5 = gen_reg_rtx (V2DImode);
+      emit_insn (gen_vec_widen_umult_even_v4si (t5, gen_lowpart (V4SImode, op1), gen_lowpart (V4SImode, op2)));
+      op0 = expand_binop (mode, add_optab, t5, t4, op0, 1, OPTAB_DIRECT);
     }
   else
     {
Index: gcc/config/sh/predicates.md
===================================================================
--- a/src/gcc/config/sh/predicates.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sh/predicates.md	(.../branches/gcc-4_9-branch)
@@ -398,7 +398,7 @@
 (define_predicate "general_extend_operand"
   (match_code "subreg,reg,mem,truncate")
 {
-  if (GET_CODE (op) == TRUNCATE)
+  if (reload_completed && GET_CODE (op) == TRUNCATE)
     return arith_operand (op, mode);
 
   if (MEM_P (op) || (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op))))
@@ -489,6 +489,10 @@
       rtx mem_rtx = MEM_P (op) ? op : SUBREG_REG (op);
       rtx x = XEXP (mem_rtx, 0);
 
+      if (! ALLOW_INDEXED_ADDRESS
+	  && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))
+	return false;
+
       if ((mode == QImode || mode == HImode)
 	  && GET_CODE (x) == PLUS
 	  && REG_P (XEXP (x, 0))
@@ -567,6 +571,10 @@
       rtx mem_rtx = MEM_P (op) ? op : SUBREG_REG (op);
       rtx x = XEXP (mem_rtx, 0);
 
+      if (! ALLOW_INDEXED_ADDRESS
+	  && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))
+	return false;
+
       if ((mode == QImode || mode == HImode)
 	  && GET_CODE (x) == PLUS
 	  && REG_P (XEXP (x, 0))
Index: gcc/config/sh/sh.c
===================================================================
--- a/src/gcc/config/sh/sh.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sh/sh.c	(.../branches/gcc-4_9-branch)
@@ -861,6 +861,12 @@
        targetm.asm_out.aligned_op.di = NULL;
        targetm.asm_out.unaligned_op.di = NULL;
     }
+
+  /* User/priviledged mode is supported only on SH3*, SH4* and SH5*.
+     Disable it for everything else.  */
+  if (! (TARGET_SH3 || TARGET_SH5) && TARGET_USERMODE)
+    TARGET_USERMODE = false;
+
   if (TARGET_SH1)
     {
       if (! strcmp (sh_div_str, "call-div1"))
@@ -10207,6 +10213,10 @@
 static bool
 sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)
 {
+  if (! ALLOW_INDEXED_ADDRESS
+      && GET_CODE (x) == PLUS && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1)))
+    return false;
+
   if (REG_P (x) && REGNO (x) == GBR_REG)
     return true;
 
@@ -10436,6 +10446,28 @@
   enum reload_type type = (enum reload_type) itype;
   const int mode_sz = GET_MODE_SIZE (mode);
 
+  if (! ALLOW_INDEXED_ADDRESS
+      && GET_CODE (*p) == PLUS
+      && REG_P (XEXP (*p, 0)) && REG_P (XEXP (*p, 1)))
+    {
+      *p = copy_rtx (*p);
+      push_reload (*p, NULL_RTX, p, NULL,
+		   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);
+      return true;
+    }
+
+  if (! ALLOW_INDEXED_ADDRESS
+      && GET_CODE (*p) == PLUS
+      && GET_CODE (XEXP (*p, 0)) == PLUS)
+    {
+      rtx sum = gen_rtx_PLUS (Pmode, XEXP (XEXP (*p, 0), 0),
+				     XEXP (XEXP (*p, 0), 1));
+      *p = gen_rtx_PLUS (Pmode, sum, XEXP (*p, 1));
+      push_reload (sum, NULL_RTX, &XEXP (*p, 0), NULL,
+		   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);
+      return true;
+    }
+
   if (TARGET_SHMEDIA)
     return false;
 
Index: gcc/config/sh/sync.md
===================================================================
--- a/src/gcc/config/sh/sync.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sh/sync.md	(.../branches/gcc-4_9-branch)
@@ -466,6 +466,7 @@
    (set (mem:SI (match_dup 1))
 	(unspec:SI
 	  [(match_operand:SI 2 "arith_operand" "rI08")] UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))]
   "TARGET_ATOMIC_HARD_LLCS
    || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)"
@@ -484,6 +485,7 @@
    (set (mem:QIHI (match_dup 1))
 	(unspec:QIHI
 	  [(match_operand:QIHI 2 "register_operand" "r")] UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))
    (clobber (match_scratch:SI 3 "=&r"))
    (clobber (match_scratch:SI 4 "=1"))]
@@ -617,6 +619,7 @@
 	  [(FETCHOP:SI (mem:SI (match_dup 1))
 	     (match_operand:SI 2 "<fetchop_predicate>" "<fetchop_constraint>"))]
 	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))]
   "TARGET_ATOMIC_HARD_LLCS
    || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)"
@@ -637,6 +640,7 @@
 	  [(FETCHOP:QIHI (mem:QIHI (match_dup 1))
 	     (match_operand:QIHI 2 "<fetchop_predicate>" "<fetchop_constraint>"))]
 	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))
    (clobber (match_scratch:SI 3 "=&r"))
    (clobber (match_scratch:SI 4 "=1"))]
@@ -784,6 +788,7 @@
 	  [(not:SI (and:SI (mem:SI (match_dup 1))
 		   (match_operand:SI 2 "logical_operand" "rK08")))]
 	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))]
   "TARGET_ATOMIC_HARD_LLCS
    || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)"
@@ -805,6 +810,7 @@
 	  [(not:QIHI (and:QIHI (mem:QIHI (match_dup 1))
 		     (match_operand:QIHI 2 "logical_operand" "rK08")))]
 	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))
    (clobber (match_scratch:SI 3 "=&r"))
    (clobber (match_scratch:SI 4 "=1"))]
@@ -903,7 +909,7 @@
 	 "	and	%0,%3"			"\n"
 	 "	not	%3,%3"			"\n"
 	 "	mov.<bwl>	%3,@%1"		"\n"
-	 "	stc	%4,sr";
+	 "	ldc	%4,sr";
 }
   [(set_attr "length" "20")])
 
@@ -960,7 +966,8 @@
    (set (mem:SI (match_dup 1))
 	(unspec:SI
 	  [(FETCHOP:SI (mem:SI (match_dup 1)) (match_dup 2))]
-	  UNSPEC_ATOMIC))]
+	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))]
   "TARGET_ATOMIC_HARD_LLCS
    || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)"
 {
@@ -980,6 +987,7 @@
 	(unspec:QIHI
 	  [(FETCHOP:QIHI (mem:QIHI (match_dup 1)) (match_dup 2))]
 	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))
    (clobber (match_scratch:SI 3 "=&r"))
    (clobber (match_scratch:SI 4 "=1"))]
@@ -1124,7 +1132,8 @@
    (set (mem:SI (match_dup 1))
 	(unspec:SI
 	  [(not:SI (and:SI (mem:SI (match_dup 1)) (match_dup 2)))]
-	  UNSPEC_ATOMIC))]
+	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))]
   "TARGET_ATOMIC_HARD_LLCS
    || (TARGET_SH4A_ARCH && TARGET_ATOMIC_ANY && !TARGET_ATOMIC_STRICT)"
 {
@@ -1145,6 +1154,7 @@
 	(unspec:QIHI
 	  [(not:QIHI (and:QIHI (mem:QIHI (match_dup 1)) (match_dup 2)))]
 	  UNSPEC_ATOMIC))
+   (set (reg:SI T_REG) (const_int 1))
    (clobber (reg:SI R0_REG))
    (clobber (match_scratch:SI 3 "=&r"))
    (clobber (match_scratch:SI 4 "=1"))]
@@ -1353,7 +1363,7 @@
 	 "	ldc	r0,sr"		"\n"
 	 "	mov.b	@%0,r0"		"\n"
 	 "	mov.b	%1,@%0"		"\n"
-	 "	stc	%2,sr"		"\n"
+	 "	ldc	%2,sr"		"\n"
 	 "	tst	r0,r0";
 }
   [(set_attr "length" "16")])
Index: gcc/config/sh/sh.md
===================================================================
--- a/src/gcc/config/sh/sh.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sh/sh.md	(.../branches/gcc-4_9-branch)
@@ -868,9 +868,9 @@
 
 (define_insn "*cmp_div0s_0"
   [(set (reg:SI T_REG)
-	(eq:SI (lshiftrt:SI (match_operand:SI 0 "arith_reg_operand")
+	(eq:SI (lshiftrt:SI (match_operand:SI 0 "arith_reg_operand" "%r")
 			    (const_int 31))
-	       (ge:SI (match_operand:SI 1 "arith_reg_operand")
+	       (ge:SI (match_operand:SI 1 "arith_reg_operand" "r")
 		      (const_int 0))))]
   "TARGET_SH1"
   "div0s	%0,%1"
@@ -4563,6 +4563,12 @@
 {
   if (TARGET_SHMEDIA)
     {
+       if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 0)
+	{
+	  operands[2] = GEN_INT (-INTVAL (operands[2]));
+	  emit_insn (gen_ashrsi3_media (operands[0], operands[1], operands[2]));
+	  DONE;
+	}
       emit_insn (gen_ashlsi3_media (operands[0], operands[1], operands[2]));
       DONE;
     }
@@ -4803,6 +4809,12 @@
 {
   if (TARGET_SHMEDIA)
     {
+       if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 0)
+	{
+	  operands[2] = GEN_INT (-INTVAL (operands[2]));
+	  emit_insn (gen_ashrdi3_media (operands[0], operands[1], operands[2]));
+	  DONE;
+	}
       emit_insn (gen_ashldi3_media (operands[0], operands[1], operands[2]));
       DONE;
     }
@@ -4896,6 +4908,12 @@
 {
   if (TARGET_SHMEDIA)
     {
+      if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 0)
+	{
+	  operands[2] = GEN_INT (-INTVAL (operands[2]));
+	  emit_insn (gen_ashlsi3_media (operands[0], operands[1], operands[2]));
+	  DONE;
+	}
       emit_insn (gen_ashrsi3_media (operands[0], operands[1], operands[2]));
       DONE;
     }
@@ -4995,6 +5013,12 @@
 {
   if (TARGET_SHMEDIA)
     {
+      if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 0)
+	{
+	  operands[2] = GEN_INT (-INTVAL (operands[2]));
+	  emit_insn (gen_ashldi3_media (operands[0], operands[1], operands[2]));
+	  DONE;
+	}
       emit_insn (gen_ashrdi3_media (operands[0], operands[1], operands[2]));
       DONE;
     }
@@ -5069,6 +5093,12 @@
 {
   if (TARGET_SHMEDIA)
     {
+      if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 0)
+	{
+	  operands[2] = GEN_INT (-INTVAL (operands[2]));
+	  emit_insn (gen_ashlsi3_media (operands[0], operands[1], operands[2]));
+	  DONE;
+	}
       emit_insn (gen_lshrsi3_media (operands[0], operands[1], operands[2]));
       DONE;
     }
@@ -5263,6 +5293,12 @@
 {
   if (TARGET_SHMEDIA)
     {
+      if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 0)
+	{
+	  operands[2] = GEN_INT (-INTVAL (operands[2]));
+	  emit_insn (gen_ashldi3_media (operands[0], operands[1], operands[2]));
+	  DONE;
+	}
       emit_insn (gen_lshrdi3_media (operands[0], operands[1], operands[2]));
       DONE;
     }
Index: gcc/config/sh/sh.opt
===================================================================
--- a/src/gcc/config/sh/sh.opt	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/sh/sh.opt	(.../branches/gcc-4_9-branch)
@@ -343,7 +343,7 @@
 Cost to assume for a multiply insn
 
 musermode
-Target Report RejectNegative Var(TARGET_USERMODE)
+Target Var(TARGET_USERMODE)
 Don't generate privileged-mode only code; implies -mno-inline-ic_invalidate if the inline code would not work in user mode.
 
 ;; We might want to enable this by default for TARGET_HARD_SH4, because
Index: gcc/config/avr/avr.md
===================================================================
--- a/src/gcc/config/avr/avr.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/avr/avr.md	(.../branches/gcc-4_9-branch)
@@ -4931,8 +4931,9 @@
         (unspec:HI [(match_operand:HI 0 "register_operand" "!z,*r,z")]
                    UNSPEC_INDEX_JMP))
    (use (label_ref (match_operand 1 "" "")))
-   (clobber (match_dup 0))]
-  ""
+   (clobber (match_dup 0))
+   (clobber (const_int 0))]
+  "!AVR_HAVE_EIJMP_EICALL"
   "@
 	ijmp
 	push %A0\;push %B0\;ret
@@ -4941,7 +4942,20 @@
    (set_attr "isa" "rjmp,rjmp,jmp")
    (set_attr "cc" "none,none,clobber")])
 
+(define_insn "*tablejump.3byte-pc"
+  [(set (pc)
+        (unspec:HI [(reg:HI REG_Z)]
+                   UNSPEC_INDEX_JMP))
+   (use (label_ref (match_operand 0 "" "")))
+   (clobber (reg:HI REG_Z))
+   (clobber (reg:QI 24))]
+  "AVR_HAVE_EIJMP_EICALL"
+  "clr r24\;subi r30,pm_lo8(-(%0))\;sbci r31,pm_hi8(-(%0))\;sbci r24,pm_hh8(-(%0))\;jmp __tablejump2__"
+  [(set_attr "length" "6")
+   (set_attr "isa" "eijmp")
+   (set_attr "cc" "clobber")])
 
+
 (define_expand "casesi"
   [(parallel [(set (match_dup 6)
                    (minus:HI (subreg:HI (match_operand:SI 0 "register_operand" "") 0)
@@ -4958,15 +4972,31 @@
                       (label_ref (match_operand 4 "" ""))
                       (pc)))
 
-   (set (match_dup 6)
-        (plus:HI (match_dup 6) (label_ref (match_operand:HI 3 "" ""))))
+   (set (match_dup 10)
+        (match_dup 7))
 
-   (parallel [(set (pc) (unspec:HI [(match_dup 6)] UNSPEC_INDEX_JMP))
+   (parallel [(set (pc)
+                   (unspec:HI [(match_dup 10)] UNSPEC_INDEX_JMP))
               (use (label_ref (match_dup 3)))
-              (clobber (match_dup 6))])]
+              (clobber (match_dup 10))
+              (clobber (match_dup 8))])]
   ""
   {
     operands[6] = gen_reg_rtx (HImode);
+
+    if (AVR_HAVE_EIJMP_EICALL)
+      {
+        operands[7] = operands[6];
+        operands[8] = all_regs_rtx[24];
+        operands[10] = gen_rtx_REG (HImode, REG_Z);
+      }
+    else
+      {
+        operands[7] = gen_rtx_PLUS (HImode, operands[6], 
+                                    gen_rtx_LABEL_REF (VOIDmode, operands[3]));
+        operands[8] = const0_rtx;
+        operands[10] = operands[6];
+      }
   })
 
 
Index: gcc/config/nios2/rtems.h
===================================================================
--- a/src/gcc/config/nios2/rtems.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/nios2/rtems.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* Definitions for rtems targeting a NIOS2 using ELF.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+
+   Contributed by Chris Johns (chrisj@rtems.org).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Specify predefined symbols in preprocessor.  */
+#define TARGET_OS_CPP_BUILTINS()        \
+do {                                    \
+  builtin_define ("__rtems__");         \
+  builtin_define ("__USE_INIT_FINI__"); \
+  builtin_assert ("system=rtems");      \
+} while (0)
+
+/* This toolchain implements the ABI for Linux Systems documented in the
+   Nios II Processor Reference Handbook.
+
+   This is done so RTEMS targets have Thread Local Storage like Linux.  */
+#define TARGET_LINUX_ABI 1
Index: gcc/config/nios2/t-rtems
===================================================================
--- a/src/gcc/config/nios2/t-rtems	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/nios2/t-rtems	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,133 @@
+# Custom RTEMS multilibs
+
+MULTILIB_OPTIONS = mhw-mul mhw-mulx mhw-div mcustom-fadds=253 mcustom-fdivs=255 mcustom-fmuls=252 mcustom-fsubs=254
+
+# Enumeration of multilibs
+
+# MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div/mcustom-fsubs=254
+# MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mhw-div
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-mulx
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mhw-div
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mul/mcustom-fsubs=254
+# MULTILIB_EXCEPTIONS += mhw-mul
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mhw-div
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-mulx/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-mulx
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mhw-div/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mhw-div
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fadds=253/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fadds=253
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255/mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255/mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fdivs=255
+MULTILIB_EXCEPTIONS += mcustom-fmuls=252/mcustom-fsubs=254
+MULTILIB_EXCEPTIONS += mcustom-fmuls=252
+MULTILIB_EXCEPTIONS += mcustom-fsubs=254
Index: gcc/config/cris/cris.md
===================================================================
--- a/src/gcc/config/cris/cris.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris.md	(.../branches/gcc-4_9-branch)
@@ -919,6 +919,8 @@
     (match_operand:SI 1 "cris_general_operand_or_symbol" ""))]
   ""
 {
+  enum cris_symbol_type t;
+
   /* If the output goes to a MEM, make sure we have zero or a register as
      input.  */
   if (MEM_P (operands[0])
@@ -934,12 +936,12 @@
      valid symbol?  Can we exclude global PIC addresses with an added
      offset?  */
     if (flag_pic
-	&& CONSTANT_ADDRESS_P (operands[1])
+	&& CONSTANT_P (operands[1])
 	&& !cris_valid_pic_const (operands[1], false))
       {
-	enum cris_pic_symbol_type t = cris_pic_symbol_type_of (operands[1]);
+	t = cris_symbol_type_of (operands[1]);
 
-	gcc_assert (t != cris_no_symbol);
+	gcc_assert (t != cris_no_symbol && t != cris_offsettable_symbol);
 
 	if (! REG_S_P (operands[0]))
 	  {
@@ -1086,7 +1088,12 @@
 	 if (!flag_pic
 	     && (GET_CODE (operands[1]) == SYMBOL_REF
 		 || GET_CODE (operands[1]) == LABEL_REF
-		 || GET_CODE (operands[1]) == CONST))
+		 || (GET_CODE (operands[1]) == CONST
+		     && (GET_CODE (XEXP (operands[1], 0)) != UNSPEC
+			 || (XINT (XEXP (operands[1], 0), 1)
+			     == CRIS_UNSPEC_PLT_PCREL)
+			 || (XINT (XEXP (operands[1], 0), 1)
+			     == CRIS_UNSPEC_PCREL)))))
 	   {
 	     /* FIXME: Express this through (set_attr cc none) instead,
 		since we can't express the ``none'' at this point.  FIXME:
@@ -1169,6 +1176,12 @@
 	  case CRIS_UNSPEC_PCREL:
 	  case CRIS_UNSPEC_PLT_PCREL:
 	    gcc_assert (TARGET_V32);
+	    /* LAPC doesn't set condition codes; clear them to make the
+	       (equivalence-marked) result of this insn not presumed
+	       present.  This instruction can be a PIC symbol load (for
+	       a hidden symbol) which for weak symbols will be followed
+	       by a test for NULL.  */
+	    CC_STATUS_INIT;
 	    return "lapc %1,%0";
 
 	  default:
@@ -3710,15 +3723,16 @@
 {
   gcc_assert (MEM_P (operands[0]));
   if (flag_pic)
-    cris_expand_pic_call_address (&operands[0]);
+    cris_expand_pic_call_address (&operands[0], &operands[1]);
+  else
+    operands[1] = const0_rtx;
 })
 
-;; Accept *anything* as operand 1.  Accept operands for operand 0 in
-;; order of preference.
+;; Accept operands for operand 0 in order of preference.
 
 (define_insn "*expanded_call_non_v32"
   [(call (mem:QI (match_operand:SI 0 "general_operand" "r,Q>,g"))
-	 (match_operand 1 "" ""))
+	 (match_operand:SI 1 "cris_call_type_marker" "rM,rM,rM"))
    (clobber (reg:SI CRIS_SRP_REGNUM))]
   "!TARGET_V32"
   "jsr %0")
@@ -3727,7 +3741,7 @@
   [(call
     (mem:QI
      (match_operand:SI 0 "cris_nonmemory_operand_or_callable_symbol" "n,r,U,i"))
-    (match_operand 1 "" ""))
+    (match_operand:SI 1 "cris_call_type_marker" "rM,rM,rM,rM"))
    (clobber (reg:SI CRIS_SRP_REGNUM))]
   "TARGET_V32"
   "@
@@ -3740,7 +3754,7 @@
 ;; Parallel when calculating and reusing address of indirect pointer
 ;; with simple offset.  (Makes most sense with PIC.)  It looks a bit
 ;; wrong not to have the clobber last, but that's the way combine
-;; generates it (except it doesn' look into the *inner* mem, so this
+;; generates it (except it doesn't look into the *inner* mem, so this
 ;; just matches a peephole2).  FIXME: investigate that.
 (define_insn "*expanded_call_side"
   [(call (mem:QI
@@ -3747,12 +3761,14 @@
 	  (mem:SI
 	   (plus:SI (match_operand:SI 0 "cris_bdap_operand" "%r,  r,r")
 		    (match_operand:SI 1 "cris_bdap_operand" "r>Rn,r,>Rn"))))
-	 (match_operand 2 "" ""))
+	 (match_operand:SI 2 "cris_call_type_marker" "rM,rM,rM"))
    (clobber (reg:SI CRIS_SRP_REGNUM))
    (set (match_operand:SI 3 "register_operand" "=*0,r,r")
 	(plus:SI (match_dup 0)
 		 (match_dup 1)))]
-  "!TARGET_AVOID_GOTPLT && !TARGET_V32"
+  ;; Disabled until after reload until we can avoid an output reload for
+  ;; operand 3 (being forbidden for call insns).
+  "reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32"
   "jsr [%3=%0%S1]")
 
 (define_expand "call_value"
@@ -3764,10 +3780,12 @@
 {
   gcc_assert (MEM_P (operands[1]));
   if (flag_pic)
-    cris_expand_pic_call_address (&operands[1]);
+    cris_expand_pic_call_address (&operands[1], &operands[2]);
+  else
+    operands[2] = const0_rtx;
 })
 
-;; Accept *anything* as operand 2.  The validity other than "general" of
+;; The validity other than "general" of
 ;; operand 0 will be checked elsewhere.  Accept operands for operand 1 in
 ;; order of preference (Q includes r, but r is shorter, faster).
 ;;  We also accept a PLT symbol.  We output it as [rPIC+sym:GOTPLT] rather
@@ -3776,7 +3794,7 @@
 (define_insn "*expanded_call_value_non_v32"
   [(set (match_operand 0 "nonimmediate_operand" "=g,g,g")
 	(call (mem:QI (match_operand:SI 1 "general_operand" "r,Q>,g"))
-	      (match_operand 2 "" "")))
+	      (match_operand:SI 2 "cris_call_type_marker" "rM,rM,rM")))
    (clobber (reg:SI CRIS_SRP_REGNUM))]
   "!TARGET_V32"
   "Jsr %1"
@@ -3790,12 +3808,14 @@
 	  (mem:SI
 	   (plus:SI (match_operand:SI 1 "cris_bdap_operand" "%r,  r,r")
 		    (match_operand:SI 2 "cris_bdap_operand" "r>Rn,r,>Rn"))))
-	      (match_operand 3 "" "")))
+	 (match_operand:SI 3 "cris_call_type_marker" "rM,rM,rM")))
    (clobber (reg:SI CRIS_SRP_REGNUM))
    (set (match_operand:SI 4 "register_operand" "=*1,r,r")
 	(plus:SI (match_dup 1)
 		 (match_dup 2)))]
-  "!TARGET_AVOID_GOTPLT && !TARGET_V32"
+  ;; Disabled until after reload until we can avoid an output reload for
+  ;; operand 4 (being forbidden for call insns).
+  "reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32"
   "Jsr [%4=%1%S2]"
   [(set_attr "cc" "clobber")])
 
@@ -3805,7 +3825,7 @@
     (call
      (mem:QI
       (match_operand:SI 1 "cris_nonmemory_operand_or_callable_symbol" "n,r,U,i"))
-     (match_operand 2 "" "")))
+     (match_operand:SI 2 "cris_call_type_marker" "rM,rM,rM,rM")))
    (clobber (reg:SI 16))]
   "TARGET_V32"
   "@
@@ -4827,7 +4847,7 @@
   /* Make sure we have canonical RTX so we match the insn pattern -
      not a constant in the first operand.  We also require the order
      (plus reg mem) to match the final pattern.  */
-  if (CONSTANT_P (otherop) || MEM_P (otherop))
+  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))
     {
       operands[7] = operands[1];
       operands[8] = otherop;
@@ -4878,7 +4898,7 @@
   /* Make sure we have canonical RTX so we match the insn pattern -
      not a constant in the first operand.  We also require the order
      (plus reg mem) to match the final pattern.  */
-  if (CONSTANT_P (otherop) || MEM_P (otherop))
+  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))
     {
       operands[7] = operands[1];
       operands[8] = otherop;
Index: gcc/config/cris/cris.c
===================================================================
--- a/src/gcc/config/cris/cris.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris.c	(.../branches/gcc-4_9-branch)
@@ -147,6 +147,7 @@
 static void cris_function_arg_advance (cumulative_args_t, enum machine_mode,
 				       const_tree, bool);
 static tree cris_md_asm_clobbers (tree, tree, tree);
+static bool cris_cannot_force_const_mem (enum machine_mode, rtx);
 
 static void cris_option_override (void);
 
@@ -214,6 +215,9 @@
 #undef TARGET_LEGITIMATE_ADDRESS_P
 #define TARGET_LEGITIMATE_ADDRESS_P cris_legitimate_address_p
 
+#undef TARGET_LEGITIMATE_CONSTANT_P
+#define TARGET_LEGITIMATE_CONSTANT_P cris_legitimate_constant_p
+
 #undef TARGET_PREFERRED_RELOAD_CLASS
 #define TARGET_PREFERRED_RELOAD_CLASS cris_preferred_reload_class
 
@@ -248,6 +252,10 @@
 #define TARGET_FUNCTION_ARG_ADVANCE cris_function_arg_advance
 #undef TARGET_MD_ASM_CLOBBERS
 #define TARGET_MD_ASM_CLOBBERS cris_md_asm_clobbers
+
+#undef TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM cris_cannot_force_const_mem
+
 #undef TARGET_FRAME_POINTER_REQUIRED
 #define TARGET_FRAME_POINTER_REQUIRED cris_frame_pointer_required
 
@@ -506,6 +514,21 @@
   return crtl->uses_pic_offset_table;
 }
 
+/* Worker function for TARGET_CANNOT_FORCE_CONST_MEM.
+   We can't put PIC addresses in the constant pool, not even the ones that
+   can be reached as pc-relative as we can't tell when or how to do that.  */
+
+static bool
+cris_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  enum cris_symbol_type t = cris_symbol_type_of (x);
+
+  return
+    t == cris_unspec
+    || t == cris_got_symbol
+    || t == cris_rel_symbol;
+}
+
 /* Given an rtx, return the text string corresponding to the CODE of X.
    Intended for use in the assembly language output section of a
    define_insn.  */
@@ -601,7 +624,7 @@
 
   if (REG_P (index))
     fprintf (file, "$%s.b", reg_names[REGNO (index)]);
-  else if (CONSTANT_P (index))
+  else if (CRIS_CONSTANT_P (index))
     cris_output_addr_const (file, index);
   else if (GET_CODE (index) == MULT)
     {
@@ -1041,7 +1064,7 @@
       /* If this is a GOT symbol, force it to be emitted as :GOT and
 	 :GOTPLT regardless of -fpic (i.e. not as :GOT16, :GOTPLT16).
 	 Avoid making this too much of a special case.  */
-      if (flag_pic == 1 && CONSTANT_P (operand))
+      if (flag_pic == 1 && CRIS_CONSTANT_P (operand))
 	{
 	  int flag_pic_save = flag_pic;
 
@@ -1161,7 +1184,7 @@
     default:
       /* No need to handle all strange variants, let output_addr_const
 	 do it for us.  */
-      if (CONSTANT_P (operand))
+      if (CRIS_CONSTANT_P (operand))
 	{
 	  cris_output_addr_const (file, operand);
 	  return;
@@ -1358,7 +1381,7 @@
 bool
 cris_constant_index_p (const_rtx x)
 {
-  return (CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));
+  return (CRIS_CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));
 }
 
 /* True if X is a valid base register.  */
@@ -1467,6 +1490,29 @@
   return false;
 }
 
+/* Worker function for TARGET_LEGITIMATE_CONSTANT_P.  We have to handle
+   PIC constants that aren't legitimized.  FIXME: there used to be a
+   guarantee that the target LEGITIMATE_CONSTANT_P didn't have to handle
+   PIC constants, but no more (4.7 era); testcase: glibc init-first.c.
+   While that may be seen as a bug, that guarantee seems a wart by design,
+   so don't bother; fix the documentation instead.  */
+
+bool
+cris_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  enum cris_symbol_type t;
+
+  if (flag_pic)
+    return LEGITIMATE_PIC_OPERAND_P (x);
+
+  t = cris_symbol_type_of (x);
+
+  return
+    t == cris_no_symbol
+    || t == cris_offsettable_symbol
+    || t == cris_unspec;
+}
+
 /* Worker function for LEGITIMIZE_RELOAD_ADDRESS.  */
 
 bool
@@ -2214,7 +2260,7 @@
 	return (2 + 2) / 2;
 
       /* A BDAP with some other constant is 2 bytes extra.  */
-      if (CONSTANT_P (tem2))
+      if (CRIS_CONSTANT_P (tem2))
 	return (2 + 2 + 2) / 2;
 
       /* BDAP with something indirect should have a higher cost than
@@ -2312,7 +2358,7 @@
 	return 0;
 
       /* Check allowed cases, like [r(+)?].[bwd] and const.  */
-      if (CONSTANT_P (val_rtx))
+      if (CRIS_CONSTANT_P (val_rtx))
 	return 1;
 
       if (MEM_P (val_rtx)
@@ -2464,32 +2510,34 @@
 	gcc_unreachable ();
       }
 
-  return cris_pic_symbol_type_of (x) == cris_no_symbol;
+  return cris_symbol_type_of (x) == cris_no_symbol;
 }
 
-/* Helper function to find the right PIC-type symbol to generate,
+/* Helper function to find the right symbol-type to generate,
    given the original (non-PIC) representation.  */
 
-enum cris_pic_symbol_type
-cris_pic_symbol_type_of (const_rtx x)
+enum cris_symbol_type
+cris_symbol_type_of (const_rtx x)
 {
   switch (GET_CODE (x))
     {
     case SYMBOL_REF:
-      return SYMBOL_REF_LOCAL_P (x)
-	? cris_rel_symbol : cris_got_symbol;
+      return flag_pic
+	? (SYMBOL_REF_LOCAL_P (x)
+	   ? cris_rel_symbol : cris_got_symbol)
+	: cris_offsettable_symbol;
 
     case LABEL_REF:
-      return cris_rel_symbol;
+      return flag_pic ? cris_rel_symbol : cris_offsettable_symbol;
 
     case CONST:
-      return cris_pic_symbol_type_of (XEXP (x, 0));
+      return cris_symbol_type_of (XEXP (x, 0));
 
     case PLUS:
     case MINUS:
       {
-	enum cris_pic_symbol_type t1 = cris_pic_symbol_type_of (XEXP (x, 0));
-	enum cris_pic_symbol_type t2 = cris_pic_symbol_type_of (XEXP (x, 1));
+	enum cris_symbol_type t1 = cris_symbol_type_of (XEXP (x, 0));
+	enum cris_symbol_type t2 = cris_symbol_type_of (XEXP (x, 1));
 
 	gcc_assert (t1 == cris_no_symbol || t2 == cris_no_symbol);
 
@@ -2504,9 +2552,7 @@
       return cris_no_symbol;
 
     case UNSPEC:
-      /* Likely an offsettability-test attempting to add a constant to
-	 a GOTREAD symbol, which can't be handled.  */
-      return cris_invalid_pic_symbol;
+      return cris_unspec;
 
     default:
       fatal_insn ("unrecognized supposed constant", x);
@@ -3714,19 +3760,19 @@
 /* Worker function for expanding the address for PIC function calls.  */
 
 void
-cris_expand_pic_call_address (rtx *opp)
+cris_expand_pic_call_address (rtx *opp, rtx *markerp)
 {
   rtx op = *opp;
 
-  gcc_assert (MEM_P (op));
+  gcc_assert (flag_pic && MEM_P (op));
   op = XEXP (op, 0);
 
   /* It might be that code can be generated that jumps to 0 (or to a
      specific address).  Don't die on that.  (There is a
      testcase.)  */
-  if (CONSTANT_ADDRESS_P (op) && !CONST_INT_P (op))
+  if (CONSTANT_P (op) && !CONST_INT_P (op))
     {
-      enum cris_pic_symbol_type t = cris_pic_symbol_type_of (op);
+      enum cris_symbol_type t = cris_symbol_type_of (op);
 
       CRIS_ASSERT (can_create_pseudo_p ());
 
@@ -3752,6 +3798,9 @@
 	    }
 	  else
 	    op = force_reg (Pmode, op);
+
+	  /* A local call.  */
+	  *markerp = const0_rtx;
 	}
       else if (t == cris_got_symbol)
 	{
@@ -3758,12 +3807,12 @@
 	  if (TARGET_AVOID_GOTPLT)
 	    {
 	      /* Change a "jsr sym" into (allocate register rM, rO)
-		 "move.d (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_GOTREL)),rM"
+		 "move.d (const (unspec [sym] CRIS_UNSPEC_PLT_GOTREL)),rM"
 		 "add.d rPIC,rM,rO", "jsr rO" for pre-v32 and
-		 "jsr (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_PCREL))"
+		 "jsr (const (unspec [sym] CRIS_UNSPEC_PLT_PCREL))"
 		 for v32.  */
 	      rtx tem, rm, ro;
-	      gcc_assert (can_create_pseudo_p ());
+
 	      crtl->uses_pic_offset_table = 1;
 	      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),
 				    TARGET_V32
@@ -3817,14 +3866,27 @@
 	      MEM_NOTRAP_P (mem) = 1;
 	      op = mem;
 	    }
+
+	  /* We need to prepare this call to go through the PLT; we
+	     need to make GOT available.  */
+	  *markerp = pic_offset_table_rtx;
 	}
       else
-	/* Can't possibly get a GOT-needing-fixup for a function-call,
-	   right?  */
+	/* Can't possibly get anything else for a function-call, right?  */
 	fatal_insn ("unidentifiable call op", op);
 
-      *opp = replace_equiv_address (*opp, op);
+      /* If the validizing variant is called, it will try to validize
+	 the address as a valid any-operand constant, but as it's only
+	 valid for calls and moves, it will fail and always be forced
+	 into a register.  */
+      *opp = replace_equiv_address_nv (*opp, op);
     }
+  else
+    /* Can't tell what locality a call to a non-constant address has;
+       better make the GOT register alive at it.
+       FIXME: Can we see whether the register has known constant
+       contents?  */
+    *markerp = pic_offset_table_rtx;
 }
 
 /* Make sure operands are in the right order for an addsi3 insn as
Index: gcc/config/cris/predicates.md
===================================================================
--- a/src/gcc/config/cris/predicates.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/predicates.md	(.../branches/gcc-4_9-branch)
@@ -142,7 +142,7 @@
   (ior (match_operand 0 "general_operand")
        (and (match_code "const, symbol_ref, label_ref")
        	    ; The following test is actually just an assertion.
-	    (match_test "cris_pic_symbol_type_of (op) != cris_no_symbol"))))
+	    (match_test "cris_symbol_type_of (op) != cris_no_symbol"))))
 
 ;; A predicate for the anon movsi expansion, one that fits a PCREL
 ;; operand as well as general_operand.
@@ -176,3 +176,15 @@
        (ior (match_operand 0 "memory_operand")
 	    (match_test "cris_general_operand_or_symbol (XEXP (op, 0),
 							 Pmode)"))))
+
+;; A marker for the call-insn: (const_int 0) for a call to a
+;; hidden or static function and non-pic and
+;; pic_offset_table_rtx for a call that *might* go through the
+;; PLT.
+
+(define_predicate "cris_call_type_marker"
+  (ior (and (match_operand 0 "const_int_operand")
+	    (match_test "op == const0_rtx"))
+       (and (and (match_operand 0 "register_operand")
+		 (match_test "op == pic_offset_table_rtx"))
+	    (match_test "flag_pic != 0"))))
Index: gcc/config/cris/constraints.md
===================================================================
--- a/src/gcc/config/cris/constraints.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/constraints.md	(.../branches/gcc-4_9-branch)
@@ -118,7 +118,7 @@
 						       reload_in_progress
 						       || reload_completed)"))
 	    ;; Just an explicit indirect reference: [const]?
-	    (match_test "CONSTANT_P (XEXP (op, 0))")
+	    (match_test "CRIS_CONSTANT_P (XEXP (op, 0))")
 	    ;; Something that is indexed; [...+...]?
 	    (and (match_code "plus" "0")
 		      ;; A BDAP constant: [reg+(8|16|32)bit offset]?
@@ -159,6 +159,8 @@
 (define_constraint "U"
   "@internal"
   (and (match_test "flag_pic")
+       ;; We're just interested in the ..._or_callable_symbol part.
+       ;; (Using CRIS_CONSTANT_P would exclude that too.)
        (match_test "CONSTANT_P (op)")
        (match_operand 0 "cris_nonmemory_operand_or_callable_symbol")))
 
Index: gcc/config/cris/cris.h
===================================================================
--- a/src/gcc/config/cris/cris.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris.h	(.../branches/gcc-4_9-branch)
@@ -794,6 +794,12 @@
     }									\
   while (0)
 
+/* The mode argument to cris_legitimate_constant_p isn't used, so just
+   pass a cheap dummy.  N.B. we have to cast away const from the
+   parameter rather than adjust the parameter, as it's type is mandated
+   by the TARGET_LEGITIMATE_CONSTANT_P target hook interface.  */
+#define CRIS_CONSTANT_P(X) \
+  (CONSTANT_P (X) && cris_legitimate_constant_p (VOIDmode, CONST_CAST_RTX (X)))
 
 /* Node: Condition Code */
 
@@ -833,13 +839,14 @@
 
 /* Helper type.  */
 
-enum cris_pic_symbol_type
+enum cris_symbol_type
   {
     cris_no_symbol = 0,
     cris_got_symbol = 1,
     cris_rel_symbol = 2,
     cris_got_symbol_needing_fixup = 3,
-    cris_invalid_pic_symbol = 4
+    cris_unspec = 7,
+    cris_offsettable_symbol = 8
   };
 
 #define PIC_OFFSET_TABLE_REGNUM (flag_pic ? CRIS_GOT_REGNUM : INVALID_REGNUM)
Index: gcc/config/cris/cris-protos.h
===================================================================
--- a/src/gcc/config/cris/cris-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/cris/cris-protos.h	(.../branches/gcc-4_9-branch)
@@ -31,8 +31,9 @@
 extern rtx cris_return_addr_rtx (int, rtx);
 extern rtx cris_split_movdx (rtx *);
 extern int cris_legitimate_pic_operand (rtx);
-extern enum cris_pic_symbol_type cris_pic_symbol_type_of (const_rtx);
+extern enum cris_symbol_type cris_symbol_type_of (const_rtx);
 extern bool cris_valid_pic_const (const_rtx, bool);
+extern bool cris_legitimate_constant_p (enum machine_mode, rtx);
 extern bool cris_constant_index_p (const_rtx);
 extern bool cris_base_p (const_rtx, bool);
 extern bool cris_base_or_autoincr_p (const_rtx, bool);
@@ -46,7 +47,7 @@
 extern void cris_asm_output_case_end (FILE *, int, rtx);
 extern rtx cris_gen_movem_load (rtx, rtx, int);
 extern rtx cris_emit_movem_store (rtx, rtx, int, bool);
-extern void cris_expand_pic_call_address (rtx *);
+extern void cris_expand_pic_call_address (rtx *, rtx *);
 extern void cris_order_for_addsi3 (rtx *, int);
 extern void cris_emit_trap_for_misalignment (rtx);
 #endif /* RTX_CODE */
Index: gcc/config/gnu-user.h
===================================================================
--- a/src/gcc/config/gnu-user.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/gnu-user.h	(.../branches/gcc-4_9-branch)
@@ -114,7 +114,8 @@
 /* Link -lasan early on the command line.  For -static-libasan, don't link
    it for -shared link, the executable should be compiled with -static-libasan
    in that case, and for executable link link with --{,no-}whole-archive around
-   it to force everything into the executable.  And similarly for -ltsan.  */
+   it to force everything into the executable.  And similarly for -ltsan
+   and -llsan.  */
 #if defined(HAVE_LD_STATIC_DYNAMIC)
 #undef LIBASAN_EARLY_SPEC
 #define LIBASAN_EARLY_SPEC "%{!shared:libasan_preinit%O%s} " \
@@ -125,4 +126,8 @@
 #define LIBTSAN_EARLY_SPEC "%{static-libtsan:%{!shared:" \
   LD_STATIC_OPTION " --whole-archive -ltsan --no-whole-archive " \
   LD_DYNAMIC_OPTION "}}%{!static-libtsan:-ltsan}"
+#undef LIBLSAN_EARLY_SPEC
+#define LIBLSAN_EARLY_SPEC "%{static-liblsan:%{!shared:" \
+  LD_STATIC_OPTION " --whole-archive -llsan --no-whole-archive " \
+  LD_DYNAMIC_OPTION "}}%{!static-liblsan:-llsan}"
 #endif
Index: gcc/config/aarch64/aarch64-simd.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64-simd.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64-simd.md	(.../branches/gcc-4_9-branch)
@@ -945,8 +945,8 @@
 ;; On big-endian this is { zeroes, operand }
 
 (define_insn "move_lo_quad_internal_<mode>"
-  [(set (match_operand:VQ 0 "register_operand" "=w,w,w")
-        (vec_concat:VQ
+  [(set (match_operand:VQ_NO2E 0 "register_operand" "=w,w,w")
+	(vec_concat:VQ_NO2E
 	  (match_operand:<VHALF> 1 "register_operand" "w,r,r")
 	  (vec_duplicate:<VHALF> (const_int 0))))]
   "TARGET_SIMD && !BYTES_BIG_ENDIAN"
@@ -960,9 +960,25 @@
    (set_attr "length" "4")]
 )
 
+(define_insn "move_lo_quad_internal_<mode>"
+  [(set (match_operand:VQ_2E 0 "register_operand" "=w,w,w")
+	(vec_concat:VQ_2E
+	  (match_operand:<VHALF> 1 "register_operand" "w,r,r")
+	  (const_int 0)))]
+  "TARGET_SIMD && !BYTES_BIG_ENDIAN"
+  "@
+   dup\\t%d0, %1.d[0]
+   fmov\\t%d0, %1
+   dup\\t%d0, %1"
+  [(set_attr "type" "neon_dup<q>,f_mcr,neon_dup<q>")
+   (set_attr "simd" "yes,*,yes")
+   (set_attr "fp" "*,yes,*")
+   (set_attr "length" "4")]
+)
+
 (define_insn "move_lo_quad_internal_be_<mode>"
-  [(set (match_operand:VQ 0 "register_operand" "=w,w,w")
-        (vec_concat:VQ
+  [(set (match_operand:VQ_NO2E 0 "register_operand" "=w,w,w")
+	(vec_concat:VQ_NO2E
 	  (vec_duplicate:<VHALF> (const_int 0))
 	  (match_operand:<VHALF> 1 "register_operand" "w,r,r")))]
   "TARGET_SIMD && BYTES_BIG_ENDIAN"
@@ -976,6 +992,22 @@
    (set_attr "length" "4")]
 )
 
+(define_insn "move_lo_quad_internal_be_<mode>"
+  [(set (match_operand:VQ_2E 0 "register_operand" "=w,w,w")
+	(vec_concat:VQ_2E
+	  (const_int 0)
+	  (match_operand:<VHALF> 1 "register_operand" "w,r,r")))]
+  "TARGET_SIMD && BYTES_BIG_ENDIAN"
+  "@
+   dup\\t%d0, %1.d[0]
+   fmov\\t%d0, %1
+   dup\\t%d0, %1"
+  [(set_attr "type" "neon_dup<q>,f_mcr,neon_dup<q>")
+   (set_attr "simd" "yes,*,yes")
+   (set_attr "fp" "*,yes,*")
+   (set_attr "length" "4")]
+)
+
 (define_expand "move_lo_quad_<mode>"
   [(match_operand:VQ 0 "register_operand")
    (match_operand:VQ 1 "register_operand")]
Index: gcc/config/aarch64/arm_neon.h
===================================================================
--- a/src/gcc/config/aarch64/arm_neon.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/arm_neon.h	(.../branches/gcc-4_9-branch)
@@ -39,9 +39,6 @@
 typedef __builtin_aarch64_simd_si int32x2_t
   __attribute__ ((__vector_size__ (8)));
 typedef int64_t int64x1_t;
-typedef int32_t int32x1_t;
-typedef int16_t int16x1_t;
-typedef int8_t int8x1_t;
 typedef double float64x1_t;
 typedef __builtin_aarch64_simd_sf float32x2_t
   __attribute__ ((__vector_size__ (8)));
@@ -56,9 +53,6 @@
 typedef __builtin_aarch64_simd_usi uint32x2_t
   __attribute__ ((__vector_size__ (8)));
 typedef uint64_t uint64x1_t;
-typedef uint32_t uint32x1_t;
-typedef uint16_t uint16x1_t;
-typedef uint8_t uint8x1_t;
 typedef __builtin_aarch64_simd_qi int8x16_t
   __attribute__ ((__vector_size__ (16)));
 typedef __builtin_aarch64_simd_hi int16x8_t
@@ -8400,7 +8394,7 @@
 #define vmull_high_lane_s16(a, b, c)                                    \
   __extension__                                                         \
     ({                                                                  \
-       int16x8_t b_ = (b);                                              \
+       int16x4_t b_ = (b);                                              \
        int16x8_t a_ = (a);                                              \
        int32x4_t result;                                                \
        __asm__ ("smull2 %0.4s, %1.8h, %2.h[%3]"                         \
@@ -8413,7 +8407,7 @@
 #define vmull_high_lane_s32(a, b, c)                                    \
   __extension__                                                         \
     ({                                                                  \
-       int32x4_t b_ = (b);                                              \
+       int32x2_t b_ = (b);                                              \
        int32x4_t a_ = (a);                                              \
        int64x2_t result;                                                \
        __asm__ ("smull2 %0.2d, %1.4s, %2.s[%3]"                         \
@@ -8426,7 +8420,7 @@
 #define vmull_high_lane_u16(a, b, c)                                    \
   __extension__                                                         \
     ({                                                                  \
-       uint16x8_t b_ = (b);                                             \
+       uint16x4_t b_ = (b);                                             \
        uint16x8_t a_ = (a);                                             \
        uint32x4_t result;                                               \
        __asm__ ("umull2 %0.4s, %1.8h, %2.h[%3]"                         \
@@ -8439,7 +8433,7 @@
 #define vmull_high_lane_u32(a, b, c)                                    \
   __extension__                                                         \
     ({                                                                  \
-       uint32x4_t b_ = (b);                                             \
+       uint32x2_t b_ = (b);                                             \
        uint32x4_t a_ = (a);                                             \
        uint64x2_t result;                                               \
        __asm__ ("umull2 %0.2d, %1.4s, %2.s[%3]"                         \
@@ -20925,42 +20919,42 @@
   return (int64x2_t) __builtin_aarch64_sqabsv2di (__a);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqabsb_s8 (int8x1_t __a)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqabsb_s8 (int8_t __a)
 {
-  return (int8x1_t) __builtin_aarch64_sqabsqi (__a);
+  return (int8_t) __builtin_aarch64_sqabsqi (__a);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqabsh_s16 (int16x1_t __a)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqabsh_s16 (int16_t __a)
 {
-  return (int16x1_t) __builtin_aarch64_sqabshi (__a);
+  return (int16_t) __builtin_aarch64_sqabshi (__a);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqabss_s32 (int32x1_t __a)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqabss_s32 (int32_t __a)
 {
-  return (int32x1_t) __builtin_aarch64_sqabssi (__a);
+  return (int32_t) __builtin_aarch64_sqabssi (__a);
 }
 
 /* vqadd */
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqaddb_s8 (int8x1_t __a, int8x1_t __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqaddb_s8 (int8_t __a, int8_t __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqaddqi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqaddqi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqaddh_s16 (int16x1_t __a, int16x1_t __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqaddh_s16 (int16_t __a, int16_t __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqaddhi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqaddhi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqadds_s32 (int32x1_t __a, int32x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqadds_s32 (int32_t __a, int32_t __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqaddsi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqaddsi (__a, __b);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
@@ -20969,22 +20963,22 @@
   return (int64x1_t) __builtin_aarch64_sqadddi (__a, __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqaddb_u8 (uint8x1_t __a, uint8x1_t __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqaddb_u8 (uint8_t __a, uint8_t __b)
 {
-  return (uint8x1_t) __builtin_aarch64_uqaddqi (__a, __b);
+  return (uint8_t) __builtin_aarch64_uqaddqi (__a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqaddh_u16 (uint16x1_t __a, uint16x1_t __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqaddh_u16 (uint16_t __a, uint16_t __b)
 {
-  return (uint16x1_t) __builtin_aarch64_uqaddhi (__a, __b);
+  return (uint16_t) __builtin_aarch64_uqaddhi (__a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
-vqadds_u32 (uint32x1_t __a, uint32x1_t __b)
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
+vqadds_u32 (uint32_t __a, uint32_t __b)
 {
-  return (uint32x1_t) __builtin_aarch64_uqaddsi (__a, __b);
+  return (uint32_t) __builtin_aarch64_uqaddsi (__a, __b);
 }
 
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
@@ -21095,26 +21089,26 @@
   return __builtin_aarch64_sqdmlal_nv2si (__a, __b, __c);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmlalh_s16 (int32x1_t __a, int16x1_t __b, int16x1_t __c)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmlalh_s16 (int32_t __a, int16_t __b, int16_t __c)
 {
   return __builtin_aarch64_sqdmlalhi (__a, __b, __c);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmlalh_lane_s16 (int32x1_t __a, int16x1_t __b, int16x4_t __c, const int __d)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmlalh_lane_s16 (int32_t __a, int16_t __b, int16x4_t __c, const int __d)
 {
   return __builtin_aarch64_sqdmlal_lanehi (__a, __b, __c, __d);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vqdmlals_s32 (int64x1_t __a, int32x1_t __b, int32x1_t __c)
+vqdmlals_s32 (int64x1_t __a, int32_t __b, int32_t __c)
 {
   return __builtin_aarch64_sqdmlalsi (__a, __b, __c);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vqdmlals_lane_s32 (int64x1_t __a, int32x1_t __b, int32x2_t __c, const int __d)
+vqdmlals_lane_s32 (int64x1_t __a, int32_t __b, int32x2_t __c, const int __d)
 {
   return __builtin_aarch64_sqdmlal_lanesi (__a, __b, __c, __d);
 }
@@ -21221,26 +21215,26 @@
   return __builtin_aarch64_sqdmlsl_nv2si (__a, __b, __c);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmlslh_s16 (int32x1_t __a, int16x1_t __b, int16x1_t __c)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmlslh_s16 (int32_t __a, int16_t __b, int16_t __c)
 {
   return __builtin_aarch64_sqdmlslhi (__a, __b, __c);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmlslh_lane_s16 (int32x1_t __a, int16x1_t __b, int16x4_t __c, const int __d)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmlslh_lane_s16 (int32_t __a, int16_t __b, int16x4_t __c, const int __d)
 {
   return __builtin_aarch64_sqdmlsl_lanehi (__a, __b, __c, __d);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vqdmlsls_s32 (int64x1_t __a, int32x1_t __b, int32x1_t __c)
+vqdmlsls_s32 (int64x1_t __a, int32_t __b, int32_t __c)
 {
   return __builtin_aarch64_sqdmlslsi (__a, __b, __c);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vqdmlsls_lane_s32 (int64x1_t __a, int32x1_t __b, int32x2_t __c, const int __d)
+vqdmlsls_lane_s32 (int64x1_t __a, int32_t __b, int32x2_t __c, const int __d)
 {
   return __builtin_aarch64_sqdmlsl_lanesi (__a, __b, __c, __d);
 }
@@ -21271,26 +21265,26 @@
   return __builtin_aarch64_sqdmulh_lanev4si (__a, __b, __c);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqdmulhh_s16 (int16x1_t __a, int16x1_t __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqdmulhh_s16 (int16_t __a, int16_t __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqdmulhhi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqdmulhhi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqdmulhh_lane_s16 (int16x1_t __a, int16x4_t __b, const int __c)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqdmulhh_lane_s16 (int16_t __a, int16x4_t __b, const int __c)
 {
   return __builtin_aarch64_sqdmulh_lanehi (__a, __b, __c);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmulhs_s32 (int32x1_t __a, int32x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmulhs_s32 (int32_t __a, int32_t __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqdmulhsi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqdmulhsi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmulhs_lane_s32 (int32x1_t __a, int32x2_t __b, const int __c)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmulhs_lane_s32 (int32_t __a, int32x2_t __b, const int __c)
 {
   return __builtin_aarch64_sqdmulh_lanesi (__a, __b, __c);
 }
@@ -21393,26 +21387,26 @@
   return __builtin_aarch64_sqdmull_nv2si (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmullh_s16 (int16x1_t __a, int16x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmullh_s16 (int16_t __a, int16_t __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqdmullhi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqdmullhi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqdmullh_lane_s16 (int16x1_t __a, int16x4_t __b, const int __c)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqdmullh_lane_s16 (int16_t __a, int16x4_t __b, const int __c)
 {
   return __builtin_aarch64_sqdmull_lanehi (__a, __b, __c);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vqdmulls_s32 (int32x1_t __a, int32x1_t __b)
+vqdmulls_s32 (int32_t __a, int32_t __b)
 {
   return (int64x1_t) __builtin_aarch64_sqdmullsi (__a, __b);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vqdmulls_lane_s32 (int32x1_t __a, int32x2_t __b, const int __c)
+vqdmulls_lane_s32 (int32_t __a, int32x2_t __b, const int __c)
 {
   return __builtin_aarch64_sqdmull_lanesi (__a, __b, __c);
 }
@@ -21455,40 +21449,40 @@
   return (uint32x2_t) __builtin_aarch64_uqmovnv2di ((int64x2_t) __a);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqmovnh_s16 (int16x1_t __a)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqmovnh_s16 (int16_t __a)
 {
-  return (int8x1_t) __builtin_aarch64_sqmovnhi (__a);
+  return (int8_t) __builtin_aarch64_sqmovnhi (__a);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqmovns_s32 (int32x1_t __a)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqmovns_s32 (int32_t __a)
 {
-  return (int16x1_t) __builtin_aarch64_sqmovnsi (__a);
+  return (int16_t) __builtin_aarch64_sqmovnsi (__a);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
 vqmovnd_s64 (int64x1_t __a)
 {
-  return (int32x1_t) __builtin_aarch64_sqmovndi (__a);
+  return (int32_t) __builtin_aarch64_sqmovndi (__a);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqmovnh_u16 (uint16x1_t __a)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqmovnh_u16 (uint16_t __a)
 {
-  return (uint8x1_t) __builtin_aarch64_uqmovnhi (__a);
+  return (uint8_t) __builtin_aarch64_uqmovnhi (__a);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqmovns_u32 (uint32x1_t __a)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqmovns_u32 (uint32_t __a)
 {
-  return (uint16x1_t) __builtin_aarch64_uqmovnsi (__a);
+  return (uint16_t) __builtin_aarch64_uqmovnsi (__a);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 vqmovnd_u64 (uint64x1_t __a)
 {
-  return (uint32x1_t) __builtin_aarch64_uqmovndi (__a);
+  return (uint32_t) __builtin_aarch64_uqmovndi (__a);
 }
 
 /* vqmovun */
@@ -21511,22 +21505,22 @@
   return (uint32x2_t) __builtin_aarch64_sqmovunv2di (__a);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqmovunh_s16 (int16x1_t __a)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqmovunh_s16 (int16_t __a)
 {
-  return (int8x1_t) __builtin_aarch64_sqmovunhi (__a);
+  return (int8_t) __builtin_aarch64_sqmovunhi (__a);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqmovuns_s32 (int32x1_t __a)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqmovuns_s32 (int32_t __a)
 {
-  return (int16x1_t) __builtin_aarch64_sqmovunsi (__a);
+  return (int16_t) __builtin_aarch64_sqmovunsi (__a);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
 vqmovund_s64 (int64x1_t __a)
 {
-  return (int32x1_t) __builtin_aarch64_sqmovundi (__a);
+  return (int32_t) __builtin_aarch64_sqmovundi (__a);
 }
 
 /* vqneg */
@@ -21537,22 +21531,22 @@
   return (int64x2_t) __builtin_aarch64_sqnegv2di (__a);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqnegb_s8 (int8x1_t __a)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqnegb_s8 (int8_t __a)
 {
-  return (int8x1_t) __builtin_aarch64_sqnegqi (__a);
+  return (int8_t) __builtin_aarch64_sqnegqi (__a);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqnegh_s16 (int16x1_t __a)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqnegh_s16 (int16_t __a)
 {
-  return (int16x1_t) __builtin_aarch64_sqneghi (__a);
+  return (int16_t) __builtin_aarch64_sqneghi (__a);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqnegs_s32 (int32x1_t __a)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqnegs_s32 (int32_t __a)
 {
-  return (int32x1_t) __builtin_aarch64_sqnegsi (__a);
+  return (int32_t) __builtin_aarch64_sqnegsi (__a);
 }
 
 /* vqrdmulh */
@@ -21581,26 +21575,26 @@
   return __builtin_aarch64_sqrdmulh_lanev4si (__a, __b, __c);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqrdmulhh_s16 (int16x1_t __a, int16x1_t __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqrdmulhh_s16 (int16_t __a, int16_t __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqrdmulhhi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqrdmulhhi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqrdmulhh_lane_s16 (int16x1_t __a, int16x4_t __b, const int __c)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqrdmulhh_lane_s16 (int16_t __a, int16x4_t __b, const int __c)
 {
   return __builtin_aarch64_sqrdmulh_lanehi (__a, __b, __c);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqrdmulhs_s32 (int32x1_t __a, int32x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqrdmulhs_s32 (int32_t __a, int32_t __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqrdmulhsi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqrdmulhsi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqrdmulhs_lane_s32 (int32x1_t __a, int32x2_t __b, const int __c)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqrdmulhs_lane_s32 (int32_t __a, int32x2_t __b, const int __c)
 {
   return __builtin_aarch64_sqrdmulh_lanesi (__a, __b, __c);
 }
@@ -21703,20 +21697,20 @@
   return (uint64x2_t) __builtin_aarch64_uqrshlv2di ((int64x2_t) __a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqrshlb_s8 (int8x1_t __a, int8x1_t __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqrshlb_s8 (int8_t __a, int8_t __b)
 {
   return __builtin_aarch64_sqrshlqi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqrshlh_s16 (int16x1_t __a, int16x1_t __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqrshlh_s16 (int16_t __a, int16_t __b)
 {
   return __builtin_aarch64_sqrshlhi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqrshls_s32 (int32x1_t __a, int32x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqrshls_s32 (int32_t __a, int32_t __b)
 {
   return __builtin_aarch64_sqrshlsi (__a, __b);
 }
@@ -21727,22 +21721,22 @@
   return __builtin_aarch64_sqrshldi (__a, __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqrshlb_u8 (uint8x1_t __a, uint8x1_t __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqrshlb_u8 (uint8_t __a, uint8_t __b)
 {
-  return (uint8x1_t) __builtin_aarch64_uqrshlqi (__a, __b);
+  return (uint8_t) __builtin_aarch64_uqrshlqi (__a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqrshlh_u16 (uint16x1_t __a, uint16x1_t __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqrshlh_u16 (uint16_t __a, uint16_t __b)
 {
-  return (uint16x1_t) __builtin_aarch64_uqrshlhi (__a, __b);
+  return (uint16_t) __builtin_aarch64_uqrshlhi (__a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
-vqrshls_u32 (uint32x1_t __a, uint32x1_t __b)
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
+vqrshls_u32 (uint32_t __a, uint32_t __b)
 {
-  return (uint32x1_t) __builtin_aarch64_uqrshlsi (__a, __b);
+  return (uint32_t) __builtin_aarch64_uqrshlsi (__a, __b);
 }
 
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
@@ -21789,40 +21783,40 @@
   return (uint32x2_t) __builtin_aarch64_uqrshrn_nv2di ((int64x2_t) __a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqrshrnh_n_s16 (int16x1_t __a, const int __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqrshrnh_n_s16 (int16_t __a, const int __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqrshrn_nhi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqrshrn_nhi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqrshrns_n_s32 (int32x1_t __a, const int __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqrshrns_n_s32 (int32_t __a, const int __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqrshrn_nsi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqrshrn_nsi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
 vqrshrnd_n_s64 (int64x1_t __a, const int __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqrshrn_ndi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqrshrn_ndi (__a, __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqrshrnh_n_u16 (uint16x1_t __a, const int __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqrshrnh_n_u16 (uint16_t __a, const int __b)
 {
-  return (uint8x1_t) __builtin_aarch64_uqrshrn_nhi (__a, __b);
+  return (uint8_t) __builtin_aarch64_uqrshrn_nhi (__a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqrshrns_n_u32 (uint32x1_t __a, const int __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqrshrns_n_u32 (uint32_t __a, const int __b)
 {
-  return (uint16x1_t) __builtin_aarch64_uqrshrn_nsi (__a, __b);
+  return (uint16_t) __builtin_aarch64_uqrshrn_nsi (__a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 vqrshrnd_n_u64 (uint64x1_t __a, const int __b)
 {
-  return (uint32x1_t) __builtin_aarch64_uqrshrn_ndi (__a, __b);
+  return (uint32_t) __builtin_aarch64_uqrshrn_ndi (__a, __b);
 }
 
 /* vqrshrun */
@@ -21845,22 +21839,22 @@
   return (uint32x2_t) __builtin_aarch64_sqrshrun_nv2di (__a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqrshrunh_n_s16 (int16x1_t __a, const int __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqrshrunh_n_s16 (int16_t __a, const int __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqrshrun_nhi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqrshrun_nhi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqrshruns_n_s32 (int32x1_t __a, const int __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqrshruns_n_s32 (int32_t __a, const int __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqrshrun_nsi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqrshrun_nsi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
 vqrshrund_n_s64 (int64x1_t __a, const int __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqrshrun_ndi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqrshrun_ndi (__a, __b);
 }
 
 /* vqshl */
@@ -21961,20 +21955,20 @@
   return (uint64x2_t) __builtin_aarch64_uqshlv2di ((int64x2_t) __a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqshlb_s8 (int8x1_t __a, int8x1_t __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqshlb_s8 (int8_t __a, int8_t __b)
 {
   return __builtin_aarch64_sqshlqi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqshlh_s16 (int16x1_t __a, int16x1_t __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqshlh_s16 (int16_t __a, int16_t __b)
 {
   return __builtin_aarch64_sqshlhi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqshls_s32 (int32x1_t __a, int32x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqshls_s32 (int32_t __a, int32_t __b)
 {
   return __builtin_aarch64_sqshlsi (__a, __b);
 }
@@ -21985,22 +21979,22 @@
   return __builtin_aarch64_sqshldi (__a, __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqshlb_u8 (uint8x1_t __a, uint8x1_t __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqshlb_u8 (uint8_t __a, uint8_t __b)
 {
-  return (uint8x1_t) __builtin_aarch64_uqshlqi (__a, __b);
+  return (uint8_t) __builtin_aarch64_uqshlqi (__a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqshlh_u16 (uint16x1_t __a, uint16x1_t __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqshlh_u16 (uint16_t __a, uint16_t __b)
 {
-  return (uint16x1_t) __builtin_aarch64_uqshlhi (__a, __b);
+  return (uint16_t) __builtin_aarch64_uqshlhi (__a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
-vqshls_u32 (uint32x1_t __a, uint32x1_t __b)
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
+vqshls_u32 (uint32_t __a, uint32_t __b)
 {
-  return (uint32x1_t) __builtin_aarch64_uqshlsi (__a, __b);
+  return (uint32_t) __builtin_aarch64_uqshlsi (__a, __b);
 }
 
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
@@ -22105,22 +22099,22 @@
   return (uint64x2_t) __builtin_aarch64_uqshl_nv2di ((int64x2_t) __a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqshlb_n_s8 (int8x1_t __a, const int __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqshlb_n_s8 (int8_t __a, const int __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqshl_nqi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqshl_nqi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqshlh_n_s16 (int16x1_t __a, const int __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqshlh_n_s16 (int16_t __a, const int __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqshl_nhi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqshl_nhi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqshls_n_s32 (int32x1_t __a, const int __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqshls_n_s32 (int32_t __a, const int __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqshl_nsi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqshl_nsi (__a, __b);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
@@ -22129,22 +22123,22 @@
   return (int64x1_t) __builtin_aarch64_sqshl_ndi (__a, __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqshlb_n_u8 (uint8x1_t __a, const int __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqshlb_n_u8 (uint8_t __a, const int __b)
 {
-  return (uint8x1_t) __builtin_aarch64_uqshl_nqi (__a, __b);
+  return (uint8_t) __builtin_aarch64_uqshl_nqi (__a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqshlh_n_u16 (uint16x1_t __a, const int __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqshlh_n_u16 (uint16_t __a, const int __b)
 {
-  return (uint16x1_t) __builtin_aarch64_uqshl_nhi (__a, __b);
+  return (uint16_t) __builtin_aarch64_uqshl_nhi (__a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
-vqshls_n_u32 (uint32x1_t __a, const int __b)
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
+vqshls_n_u32 (uint32_t __a, const int __b)
 {
-  return (uint32x1_t) __builtin_aarch64_uqshl_nsi (__a, __b);
+  return (uint32_t) __builtin_aarch64_uqshl_nsi (__a, __b);
 }
 
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
@@ -22203,22 +22197,22 @@
   return (uint64x2_t) __builtin_aarch64_sqshlu_nv2di (__a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqshlub_n_s8 (int8x1_t __a, const int __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqshlub_n_s8 (int8_t __a, const int __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqshlu_nqi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqshlu_nqi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqshluh_n_s16 (int16x1_t __a, const int __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqshluh_n_s16 (int16_t __a, const int __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqshlu_nhi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqshlu_nhi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqshlus_n_s32 (int32x1_t __a, const int __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqshlus_n_s32 (int32_t __a, const int __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqshlu_nsi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqshlu_nsi (__a, __b);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
@@ -22265,40 +22259,40 @@
   return (uint32x2_t) __builtin_aarch64_uqshrn_nv2di ((int64x2_t) __a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqshrnh_n_s16 (int16x1_t __a, const int __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqshrnh_n_s16 (int16_t __a, const int __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqshrn_nhi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqshrn_nhi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqshrns_n_s32 (int32x1_t __a, const int __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqshrns_n_s32 (int32_t __a, const int __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqshrn_nsi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqshrn_nsi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
 vqshrnd_n_s64 (int64x1_t __a, const int __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqshrn_ndi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqshrn_ndi (__a, __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqshrnh_n_u16 (uint16x1_t __a, const int __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqshrnh_n_u16 (uint16_t __a, const int __b)
 {
-  return (uint8x1_t) __builtin_aarch64_uqshrn_nhi (__a, __b);
+  return (uint8_t) __builtin_aarch64_uqshrn_nhi (__a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqshrns_n_u32 (uint32x1_t __a, const int __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqshrns_n_u32 (uint32_t __a, const int __b)
 {
-  return (uint16x1_t) __builtin_aarch64_uqshrn_nsi (__a, __b);
+  return (uint16_t) __builtin_aarch64_uqshrn_nsi (__a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 vqshrnd_n_u64 (uint64x1_t __a, const int __b)
 {
-  return (uint32x1_t) __builtin_aarch64_uqshrn_ndi (__a, __b);
+  return (uint32_t) __builtin_aarch64_uqshrn_ndi (__a, __b);
 }
 
 /* vqshrun */
@@ -22321,42 +22315,42 @@
   return (uint32x2_t) __builtin_aarch64_sqshrun_nv2di (__a, __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqshrunh_n_s16 (int16x1_t __a, const int __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqshrunh_n_s16 (int16_t __a, const int __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqshrun_nhi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqshrun_nhi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqshruns_n_s32 (int32x1_t __a, const int __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqshruns_n_s32 (int32_t __a, const int __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqshrun_nsi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqshrun_nsi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
 vqshrund_n_s64 (int64x1_t __a, const int __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqshrun_ndi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqshrun_ndi (__a, __b);
 }
 
 /* vqsub */
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vqsubb_s8 (int8x1_t __a, int8x1_t __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vqsubb_s8 (int8_t __a, int8_t __b)
 {
-  return (int8x1_t) __builtin_aarch64_sqsubqi (__a, __b);
+  return (int8_t) __builtin_aarch64_sqsubqi (__a, __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vqsubh_s16 (int16x1_t __a, int16x1_t __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vqsubh_s16 (int16_t __a, int16_t __b)
 {
-  return (int16x1_t) __builtin_aarch64_sqsubhi (__a, __b);
+  return (int16_t) __builtin_aarch64_sqsubhi (__a, __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vqsubs_s32 (int32x1_t __a, int32x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vqsubs_s32 (int32_t __a, int32_t __b)
 {
-  return (int32x1_t) __builtin_aarch64_sqsubsi (__a, __b);
+  return (int32_t) __builtin_aarch64_sqsubsi (__a, __b);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
@@ -22365,22 +22359,22 @@
   return (int64x1_t) __builtin_aarch64_sqsubdi (__a, __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vqsubb_u8 (uint8x1_t __a, uint8x1_t __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vqsubb_u8 (uint8_t __a, uint8_t __b)
 {
-  return (uint8x1_t) __builtin_aarch64_uqsubqi (__a, __b);
+  return (uint8_t) __builtin_aarch64_uqsubqi (__a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vqsubh_u16 (uint16x1_t __a, uint16x1_t __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vqsubh_u16 (uint16_t __a, uint16_t __b)
 {
-  return (uint16x1_t) __builtin_aarch64_uqsubhi (__a, __b);
+  return (uint16_t) __builtin_aarch64_uqsubhi (__a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
-vqsubs_u32 (uint32x1_t __a, uint32x1_t __b)
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
+vqsubs_u32 (uint32_t __a, uint32_t __b)
 {
-  return (uint32x1_t) __builtin_aarch64_uqsubsi (__a, __b);
+  return (uint32_t) __builtin_aarch64_uqsubsi (__a, __b);
 }
 
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
@@ -23596,22 +23590,22 @@
 						    (int64x2_t) __b);
 }
 
-__extension__ static __inline uint8x1_t __attribute__ ((__always_inline__))
-vsqaddb_u8 (uint8x1_t __a, int8x1_t __b)
+__extension__ static __inline uint8_t __attribute__ ((__always_inline__))
+vsqaddb_u8 (uint8_t __a, int8_t __b)
 {
-  return (uint8x1_t) __builtin_aarch64_usqaddqi ((int8x1_t) __a, __b);
+  return (uint8_t) __builtin_aarch64_usqaddqi ((int8_t) __a, __b);
 }
 
-__extension__ static __inline uint16x1_t __attribute__ ((__always_inline__))
-vsqaddh_u16 (uint16x1_t __a, int16x1_t __b)
+__extension__ static __inline uint16_t __attribute__ ((__always_inline__))
+vsqaddh_u16 (uint16_t __a, int16_t __b)
 {
-  return (uint16x1_t) __builtin_aarch64_usqaddhi ((int16x1_t) __a, __b);
+  return (uint16_t) __builtin_aarch64_usqaddhi ((int16_t) __a, __b);
 }
 
-__extension__ static __inline uint32x1_t __attribute__ ((__always_inline__))
-vsqadds_u32 (uint32x1_t __a, int32x1_t __b)
+__extension__ static __inline uint32_t __attribute__ ((__always_inline__))
+vsqadds_u32 (uint32_t __a, int32_t __b)
 {
-  return (uint32x1_t) __builtin_aarch64_usqaddsi ((int32x1_t) __a, __b);
+  return (uint32_t) __builtin_aarch64_usqaddsi ((int32_t) __a, __b);
 }
 
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
@@ -25251,22 +25245,22 @@
   return (int64x2_t) __builtin_aarch64_suqaddv2di (__a, (int64x2_t) __b);
 }
 
-__extension__ static __inline int8x1_t __attribute__ ((__always_inline__))
-vuqaddb_s8 (int8x1_t __a, uint8x1_t __b)
+__extension__ static __inline int8_t __attribute__ ((__always_inline__))
+vuqaddb_s8 (int8_t __a, uint8_t __b)
 {
-  return (int8x1_t) __builtin_aarch64_suqaddqi (__a, (int8x1_t) __b);
+  return (int8_t) __builtin_aarch64_suqaddqi (__a, (int8_t) __b);
 }
 
-__extension__ static __inline int16x1_t __attribute__ ((__always_inline__))
-vuqaddh_s16 (int16x1_t __a, uint16x1_t __b)
+__extension__ static __inline int16_t __attribute__ ((__always_inline__))
+vuqaddh_s16 (int16_t __a, uint16_t __b)
 {
-  return (int16x1_t) __builtin_aarch64_suqaddhi (__a, (int16x1_t) __b);
+  return (int16_t) __builtin_aarch64_suqaddhi (__a, (int16_t) __b);
 }
 
-__extension__ static __inline int32x1_t __attribute__ ((__always_inline__))
-vuqadds_s32 (int32x1_t __a, uint32x1_t __b)
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+vuqadds_s32 (int32_t __a, uint32_t __b)
 {
-  return (int32x1_t) __builtin_aarch64_suqaddsi (__a, (int32x1_t) __b);
+  return (int32_t) __builtin_aarch64_suqaddsi (__a, (int32_t) __b);
 }
 
 __extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
Index: gcc/config/aarch64/aarch64.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64.md	(.../branches/gcc-4_9-branch)
@@ -1102,7 +1102,7 @@
   add\\t%x0, %x1, %x2
   sub\\t%x0, %x1, #%n2
   add\\t%d0, %d1, %d2"
-  [(set_attr "type" "alu_imm,alu_reg,alu_imm,alu_reg")
+  [(set_attr "type" "alu_imm,alu_reg,alu_imm,neon_add")
    (set_attr "simd" "*,*,*,yes")]
 )
 
@@ -3157,7 +3157,8 @@
 	(and:GPI (ashift:GPI (match_operand:GPI 1 "register_operand" "r")
 			     (match_operand 2 "const_int_operand" "n"))
 		 (match_operand 3 "const_int_operand" "n")))]
-  "exact_log2 ((INTVAL (operands[3]) >> INTVAL (operands[2])) + 1) >= 0
+  "(INTVAL (operands[2]) < (<GPI:sizen>))
+   && exact_log2 ((INTVAL (operands[3]) >> INTVAL (operands[2])) + 1) >= 0
    && (INTVAL (operands[3]) & ((1 << INTVAL (operands[2])) - 1)) == 0"
   "ubfiz\\t%<w>0, %<w>1, %2, %P3"
   [(set_attr "type" "bfm")]
Index: gcc/config/aarch64/aarch64.opt
===================================================================
--- a/src/gcc/config/aarch64/aarch64.opt	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64.opt	(.../branches/gcc-4_9-branch)
@@ -67,6 +67,10 @@
 Target Report RejectNegative Mask(GENERAL_REGS_ONLY)
 Generate code which uses only the general registers
 
+mfix-cortex-a53-835769
+Target Report Var(aarch64_fix_a53_err835769) Init(2)
+Workaround for ARM Cortex-A53 Erratum number 835769
+
 mlittle-endian
 Target Report RejectNegative InverseMask(BIG_END)
 Assume target CPU is configured as little endian
Index: gcc/config/aarch64/aarch64-protos.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64-protos.h	(.../branches/gcc-4_9-branch)
@@ -287,6 +287,8 @@
 
 extern void aarch64_split_combinev16qi (rtx operands[3]);
 extern void aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);
+extern bool aarch64_madd_needs_nop (rtx);
+extern void aarch64_final_prescan_insn (rtx);
 extern bool
 aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);
 #endif /* GCC_AARCH64_PROTOS_H */
Index: gcc/config/aarch64/aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64.c	(.../branches/gcc-4_9-branch)
@@ -5256,6 +5256,15 @@
   aarch64_tune = selected_tune->core;
   aarch64_tune_params = selected_tune->tune;
 
+  if (aarch64_fix_a53_err835769 == 2)
+    {
+#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
+      aarch64_fix_a53_err835769 = 1;
+#else
+      aarch64_fix_a53_err835769 = 0;
+#endif
+    }
+
   aarch64_override_options_after_change ();
 }
 
@@ -6452,6 +6461,128 @@
   return NULL;
 }
 
+static int
+is_mem_p (rtx *x, void *data ATTRIBUTE_UNUSED)
+{
+  return MEM_P (*x);
+}
+
+static bool
+is_memory_op (rtx mem_insn)
+{
+   rtx pattern = PATTERN (mem_insn);
+   return for_each_rtx (&pattern, is_mem_p, NULL);
+}
+
+/* Find the first rtx before insn that will generate an assembly
+   instruction.  */
+
+static rtx
+aarch64_prev_real_insn (rtx insn)
+{
+  if (!insn)
+    return NULL;
+
+  do
+    {
+      insn = prev_real_insn (insn);
+    }
+  while (insn && recog_memoized (insn) < 0);
+
+  return insn;
+}
+
+static bool
+is_madd_op (enum attr_type t1)
+{
+  unsigned int i;
+  /* A number of these may be AArch32 only.  */
+  enum attr_type mlatypes[] = {
+    TYPE_MLA, TYPE_MLAS, TYPE_SMLAD, TYPE_SMLADX, TYPE_SMLAL, TYPE_SMLALD,
+    TYPE_SMLALS, TYPE_SMLALXY, TYPE_SMLAWX, TYPE_SMLAWY, TYPE_SMLAXY,
+    TYPE_SMMLA, TYPE_UMLAL, TYPE_UMLALS,TYPE_SMLSD, TYPE_SMLSDX, TYPE_SMLSLD
+  };
+
+  for (i = 0; i < sizeof (mlatypes) / sizeof (enum attr_type); i++)
+    {
+      if (t1 == mlatypes[i])
+	return true;
+    }
+
+  return false;
+}
+
+/* Check if there is a register dependency between a load and the insn
+   for which we hold recog_data.  */
+
+static bool
+dep_between_memop_and_curr (rtx memop)
+{
+  rtx load_reg;
+  int opno;
+
+  if (!memop)
+    return false;
+
+  if (!REG_P (SET_DEST (memop)))
+    return false;
+
+  load_reg = SET_DEST (memop);
+  for (opno = 0; opno < recog_data.n_operands; opno++)
+    {
+      rtx operand = recog_data.operand[opno];
+      if (REG_P (operand)
+          && reg_overlap_mentioned_p (load_reg, operand))
+        return true;
+
+    }
+  return false;
+}
+
+bool
+aarch64_madd_needs_nop (rtx insn)
+{
+  enum attr_type attr_type;
+  rtx prev;
+  rtx body;
+
+  if (!aarch64_fix_a53_err835769)
+    return false;
+
+  if (recog_memoized (insn) < 0)
+    return false;
+
+  attr_type = get_attr_type (insn);
+  if (!is_madd_op (attr_type))
+    return false;
+
+  prev = aarch64_prev_real_insn (insn);
+  if (!prev)
+    return false;
+
+  body = single_set (prev);
+
+  /* If the previous insn is a memory op and there is no dependency between
+     it and the madd, emit a nop between them.  If we know the previous insn is
+     a memory op but body is NULL, emit the nop to be safe, it's probably a
+     load/store pair insn.  */
+  if (is_memory_op (prev)
+      && GET_MODE (recog_data.operand[0]) == DImode
+      && (!dep_between_memop_and_curr (body)))
+    return true;
+
+  return false;
+
+}
+
+void
+aarch64_final_prescan_insn (rtx insn)
+{
+  if (aarch64_madd_needs_nop (insn))
+    fprintf (asm_out_file, "\tnop // between mem op and mult-accumulate\n");
+}
+
+
 /* Return the equivalent letter for size.  */
 static char
 sizetochar (int size)
Index: gcc/config/aarch64/aarch64-linux.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-linux.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64-linux.h	(.../branches/gcc-4_9-branch)
@@ -44,4 +44,6 @@
     }						\
   while (0)
 
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
 #endif  /* GCC_AARCH64_LINUX_H */
Index: gcc/config/aarch64/iterators.md
===================================================================
--- a/src/gcc/config/aarch64/iterators.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/iterators.md	(.../branches/gcc-4_9-branch)
@@ -66,6 +66,12 @@
 ;; Quad vector modes.
 (define_mode_iterator VQ [V16QI V8HI V4SI V2DI V4SF V2DF])
 
+;; VQ without 2 element modes.
+(define_mode_iterator VQ_NO2E [V16QI V8HI V4SI V4SF])
+
+;; Quad vector with only 2 element modes.
+(define_mode_iterator VQ_2E [V2DI V2DF])
+
 ;; All vector modes, except double.
 (define_mode_iterator VQ_S [V8QI V16QI V4HI V8HI V2SI V4SI])
 
Index: gcc/config/aarch64/aarch64.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/aarch64/aarch64.h	(.../branches/gcc-4_9-branch)
@@ -481,6 +481,15 @@
   (TARGET_CPU_generic | (AARCH64_CPU_DEFAULT_FLAGS << 6))
 #endif
 
+/* If inserting NOP before a mult-accumulate insn remember to adjust the
+   length so that conditional branching code is updated appropriately.  */
+#define ADJUST_INSN_LENGTH(insn, length)	\
+  if (aarch64_madd_needs_nop (insn))		\
+    length += 4;
+
+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)	\
+    aarch64_final_prescan_insn (INSN);			\
+
 /* The processor for which instructions should be scheduled.  */
 extern enum aarch64_processor aarch64_tune;
 
Index: gcc/config/rs6000/constraints.md
===================================================================
--- a/src/gcc/config/rs6000/constraints.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/constraints.md	(.../branches/gcc-4_9-branch)
@@ -68,6 +68,20 @@
 (define_register_constraint "wg" "rs6000_constraints[RS6000_CONSTRAINT_wg]"
   "If -mmfpgpr was used, a floating point register or NO_REGS.")
 
+(define_register_constraint "wh" "rs6000_constraints[RS6000_CONSTRAINT_wh]"
+  "Floating point register if direct moves are available, or NO_REGS.")
+
+;; At present, DImode is not allowed in the Altivec registers.  If in the
+;; future it is allowed, wi/wj can be set to VSX_REGS instead of FLOAT_REGS.
+(define_register_constraint "wi" "rs6000_constraints[RS6000_CONSTRAINT_wi]"
+  "FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.")
+
+(define_register_constraint "wj" "rs6000_constraints[RS6000_CONSTRAINT_wj]"
+  "FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.")
+
+(define_register_constraint "wk" "rs6000_constraints[RS6000_CONSTRAINT_wk]"
+  "FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.")
+
 (define_register_constraint "wl" "rs6000_constraints[RS6000_CONSTRAINT_wl]"
   "Floating point register if the LFIWAX instruction is enabled or NO_REGS.")
 
@@ -101,7 +115,7 @@
   "Floating point register if the STFIWX instruction is enabled or NO_REGS.")
 
 (define_register_constraint "wy" "rs6000_constraints[RS6000_CONSTRAINT_wy]"
-  "VSX vector register to hold scalar float values or NO_REGS.")
+  "FP or VSX register to perform ISA 2.07 float ops or NO_REGS.")
 
 (define_register_constraint "wz" "rs6000_constraints[RS6000_CONSTRAINT_wz]"
   "Floating point register if the LFIWZX instruction is enabled or NO_REGS.")
Index: gcc/config/rs6000/predicates.md
===================================================================
--- a/src/gcc/config/rs6000/predicates.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/predicates.md	(.../branches/gcc-4_9-branch)
@@ -1783,7 +1783,7 @@
 (define_predicate "fusion_gpr_mem_load"
   (match_code "mem,sign_extend,zero_extend")
 {
-  rtx addr;
+  rtx addr, base, offset;
 
   /* Handle sign/zero extend.  */
   if (GET_CODE (op) == ZERO_EXTEND
@@ -1813,24 +1813,79 @@
     }
 
   addr = XEXP (op, 0);
+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)
+    return 0;
+
+  base = XEXP (addr, 0);
+  if (!base_reg_operand (base, GET_MODE (base)))
+    return 0;
+
+  offset = XEXP (addr, 1);
+
   if (GET_CODE (addr) == PLUS)
+    return satisfies_constraint_I (offset);
+
+  else if (GET_CODE (addr) == LO_SUM)
     {
-      rtx base = XEXP (addr, 0);
-      rtx offset = XEXP (addr, 1);
+      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))
+	return small_toc_ref (offset, GET_MODE (offset));
 
-      return (base_reg_operand (base, GET_MODE (base))
-	      && satisfies_constraint_I (offset));
+      else if (TARGET_ELF && !TARGET_POWERPC64)
+	return CONSTANT_P (offset);
     }
 
-  else if (GET_CODE (addr) == LO_SUM)
+  return 0;
+})
+
+;; Match a GPR load (lbz, lhz, lwz, ld) that uses a combined address in the
+;; memory field with both the addis and the memory offset.  Sign extension
+;; is not handled here, since lha and lwa are not fused.
+(define_predicate "fusion_gpr_mem_combo"
+  (match_code "mem,zero_extend")
+{
+  rtx addr, base, offset;
+
+  /* Handle zero extend.  */
+  if (GET_CODE (op) == ZERO_EXTEND)
     {
-      rtx base = XEXP (addr, 0);
-      rtx offset = XEXP (addr, 1);
+      op = XEXP (op, 0);
+      mode = GET_MODE (op);
+    }
 
-      if (!base_reg_operand (base, GET_MODE (base)))
+  if (!MEM_P (op))
+    return 0;
+
+  switch (mode)
+    {
+    case QImode:
+    case HImode:
+    case SImode:
+      break;
+
+    case DImode:
+      if (!TARGET_POWERPC64)
 	return 0;
+      break;
 
-      else if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))
+    default:
+      return 0;
+    }
+
+  addr = XEXP (op, 0);
+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)
+    return 0;
+
+  base = XEXP (addr, 0);
+  if (!fusion_gpr_addis (base, GET_MODE (base)))
+    return 0;
+
+  offset = XEXP (addr, 1);
+  if (GET_CODE (addr) == PLUS)
+    return satisfies_constraint_I (offset);
+
+  else if (GET_CODE (addr) == LO_SUM)
+    {
+      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))
 	return small_toc_ref (offset, GET_MODE (offset));
 
       else if (TARGET_ELF && !TARGET_POWERPC64)
Index: gcc/config/rs6000/freebsd64.h
===================================================================
--- a/src/gcc/config/rs6000/freebsd64.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/freebsd64.h	(.../branches/gcc-4_9-branch)
@@ -367,7 +367,7 @@
 /* PowerPC64 Linux word-aligns FP doubles when -malign-power is given.  */
 #undef  ADJUST_FIELD_ALIGN
 #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \
-  ((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)     \
+  (rs6000_special_adjust_field_align_p ((FIELD), (COMPUTED))		\
    ? 128                                                                \
    : (TARGET_64BIT                                                      \
       && TARGET_ALIGN_NATURAL == 0                                      \
Index: gcc/config/rs6000/rs6000-protos.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000-protos.h	(.../branches/gcc-4_9-branch)
@@ -79,9 +79,9 @@
 extern bool gpr_or_gpr_p (rtx, rtx);
 extern bool direct_move_p (rtx, rtx);
 extern bool quad_load_store_p (rtx, rtx);
-extern bool fusion_gpr_load_p (rtx *, bool);
+extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx);
 extern void expand_fusion_gpr_load (rtx *);
-extern const char *emit_fusion_gpr_load (rtx *);
+extern const char *emit_fusion_gpr_load (rtx, rtx);
 extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,
 							    enum reg_class);
 extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,
@@ -155,6 +155,7 @@
 
 #ifdef TREE_CODE
 extern unsigned int rs6000_data_alignment (tree, unsigned int, enum data_align);
+extern bool rs6000_special_adjust_field_align_p (tree, unsigned int);
 extern unsigned int rs6000_special_round_type_align (tree, unsigned int,
 						     unsigned int);
 extern unsigned int darwin_rs6000_special_round_type_align (tree, unsigned int,
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-4_9-branch)
@@ -4128,7 +4128,8 @@
      argument) is reversed.  Patch the arguments here before building
      the resolved CALL_EXPR.  */
   if (desc->code == ALTIVEC_BUILTIN_VEC_VCMPGE_P
-      && desc->overloaded_code != ALTIVEC_BUILTIN_VCMPGEFP_P)
+      && desc->overloaded_code != ALTIVEC_BUILTIN_VCMPGEFP_P
+      && desc->overloaded_code != VSX_BUILTIN_XVCMPGEDP_P)
     {
       tree t;
       t = args[2], args[2] = args[1], args[1] = t;
Index: gcc/config/rs6000/linux64.h
===================================================================
--- a/src/gcc/config/rs6000/linux64.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/linux64.h	(.../branches/gcc-4_9-branch)
@@ -246,7 +246,7 @@
 /* PowerPC64 Linux word-aligns FP doubles when -malign-power is given.  */
 #undef  ADJUST_FIELD_ALIGN
 #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \
-  ((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)	\
+  (rs6000_special_adjust_field_align_p ((FIELD), (COMPUTED))		\
    ? 128								\
    : (TARGET_64BIT							\
       && TARGET_ALIGN_NATURAL == 0					\
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_9-branch)
@@ -388,6 +388,7 @@
   enum insn_code reload_gpr_vsx;	/* INSN to move from GPR to VSX.  */
   enum insn_code reload_vsx_gpr;	/* INSN to move from VSX to GPR.  */
   addr_mask_type addr_mask[(int)N_RELOAD_REG]; /* Valid address masks.  */
+  bool scalar_in_vmx_p;			/* Scalar value can go in VMX.  */
 };
 
 static struct rs6000_reg_addr reg_addr[NUM_MACHINE_MODES];
@@ -1221,7 +1222,12 @@
       /* Soft frame pointer.  */
       "sfp",
       /* HTM SPR registers.  */
-      "tfhar", "tfiar", "texasr"
+      "tfhar", "tfiar", "texasr",
+      /* SPE High registers.  */
+      "0",  "1",  "2",  "3",  "4",  "5",  "6",  "7",
+      "8",  "9", "10", "11", "12", "13", "14", "15",
+     "16", "17", "18", "19", "20", "21", "22", "23",
+     "24", "25", "26", "27", "28", "29", "30", "31"
 };
 
 #ifdef TARGET_REGNAMES
@@ -1249,7 +1255,12 @@
   /* Soft frame pointer.  */
   "sfp",
   /* HTM SPR registers.  */
-  "tfhar", "tfiar", "texasr"
+  "tfhar", "tfiar", "texasr",
+  /* SPE High registers.  */
+  "%rh0",  "%rh1",  "%rh2",  "%rh3",  "%rh4",  "%rh5",  "%rh6",   "%rh7",
+  "%rh8",  "%rh9",  "%rh10", "%r11",  "%rh12", "%rh13", "%rh14", "%rh15",
+  "%rh16", "%rh17", "%rh18", "%rh19", "%rh20", "%rh21", "%rh22", "%rh23",
+  "%rh24", "%rh25", "%rh26", "%rh27", "%rh28", "%rh29", "%rh30", "%rh31"
 };
 #endif
 
@@ -1723,8 +1734,7 @@
      asked for it.  */
   if (TARGET_VSX && VSX_REGNO_P (regno)
       && (VECTOR_MEM_VSX_P (mode)
-	  || (TARGET_VSX_SCALAR_FLOAT && mode == SFmode)
-	  || (TARGET_VSX_SCALAR_DOUBLE && (mode == DFmode || mode == DImode))
+	  || reg_addr[mode].scalar_in_vmx_p
 	  || (TARGET_VSX_TIMODE && mode == TImode)
 	  || (TARGET_VADDUQM && mode == V1TImode)))
     {
@@ -1733,12 +1743,9 @@
 
       if (ALTIVEC_REGNO_P (regno))
 	{
-	  if (mode == SFmode && !TARGET_UPPER_REGS_SF)
+	  if (GET_MODE_SIZE (mode) != 16 && !reg_addr[mode].scalar_in_vmx_p)
 	    return 0;
 
-	  if ((mode == DFmode || mode == DImode) && !TARGET_UPPER_REGS_DF)
-	    return 0;
-
 	  return ALTIVEC_REGNO_P (last_regno);
 	}
     }
@@ -1916,14 +1923,16 @@
   if (rs6000_vector_unit[m] != VECTOR_NONE
       || rs6000_vector_mem[m] != VECTOR_NONE
       || (reg_addr[m].reload_store != CODE_FOR_nothing)
-      || (reg_addr[m].reload_load != CODE_FOR_nothing))
+      || (reg_addr[m].reload_load != CODE_FOR_nothing)
+      || reg_addr[m].scalar_in_vmx_p)
     {
       fprintf (stderr,
-	       "  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c",
+	       "  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c Upper=%c",
 	       rs6000_debug_vector_unit (rs6000_vector_unit[m]),
 	       rs6000_debug_vector_unit (rs6000_vector_mem[m]),
 	       (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',
-	       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*');
+	       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*',
+	       (reg_addr[m].scalar_in_vmx_p) ? 'y' : 'n');
     }
 
   fputs ("\n", stderr);
@@ -2040,6 +2049,10 @@
 	   "wd reg_class = %s\n"
 	   "wf reg_class = %s\n"
 	   "wg reg_class = %s\n"
+	   "wh reg_class = %s\n"
+	   "wi reg_class = %s\n"
+	   "wj reg_class = %s\n"
+	   "wk reg_class = %s\n"
 	   "wl reg_class = %s\n"
 	   "wm reg_class = %s\n"
 	   "wr reg_class = %s\n"
@@ -2059,6 +2072,10 @@
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wd]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wf]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wg]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wh]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wi]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wj]],
+	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wk]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wl]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wm]],
 	   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wr]],
@@ -2347,6 +2364,8 @@
 
   for (m = 0; m < NUM_MACHINE_MODES; ++m)
     {
+      enum machine_mode m2 = (enum machine_mode)m;
+
       /* SDmode is special in that we want to access it only via REG+REG
 	 addressing on power7 and above, since we want to use the LFIWZX and
 	 STFIWZX instructions to load it.  */
@@ -2381,13 +2400,12 @@
 
 	      if (TARGET_UPDATE
 		  && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR)
-		  && GET_MODE_SIZE (m) <= 8
-		  && !VECTOR_MODE_P (m)
-		  && !COMPLEX_MODE_P (m)
+		  && GET_MODE_SIZE (m2) <= 8
+		  && !VECTOR_MODE_P (m2)
+		  && !COMPLEX_MODE_P (m2)
 		  && !indexed_only_p
-		  && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (m) == 8)
-		  && !(m == DFmode && TARGET_UPPER_REGS_DF)
-		  && !(m == SFmode && TARGET_UPPER_REGS_SF))
+		  && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (m2) == 8)
+		  && !reg_addr[m2].scalar_in_vmx_p)
 		{
 		  addr_mask |= RELOAD_REG_PRE_INCDEC;
 
@@ -2618,16 +2636,22 @@
 	f  - Register class to use with traditional SFmode instructions.
 	v  - Altivec register.
 	wa - Any VSX register.
+	wc - Reserved to represent individual CR bits (used in LLVM).
 	wd - Preferred register class for V2DFmode.
 	wf - Preferred register class for V4SFmode.
 	wg - Float register for power6x move insns.
+	wh - FP register for direct move instructions.
+	wi - FP or VSX register to hold 64-bit integers for VSX insns.
+	wj - FP or VSX register to hold 64-bit integers for direct moves.
+	wk - FP or VSX register to hold 64-bit doubles for direct moves.
 	wl - Float register if we can do 32-bit signed int loads.
 	wm - VSX register for ISA 2.07 direct move operations.
+	wn - always NO_REGS.
 	wr - GPR if 64-bit mode is permitted.
 	ws - Register class to do ISA 2.06 DF operations.
+	wt - VSX register for TImode in VSX registers.
 	wu - Altivec register for ISA 2.07 VSX SF/SI load/stores.
 	wv - Altivec register for ISA 2.06 VSX DF/DI load/stores.
-	wt - VSX register for TImode in VSX registers.
 	ww - Register class to do SF conversions in with VSX operations.
 	wx - Float register if we can do 32-bit int stores.
 	wy - Register class to do ISA 2.07 SF operations.
@@ -2634,21 +2658,22 @@
 	wz - Float register if we can do 32-bit unsigned int loads.  */
 
   if (TARGET_HARD_FLOAT && TARGET_FPRS)
-    rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;	/* SFmode  */
 
   if (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)
-    rs6000_constraints[RS6000_CONSTRAINT_d] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_d]  = FLOAT_REGS;	/* DFmode  */
 
   if (TARGET_VSX)
     {
       rs6000_constraints[RS6000_CONSTRAINT_wa] = VSX_REGS;
-      rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;
-      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;
+      rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;	/* V2DFmode  */
+      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;	/* V4SFmode  */
+      rs6000_constraints[RS6000_CONSTRAINT_wi] = FLOAT_REGS;	/* DImode  */
 
       if (TARGET_VSX_TIMODE)
-	rs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;
+	rs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;	/* TImode  */
 
-      if (TARGET_UPPER_REGS_DF)
+      if (TARGET_UPPER_REGS_DF)					/* DFmode  */
 	{
 	  rs6000_constraints[RS6000_CONSTRAINT_ws] = VSX_REGS;
 	  rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;
@@ -2662,19 +2687,26 @@
   if (TARGET_ALTIVEC)
     rs6000_constraints[RS6000_CONSTRAINT_v] = ALTIVEC_REGS;
 
-  if (TARGET_MFPGPR)
+  if (TARGET_MFPGPR)						/* DFmode  */
     rs6000_constraints[RS6000_CONSTRAINT_wg] = FLOAT_REGS;
 
   if (TARGET_LFIWAX)
-    rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;	/* DImode  */
 
   if (TARGET_DIRECT_MOVE)
-    rs6000_constraints[RS6000_CONSTRAINT_wm] = VSX_REGS;
+    {
+      rs6000_constraints[RS6000_CONSTRAINT_wh] = FLOAT_REGS;
+      rs6000_constraints[RS6000_CONSTRAINT_wj]			/* DImode  */
+	= rs6000_constraints[RS6000_CONSTRAINT_wi];
+      rs6000_constraints[RS6000_CONSTRAINT_wk]			/* DFmode  */
+	= rs6000_constraints[RS6000_CONSTRAINT_ws];
+      rs6000_constraints[RS6000_CONSTRAINT_wm] = VSX_REGS;
+    }
 
   if (TARGET_POWERPC64)
     rs6000_constraints[RS6000_CONSTRAINT_wr] = GENERAL_REGS;
 
-  if (TARGET_P8_VECTOR && TARGET_UPPER_REGS_SF)
+  if (TARGET_P8_VECTOR && TARGET_UPPER_REGS_SF)			/* SFmode  */
     {
       rs6000_constraints[RS6000_CONSTRAINT_wu] = ALTIVEC_REGS;
       rs6000_constraints[RS6000_CONSTRAINT_wy] = VSX_REGS;
@@ -2689,10 +2721,10 @@
     rs6000_constraints[RS6000_CONSTRAINT_ww] = FLOAT_REGS;
 
   if (TARGET_STFIWX)
-    rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;	/* DImode  */
 
   if (TARGET_LFIWZX)
-    rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;
+    rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;	/* DImode  */
 
   /* Set up the reload helper and direct move functions.  */
   if (TARGET_VSX || TARGET_ALTIVEC)
@@ -2715,10 +2747,11 @@
 	  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_di_load;
 	  if (TARGET_VSX && TARGET_UPPER_REGS_DF)
 	    {
-	      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_di_store;
-	      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_di_load;
-	      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_di_store;
-	      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_di_load;
+	      reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_di_store;
+	      reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_di_load;
+	      reg_addr[DFmode].scalar_in_vmx_p = true;
+	      reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_di_store;
+	      reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_di_load;
 	    }
 	  if (TARGET_P8_VECTOR)
 	    {
@@ -2726,6 +2759,8 @@
 	      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_di_load;
 	      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_di_store;
 	      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_di_load;
+	      if (TARGET_UPPER_REGS_SF)
+		reg_addr[SFmode].scalar_in_vmx_p = true;
 	    }
 	  if (TARGET_VSX_TIMODE)
 	    {
@@ -2782,10 +2817,11 @@
 	  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_si_load;
 	  if (TARGET_VSX && TARGET_UPPER_REGS_DF)
 	    {
-	      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_si_store;
-	      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_si_load;
-	      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_si_store;
-	      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_si_load;
+	      reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_si_store;
+	      reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_si_load;
+	      reg_addr[DFmode].scalar_in_vmx_p = true;
+	      reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_si_store;
+	      reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_si_load;
 	    }
 	  if (TARGET_P8_VECTOR)
 	    {
@@ -2793,6 +2829,8 @@
 	      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_si_load;
 	      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_si_store;
 	      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_si_load;
+	      if (TARGET_UPPER_REGS_SF)
+		reg_addr[SFmode].scalar_in_vmx_p = true;
 	    }
 	  if (TARGET_VSX_TIMODE)
 	    {
@@ -2833,6 +2871,7 @@
 
       for (m = 0; m < NUM_MACHINE_MODES; ++m)
 	{
+	  enum machine_mode m2 = (enum machine_mode)m;
 	  int reg_size2 = reg_size;
 
 	  /* TFmode/TDmode always takes 2 registers, even in VSX.  */
@@ -2841,7 +2880,7 @@
 	    reg_size2 = UNITS_PER_FP_WORD;
 
 	  rs6000_class_max_nregs[m][c]
-	    = (GET_MODE_SIZE (m) + reg_size2 - 1) / reg_size2;
+	    = (GET_MODE_SIZE (m2) + reg_size2 - 1) / reg_size2;
 	}
     }
 
@@ -5871,6 +5910,34 @@
   return align;
 }
 
+/* Previous GCC releases forced all vector types to have 16-byte alignment.  */
+
+bool
+rs6000_special_adjust_field_align_p (tree field, unsigned int computed)
+{
+  if (TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE)
+    {
+      if (computed != 128)
+	{
+	  static bool warned;
+	  if (!warned && warn_psabi)
+	    {
+	      warned = true;
+	      inform (input_location,
+		      "the layout of aggregates containing vectors with"
+		      " %d-byte alignment will change in a future GCC release",
+		      computed / BITS_PER_UNIT);
+	    }
+	}
+      /* GCC 4.8/4.9 Note: To avoid any ABI change on a release branch, we
+	 keep the special treatment of vector types, but warn if there will
+	 be differences in future GCC releases.  */
+      return true;
+    }
+
+  return false;
+}
+
 /* AIX increases natural record alignment to doubleword if the first
    field is an FP double while the FP fields remain word aligned.  */
 
@@ -9180,14 +9247,51 @@
 	   || (type && TREE_CODE (type) == VECTOR_TYPE
 	       && int_size_in_bytes (type) >= 16))
     return 128;
-  else if (((TARGET_MACHO && rs6000_darwin64_abi)
-	    || DEFAULT_ABI == ABI_ELFv2
-            || (DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm))
- 	   && mode == BLKmode
-	   && type && TYPE_ALIGN (type) > 64)
+
+  /* Aggregate types that need > 8 byte alignment are quadword-aligned
+     in the parameter area in the ELFv2 ABI, and in the AIX ABI unless
+     -mcompat-align-parm is used.  */
+  if (((DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm)
+       || DEFAULT_ABI == ABI_ELFv2)
+      && type && TYPE_ALIGN (type) > 64)
+    {
+      /* "Aggregate" means any AGGREGATE_TYPE except for single-element
+         or homogeneous float/vector aggregates here.  We already handled
+         vector aggregates above, but still need to check for float here. */
+      bool aggregate_p = (AGGREGATE_TYPE_P (type)
+			  && !SCALAR_FLOAT_MODE_P (elt_mode));
+
+      /* We used to check for BLKmode instead of the above aggregate type
+	 check.  Warn when this results in any difference to the ABI.  */
+      if (aggregate_p != (mode == BLKmode))
+	{
+	  static bool warned;
+	  if (!warned && warn_psabi)
+	    {
+	      warned = true;
+	      inform (input_location,
+		      "the ABI of passing aggregates with %d-byte alignment"
+		      " will change in a future GCC release",
+		      (int) TYPE_ALIGN (type) / BITS_PER_UNIT);
+	    }
+	}
+
+      /* GCC 4.8/4.9 Note: To avoid any ABI change on a release branch, we
+	 keep using the BLKmode check, but warn if there will be differences
+	 in future GCC releases.  */
+      if (mode == BLKmode)
+	return 128;
+    }
+
+  /* Similar for the Darwin64 ABI.  Note that for historical reasons we
+     implement the "aggregate type" check as a BLKmode check here; this
+     means certain aggregate types are in fact not aligned.  */
+  if (TARGET_MACHO && rs6000_darwin64_abi
+      && mode == BLKmode
+      && type && TYPE_ALIGN (type) > 64)
     return 128;
-  else
-    return PARM_BOUNDARY;
+
+  return PARM_BOUNDARY;
 }
 
 /* The offset in words to the start of the parameter save area.  */
@@ -10225,6 +10329,7 @@
 	  rtx r, off;
 	  int i, k = 0;
 	  unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;
+	  int fpr_words;
 
 	  /* Do we also need to pass this argument in the parameter
 	     save area?  */
@@ -10253,6 +10358,37 @@
 	      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);
 	    }
 
+	  /* If there were not enough FPRs to hold the argument, the rest
+	     usually goes into memory.  However, if the current position
+	     is still within the register parameter area, a portion may
+	     actually have to go into GPRs.
+
+	     Note that it may happen that the portion of the argument
+	     passed in the first "half" of the first GPR was already
+	     passed in the last FPR as well.
+
+	     For unnamed arguments, we already set up GPRs to cover the
+	     whole argument in rs6000_psave_function_arg, so there is
+	     nothing further to do at this point.
+
+	     GCC 4.8/4.9 Note: This was implemented incorrectly in earlier
+	     GCC releases.  To avoid any ABI change on the release branch,
+	     we retain that original implementation here, but warn if we
+	     encounter a case where the ABI will change in the future.  */
+	  fpr_words = (i * GET_MODE_SIZE (elt_mode)) / (TARGET_32BIT ? 4 : 8);
+	  if (i < n_elts && align_words + fpr_words < GP_ARG_NUM_REG
+	      && cum->nargs_prototype > 0)
+            {
+	      static bool warned;
+	      if (!warned && warn_psabi)
+		{
+		  warned = true;
+		  inform (input_location,
+			  "the ABI of passing homogeneous float aggregates"
+			  " will change in a future GCC release");
+		}
+	    }
+
 	  return rs6000_finish_function_arg (mode, rvec, k);
 	}
       else if (align_words < GP_ARG_NUM_REG)
@@ -17070,7 +17206,14 @@
      prefer Altivec loads..  */
   if (rclass == VSX_REGS)
     {
-      if (GET_MODE_SIZE (mode) <= 8)
+      if (MEM_P (x) && reg_addr[mode].scalar_in_vmx_p)
+	{
+	  rtx addr = XEXP (x, 0);
+	  if (rs6000_legitimate_offset_address_p (mode, addr, false, true)
+	      || legitimate_lo_sum_address_p (mode, addr, false))
+	    return FLOAT_REGS;
+	}
+      else if (GET_MODE_SIZE (mode) <= 8 && !reg_addr[mode].scalar_in_vmx_p)
 	return FLOAT_REGS;
 
       if (VECTOR_UNIT_ALTIVEC_P (mode) || VECTOR_MEM_ALTIVEC_P (mode)
@@ -31074,13 +31217,13 @@
     {
       if (BYTES_BIG_ENDIAN)
 	{
-	  parts[2 * i] = gen_rtx_REG (SImode, regno + 1200);
+	  parts[2 * i] = gen_rtx_REG (SImode, regno + FIRST_SPE_HIGH_REGNO);
 	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno);
 	}
       else
 	{
 	  parts[2 * i] = gen_rtx_REG (SImode, regno);
-	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno + 1200);
+	  parts[2 * i + 1] = gen_rtx_REG (SImode, regno + FIRST_SPE_HIGH_REGNO);
 	}
     }
 
@@ -31100,11 +31243,11 @@
       rtx mem = gen_rtx_MEM (BLKmode, addr);
       rtx value = gen_int_mode (4, mode);
 
-      for (i = 1201; i < 1232; i++)
+      for (i = FIRST_SPE_HIGH_REGNO; i < LAST_SPE_HIGH_REGNO+1; i++)
 	{
-	  int column = DWARF_REG_TO_UNWIND_COLUMN (i);
-	  HOST_WIDE_INT offset
-	    = DWARF_FRAME_REGNUM (column) * GET_MODE_SIZE (mode);
+	  int column = DWARF_REG_TO_UNWIND_COLUMN
+		(DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), true));
+	  HOST_WIDE_INT offset = column * GET_MODE_SIZE (mode);
 
 	  emit_move_insn (adjust_address (mem, mode, offset), value);
 	}
@@ -31123,9 +31266,9 @@
 
       for (i = FIRST_ALTIVEC_REGNO; i < LAST_ALTIVEC_REGNO+1; i++)
 	{
-	  int column = DWARF_REG_TO_UNWIND_COLUMN (i);
-	  HOST_WIDE_INT offset
-	    = DWARF_FRAME_REGNUM (column) * GET_MODE_SIZE (mode);
+	  int column = DWARF_REG_TO_UNWIND_COLUMN
+		(DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), true));
+	  HOST_WIDE_INT offset = column * GET_MODE_SIZE (mode);
 
 	  emit_move_insn (adjust_address (mem, mode, offset), value);
 	}
@@ -31157,9 +31300,8 @@
     return 99;
   if (regno == SPEFSCR_REGNO)
     return 612;
-  /* SPE high reg number.  We get these values of regno from
-     rs6000_dwarf_register_span.  */
-  gcc_assert (regno >= 1200 && regno < 1232);
+  if (SPE_HIGH_REGNO_P (regno))
+    return regno - FIRST_SPE_HIGH_REGNO + 1200;
   return regno;
 }
 
@@ -32613,25 +32755,14 @@
 
 /* Return true if the peephole2 can combine a load involving a combination of
    an addis instruction and a load with an offset that can be fused together on
-   a power8.
+   a power8.  */
 
-   The operands are:
-	operands[0]	register set with addis
-	operands[1]	value set via addis
-	operands[2]	target register being loaded
-	operands[3]	D-form memory reference using operands[0].
-
-   In addition, we are passed a boolean that is true if this is a peephole2,
-   and we can use see if the addis_reg is dead after the insn and can be
-   replaced by the target register.  */
-
 bool
-fusion_gpr_load_p (rtx *operands, bool peep2_p)
+fusion_gpr_load_p (rtx addis_reg,	/* register set via addis.  */
+		   rtx addis_value,	/* addis value.  */
+		   rtx target,		/* target register that is loaded.  */
+		   rtx mem)		/* bottom part of the memory addr. */
 {
-  rtx addis_reg = operands[0];
-  rtx addis_value = operands[1];
-  rtx target = operands[2];
-  rtx mem = operands[3];
   rtx addr;
   rtx base_reg;
 
@@ -32645,9 +32776,6 @@
   if (!fusion_gpr_addis (addis_value, GET_MODE (addis_value)))
     return false;
 
-  if (!fusion_gpr_mem_load (mem, GET_MODE (mem)))
-    return false;
-
   /* Allow sign/zero extension.  */
   if (GET_CODE (mem) == ZERO_EXTEND
       || (GET_CODE (mem) == SIGN_EXTEND && TARGET_P8_FUSION_SIGN))
@@ -32656,22 +32784,22 @@
   if (!MEM_P (mem))
     return false;
 
+  if (!fusion_gpr_mem_load (mem, GET_MODE (mem)))
+    return false;
+
   addr = XEXP (mem, 0);			/* either PLUS or LO_SUM.  */
   if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)
     return false;
 
   /* Validate that the register used to load the high value is either the
-     register being loaded, or we can safely replace its use in a peephole2.
+     register being loaded, or we can safely replace its use.
 
-     If this is a peephole2, we assume that there are 2 instructions in the
-     peephole (addis and load), so we want to check if the target register was
-     not used in the memory address and the register to hold the addis result
-     is dead after the peephole.  */
+     This function is only called from the peephole2 pass and we assume that
+     there are 2 instructions in the peephole (addis and load), so we want to
+     check if the target register was not used in the memory address and the
+     register to hold the addis result is dead after the peephole.  */
   if (REGNO (addis_reg) != REGNO (target))
     {
-      if (!peep2_p)
-	return false;
-
       if (reg_mentioned_p (target, mem))
 	return false;
 
@@ -32712,9 +32840,6 @@
   enum machine_mode extend_mode = target_mode;
   enum machine_mode ptr_mode = Pmode;
   enum rtx_code extend = UNKNOWN;
-  rtx addis_reg = ((ptr_mode == target_mode)
-		   ? target
-		   : simplify_subreg (ptr_mode, target, target_mode, 0));
 
   if (GET_CODE (orig_mem) == ZERO_EXTEND
       || (TARGET_P8_FUSION_SIGN && GET_CODE (orig_mem) == SIGN_EXTEND))
@@ -32731,13 +32856,14 @@
   gcc_assert (plus_or_lo_sum == PLUS || plus_or_lo_sum == LO_SUM);
 
   offset = XEXP (orig_addr, 1);
-  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_reg, offset);
-  new_mem = change_address (orig_mem, target_mode, new_addr);
+  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_value, offset);
+  new_mem = replace_equiv_address_nv (orig_mem, new_addr);
 
   if (extend != UNKNOWN)
     new_mem = gen_rtx_fmt_e (ZERO_EXTEND, extend_mode, new_mem);
 
-  emit_insn (gen_rtx_SET (VOIDmode, addis_reg, addis_value));
+  new_mem = gen_rtx_UNSPEC (extend_mode, gen_rtvec (1, new_mem),
+			    UNSPEC_FUSION_GPR);
   emit_insn (gen_rtx_SET (VOIDmode, target, new_mem));
 
   if (extend == SIGN_EXTEND)
@@ -32756,55 +32882,40 @@
 }
 
 /* Return a string to fuse an addis instruction with a gpr load to the same
-   register that we loaded up the addis instruction.  The code is complicated,
-   so we call output_asm_insn directly, and just return "".
+   register that we loaded up the addis instruction.  The address that is used
+   is the logical address that was formed during peephole2:
+	(lo_sum (high) (low-part))
 
-   The operands are:
-	operands[0]	register set with addis (must be same reg as target).
-	operands[1]	value set via addis
-	operands[2]	target register being loaded
-	operands[3]	D-form memory reference using operands[0].  */
+   The code is complicated, so we call output_asm_insn directly, and just
+   return "".  */
 
 const char *
-emit_fusion_gpr_load (rtx *operands)
+emit_fusion_gpr_load (rtx target, rtx mem)
 {
-  rtx addis_reg = operands[0];
-  rtx addis_value = operands[1];
-  rtx target = operands[2];
-  rtx mem = operands[3];
+  rtx addis_value;
   rtx fuse_ops[10];
   rtx addr;
   rtx load_offset;
   const char *addis_str = NULL;
   const char *load_str = NULL;
-  const char *extend_insn = NULL;
   const char *mode_name = NULL;
   char insn_template[80];
   enum machine_mode mode;
   const char *comment_str = ASM_COMMENT_START;
-  bool sign_p = false;
 
-  gcc_assert (REG_P (addis_reg) && REG_P (target));
-  gcc_assert (REGNO (addis_reg) == REGNO (target));
+  if (GET_CODE (mem) == ZERO_EXTEND)
+    mem = XEXP (mem, 0);
 
+  gcc_assert (REG_P (target) && MEM_P (mem));
+
   if (*comment_str == ' ')
     comment_str++;
 
-  /* Allow sign/zero extension.  */
-  if (GET_CODE (mem) == ZERO_EXTEND)
-    mem = XEXP (mem, 0);
-
-  else if (GET_CODE (mem) == SIGN_EXTEND && TARGET_P8_FUSION_SIGN)
-    {
-      sign_p = true;
-      mem = XEXP (mem, 0);
-    }
-
-  gcc_assert (MEM_P (mem));
   addr = XEXP (mem, 0);
   if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)
     gcc_unreachable ();
 
+  addis_value = XEXP (addr, 0);
   load_offset = XEXP (addr, 1);
 
   /* Now emit the load instruction to the same register.  */
@@ -32814,29 +32925,22 @@
     case QImode:
       mode_name = "char";
       load_str = "lbz";
-      extend_insn = "extsb %0,%0";
       break;
 
     case HImode:
       mode_name = "short";
       load_str = "lhz";
-      extend_insn = "extsh %0,%0";
       break;
 
     case SImode:
       mode_name = "int";
       load_str = "lwz";
-      extend_insn = "extsw %0,%0";
       break;
 
     case DImode:
-      if (TARGET_POWERPC64)
-	{
-	  mode_name = "long";
-	  load_str = "ld";
-	}
-      else
-	gcc_unreachable ();
+      gcc_assert (TARGET_POWERPC64);
+      mode_name = "long";
+      load_str = "ld";
       break;
 
     default:
@@ -32980,14 +33084,6 @@
   else
     fatal_insn ("Unable to generate load offset for fusion", load_offset);
 
-  /* Handle sign extension.  The peephole2 pass generates this as a separate
-     insn, but we handle it just in case it got reattached.  */
-  if (sign_p)
-    {
-      gcc_assert (extend_insn != NULL);
-      output_asm_insn (extend_insn, fuse_ops);
-    }
-
   return "";
 }
 
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-4_9-branch)
@@ -86,19 +86,26 @@
 			 (V4SF  "wf")
 			 (V2DI  "wd")
 			 (V2DF  "wd")
+			 (DI	"wi")
 			 (DF    "ws")
-			 (SF	"d")
+			 (SF	"ww")
 			 (V1TI  "v")
 			 (TI    "wt")])
 
-;; Map the register class used for float<->int conversions
+;; Map the register class used for float<->int conversions (floating point side)
+;; VSr2 is the preferred register class, VSr3 is any register class that will
+;; hold the data
 (define_mode_attr VSr2	[(V2DF  "wd")
 			 (V4SF  "wf")
-			 (DF    "ws")])
+			 (DF    "ws")
+			 (SF	"ww")
+			 (DI	"wi")])
 
 (define_mode_attr VSr3	[(V2DF  "wa")
 			 (V4SF  "wa")
-			 (DF    "ws")])
+			 (DF    "ws")
+			 (SF	"ww")
+			 (DI	"wi")])
 
 ;; Map the register class for sp<->dp float conversions, destination
 (define_mode_attr VSr4	[(SF	"ws")
@@ -106,12 +113,27 @@
 			 (V2DF  "wd")
 			 (V4SF	"v")])
 
-;; Map the register class for sp<->dp float conversions, destination
+;; Map the register class for sp<->dp float conversions, source
 (define_mode_attr VSr5	[(SF	"ws")
 			 (DF	"f")
 			 (V2DF  "v")
 			 (V4SF	"wd")])
 
+;; The VSX register class that a type can occupy, even if it is not the
+;; preferred register class (VSr is the preferred register class that will get
+;; allocated first).
+(define_mode_attr VSa	[(V16QI "wa")
+			 (V8HI  "wa")
+			 (V4SI  "wa")
+			 (V4SF  "wa")
+			 (V2DI  "wa")
+			 (V2DF  "wa")
+			 (DI	"wi")
+			 (DF    "ws")
+			 (SF	"ww")
+			 (V1TI	"wa")
+			 (TI    "wt")])
+
 ;; Same size integer type for floating point data
 (define_mode_attr VSi [(V4SF  "v4si")
 		       (V2DF  "v2di")
@@ -207,6 +229,16 @@
 			     (V2DF	"V4DF")
 			     (V1TI	"V2TI")])
 
+;; Map register class for 64-bit element in 128-bit vector for direct moves
+;; to/from gprs
+(define_mode_attr VS_64dm [(V2DF	"wk")
+			   (V2DI	"wj")])
+
+;; Map register class for 64-bit element in 128-bit vector for normal register
+;; to register moves
+(define_mode_attr VS_64reg [(V2DF	"ws")
+			    (V2DI	"wi")])
+
 ;; Constants for creating unspecs
 (define_c_enum "unspec"
   [UNSPEC_VSX_CONCAT
@@ -235,7 +267,7 @@
 ;; The patterns for LE permuted loads and stores come before the general
 ;; VSX moves so they match first.
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
-  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=<VSa>")
         (match_operand:VSX_LE 1 "memory_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
@@ -258,7 +290,7 @@
    (set_attr "length" "8")])
 
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
         (match_operand:VSX_W 1 "memory_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
@@ -350,7 +382,7 @@
 
 (define_insn "*vsx_le_perm_store_<mode>"
   [(set (match_operand:VSX_LE 0 "memory_operand" "=Z")
-        (match_operand:VSX_LE 1 "vsx_register_operand" "+wa"))]
+        (match_operand:VSX_LE 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
   [(set_attr "type" "vecstore")
@@ -395,7 +427,7 @@
 
 (define_insn "*vsx_le_perm_store_<mode>"
   [(set (match_operand:VSX_W 0 "memory_operand" "=Z")
-        (match_operand:VSX_W 1 "vsx_register_operand" "+wa"))]
+        (match_operand:VSX_W 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX"
   "#"
   [(set_attr "type" "vecstore")
@@ -585,8 +617,8 @@
 
 
 (define_insn "*vsx_mov<mode>"
-  [(set (match_operand:VSX_M 0 "nonimmediate_operand" "=Z,<VSr>,<VSr>,?Z,?wa,?wa,wQ,?&r,??Y,??r,??r,<VSr>,?wa,*r,v,wZ, v")
-	(match_operand:VSX_M 1 "input_operand" "<VSr>,Z,<VSr>,wa,Z,wa,r,wQ,r,Y,r,j,j,j,W,v,wZ"))]
+  [(set (match_operand:VSX_M 0 "nonimmediate_operand" "=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ, v")
+	(match_operand:VSX_M 1 "input_operand" "<VSr>,Z,<VSr>,<VSa>,Z,<VSa>,r,wQ,r,Y,r,j,j,j,W,v,wZ"))]
   "VECTOR_MEM_VSX_P (<MODE>mode)
    && (register_operand (operands[0], <MODE>mode) 
        || register_operand (operands[1], <MODE>mode))"
@@ -688,9 +720,9 @@
 ;; instructions are now combined with the insn for the traditional floating
 ;; point unit.
 (define_insn "*vsx_add<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (plus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (plus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvadd<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -697,9 +729,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_sub<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (minus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		     (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (minus:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		     (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvsub<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -706,9 +738,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_mul<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (mult:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (mult:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvmul<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -715,9 +747,9 @@
    (set_attr "fp_type" "<VSfptype_mul>")])
 
 (define_insn "*vsx_div<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (div:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		   (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (div:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		   (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvdiv<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_div>")
@@ -753,8 +785,8 @@
 
 (define_insn "*vsx_tdiv<mode>3_internal"
   [(set (match_operand:CCFP 0 "cc_reg_operand" "=x,x")
-	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")
-		      (match_operand:VSX_B 2 "vsx_register_operand" "<VSr>,wa")]
+	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")
+		      (match_operand:VSX_B 2 "vsx_register_operand" "<VSr>,<VSa>")]
 		   UNSPEC_VSX_TDIV))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>tdiv<VSs> %0,%x1,%x2"
@@ -762,8 +794,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_fre<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRES))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvre<VSs> %x0,%x1"
@@ -771,8 +803,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_neg<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (neg:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (neg:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvneg<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -779,8 +811,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_abs<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (abs:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (abs:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvabs<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -787,10 +819,10 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_nabs<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
         (neg:VSX_F
 	 (abs:VSX_F
-	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa"))))]
+	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>"))))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvnabs<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -797,9 +829,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_smax<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (smax:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (smax:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvmax<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -806,9 +838,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_smin<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (smin:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (smin:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		    (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvmin<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -815,8 +847,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_sqrt<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-        (sqrt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+        (sqrt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvsqrt<VSs> %x0,%x1"
   [(set_attr "type" "<VStype_sqrt>")
@@ -823,8 +855,8 @@
    (set_attr "fp_type" "<VSfptype_sqrt>")])
 
 (define_insn "*vsx_rsqrte<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_RSQRT))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvrsqrte<VSs> %x0,%x1"
@@ -859,7 +891,7 @@
 
 (define_insn "*vsx_tsqrt<mode>2_internal"
   [(set (match_operand:CCFP 0 "cc_reg_operand" "=x,x")
-	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+	(unspec:CCFP [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		     UNSPEC_VSX_TSQRT))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>tsqrt<VSs> %0,%x1"
@@ -872,11 +904,11 @@
 ;; multiply.
 
 (define_insn "*vsx_fmav4sf4"
-  [(set (match_operand:V4SF 0 "vsx_register_operand" "=ws,ws,?wa,?wa,v")
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wf,wf,?wa,?wa,v")
 	(fma:V4SF
-	  (match_operand:V4SF 1 "vsx_register_operand" "%ws,ws,wa,wa,v")
-	  (match_operand:V4SF 2 "vsx_register_operand" "ws,0,wa,0,v")
-	  (match_operand:V4SF 3 "vsx_register_operand" "0,ws,0,wa,v")))]
+	  (match_operand:V4SF 1 "vsx_register_operand" "%wf,wf,wa,wa,v")
+	  (match_operand:V4SF 2 "vsx_register_operand" "wf,0,wa,0,v")
+	  (match_operand:V4SF 3 "vsx_register_operand" "0,wf,0,wa,v")))]
   "VECTOR_UNIT_VSX_P (V4SFmode)"
   "@
    xvmaddasp %x0,%x1,%x2
@@ -887,11 +919,11 @@
   [(set_attr "type" "vecfloat")])
 
 (define_insn "*vsx_fmav2df4"
-  [(set (match_operand:V2DF 0 "vsx_register_operand" "=ws,ws,?wa,?wa")
+  [(set (match_operand:V2DF 0 "vsx_register_operand" "=wd,wd,?wa,?wa")
 	(fma:V2DF
-	  (match_operand:V2DF 1 "vsx_register_operand" "%ws,ws,wa,wa")
-	  (match_operand:V2DF 2 "vsx_register_operand" "ws,0,wa,0")
-	  (match_operand:V2DF 3 "vsx_register_operand" "0,ws,0,wa")))]
+	  (match_operand:V2DF 1 "vsx_register_operand" "%wd,wd,wa,wa")
+	  (match_operand:V2DF 2 "vsx_register_operand" "wd,0,wa,0")
+	  (match_operand:V2DF 3 "vsx_register_operand" "0,wd,0,wa")))]
   "VECTOR_UNIT_VSX_P (V2DFmode)"
   "@
    xvmaddadp %x0,%x1,%x2
@@ -901,12 +933,12 @@
   [(set_attr "type" "vecdouble")])
 
 (define_insn "*vsx_fms<mode>4"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?wa,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?<VSa>,?<VSa>")
 	(fma:VSX_F
-	  (match_operand:VSX_F 1 "vsx_register_operand" "%<VSr>,<VSr>,wa,wa")
-	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,wa,0")
+	  (match_operand:VSX_F 1 "vsx_register_operand" "%<VSr>,<VSr>,<VSa>,<VSa>")
+	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,<VSa>,0")
 	  (neg:VSX_F
-	    (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,wa"))))]
+	    (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,<VSa>"))))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "@
    xvmsuba<VSs> %x0,%x1,%x2
@@ -916,12 +948,12 @@
   [(set_attr "type" "<VStype_mul>")])
 
 (define_insn "*vsx_nfma<mode>4"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?wa,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,<VSr>,?<VSa>,?<VSa>")
 	(neg:VSX_F
 	 (fma:VSX_F
-	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSr>,wa,wa")
-	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,wa,0")
-	  (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,wa"))))]
+	  (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSr>,<VSa>,<VSa>")
+	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,0,<VSa>,0")
+	  (match_operand:VSX_F 3 "vsx_register_operand" "0,<VSr>,0,<VSa>"))))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "@
    xvnmadda<VSs> %x0,%x1,%x2
@@ -966,9 +998,9 @@
 
 ;; Vector conditional expressions (no scalar version for these instructions)
 (define_insn "vsx_eq<mode>"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(eq:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(eq:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcmpeq<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -975,9 +1007,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_gt<mode>"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(gt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(gt:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcmpgt<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -984,9 +1016,9 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_ge<mode>"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(ge:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(ge:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+		  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcmpge<VSs> %x0,%x1,%x2"
   [(set_attr "type" "<VStype_simple>")
@@ -997,10 +1029,10 @@
 (define_insn "*vsx_eq_<mode>_p"
   [(set (reg:CC 74)
 	(unspec:CC
-	 [(eq:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?wa")
-		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?wa"))]
+	 [(eq:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?<VSa>")
+		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?<VSa>"))]
 	 UNSPEC_PREDICATE))
-   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(eq:VSX_F (match_dup 1)
 		  (match_dup 2)))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
@@ -1010,10 +1042,10 @@
 (define_insn "*vsx_gt_<mode>_p"
   [(set (reg:CC 74)
 	(unspec:CC
-	 [(gt:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?wa")
-		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?wa"))]
+	 [(gt:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?<VSa>")
+		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?<VSa>"))]
 	 UNSPEC_PREDICATE))
-   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(gt:VSX_F (match_dup 1)
 		  (match_dup 2)))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
@@ -1023,10 +1055,10 @@
 (define_insn "*vsx_ge_<mode>_p"
   [(set (reg:CC 74)
 	(unspec:CC
-	 [(ge:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?wa")
-		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?wa"))]
+	 [(ge:CC (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,?<VSa>")
+		 (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,?<VSa>"))]
 	 UNSPEC_PREDICATE))
-   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+   (set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(ge:VSX_F (match_dup 1)
 		  (match_dup 2)))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
@@ -1035,23 +1067,23 @@
 
 ;; Vector select
 (define_insn "*vsx_xxsel<mode>"
-  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(if_then_else:VSX_L
-	 (ne:CC (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,wa")
+	 (ne:CC (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,<VSa>")
 		(match_operand:VSX_L 4 "zero_constant" ""))
-	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,wa")
-	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,wa")))]
+	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,<VSa>")
+	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxsel %x0,%x3,%x2,%x1"
   [(set_attr "type" "vecperm")])
 
 (define_insn "*vsx_xxsel<mode>_uns"
-  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(if_then_else:VSX_L
-	 (ne:CCUNS (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,wa")
+	 (ne:CCUNS (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,<VSa>")
 		   (match_operand:VSX_L 4 "zero_constant" ""))
-	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,wa")
-	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,wa")))]
+	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,<VSa>")
+	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxsel %x0,%x3,%x2,%x1"
   [(set_attr "type" "vecperm")])
@@ -1058,10 +1090,10 @@
 
 ;; Copy sign
 (define_insn "vsx_copysign<mode>3"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(unspec:VSX_F
-	 [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")
-	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,wa")]
+	 [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
+	  (match_operand:VSX_F 2 "vsx_register_operand" "<VSr>,<VSa>")]
 	 UNSPEC_COPYSIGN))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvcpsgn<VSs> %x0,%x2,%x1"
@@ -1074,7 +1106,7 @@
 ;; in rs6000.md so don't test VECTOR_UNIT_VSX_P, just test against VSX.
 ;; Don't use vsx_register_operand here, use gpc_reg_operand to match rs6000.md.
 (define_insn "vsx_float<VSi><mode>2"
-  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?<VSa>")
 	(float:VSX_B (match_operand:<VSI> 1 "gpc_reg_operand" "<VSr2>,<VSr3>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cvsx<VSc><VSs> %x0,%x1"
@@ -1082,7 +1114,7 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_floatuns<VSi><mode>2"
-  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?<VSa>")
 	(unsigned_float:VSX_B (match_operand:<VSI> 1 "gpc_reg_operand" "<VSr2>,<VSr3>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cvux<VSc><VSs> %x0,%x1"
@@ -1091,7 +1123,7 @@
 
 (define_insn "vsx_fix_trunc<mode><VSi>2"
   [(set (match_operand:<VSI> 0 "gpc_reg_operand" "=<VSr2>,?<VSr3>")
-	(fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,wa")))]
+	(fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cv<VSs>sx<VSc>s %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -1099,7 +1131,7 @@
 
 (define_insn "vsx_fixuns_trunc<mode><VSi>2"
   [(set (match_operand:<VSI> 0 "gpc_reg_operand" "=<VSr2>,?<VSr3>")
-	(unsigned_fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,wa")))]
+	(unsigned_fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cv<VSs>ux<VSc>s %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -1107,8 +1139,8 @@
 
 ;; Math rounding functions
 (define_insn "vsx_x<VSv>r<VSs>i"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_VSX_ROUND_I))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>r<VSs>i %x0,%x1"
@@ -1116,8 +1148,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_x<VSv>r<VSs>ic"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_VSX_ROUND_IC))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>r<VSs>ic %x0,%x1"
@@ -1125,8 +1157,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_btrunc<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(fix:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(fix:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvr<VSs>iz %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
@@ -1133,8 +1165,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "*vsx_b2trunc<mode>2"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_B [(match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRIZ))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>r<VSs>iz %x0,%x1"
@@ -1142,8 +1174,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_floor<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRIM))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvr<VSs>im %x0,%x1"
@@ -1151,8 +1183,8 @@
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_ceil<mode>2"
-  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,wa")]
+  [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
+	(unspec:VSX_F [(match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")]
 		      UNSPEC_FRIP))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "xvr<VSs>ip %x0,%x1"
@@ -1167,8 +1199,8 @@
 ;; scalar single precision instructions internally use the double format.
 ;; Prefer the altivec registers, since we likely will need to do a vperm
 (define_insn "vsx_<VS_spdp_insn>"
-  [(set (match_operand:<VS_spdp_res> 0 "vsx_register_operand" "=<VSr4>,?wa")
-	(unspec:<VS_spdp_res> [(match_operand:VSX_SPDP 1 "vsx_register_operand" "<VSr5>,wa")]
+  [(set (match_operand:<VS_spdp_res> 0 "vsx_register_operand" "=<VSr4>,?<VSa>")
+	(unspec:<VS_spdp_res> [(match_operand:VSX_SPDP 1 "vsx_register_operand" "<VSr5>,<VSa>")]
 			      UNSPEC_VSX_CVSPDP))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "<VS_spdp_insn> %x0,%x1"
@@ -1176,8 +1208,8 @@
 
 ;; xscvspdp, represent the scalar SF type as V4SF
 (define_insn "vsx_xscvspdp"
-  [(set (match_operand:DF 0 "vsx_register_operand" "=ws,?wa")
-	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wa,wa")]
+  [(set (match_operand:DF 0 "vsx_register_operand" "=ws")
+	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wa")]
 		   UNSPEC_VSX_CVSPDP))]
   "VECTOR_UNIT_VSX_P (V4SFmode)"
   "xscvspdp %x0,%x1"
@@ -1204,7 +1236,7 @@
 
 ;; ISA 2.07 xscvdpspn/xscvspdpn that does not raise an error on signalling NaNs
 (define_insn "vsx_xscvdpspn"
-  [(set (match_operand:V4SF 0 "vsx_register_operand" "=ws,?wa")
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=ww,?ww")
 	(unspec:V4SF [(match_operand:DF 1 "vsx_register_operand" "wd,wa")]
 		     UNSPEC_VSX_CVDPSPN))]
   "TARGET_XSCVDPSPN"
@@ -1212,8 +1244,8 @@
   [(set_attr "type" "fp")])
 
 (define_insn "vsx_xscvspdpn"
-  [(set (match_operand:DF 0 "vsx_register_operand" "=ws,?wa")
-	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wa,wa")]
+  [(set (match_operand:DF 0 "vsx_register_operand" "=ws,?ws")
+	(unspec:DF [(match_operand:V4SF 1 "vsx_register_operand" "wf,wa")]
 		   UNSPEC_VSX_CVSPDPN))]
   "TARGET_XSCVSPDPN"
   "xscvspdpn %x0,%x1"
@@ -1220,8 +1252,8 @@
   [(set_attr "type" "fp")])
 
 (define_insn "vsx_xscvdpspn_scalar"
-  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa")
-	(unspec:V4SF [(match_operand:SF 1 "vsx_register_operand" "f")]
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wf,?wa")
+	(unspec:V4SF [(match_operand:SF 1 "vsx_register_operand" "ww,ww")]
 		     UNSPEC_VSX_CVDPSPN))]
   "TARGET_XSCVDPSPN"
   "xscvdpspn %x0,%x1"
@@ -1309,10 +1341,10 @@
 ;; since the xsrdpiz instruction does not truncate the value if the floating
 ;; point value is < LONG_MIN or > LONG_MAX.
 (define_insn "*vsx_float_fix_<mode>2"
-  [(set (match_operand:VSX_DF 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_DF 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(float:VSX_DF
 	 (fix:<VSI>
-	  (match_operand:VSX_DF 1 "vsx_register_operand" "<VSr>,?wa"))))]
+	  (match_operand:VSX_DF 1 "vsx_register_operand" "<VSr>,?<VSa>"))))]
   "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
    && VECTOR_UNIT_VSX_P (<MODE>mode) && flag_unsafe_math_optimizations
    && !flag_trapping_math && TARGET_FRIZ"
@@ -1325,10 +1357,10 @@
 
 ;; Build a V2DF/V2DI vector from two scalars
 (define_insn "vsx_concat_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSr>,?wa")
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSr>,?<VSa>")
 	(vec_concat:VSX_D
-	 (match_operand:<VS_scalar> 1 "vsx_register_operand" "ws,wa")
-	 (match_operand:<VS_scalar> 2 "vsx_register_operand" "ws,wa")))]
+	 (match_operand:<VS_scalar> 1 "vsx_register_operand" "<VS_64reg>,<VSa>")
+	 (match_operand:<VS_scalar> 2 "vsx_register_operand" "<VS_64reg>,<VSa>")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
 {
   if (BYTES_BIG_ENDIAN)
@@ -1359,9 +1391,9 @@
 ;; xxpermdi for little endian loads and stores.  We need several of
 ;; these since the form of the PARALLEL differs by mode.
 (define_insn "*vsx_xxpermdi2_le_<mode>"
-  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_LE
-          (match_operand:VSX_LE 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_LE 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 1) (const_int 0)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
   "xxpermdi %x0,%x1,%x1,2"
@@ -1368,9 +1400,9 @@
   [(set_attr "type" "vecperm")])
 
 (define_insn "*vsx_xxpermdi4_le_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_W
-          (match_operand:VSX_W 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_W 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 2) (const_int 3)
                      (const_int 0) (const_int 1)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1408,7 +1440,7 @@
 ;; lxvd2x for little endian loads.  We need several of
 ;; these since the form of the PARALLEL differs by mode.
 (define_insn "*vsx_lxvd2x2_le_<mode>"
-  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_LE 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_LE
           (match_operand:VSX_LE 1 "memory_operand" "Z")
           (parallel [(const_int 1) (const_int 0)])))]
@@ -1417,7 +1449,7 @@
   [(set_attr "type" "vecload")])
 
 (define_insn "*vsx_lxvd2x4_le_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
         (vec_select:VSX_W
           (match_operand:VSX_W 1 "memory_operand" "Z")
           (parallel [(const_int 2) (const_int 3)
@@ -1459,7 +1491,7 @@
 (define_insn "*vsx_stxvd2x2_le_<mode>"
   [(set (match_operand:VSX_LE 0 "memory_operand" "=Z")
         (vec_select:VSX_LE
-          (match_operand:VSX_LE 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_LE 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 1) (const_int 0)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
   "stxvd2x %x1,%y0"
@@ -1468,7 +1500,7 @@
 (define_insn "*vsx_stxvd2x4_le_<mode>"
   [(set (match_operand:VSX_W 0 "memory_operand" "=Z")
         (vec_select:VSX_W
-          (match_operand:VSX_W 1 "vsx_register_operand" "wa")
+          (match_operand:VSX_W 1 "vsx_register_operand" "<VSa>")
           (parallel [(const_int 2) (const_int 3)
                      (const_int 0) (const_int 1)])))]
   "!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1520,11 +1552,12 @@
 
 ;; Set the element of a V2DI/VD2F mode
 (define_insn "vsx_set_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,?wa")
-	(unspec:VSX_D [(match_operand:VSX_D 1 "vsx_register_operand" "wd,wa")
-		       (match_operand:<VS_scalar> 2 "vsx_register_operand" "ws,wa")
-		       (match_operand:QI 3 "u5bit_cint_operand" "i,i")]
-		      UNSPEC_VSX_SET))]
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,?<VSa>")
+	(unspec:VSX_D
+	 [(match_operand:VSX_D 1 "vsx_register_operand" "wd,<VSa>")
+	  (match_operand:<VS_scalar> 2 "vsx_register_operand" "<VS_64reg>,<VSa>")
+	  (match_operand:QI 3 "u5bit_cint_operand" "i,i")]
+	 UNSPEC_VSX_SET))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
 {
   int idx_first = BYTES_BIG_ENDIAN ? 0 : 1;
@@ -1549,11 +1582,11 @@
 ;; Optimize cases were we can do a simple or direct move.
 ;; Or see if we can avoid doing the move at all
 (define_insn "*vsx_extract_<mode>_internal1"
-  [(set (match_operand:<VS_scalar> 0 "register_operand" "=d,ws,?wa,r")
+  [(set (match_operand:<VS_scalar> 0 "register_operand" "=d,<VS_64reg>,r")
 	(vec_select:<VS_scalar>
-	 (match_operand:VSX_D 1 "register_operand" "d,wd,wa,wm")
+	 (match_operand:VSX_D 1 "register_operand" "d,<VS_64reg>,<VS_64dm>")
 	 (parallel
-	  [(match_operand:QI 2 "vsx_scalar_64bit" "wD,wD,wD,wD")])))]
+	  [(match_operand:QI 2 "vsx_scalar_64bit" "wD,wD,wD")])))]
   "VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
 {
   int op0_regno = REGNO (operands[0]);
@@ -1570,14 +1603,14 @@
 
   return "xxlor %x0,%x1,%x1";
 }
-  [(set_attr "type" "fp,vecsimple,vecsimple,mftgpr")
+  [(set_attr "type" "fp,vecsimple,mftgpr")
    (set_attr "length" "4")])
 
 (define_insn "*vsx_extract_<mode>_internal2"
-  [(set (match_operand:<VS_scalar> 0 "vsx_register_operand" "=d,ws,ws,?wa")
+  [(set (match_operand:<VS_scalar> 0 "vsx_register_operand" "=d,<VS_64reg>,<VS_64reg>")
 	(vec_select:<VS_scalar>
-	 (match_operand:VSX_D 1 "vsx_register_operand" "d,wd,wd,wa")
-	 (parallel [(match_operand:QI 2 "u5bit_cint_operand" "wD,wD,i,i")])))]
+	 (match_operand:VSX_D 1 "vsx_register_operand" "d,wd,wd")
+	 (parallel [(match_operand:QI 2 "u5bit_cint_operand" "wD,wD,i")])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)
    && (!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE
        || INTVAL (operands[2]) != VECTOR_ELEMENT_SCALAR_64BIT)"
@@ -1605,7 +1638,7 @@
   operands[3] = GEN_INT (fldDM);
   return "xxpermdi %x0,%x1,%x1,%3";
 }
-  [(set_attr "type" "fp,vecsimple,vecperm,vecperm")
+  [(set_attr "type" "fp,vecsimple,vecperm")
    (set_attr "length" "4")])
 
 ;; Optimize extracting a single scalar element from memory if the scalar is in
@@ -1614,7 +1647,7 @@
   [(set (match_operand:<VS_scalar> 0 "register_operand" "=d,wv,wr")
 	(vec_select:<VS_scalar>
 	 (match_operand:VSX_D 1 "memory_operand" "m,Z,m")
-	 (parallel [(match_operand:QI 2 "vsx_scalar_64bit" "wD,wD,wD")])))]
+	 (parallel [(const_int 0)])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "@
    lfd%U1%X1 %0,%1
@@ -1643,7 +1676,7 @@
 (define_insn "*vsx_extract_<mode>_store"
   [(set (match_operand:<VS_scalar> 0 "memory_operand" "=m,Z,?Z")
 	(vec_select:<VS_scalar>
-	 (match_operand:VSX_D 1 "register_operand" "d,wd,wa")
+	 (match_operand:VSX_D 1 "register_operand" "d,wd,<VSa>")
 	 (parallel [(match_operand:QI 2 "vsx_scalar_64bit" "wD,wD,wD")])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "@
@@ -1666,7 +1699,7 @@
 (define_insn_and_split "vsx_extract_v4sf"
   [(set (match_operand:SF 0 "vsx_register_operand" "=f,f")
 	(vec_select:SF
-	 (match_operand:V4SF 1 "vsx_register_operand" "wa,wa")
+	 (match_operand:V4SF 1 "vsx_register_operand" "<VSa>,<VSa>")
 	 (parallel [(match_operand:QI 2 "u5bit_cint_operand" "O,i")])))
    (clobber (match_scratch:V4SF 3 "=X,0"))]
   "VECTOR_UNIT_VSX_P (V4SFmode)"
@@ -1849,9 +1882,9 @@
 
 ;; V2DF/V2DI splat
 (define_insn "vsx_splat_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,wd,wd,?wa,?wa,?wa")
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,wd,wd,?<VSa>,?<VSa>,?<VSa>")
 	(vec_duplicate:VSX_D
-	 (match_operand:<VS_scalar> 1 "splat_input_operand" "ws,f,Z,wa,wa,Z")))]
+	 (match_operand:<VS_scalar> 1 "splat_input_operand" "<VS_64reg>,f,Z,<VSa>,<VSa>,Z")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
   "@
    xxpermdi %x0,%x1,%x1,0
@@ -1864,10 +1897,10 @@
 
 ;; V4SF/V4SI splat
 (define_insn "vsx_xxspltw_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
 	(vec_duplicate:VSX_W
 	 (vec_select:<VS_scalar>
-	  (match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
+	  (match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
 	  (parallel
 	   [(match_operand:QI 2 "u5bit_cint_operand" "i,i")]))))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1880,8 +1913,8 @@
   [(set_attr "type" "vecperm")])
 
 (define_insn "vsx_xxspltw_<mode>_direct"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
-        (unspec:VSX_W [(match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
+        (unspec:VSX_W [(match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
                        (match_operand:QI 2 "u5bit_cint_operand" "i,i")]
                       UNSPEC_VSX_XXSPLTW))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1890,11 +1923,11 @@
 
 ;; V4SF/V4SI interleave
 (define_insn "vsx_xxmrghw_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
         (vec_select:VSX_W
 	  (vec_concat:<VS_double>
-	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
-	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,wa"))
+	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
+	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,<VSa>"))
 	  (parallel [(const_int 0) (const_int 4)
 		     (const_int 1) (const_int 5)])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1907,11 +1940,11 @@
   [(set_attr "type" "vecperm")])
 
 (define_insn "vsx_xxmrglw_<mode>"
-  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?wa")
+  [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
 	(vec_select:VSX_W
 	  (vec_concat:<VS_double>
-	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,wa")
-	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,?wa"))
+	    (match_operand:VSX_W 1 "vsx_register_operand" "wf,<VSa>")
+	    (match_operand:VSX_W 2 "vsx_register_operand" "wf,?<VSa>"))
 	  (parallel [(const_int 2) (const_int 6)
 		     (const_int 3) (const_int 7)])))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -1925,9 +1958,9 @@
 
 ;; Shift left double by word immediate
 (define_insn "vsx_xxsldwi_<mode>"
-  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=wa")
-	(unspec:VSX_L [(match_operand:VSX_L 1 "vsx_register_operand" "wa")
-		       (match_operand:VSX_L 2 "vsx_register_operand" "wa")
+  [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSa>")
+	(unspec:VSX_L [(match_operand:VSX_L 1 "vsx_register_operand" "<VSa>")
+		       (match_operand:VSX_L 2 "vsx_register_operand" "<VSa>")
 		       (match_operand:QI 3 "u5bit_cint_operand" "i")]
 		      UNSPEC_VSX_SLDWI))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -2008,7 +2041,7 @@
 ;; to the top element of the V2DF array without doing an extract.
 
 (define_insn_and_split "*vsx_reduc_<VEC_reduc_name>_v2df_scalar"
-  [(set (match_operand:DF 0 "vfloat_operand" "=&ws,&?wa,ws,?wa")
+  [(set (match_operand:DF 0 "vfloat_operand" "=&ws,&?ws,ws,?ws")
 	(vec_select:DF
 	 (VEC_reduc:V2DF
 	  (vec_concat:V2DF
Index: gcc/config/rs6000/rs6000.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000.h	(.../branches/gcc-4_9-branch)
@@ -930,35 +930,36 @@
 
    The 3 HTM registers aren't also included in DWARF_FRAME_REGISTERS.  */
 
-#define FIRST_PSEUDO_REGISTER 117
+#define FIRST_PSEUDO_REGISTER 149
 
 /* This must be included for pre gcc 3.0 glibc compatibility.  */
 #define PRE_GCC3_DWARF_FRAME_REGISTERS 77
 
-/* Add 32 dwarf columns for synthetic SPE registers.  */
-#define DWARF_FRAME_REGISTERS ((FIRST_PSEUDO_REGISTER - 4) + 32)
+/* True if register is an SPE High register.  */
+#define SPE_HIGH_REGNO_P(N) \
+  ((N) >= FIRST_SPE_HIGH_REGNO && (N) <= LAST_SPE_HIGH_REGNO)
 
+/* SPE high registers added as hard regs.
+   The sfp register and 3 HTM registers
+   aren't included in DWARF_FRAME_REGISTERS.  */
+#define DWARF_FRAME_REGISTERS (FIRST_PSEUDO_REGISTER - 4)
+
 /* The SPE has an additional 32 synthetic registers, with DWARF debug
    info numbering for these registers starting at 1200.  While eh_frame
    register numbering need not be the same as the debug info numbering,
-   we choose to number these regs for eh_frame at 1200 too.  This allows
-   future versions of the rs6000 backend to add hard registers and
-   continue to use the gcc hard register numbering for eh_frame.  If the
-   extra SPE registers in eh_frame were numbered starting from the
-   current value of FIRST_PSEUDO_REGISTER, then if FIRST_PSEUDO_REGISTER
-   changed we'd need to introduce a mapping in DWARF_FRAME_REGNUM to
-   avoid invalidating older SPE eh_frame info.
+   we choose to number these regs for eh_frame at 1200 too.
 
    We must map them here to avoid huge unwinder tables mostly consisting
    of unused space.  */
 #define DWARF_REG_TO_UNWIND_COLUMN(r) \
-  ((r) > 1200 ? ((r) - 1200 + (DWARF_FRAME_REGISTERS - 32)) : (r))
+  ((r) >= 1200 ? ((r) - 1200 + (DWARF_FRAME_REGISTERS - 32)) : (r))
 
 /* Use standard DWARF numbering for DWARF debugging information.  */
 #define DBX_REGISTER_NUMBER(REGNO) rs6000_dbx_register_number (REGNO)
 
 /* Use gcc hard register numbering for eh_frame.  */
-#define DWARF_FRAME_REGNUM(REGNO) (REGNO)
+#define DWARF_FRAME_REGNUM(REGNO) \
+  (SPE_HIGH_REGNO_P (REGNO) ? ((REGNO) - FIRST_SPE_HIGH_REGNO + 1200) : (REGNO))
 
 /* Map register numbers held in the call frame info that gcc has
    collected using DWARF_FRAME_REGNUM to those that should be output in
@@ -992,7 +993,10 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1						   \
-   , 1, 1, 1, 1, 1, 1				   \
+   , 1, 1, 1, 1, 1, 1,				   \
+   /* SPE High registers.  */			   \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \
 }
 
 /* 1 for registers not available across function calls.
@@ -1012,7 +1016,10 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1						   \
-   , 1, 1, 1, 1, 1, 1				   \
+   , 1, 1, 1, 1, 1, 1,				   \
+   /* SPE High registers.  */			   \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \
 }
 
 /* Like `CALL_USED_REGISTERS' except this macro doesn't require that
@@ -1031,7 +1038,10 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0						   \
-   , 0, 0, 0, 0, 0, 0				   \
+   , 0, 0, 0, 0, 0, 0,				   \
+   /* SPE High registers.  */			   \
+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  \
 }
 
 #define TOTAL_ALTIVEC_REGS	(LAST_ALTIVEC_REGNO - FIRST_ALTIVEC_REGNO + 1)
@@ -1114,7 +1124,10 @@
    96, 95, 94, 93, 92, 91,					\
    108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97,	\
    109, 110,							\
-   111, 112, 113, 114, 115, 116					\
+   111, 112, 113, 114, 115, 116,				\
+   117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,  \
+   129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140,  \
+   141, 142, 143, 144, 145, 146, 147, 148			\
 }
 
 /* True if register is floating-point.  */
@@ -1349,6 +1362,7 @@
   CR_REGS,
   NON_FLOAT_REGS,
   CA_REGS,
+  SPE_HIGH_REGS,
   ALL_REGS,
   LIM_REG_CLASSES
 };
@@ -1380,6 +1394,7 @@
   "CR_REGS",								\
   "NON_FLOAT_REGS",							\
   "CA_REGS",								\
+  "SPE_HIGH_REGS",							\
   "ALL_REGS"								\
 }
 
@@ -1387,30 +1402,54 @@
    This is an initializer for a vector of HARD_REG_SET
    of length N_REG_CLASSES.  */
 
-#define REG_CLASS_CONTENTS						     \
-{									     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS */	     \
-  { 0xfffffffe, 0x00000000, 0x00000008, 0x00020000 }, /* BASE_REGS */	     \
-  { 0xffffffff, 0x00000000, 0x00000008, 0x00020000 }, /* GENERAL_REGS */     \
-  { 0x00000000, 0xffffffff, 0x00000000, 0x00000000 }, /* FLOAT_REGS */       \
-  { 0x00000000, 0x00000000, 0xffffe000, 0x00001fff }, /* ALTIVEC_REGS */     \
-  { 0x00000000, 0xffffffff, 0xffffe000, 0x00001fff }, /* VSX_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00002000 }, /* VRSAVE_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00004000 }, /* VSCR_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00008000 }, /* SPE_ACC_REGS */     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00010000 }, /* SPEFSCR_REGS */     \
-  { 0x00000000, 0x00000000, 0x00000000, 0x00040000 }, /* SPR_REGS */     \
-  { 0xffffffff, 0xffffffff, 0x00000008, 0x00020000 }, /* NON_SPECIAL_REGS */ \
-  { 0x00000000, 0x00000000, 0x00000002, 0x00000000 }, /* LINK_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000004, 0x00000000 }, /* CTR_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000006, 0x00000000 }, /* LINK_OR_CTR_REGS */ \
-  { 0x00000000, 0x00000000, 0x00000006, 0x00002000 }, /* SPECIAL_REGS */     \
-  { 0xffffffff, 0x00000000, 0x0000000e, 0x00022000 }, /* SPEC_OR_GEN_REGS */ \
-  { 0x00000000, 0x00000000, 0x00000010, 0x00000000 }, /* CR0_REGS */	     \
-  { 0x00000000, 0x00000000, 0x00000ff0, 0x00000000 }, /* CR_REGS */	     \
-  { 0xffffffff, 0x00000000, 0x00000ffe, 0x00020000 }, /* NON_FLOAT_REGS */   \
-  { 0x00000000, 0x00000000, 0x00001000, 0x00000000 }, /* CA_REGS */	     \
-  { 0xffffffff, 0xffffffff, 0xfffffffe, 0x0007ffff }  /* ALL_REGS */	     \
+#define REG_CLASS_CONTENTS						\
+{									\
+  /* NO_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },	\
+  /* BASE_REGS.  */							\
+  { 0xfffffffe, 0x00000000, 0x00000008, 0x00020000, 0x00000000 },	\
+  /* GENERAL_REGS.  */							\
+  { 0xffffffff, 0x00000000, 0x00000008, 0x00020000, 0x00000000 },	\
+  /* FLOAT_REGS.  */							\
+  { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },	\
+  /* ALTIVEC_REGS.  */							\
+  { 0x00000000, 0x00000000, 0xffffe000, 0x00001fff, 0x00000000 },	\
+  /* VSX_REGS.  */							\
+  { 0x00000000, 0xffffffff, 0xffffe000, 0x00001fff, 0x00000000 },	\
+  /* VRSAVE_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00002000, 0x00000000 },	\
+  /* VSCR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00004000, 0x00000000 },	\
+  /* SPE_ACC_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00008000, 0x00000000 },	\
+  /* SPEFSCR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000 },	\
+  /* SPR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00040000, 0x00000000 },	\
+  /* NON_SPECIAL_REGS.  */						\
+  { 0xffffffff, 0xffffffff, 0x00000008, 0x00020000, 0x00000000 },	\
+  /* LINK_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000 },	\
+  /* CTR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x00000000 },	\
+  /* LINK_OR_CTR_REGS.  */						\
+  { 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000 },	\
+  /* SPECIAL_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000006, 0x00002000, 0x00000000 },	\
+  /* SPEC_OR_GEN_REGS.  */						\
+  { 0xffffffff, 0x00000000, 0x0000000e, 0x00022000, 0x00000000 },	\
+  /* CR0_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000010, 0x00000000, 0x00000000 },	\
+  /* CR_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000ff0, 0x00000000, 0x00000000 },	\
+  /* NON_FLOAT_REGS.  */						\
+  { 0xffffffff, 0x00000000, 0x00000ffe, 0x00020000, 0x00000000 },	\
+  /* CA_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00001000, 0x00000000, 0x00000000 },	\
+  /* SPE_HIGH_REGS.  */							\
+  { 0x00000000, 0x00000000, 0x00000000, 0xffe00000, 0x001fffff },	\
+  /* ALL_REGS.  */							\
+  { 0xffffffff, 0xffffffff, 0xfffffffe, 0xffe7ffff, 0x001fffff }	\
 }
 
 /* The same information, inverted:
@@ -1439,6 +1478,10 @@
   RS6000_CONSTRAINT_wd,		/* VSX register for V2DF */
   RS6000_CONSTRAINT_wf,		/* VSX register for V4SF */
   RS6000_CONSTRAINT_wg,		/* FPR register for -mmfpgpr */
+  RS6000_CONSTRAINT_wh,		/* FPR register for direct moves.  */
+  RS6000_CONSTRAINT_wi,		/* FPR/VSX register to hold DImode */
+  RS6000_CONSTRAINT_wj,		/* FPR/VSX register for DImode direct moves. */
+  RS6000_CONSTRAINT_wk,		/* FPR/VSX register for DFmode direct moves. */
   RS6000_CONSTRAINT_wl,		/* FPR register for LFIWAX */
   RS6000_CONSTRAINT_wm,		/* VSX register for direct move */
   RS6000_CONSTRAINT_wr,		/* GPR register if 64-bit  */
@@ -1463,6 +1506,9 @@
 #define VSX_REG_CLASS_P(CLASS)			\
   ((CLASS) == VSX_REGS || (CLASS) == FLOAT_REGS || (CLASS) == ALTIVEC_REGS)
 
+/* Return whether a given register class targets general purpose registers.  */
+#define GPR_REG_CLASS_P(CLASS) ((CLASS) == GENERAL_REGS || (CLASS) == BASE_REGS)
+
 /* Given an rtx X being reloaded into a reg required to be
    in class CLASS, return the class of reg to actually use.
    In general this is just CLASS; but on some machines
@@ -2349,6 +2395,39 @@
   &rs6000_reg_names[114][0],	/* tfhar  */				\
   &rs6000_reg_names[115][0],	/* tfiar  */				\
   &rs6000_reg_names[116][0],	/* texasr  */				\
+									\
+  &rs6000_reg_names[117][0],	/* SPE rh0.  */				\
+  &rs6000_reg_names[118][0],	/* SPE rh1.  */				\
+  &rs6000_reg_names[119][0],	/* SPE rh2.  */				\
+  &rs6000_reg_names[120][0],	/* SPE rh3.  */				\
+  &rs6000_reg_names[121][0],	/* SPE rh4.  */				\
+  &rs6000_reg_names[122][0],	/* SPE rh5.  */				\
+  &rs6000_reg_names[123][0],	/* SPE rh6.  */				\
+  &rs6000_reg_names[124][0],	/* SPE rh7.  */				\
+  &rs6000_reg_names[125][0],	/* SPE rh8.  */				\
+  &rs6000_reg_names[126][0],	/* SPE rh9.  */				\
+  &rs6000_reg_names[127][0],	/* SPE rh10.  */			\
+  &rs6000_reg_names[128][0],	/* SPE rh11.  */			\
+  &rs6000_reg_names[129][0],	/* SPE rh12.  */			\
+  &rs6000_reg_names[130][0],	/* SPE rh13.  */			\
+  &rs6000_reg_names[131][0],	/* SPE rh14.  */			\
+  &rs6000_reg_names[132][0],	/* SPE rh15.  */			\
+  &rs6000_reg_names[133][0],	/* SPE rh16.  */			\
+  &rs6000_reg_names[134][0],	/* SPE rh17.  */			\
+  &rs6000_reg_names[135][0],	/* SPE rh18.  */			\
+  &rs6000_reg_names[136][0],	/* SPE rh19.  */			\
+  &rs6000_reg_names[137][0],	/* SPE rh20.  */			\
+  &rs6000_reg_names[138][0],	/* SPE rh21.  */			\
+  &rs6000_reg_names[139][0],	/* SPE rh22.  */			\
+  &rs6000_reg_names[140][0],	/* SPE rh22.  */			\
+  &rs6000_reg_names[141][0],	/* SPE rh24.  */			\
+  &rs6000_reg_names[142][0],	/* SPE rh25.  */			\
+  &rs6000_reg_names[143][0],	/* SPE rh26.  */			\
+  &rs6000_reg_names[144][0],	/* SPE rh27.  */			\
+  &rs6000_reg_names[145][0],	/* SPE rh28.  */			\
+  &rs6000_reg_names[146][0],	/* SPE rh29.  */			\
+  &rs6000_reg_names[147][0],	/* SPE rh30.  */			\
+  &rs6000_reg_names[148][0],	/* SPE rh31.  */			\
 }
 
 /* Table of additional register names to use in user input.  */
@@ -2404,7 +2483,17 @@
   {"vs56", 101},{"vs57", 102},{"vs58", 103},{"vs59", 104},      \
   {"vs60", 105},{"vs61", 106},{"vs62", 107},{"vs63", 108},	\
   /* Transactional Memory Facility (HTM) Registers.  */		\
-  {"tfhar",  114}, {"tfiar",  115}, {"texasr",  116} }
+  {"tfhar",  114}, {"tfiar",  115}, {"texasr",  116},		\
+  /* SPE high registers.  */					\
+  {"rh0",  117}, {"rh1",  118}, {"rh2",  119}, {"rh3",  120},	\
+  {"rh4",  121}, {"rh5",  122}, {"rh6",  123}, {"rh7",  124},	\
+  {"rh8",  125}, {"rh9",  126}, {"rh10", 127}, {"rh11", 128},	\
+  {"rh12", 129}, {"rh13", 130}, {"rh14", 131}, {"rh15", 132},	\
+  {"rh16", 133}, {"rh17", 134}, {"rh18", 135}, {"rh19", 136},	\
+  {"rh20", 137}, {"rh21", 138}, {"rh22", 139}, {"rh23", 140},	\
+  {"rh24", 141}, {"rh25", 142}, {"rh26", 143}, {"rh27", 144},	\
+  {"rh28", 145}, {"rh29", 146}, {"rh30", 147}, {"rh31", 148},	\
+}
 
 /* This is how to output an element of a case-vector that is relative.  */
 
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_9-branch)
@@ -56,6 +56,8 @@
    (TFHAR_REGNO			114)
    (TFIAR_REGNO			115)
    (TEXASR_REGNO		116)
+   (FIRST_SPE_HIGH_REGNO	117)
+   (LAST_SPE_HIGH_REGNO		148)
   ])
 
 ;;
@@ -135,6 +137,7 @@
    UNSPEC_UNPACK_128BIT
    UNSPEC_PACK_128BIT
    UNSPEC_LSQ
+   UNSPEC_FUSION_GPR
   ])
 
 ;;
@@ -326,8 +329,25 @@
 (define_mode_attr f32_sv [(SF "stxsspx %x1,%y0")  (SD "stxsiwzx %x1,%y0")])
 
 ; Definitions for 32-bit fpr direct move
-(define_mode_attr f32_dm [(SF "wn") (SD "wm")])
+; At present, the decimal modes are not allowed in the traditional altivec
+; registers, so restrict the constraints to just the traditional FPRs.
+(define_mode_attr f32_dm [(SF "wn") (SD "wh")])
 
+; Definitions for 32-bit VSX
+(define_mode_attr f32_vsx [(SF "ww") (SD "wn")])
+
+; Definitions for 32-bit use of altivec registers
+(define_mode_attr f32_av  [(SF "wu") (SD "wn")])
+
+; Definitions for 64-bit VSX
+(define_mode_attr f64_vsx [(DF "ws") (DD "wn")])
+
+; Definitions for 64-bit direct move
+(define_mode_attr f64_dm  [(DF "wk") (DD "wh")])
+
+; Definitions for 64-bit use of altivec registers
+(define_mode_attr f64_av  [(DF "wv") (DD "wn")])
+
 ; These modes do not fit in integer registers in 32-bit mode.
 ; but on e500v2, the gpr are 64 bit registers
 (define_mode_iterator DIFD [DI (DF "!TARGET_E500_DOUBLE") DD])
@@ -433,7 +453,7 @@
 ;; either.
 
 ;; Mode attribute for boolean operation register constraints for output
-(define_mode_attr BOOL_REGS_OUTPUT	[(TI	"&r,r,r,wa,v")
+(define_mode_attr BOOL_REGS_OUTPUT	[(TI	"&r,r,r,wt,v")
 					 (PTI	"&r,r,r")
 					 (V16QI	"wa,v,&?r,?r,?r")
 					 (V8HI	"wa,v,&?r,?r,?r")
@@ -444,7 +464,7 @@
 					 (V1TI	"wa,v,&?r,?r,?r")])
 
 ;; Mode attribute for boolean operation register constraints for operand1
-(define_mode_attr BOOL_REGS_OP1		[(TI	"r,0,r,wa,v")
+(define_mode_attr BOOL_REGS_OP1		[(TI	"r,0,r,wt,v")
 					 (PTI	"r,0,r")
 					 (V16QI	"wa,v,r,0,r")
 					 (V8HI	"wa,v,r,0,r")
@@ -455,7 +475,7 @@
 					 (V1TI	"wa,v,r,0,r")])
 
 ;; Mode attribute for boolean operation register constraints for operand2
-(define_mode_attr BOOL_REGS_OP2		[(TI	"r,r,0,wa,v")
+(define_mode_attr BOOL_REGS_OP2		[(TI	"r,r,0,wt,v")
 					 (PTI	"r,r,0")
 					 (V16QI	"wa,v,r,r,0")
 					 (V8HI	"wa,v,r,r,0")
@@ -468,7 +488,7 @@
 ;; Mode attribute for boolean operation register constraints for operand1
 ;; for one_cmpl.  To simplify things, we repeat the constraint where 0
 ;; is used for operand1 or operand2
-(define_mode_attr BOOL_REGS_UNARY	[(TI	"r,0,0,wa,v")
+(define_mode_attr BOOL_REGS_UNARY	[(TI	"r,0,0,wt,v")
 					 (PTI	"r,0,0")
 					 (V16QI	"wa,v,r,0,0")
 					 (V8HI	"wa,v,r,0,0")
@@ -575,7 +595,7 @@
   "")
 
 (define_insn "*zero_extendsidi2_lfiwzx"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wm,!wz,!wu")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wj,!wz,!wu")
 	(zero_extend:DI (match_operand:SI 1 "reg_or_mem_operand" "m,r,r,Z,Z")))]
   "TARGET_POWERPC64 && TARGET_LFIWZX"
   "@
@@ -745,7 +765,7 @@
   "")
 
 (define_insn "*extendsidi2_lfiwax"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wm,!wl,!wu")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,??wj,!wl,!wu")
 	(sign_extend:DI (match_operand:SI 1 "lwa_operand" "Y,r,r,Z,Z")))]
   "TARGET_POWERPC64 && TARGET_LFIWAX"
   "@
@@ -5623,7 +5643,7 @@
 ; We don't define lfiwax/lfiwzx with the normal definition, because we
 ; don't want to support putting SImode in FPR registers.
 (define_insn "lfiwax"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wm,!wm")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wj,!wj")
 	(unspec:DI [(match_operand:SI 1 "reg_or_indexed_operand" "Z,Z,r")]
 		   UNSPEC_LFIWAX))]
   "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX"
@@ -5703,7 +5723,7 @@
    (set_attr "type" "fpload")])
 
 (define_insn "lfiwzx"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wm,!wm")
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=d,wj,!wj")
 	(unspec:DI [(match_operand:SI 1 "reg_or_indexed_operand" "Z,Z,r")]
 		   UNSPEC_LFIWZX))]
   "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX"
@@ -9186,8 +9206,8 @@
 }")
 
 (define_insn "mov<mode>_hardfloat"
-  [(set (match_operand:FMOVE32 0 "nonimmediate_operand" "=!r,!r,m,f,wa,wa,<f32_lr>,<f32_sm>,wu,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r")
-	(match_operand:FMOVE32 1 "input_operand" "r,m,r,f,wa,j,<f32_lm>,<f32_sr>,Z,wu,r,<f32_dm>,r,h,0,G,Fn"))]
+  [(set (match_operand:FMOVE32 0 "nonimmediate_operand" "=!r,!r,m,f,<f32_vsx>,<f32_vsx>,<f32_lr>,<f32_sm>,<f32_av>,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r")
+	(match_operand:FMOVE32 1 "input_operand" "r,m,r,f,<f32_vsx>,j,<f32_lm>,<f32_sr>,Z,<f32_av>,r,<f32_dm>,r, h, 0, G,Fn"))]
   "(gpc_reg_operand (operands[0], <MODE>mode)
    || gpc_reg_operand (operands[1], <MODE>mode))
    && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)"
@@ -9388,8 +9408,8 @@
 ;; reloading.
 
 (define_insn "*mov<mode>_hardfloat32"
-  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,wv,Z,wa,wa,Y,r,!r,!r,!r,!r")
-	(match_operand:FMOVE64 1 "input_operand" "d,m,d,Z,wv,wa,j,r,Y,r,G,H,F"))]
+  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,Y,r,!r,!r,!r,!r")
+	(match_operand:FMOVE64 1 "input_operand" "d,m,d,Z,<f64_av>,<f64_vsx>,j,r,Y,r,G,H,F"))]
   "! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT 
    && (gpc_reg_operand (operands[0], <MODE>mode)
        || gpc_reg_operand (operands[1], <MODE>mode))"
@@ -9457,8 +9477,8 @@
 ; ld/std require word-aligned displacements -> 'Y' constraint.
 ; List Y->r and r->Y before r->r for reload.
 (define_insn "*mov<mode>_hardfloat64"
-  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,wv,Z,wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wm")
-	(match_operand:FMOVE64 1 "input_operand" "d,m,d,Z,wv,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wm,r"))]
+  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,<f64_dm>")
+	(match_operand:FMOVE64 1 "input_operand" "d,m,d,Z,<f64_av>,<f64_vsx>,j,r,Y,r,r,h,0,G,H,F,wg,r,<f64_dm>,r"))]
   "TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
    && (gpc_reg_operand (operands[0], <MODE>mode)
        || gpc_reg_operand (operands[1], <MODE>mode))"
@@ -10237,8 +10257,8 @@
 { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })
 
 (define_insn "*movdi_internal64"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*wg,r,?*wm")
-	(match_operand:DI 1 "input_operand" "r,Y,r,I,L,nF,d,m,d,*h,r,0,*wg,r,*wm,r"))]
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*wg,r,?*wj,?*wi")
+	(match_operand:DI 1 "input_operand" "r,Y,r,I,L,nF,d,m,d,*h,r,0,*wg,r,*wj,r,O"))]
   "TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
        || gpc_reg_operand (operands[1], DImode))"
@@ -10258,7 +10278,8 @@
    mftgpr %0,%1
    mffgpr %0,%1
    mfvsrd %0,%x1
-   mtvsrd %x0,%1"
+   mtvsrd %x0,%1
+   xxlxor %x0,%x0,%x0"
   [(set_attr_alternative "type"
       [(if_then_else
 	 (match_test "update_indexed_address_mem (operands[0], VOIDmode)")
@@ -10299,8 +10320,9 @@
        (const_string "mftgpr")
        (const_string "mffgpr")
        (const_string "mftgpr")
-       (const_string "mffgpr")])
-   (set_attr "length" "4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4")])
+       (const_string "mffgpr")
+       (const_string "vecsimple")])
+   (set_attr "length" "4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4")])
 
 ;; Generate all one-bits and clear left or right.
 ;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.
@@ -15710,23 +15732,10 @@
 ;; a GPR.  The addis instruction must be adjacent to the load, and use the same
 ;; register that is being loaded.  The fused ops must be physically adjacent.
 
-;; We use define_peephole for the actual addis/load, and the register used to
-;; hold the addis value must be the same as the register being loaded.  We use
-;; define_peephole2 to change the register used for addis to be the register
-;; being loaded, since we can look at whether it is dead after the load insn.
+;; Find cases where the addis that feeds into a load instruction is either used
+;; once or is the same as the target register, and replace it with the fusion
+;; insn
 
-(define_peephole
-  [(set (match_operand:P 0 "base_reg_operand" "")
-	(match_operand:P 1 "fusion_gpr_addis" ""))
-   (set (match_operand:INT1 2 "base_reg_operand" "")
-	(match_operand:INT1 3 "fusion_gpr_mem_load" ""))]
-  "TARGET_P8_FUSION && fusion_gpr_load_p (operands, false)"
-{
-  return emit_fusion_gpr_load (operands);
-}
-  [(set_attr "type" "load")
-   (set_attr "length" "8")])
-
 (define_peephole2
   [(set (match_operand:P 0 "base_reg_operand" "")
 	(match_operand:P 1 "fusion_gpr_addis" ""))
@@ -15733,9 +15742,8 @@
    (set (match_operand:INT1 2 "base_reg_operand" "")
 	(match_operand:INT1 3 "fusion_gpr_mem_load" ""))]
   "TARGET_P8_FUSION
-   && (REGNO (operands[0]) != REGNO (operands[2])
-       || GET_CODE (operands[3]) == SIGN_EXTEND)
-   && fusion_gpr_load_p (operands, true)"
+   && fusion_gpr_load_p (operands[0], operands[1], operands[2],
+			 operands[3])"
   [(const_int 0)]
 {
   expand_fusion_gpr_load (operands);
@@ -15742,6 +15750,20 @@
   DONE;
 })
 
+;; Fusion insn, created by the define_peephole2 above (and eventually by
+;; reload)
+
+(define_insn "fusion_gpr_load_<mode>"
+  [(set (match_operand:INT1 0 "base_reg_operand" "=&b")
+	(unspec:INT1 [(match_operand:INT1 1 "fusion_gpr_mem_combo" "")]
+		     UNSPEC_FUSION_GPR))]
+  "TARGET_P8_FUSION"
+{
+  return emit_fusion_gpr_load (operands[0], operands[1]);
+}
+  [(set_attr "type" "load")
+   (set_attr "length" "8")])
+
 
 ;; Miscellaneous ISA 2.06 (power7) instructions
 (define_insn "addg6s"
Index: gcc/config/rs6000/sysv4.h
===================================================================
--- a/src/gcc/config/rs6000/sysv4.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/rs6000/sysv4.h	(.../branches/gcc-4_9-branch)
@@ -292,7 +292,7 @@
 /* An expression for the alignment of a structure field FIELD if the
    alignment computed in the usual way is COMPUTED.  */
 #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED)				      \
-	((TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)     \
+	(rs6000_special_adjust_field_align_p ((FIELD), (COMPUTED))	      \
 	 ? 128 : COMPUTED)
 
 #undef  BIGGEST_FIELD_ALIGNMENT
@@ -949,3 +949,19 @@
 #define TARGET_USES_SYSV4_OPT 1
 
 #undef DBX_REGISTER_NUMBER
+
+/* Link -lasan early on the command line.  For -static-libasan, don't link
+   it for -shared link, the executable should be compiled with -static-libasan
+   in that case, and for executable link link with --{,no-}whole-archive around
+   it to force everything into the executable.  And similarly for -ltsan.  */
+#if defined(HAVE_LD_STATIC_DYNAMIC)
+#undef LIBASAN_EARLY_SPEC
+#define LIBASAN_EARLY_SPEC "%{!shared:libasan_preinit%O%s} " \
+  "%{static-libasan:%{!shared:" \
+  LD_STATIC_OPTION " --whole-archive -lasan --no-whole-archive " \
+  LD_DYNAMIC_OPTION "}}%{!static-libasan:-lasan}"
+#undef LIBTSAN_EARLY_SPEC
+#define LIBTSAN_EARLY_SPEC "%{static-libtsan:%{!shared:" \
+  LD_STATIC_OPTION " --whole-archive -ltsan --no-whole-archive " \
+  LD_DYNAMIC_OPTION "}}%{!static-libtsan:-ltsan}"
+#endif
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,6 @@
 static reg_class_t arm_preferred_reload_class (rtx, reg_class_t);
 static rtx thumb_legitimize_address (rtx, rtx, enum machine_mode);
 inline static int thumb1_index_register_rtx_p (rtx, int);
-static bool arm_legitimate_address_p (enum machine_mode, rtx, bool);
 static int thumb_far_jump_used_p (void);
 static bool thumb_force_lr_save (void);
 static unsigned arm_size_return_regs (void);
@@ -31167,4 +31166,13 @@
   return false;
 }
 
+/* return TRUE if x is a reference to a value in a constant pool */
+extern bool
+arm_is_constant_pool_ref (rtx x)
+{
+  return (MEM_P (x)
+	  && GET_CODE (XEXP (x, 0)) == SYMBOL_REF
+	  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)));
+}
+
 #include "gt-arm.h"
Index: gcc/config/arm/arm-protos.h
===================================================================
--- a/src/gcc/config/arm/arm-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/arm-protos.h	(.../branches/gcc-4_9-branch)
@@ -56,6 +56,7 @@
 extern int legitimate_pic_operand_p (rtx);
 extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);
 extern rtx legitimize_tls_address (rtx, rtx);
+extern bool arm_legitimate_address_p (enum machine_mode, rtx, bool);
 extern int arm_legitimate_address_outer_p (enum machine_mode, rtx, RTX_CODE, int);
 extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);
 extern bool arm_legitimize_reload_address (rtx *, enum machine_mode, int, int,
@@ -294,4 +295,6 @@
 /* Defined in gcc/common/config/arm-common.c.  */
 extern const char *arm_rewrite_selected_cpu (const char *name);
 
+extern bool arm_is_constant_pool_ref (rtx);
+
 #endif /* ! GCC_ARM_PROTOS_H */
Index: gcc/config/arm/vfp.md
===================================================================
--- a/src/gcc/config/arm/vfp.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/vfp.md	(.../branches/gcc-4_9-branch)
@@ -1254,17 +1254,15 @@
 )
 
 (define_insn "*combine_vcvtf2i"
-  [(set (match_operand:SI 0 "s_register_operand" "=r")
-	(fix:SI (fix:SF (mult:SF (match_operand:SF 1 "s_register_operand" "t")
+  [(set (match_operand:SI 0 "s_register_operand" "=t")
+	(fix:SI (fix:SF (mult:SF (match_operand:SF 1 "s_register_operand" "0")
 				 (match_operand 2
 				 "const_double_vcvt_power_of_two" "Dp")))))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP3 && !flag_rounding_math"
-  "vcvt%?.s32.f32\\t%1, %1, %v2\;vmov%?\\t%0, %1"
+  "vcvt%?.s32.f32\\t%0, %1, %v2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
-   (set_attr "ce_count" "2")
-   (set_attr "type" "f_cvtf2i")
-   (set_attr "length" "8")]
+   (set_attr "type" "f_cvtf2i")]
  )
 
 ;; Store multiple insn used in function prologue.
Index: gcc/config/arm/constraints.md
===================================================================
--- a/src/gcc/config/arm/constraints.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/constraints.md	(.../branches/gcc-4_9-branch)
@@ -36,7 +36,7 @@
 ;; in Thumb-2 state: Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py
 
 ;; The following memory constraints have been used:
-;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Um, Us
+;; in ARM/Thumb-2 state: Q, Uh, Ut, Uv, Uy, Un, Um, Us
 ;; in ARM state: Uq
 ;; in Thumb state: Uu, Uw
 
@@ -348,6 +348,12 @@
   An address valid for loading/storing register exclusive"
  (match_operand 0 "mem_noofs_operand"))
 
+(define_memory_constraint "Uh"
+ "@internal
+  An address suitable for byte and half-word loads which does not point inside a constant pool"
+ (and (match_code "mem")
+      (match_test "arm_legitimate_address_p (GET_MODE (op), XEXP (op, 0), false) && !arm_is_constant_pool_ref (op)")))
+
 (define_memory_constraint "Ut"
  "@internal
   In ARM/Thumb-2 state an address valid for loading/storing opaque structure
@@ -394,7 +400,8 @@
  (and (match_code "mem")
       (match_test "TARGET_ARM
 		   && arm_legitimate_address_outer_p (GET_MODE (op), XEXP (op, 0),
-						      SIGN_EXTEND, 0)")))
+						      SIGN_EXTEND, 0)
+		   && !arm_is_constant_pool_ref (op)")))
 
 (define_memory_constraint "Q"
  "@internal
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-4_9-branch)
@@ -3629,7 +3629,7 @@
 	 [(match_operand:SI 1 "s_register_operand" "r")
 	  (match_operand:SI 2 "s_register_operand" "r")]))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_32BIT && optimize_function_for_size_p (cfun)"
+  "TARGET_32BIT && optimize_function_for_size_p (cfun) && !arm_restrict_it"
   "*
   operands[3] = gen_rtx_fmt_ee (minmax_code (operands[3]), SImode,
 				operands[1], operands[2]);
@@ -4372,7 +4372,7 @@
 (define_insn "unaligned_loadhis"
   [(set (match_operand:SI 0 "s_register_operand" "=l,r")
 	(sign_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,m")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access && TARGET_32BIT"
   "ldr%(sh%)\t%0, %1\t@ unaligned"
@@ -5285,7 +5285,7 @@
 
 (define_insn "*arm_zero_extendhisi2_v6"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
-	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,Uh")))]
   "TARGET_ARM && arm_arch6"
   "@
    uxth%?\\t%0, %1
@@ -5379,7 +5379,7 @@
 
 (define_insn "*arm_zero_extendqisi2_v6"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
-	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,Uh")))]
   "TARGET_ARM && arm_arch6"
   "@
    uxtb%(%)\\t%0, %1
@@ -5613,7 +5613,7 @@
 
 (define_insn "*arm_extendhisi2"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
-	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,Uh")))]
   "TARGET_ARM && arm_arch4 && !arm_arch6"
   "@
    #
@@ -5620,15 +5620,13 @@
    ldr%(sh%)\\t%0, %1"
   [(set_attr "length" "8,4")
    (set_attr "type" "alu_shift_reg,load_byte")
-   (set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,256")
-   (set_attr "neg_pool_range" "*,244")]
+   (set_attr "predicable" "yes")]
 )
 
 ;; ??? Check Thumb-2 pool range
 (define_insn "*arm_extendhisi2_v6"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
-	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,Uh")))]
   "TARGET_32BIT && arm_arch6"
   "@
    sxth%?\\t%0, %1
@@ -5635,9 +5633,7 @@
    ldr%(sh%)\\t%0, %1"
   [(set_attr "type" "extend,load_byte")
    (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "no")
-   (set_attr "pool_range" "*,256")
-   (set_attr "neg_pool_range" "*,244")]
+   (set_attr "predicable_short_it" "no")]
 )
 
 (define_insn "*arm_extendhisi2addsi"
@@ -5680,9 +5676,7 @@
   "TARGET_ARM && arm_arch4"
   "ldr%(sb%)\\t%0, %1"
   [(set_attr "type" "load_byte")
-   (set_attr "predicable" "yes")
-   (set_attr "pool_range" "256")
-   (set_attr "neg_pool_range" "244")]
+   (set_attr "predicable" "yes")]
 )
 
 (define_expand "extendqisi2"
@@ -5722,9 +5716,7 @@
    ldr%(sb%)\\t%0, %1"
   [(set_attr "length" "8,4")
    (set_attr "type" "alu_shift_reg,load_byte")
-   (set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,256")
-   (set_attr "neg_pool_range" "*,244")]
+   (set_attr "predicable" "yes")]
 )
 
 (define_insn "*arm_extendqisi_v6"
@@ -5736,9 +5728,7 @@
    sxtb%?\\t%0, %1
    ldr%(sb%)\\t%0, %1"
   [(set_attr "type" "extend,load_byte")
-   (set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,256")
-   (set_attr "neg_pool_range" "*,244")]
+   (set_attr "predicable" "yes")]
 )
 
 (define_insn "*arm_extendqisi2addsi"
@@ -10942,10 +10932,16 @@
     enum machine_mode mode = SELECT_CC_MODE (GET_CODE (operands[5]),
 					     operands[3], operands[4]);
     enum rtx_code rc = GET_CODE (operands[5]);
-
     operands[6] = gen_rtx_REG (mode, CC_REGNUM);
     gcc_assert (!(mode == CCFPmode || mode == CCFPEmode));
-    rc = reverse_condition (rc);
+    if (REGNO (operands[2]) != REGNO (operands[0]))
+      rc = reverse_condition (rc);
+    else 
+      {
+	rtx tmp = operands[1];
+	operands[1] = operands[2];
+	operands[2] = tmp;
+      }
 
     operands[6] = gen_rtx_fmt_ee (rc, VOIDmode, operands[6], const0_rtx);
   }
Index: gcc/config/arm/t-rtems-eabi
===================================================================
--- a/src/gcc/config/arm/t-rtems-eabi	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/arm/t-rtems-eabi	(.../branches/gcc-4_9-branch)
@@ -1,47 +1,167 @@
 # Custom RTEMS EABI multilibs
 
-MULTILIB_OPTIONS  = mthumb march=armv6-m/march=armv7-a/march=armv7-r/march=armv7-m mfpu=neon mfloat-abi=hard
-MULTILIB_DIRNAMES = thumb armv6-m armv7-a armv7-r armv7-m neon hard
+MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/march=armv7-m mfpu=neon/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16 mfloat-abi=hard
+MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r armv7-m neon vfpv3-d16 fpv4-sp-d16 hard
 
 # Enumeration of multilibs
 
 MULTILIB_EXCEPTIONS =
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv6-m
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-a
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=neon
+# MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r/mfloat-abi=hard
+# MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-r
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/march=armv7-m
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mthumb
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv6-m
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-a
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-r
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/march=armv7-m
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=neon/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=neon
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian/mfpu=fpv4-sp-d16
+MULTILIB_EXCEPTIONS += mbig-endian/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mbig-endian
 MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv6-m/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv6-m
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-a/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-a
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=neon
+# MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-r/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-r
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=vfpv3-d16
+# MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/march=armv7-m/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb/march=armv7-m
 MULTILIB_EXCEPTIONS += mthumb/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mthumb/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mthumb/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mthumb/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mthumb/mfloat-abi=hard
 # MULTILIB_EXCEPTIONS += mthumb
 MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv6-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv6-m/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv6-m
 MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-a/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv7-a/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-a
 MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-r/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv7-r/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-r
 MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=neon
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += march=armv7-m/mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += march=armv7-m/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += march=armv7-m
 MULTILIB_EXCEPTIONS += mfpu=neon/mfloat-abi=hard
 MULTILIB_EXCEPTIONS += mfpu=neon
+MULTILIB_EXCEPTIONS += mfpu=vfpv3-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mfpu=vfpv3-d16
+MULTILIB_EXCEPTIONS += mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_EXCEPTIONS += mfpu=fpv4-sp-d16
 MULTILIB_EXCEPTIONS += mfloat-abi=hard
Index: gcc/config/darwin-driver.c
===================================================================
--- a/src/gcc/config/darwin-driver.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/darwin-driver.c	(.../branches/gcc-4_9-branch)
@@ -29,8 +29,8 @@
 #include <sys/sysctl.h>
 #include "xregex.h"
 
-static bool
-darwin_find_version_from_kernel (char *new_flag)
+static char *
+darwin_find_version_from_kernel (void)
 {
   char osversion[32];
   size_t osversion_len = sizeof (osversion) - 1;
@@ -39,6 +39,7 @@
   char minor_vers[6];
   char * version_p;
   char * version_pend;
+  char * new_flag;
 
   /* Determine the version of the running OS.  If we can't, warn user,
      and do nothing.  */
@@ -46,7 +47,7 @@
 	      &osversion_len, NULL, 0) == -1)
     {
       warning (0, "sysctl for kern.osversion failed: %m");
-      return false;
+      return NULL;
     }
 
   /* Try to parse the first two parts of the OS version number.  Warn
@@ -57,8 +58,6 @@
   version_p = osversion + 1;
   if (ISDIGIT (*version_p))
     major_vers = major_vers * 10 + (*version_p++ - '0');
-  if (major_vers > 4 + 9)
-    goto parse_failed;
   if (*version_p++ != '.')
     goto parse_failed;
   version_pend = strchr(version_p, '.');
@@ -74,17 +73,16 @@
   if (major_vers - 4 <= 4)
     /* On 10.4 and earlier, the old linker is used which does not
        support three-component system versions.  */
-    sprintf (new_flag, "10.%d", major_vers - 4);
+    asprintf (&new_flag, "10.%d", major_vers - 4);
   else
-    sprintf (new_flag, "10.%d.%s", major_vers - 4,
-	     minor_vers);
+    asprintf (&new_flag, "10.%d.%s", major_vers - 4, minor_vers);
 
-  return true;
+  return new_flag;
 
  parse_failed:
   warning (0, "couldn%'t understand kern.osversion %q.*s",
 	   (int) osversion_len, osversion);
-  return false;
+  return NULL;
 }
 
 #endif
@@ -105,7 +103,7 @@
   const unsigned int argc = *decoded_options_count;
   struct cl_decoded_option *const argv = *decoded_options;
   unsigned int i;
-  static char new_flag[sizeof ("10.0.0") + 6];
+  const char *new_flag;
 
   /* If the command-line is empty, just return.  */
   if (argc <= 1)
@@ -142,17 +140,17 @@
 
 #ifndef CROSS_DIRECTORY_STRUCTURE
 
- /* Try to find the version from the kernel, if we fail - we print a message 
-    and give up.  */
- if (!darwin_find_version_from_kernel (new_flag))
-   return;
+  /* Try to find the version from the kernel, if we fail - we print a message 
+     and give up.  */
+  new_flag = darwin_find_version_from_kernel ();
+  if (!new_flag)
+    return;
 
 #else
 
- /* For cross-compilers, default to the target OS version. */
+  /* For cross-compilers, default to the target OS version. */
+  new_flag = DEF_MIN_OSX_VERSION;
 
- strncpy (new_flag, DEF_MIN_OSX_VERSION, sizeof (new_flag));
-
 #endif /* CROSS_DIRECTORY_STRUCTURE */
 
   /* Add the new flag.  */
@@ -165,7 +163,6 @@
   memcpy (*decoded_options + 2, argv + 1,
 	  (argc - 1) * sizeof (struct cl_decoded_option));
   return;
-  
 }
 
 /* Translate -filelist and -framework options in *DECODED_OPTIONS
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-4_9-branch)
@@ -8508,36 +8508,6 @@
   [(set_attr "type" "move")
    (set_attr "length" "4")])
 
-;; These are just placeholders so we know where branch tables
-;; begin and end.
-(define_insn "begin_brtab"
-  [(const_int 1)]
-  ""
-  "*
-{
-  /* Only GAS actually supports this pseudo-op.  */
-  if (TARGET_GAS)
-    return \".begin_brtab\";
-  else
-    return \"\";
-}"
-  [(set_attr "type" "move")
-   (set_attr "length" "0")])
-
-(define_insn "end_brtab"
-  [(const_int 2)]
-  ""
-  "*
-{
-  /* Only GAS actually supports this pseudo-op.  */
-  if (TARGET_GAS)
-    return \".end_brtab\";
-  else
-    return \"\";
-}"
-  [(set_attr "type" "move")
-   (set_attr "length" "0")])
-
 ;;; EH does longjmp's from and within the data section.  Thus,
 ;;; an interspace branch is required for the longjmp implementation.
 ;;; Registers r1 and r2 are used as scratch registers for the jump
Index: gcc/config/pa/pa-protos.h
===================================================================
--- a/src/gcc/config/pa/pa-protos.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa-protos.h	(.../branches/gcc-4_9-branch)
@@ -49,6 +49,8 @@
 extern const char *pa_output_div_insn (rtx *, int, rtx);
 extern const char *pa_output_mod_insn (int, rtx);
 extern const char *pa_singlemove_string (rtx *);
+extern void pa_output_addr_vec (rtx, rtx);
+extern void pa_output_addr_diff_vec (rtx, rtx);
 extern void pa_output_arg_descriptor (rtx);
 extern void pa_output_global_address (FILE *, rtx, int);
 extern void pa_print_operand (FILE *, rtx, int);
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-4_9-branch)
@@ -3235,7 +3235,12 @@
       && aligned_p
       && function_label_operand (x, VOIDmode))
     {
-      fputs (size == 8? "\t.dword\tP%" : "\t.word\tP%", asm_out_file);
+      fputs (size == 8? "\t.dword\t" : "\t.word\t", asm_out_file);
+
+      /* We don't want an OPD when generating fast indirect calls.  */
+      if (!TARGET_FAST_INDIRECT_CALLS)
+	fputs ("P%", asm_out_file);
+
       output_addr_const (asm_out_file, x);
       fputc ('\n', asm_out_file);
       return true;
@@ -4155,9 +4160,8 @@
 pa_output_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)
 {
   rtx insn = get_last_insn ();
+  bool extra_nop;
 
-  last_address = 0;
-
   /* pa_expand_epilogue does the dirty work now.  We just need
      to output the assembler directives which denote the end
      of a function.
@@ -4180,8 +4184,10 @@
   if (insn && CALL_P (insn))
     {
       fputs ("\tnop\n", file);
-      last_address += 4;
+      extra_nop = true;
     }
+  else
+    extra_nop = false;
 
   fputs ("\t.EXIT\n\t.PROCEND\n", file);
 
@@ -4194,16 +4200,20 @@
       cfun->machine->in_nsubspa = 2;
     }
 
-  /* Thunks do their own accounting.  */
+  /* Thunks do their own insn accounting.  */
   if (cfun->is_thunk)
     return;
 
   if (INSN_ADDRESSES_SET_P ())
     {
+      last_address = extra_nop ? 4 : 0;
       insn = get_last_nonnote_insn ();
-      last_address += INSN_ADDRESSES (INSN_UID (insn));
-      if (INSN_P (insn))
-	last_address += insn_default_length (insn);
+      if (insn)
+	{
+	  last_address += INSN_ADDRESSES (INSN_UID (insn));
+	  if (INSN_P (insn))
+	    last_address += insn_default_length (insn);
+	}
       last_address = ((last_address + FUNCTION_BOUNDARY / BITS_PER_UNIT - 1)
 		      & ~(FUNCTION_BOUNDARY / BITS_PER_UNIT - 1));
     }
@@ -8293,12 +8303,16 @@
 		   || ((DECL_SECTION_NAME (thunk_fndecl)
 			== DECL_SECTION_NAME (function))
 		       && last_address < 262132)))
+	      /* In this case, we need to be able to reach the start of
+		 the stub table even though the function is likely closer
+		 and can be jumped to directly.  */
 	      || (targetm_common.have_named_sections
 		  && DECL_SECTION_NAME (thunk_fndecl) == NULL
 		  && DECL_SECTION_NAME (function) == NULL
-		  && last_address < 262132)
+		  && total_code_bytes < MAX_PCREL17F_OFFSET)
+	      /* Likewise.  */
 	      || (!targetm_common.have_named_sections
-		  && last_address < 262132))))
+		  && total_code_bytes < MAX_PCREL17F_OFFSET))))
     {
       if (!val_14)
 	output_asm_insn ("addil L'%2,%%r26", xoperands);
@@ -8944,40 +8958,15 @@
 }
 
 /* We use this hook to perform a PA specific optimization which is difficult
-   to do in earlier passes.
+   to do in earlier passes.  */
 
-   We surround the jump table itself with BEGIN_BRTAB and END_BRTAB
-   insns.  Those insns mark where we should emit .begin_brtab and
-   .end_brtab directives when using GAS.  This allows for better link
-   time optimizations.  */
-
 static void
 pa_reorg (void)
 {
-  rtx insn;
-
   remove_useless_addtr_insns (1);
 
   if (pa_cpu < PROCESSOR_8000)
     pa_combine_instructions ();
-
-    /* Still need brtab marker insns.  FIXME: the presence of these
-       markers disables output of the branch table to readonly memory,
-       and any alignment directives that might be needed.  Possibly,
-       the begin_brtab insn should be output before the label for the
-       table.  This doesn't matter at the moment since the tables are
-       always output in the text section.  */
-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
-      {
-	/* Find an ADDR_VEC insn.  */
-	if (! JUMP_TABLE_DATA_P (insn))
-	  continue;
-
-	/* Now generate markers for the beginning and end of the
-	   branch table.  */
-	emit_insn_before (gen_begin_brtab (), insn);
-	emit_insn_after (gen_end_brtab (), insn);
-      }
 }
 
 /* The PA has a number of odd instructions which can perform multiple
@@ -9327,6 +9316,12 @@
       || TREE_CODE (valtype) == COMPLEX_TYPE
       || TREE_CODE (valtype) == VECTOR_TYPE)
     {
+      HOST_WIDE_INT valsize = int_size_in_bytes (valtype);
+
+      /* Handle aggregates that fit exactly in a word or double word.  */
+      if ((valsize & (UNITS_PER_WORD - 1)) == 0)
+	return gen_rtx_REG (TYPE_MODE (valtype), 28);
+
       if (TARGET_64BIT)
 	{
           /* Aggregates with a size less than or equal to 128 bits are
@@ -9335,7 +9330,7 @@
 	     memory.  */
 	  rtx loc[2];
 	  int i, offset = 0;
-	  int ub = int_size_in_bytes (valtype) <= UNITS_PER_WORD ? 1 : 2;
+	  int ub = valsize <= UNITS_PER_WORD ? 1 : 2;
 
 	  for (i = 0; i < ub; i++)
 	    {
@@ -9347,7 +9342,7 @@
 
 	  return gen_rtx_PARALLEL (BLKmode, gen_rtvec_v (ub, loc));
 	}
-      else if (int_size_in_bytes (valtype) > UNITS_PER_WORD)
+      else if (valsize > UNITS_PER_WORD)
 	{
 	  /* Aggregates 5 to 8 bytes in size are returned in general
 	     registers r28-r29 in the same manner as other non
@@ -10572,4 +10567,46 @@
   return NULL_RTX;
 }
 
+/* Output address vector.  */
+
+void
+pa_output_addr_vec (rtx lab, rtx body)
+{
+  int idx, vlen = XVECLEN (body, 0);
+
+  targetm.asm_out.internal_label (asm_out_file, "L", CODE_LABEL_NUMBER (lab));
+  if (TARGET_GAS)
+    fputs ("\t.begin_brtab\n", asm_out_file);
+  for (idx = 0; idx < vlen; idx++)
+    {
+      ASM_OUTPUT_ADDR_VEC_ELT
+	(asm_out_file, CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 0, idx), 0)));
+    }
+  if (TARGET_GAS)
+    fputs ("\t.end_brtab\n", asm_out_file);
+}
+
+/* Output address difference vector.  */
+
+void
+pa_output_addr_diff_vec (rtx lab, rtx body)
+{
+  rtx base = XEXP (XEXP (body, 0), 0);
+  int idx, vlen = XVECLEN (body, 1);
+
+  targetm.asm_out.internal_label (asm_out_file, "L", CODE_LABEL_NUMBER (lab));
+  if (TARGET_GAS)
+    fputs ("\t.begin_brtab\n", asm_out_file);
+  for (idx = 0; idx < vlen; idx++)
+    {
+      ASM_OUTPUT_ADDR_DIFF_ELT
+	(asm_out_file,
+	 body,
+	 CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 1, idx), 0)),
+	 CODE_LABEL_NUMBER (base));
+    }
+  if (TARGET_GAS)
+    fputs ("\t.end_brtab\n", asm_out_file);
+}
+
 #include "gt-pa.h"
Index: gcc/config/pa/pa.h
===================================================================
--- a/src/gcc/config/pa/pa.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/pa/pa.h	(.../branches/gcc-4_9-branch)
@@ -1193,6 +1193,16 @@
 #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \
   fprintf (FILE, "\t.word L$%04d-L$%04d\n", VALUE, REL)
 
+/* This is how to output an absolute case-vector.  */
+
+#define ASM_OUTPUT_ADDR_VEC(LAB,BODY)	\
+  pa_output_addr_vec ((LAB),(BODY))
+
+/* This is how to output a relative case-vector.  */
+
+#define ASM_OUTPUT_ADDR_DIFF_VEC(LAB,BODY)	\
+  pa_output_addr_diff_vec ((LAB),(BODY))
+
 /* This is how to output an assembler line that says to advance the
    location counter to a multiple of 2**LOG bytes.  */
 
Index: gcc/config/msp430/msp430.md
===================================================================
--- a/src/gcc/config/msp430/msp430.md	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/config/msp430/msp430.md	(.../branches/gcc-4_9-branch)
@@ -559,7 +559,7 @@
   [(set (match_operand:PSI 0 "nonimmediate_operand" "=r")
 	(subreg:PSI (sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0")) 0))]
   "TARGET_LARGE"
-  "RLAM #4, %0 { RRAM #4, %0"
+  "RLAM.A #4, %0 { RRAM.A #4, %0"
 )
 
 ;; Look for cases where integer/pointer conversions are suboptimal due
@@ -587,7 +587,7 @@
 	(ashift:SI (sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0"))
 		   (const_int 1)))]
   "TARGET_LARGE"
-  "RLAM #4, %0 { RRAM #3, %0"
+  "RLAM.A #4, %0 { RRAM.A #3, %0"
 )
 
 (define_insn "extend_and_shift2_hipsi2"
@@ -595,7 +595,7 @@
 	(ashift:SI (sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0"))
 		   (const_int 2)))]
   "TARGET_LARGE"
-  "RLAM #4, %0 { RRAM #2, %0"
+  "RLAM.A #4, %0 { RRAM.A #2, %0"
 )
 
 ; Nasty - we are sign-extending a 20-bit PSI value in one register into
Index: gcc/tree-vect-slp.c
===================================================================
--- a/src/gcc/tree-vect-slp.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-vect-slp.c	(.../branches/gcc-4_9-branch)
@@ -1793,7 +1793,10 @@
 	    && (stmt_vinfo = vinfo_for_stmt (use_stmt))
 	    && !STMT_SLP_TYPE (stmt_vinfo)
             && (STMT_VINFO_RELEVANT (stmt_vinfo)
-                || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_vinfo)))
+                || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_vinfo))
+		|| (STMT_VINFO_IN_PATTERN_P (stmt_vinfo)
+		    && STMT_VINFO_RELATED_STMT (stmt_vinfo)
+		    && !STMT_SLP_TYPE (vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_vinfo)))))
 	    && !(gimple_code (use_stmt) == GIMPLE_PHI
                  && STMT_VINFO_DEF_TYPE (stmt_vinfo)
                   == vect_reduction_def))
@@ -2392,13 +2395,21 @@
             neutral_op = build_int_cst (TREE_TYPE (op), -1);
             break;
 
-          case MAX_EXPR:
-          case MIN_EXPR:
-            def_stmt = SSA_NAME_DEF_STMT (op);
-            loop = (gimple_bb (stmt))->loop_father;
-            neutral_op = PHI_ARG_DEF_FROM_EDGE (def_stmt,
-                                                loop_preheader_edge (loop));
-            break;
+	  /* For MIN/MAX we don't have an easy neutral operand but
+	     the initial values can be used fine here.  Only for
+	     a reduction chain we have to force a neutral element.  */
+	  case MAX_EXPR:
+	  case MIN_EXPR:
+	    if (!GROUP_FIRST_ELEMENT (stmt_vinfo))
+	      neutral_op = NULL;
+	    else
+	      {
+		def_stmt = SSA_NAME_DEF_STMT (op);
+		loop = (gimple_bb (stmt))->loop_father;
+		neutral_op = PHI_ARG_DEF_FROM_EDGE (def_stmt,
+						    loop_preheader_edge (loop));
+	      }
+	    break;
 
           default:
             neutral_op = NULL;
Index: gcc/varpool.c
===================================================================
--- a/src/gcc/varpool.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/varpool.c	(.../branches/gcc-4_9-branch)
@@ -329,8 +329,16 @@
 
   /* Variables declared 'const' without an initializer
      have zero as the initializer if they may not be
-     overridden at link or run time.  */
-  if (!DECL_INITIAL (real_decl)
+     overridden at link or run time.
+
+     It is actually requirement for C++ compiler to optimize const variables
+     consistently. As a GNU extension, do not enfore this rule for user defined
+     weak variables, so we support interposition on:
+     static const int dummy = 0;
+     extern const int foo __attribute__((__weak__, __alias__("dummy"))); 
+   */
+  if ((!DECL_INITIAL (real_decl)
+       || (DECL_WEAK (decl) && !DECL_COMDAT (decl)))
       && (DECL_EXTERNAL (decl) || decl_replaceable_p (decl)))
     return error_mark_node;
 
Index: gcc/tree-ssanames.h
===================================================================
--- a/src/gcc/tree-ssanames.h	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssanames.h	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,6 @@
 
 
 #define SSANAMES(fun) (fun)->gimple_df->ssa_names
-#define MODIFIED_NORETURN_CALLS(fun) (fun)->gimple_df->modified_noreturn_calls
 #define DEFAULT_DEFS(fun) (fun)->gimple_df->default_defs
 
 #define num_ssa_names (vec_safe_length (cfun->gimple_df->ssa_names))
Index: gcc/regcprop.c
===================================================================
--- a/src/gcc/regcprop.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/regcprop.c	(.../branches/gcc-4_9-branch)
@@ -1039,7 +1039,17 @@
 	     but instead among CLOBBERs on the CALL_INSN, we could wrongly
 	     assume the value in it is still live.  */
 	  if (ksvd.ignore_set_reg)
-	    note_stores (PATTERN (insn), kill_clobbered_value, vd);
+	    {
+	      note_stores (PATTERN (insn), kill_clobbered_value, vd);
+	      for (exp = CALL_INSN_FUNCTION_USAGE (insn);
+		   exp;
+		   exp = XEXP (exp, 1))
+		{
+		  rtx x = XEXP (exp, 0);
+		  if (GET_CODE (x) == CLOBBER)
+		    kill_value (SET_DEST (x), vd);
+		}
+	    }
 	}
 
       /* Notice stores.  */
Index: gcc/tree-ssa-operands.c
===================================================================
--- a/src/gcc/tree-ssa-operands.c	(.../tags/gcc_4_9_1_release)
+++ b/src/gcc/tree-ssa-operands.c	(.../branches/gcc-4_9-branch)
@@ -1091,12 +1091,6 @@
 
   timevar_push (TV_TREE_OPS);
 
-  /* If the stmt is a noreturn call queue it to be processed by
-     split_bbs_on_noreturn_calls during cfg cleanup.  */
-  if (is_gimple_call (stmt)
-      && gimple_call_noreturn_p (stmt))
-    vec_safe_push (MODIFIED_NORETURN_CALLS (fn), stmt);
-
   gcc_assert (gimple_modified_p (stmt));
   build_ssa_operands (fn, stmt);
   gimple_set_modified (stmt, false);
Index: libgo/runtime/mgc0.c
===================================================================
--- a/src/libgo/runtime/mgc0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/runtime/mgc0.c	(.../branches/gcc-4_9-branch)
@@ -2000,6 +2000,7 @@
 		runtime_mcall(mgc);
 		// record a new start time in case we're going around again
 		a.start_time = runtime_nanotime();
+		m = runtime_m();
 	}
 
 	// all done
Index: libgo/runtime/go-caller.c
===================================================================
--- a/src/libgo/runtime/go-caller.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/runtime/go-caller.c	(.../branches/gcc-4_9-branch)
@@ -7,6 +7,9 @@
 /* Implement runtime.Caller.  */
 
 #include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
 
 #include "backtrace.h"
 
@@ -99,6 +102,7 @@
   if (back_state == NULL)
     {
       const char *filename;
+      struct stat s;
 
       filename = (const char *) runtime_progname ();
 
@@ -108,6 +112,14 @@
       if (__builtin_strchr (filename, '/') == NULL)
 	filename = NULL;
 
+      /* If the file is small, then it's not the real executable.
+	 This is specifically to deal with Docker, which uses a bogus
+	 argv[0] (http://gcc.gnu.org/PR61895).  It would be nice to
+	 have a better check for whether this file is the real
+	 executable.  */
+      if (stat (filename, &s) < 0 || s.st_size < 1024)
+	filename = NULL;
+
       back_state = backtrace_create_state (filename, 1, error_callback, NULL);
     }
   runtime_unlock (&back_state_lock);
Index: libgo/runtime/malloc.goc
===================================================================
--- a/src/libgo/runtime/malloc.goc	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/runtime/malloc.goc	(.../branches/gcc-4_9-branch)
@@ -79,6 +79,7 @@
 	MSpan *s;
 	MLink *v;
 	bool incallback;
+	void *closure;
 
 	if(size == 0) {
 		// All 0-length allocations use this pointer.
@@ -90,6 +91,10 @@
 	m = runtime_m();
 	g = runtime_g();
 
+	// We should not be called in between __go_set_closure and the
+	// actual function call, but cope with it if we are.
+	closure = g->closure;
+
 	incallback = false;
 	if(m->mcache == nil && g->ncgo > 0) {
 		// For gccgo this case can occur when a cgo or SWIG function
@@ -206,6 +211,8 @@
 	if(incallback)
 		runtime_entersyscall();
 
+	g->closure = closure;
+
 	return v;
 }
 
Index: libgo/runtime/getncpu-linux.c
===================================================================
--- a/src/libgo/runtime/getncpu-linux.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/runtime/getncpu-linux.c	(.../branches/gcc-4_9-branch)
@@ -6,7 +6,7 @@
 #include <sched.h>
 
 // CPU_COUNT is only provided by glibc 2.6 or higher
-#if !defined(__GLIBC_PREREQ) || !__GLIBC_PREREQ(2, 6)
+#ifndef CPU_COUNT
 #define CPU_COUNT(set) _CPU_COUNT((unsigned int *)(set), sizeof(*(set))/sizeof(unsigned int))
 static int _CPU_COUNT(unsigned int *set, size_t len) {
 	int cnt;
Index: libgo/go/debug/elf/file.go
===================================================================
--- a/src/libgo/go/debug/elf/file.go	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/go/debug/elf/file.go	(.../branches/gcc-4_9-branch)
@@ -519,6 +519,9 @@
 	if f.Class == ELFCLASS64 && f.Machine == EM_X86_64 {
 		return f.applyRelocationsAMD64(dst, rels)
 	}
+	if f.Class == ELFCLASS64 && f.Machine == EM_AARCH64 {
+		return f.applyRelocationsARM64(dst, rels)
+	}
 
 	return errors.New("not implemented")
 }
@@ -567,6 +570,51 @@
 	return nil
 }
 
+func (f *File) applyRelocationsARM64(dst []byte, rels []byte) error {
+	// 24 is the size of Rela64.
+	if len(rels)%24 != 0 {
+		return errors.New("length of relocation section is not a multiple of 24")
+	}
+
+	symbols, _, err := f.getSymbols(SHT_SYMTAB)
+	if err != nil {
+		return err
+	}
+
+	b := bytes.NewReader(rels)
+	var rela Rela64
+
+	for b.Len() > 0 {
+		binary.Read(b, f.ByteOrder, &rela)
+		symNo := rela.Info >> 32
+		t := R_AARCH64(rela.Info & 0xffff)
+
+		if symNo == 0 || symNo > uint64(len(symbols)) {
+			continue
+		}
+		sym := &symbols[symNo-1]
+		if SymType(sym.Info&0xf) != STT_SECTION {
+			// We don't handle non-section relocations for now.
+			continue
+		}
+
+		switch t {
+		case R_AARCH64_ABS64:
+			if rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {
+				continue
+			}
+			f.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend))
+		case R_AARCH64_ABS32:
+			if rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {
+				continue
+			}
+			f.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend))
+		}
+	}
+
+	return nil
+}
+
 func (f *File) DWARF() (*dwarf.Data, error) {
 	// There are many other DWARF sections, but these
 	// are the required ones, and the debug/dwarf package
@@ -589,7 +637,7 @@
 	// If there's a relocation table for .debug_info, we have to process it
 	// now otherwise the data in .debug_info is invalid for x86-64 objects.
 	rela := f.Section(".rela.debug_info")
-	if rela != nil && rela.Type == SHT_RELA && f.Machine == EM_X86_64 {
+	if rela != nil && rela.Type == SHT_RELA && (f.Machine == EM_X86_64 || f.Machine == EM_AARCH64) {
 		data, err := rela.Data()
 		if err != nil {
 			return nil, err
Index: libgo/go/debug/elf/elf.go
===================================================================
--- a/src/libgo/go/debug/elf/elf.go	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/go/debug/elf/elf.go	(.../branches/gcc-4_9-branch)
@@ -11,6 +11,7 @@
  * $FreeBSD: src/sys/i386/include/elf.h,v 1.16 2004/08/02 19:12:17 dfr Exp $
  * $FreeBSD: src/sys/powerpc/include/elf.h,v 1.7 2004/11/02 09:47:01 ssouhlal Exp $
  * $FreeBSD: src/sys/sparc64/include/elf.h,v 1.12 2003/09/25 01:10:26 peter Exp $
+ * "ELF for the ARM 64-bit Architecture (AArch64)" (ARM IHI 0056B)
  *
  * Copyright (c) 1996-1998 John D. Polstra.  All rights reserved.
  * Copyright (c) 2001 David E. O'Brien
@@ -192,49 +193,50 @@
 type Machine uint16
 
 const (
-	EM_NONE        Machine = 0  /* Unknown machine. */
-	EM_M32         Machine = 1  /* AT&T WE32100. */
-	EM_SPARC       Machine = 2  /* Sun SPARC. */
-	EM_386         Machine = 3  /* Intel i386. */
-	EM_68K         Machine = 4  /* Motorola 68000. */
-	EM_88K         Machine = 5  /* Motorola 88000. */
-	EM_860         Machine = 7  /* Intel i860. */
-	EM_MIPS        Machine = 8  /* MIPS R3000 Big-Endian only. */
-	EM_S370        Machine = 9  /* IBM System/370. */
-	EM_MIPS_RS3_LE Machine = 10 /* MIPS R3000 Little-Endian. */
-	EM_PARISC      Machine = 15 /* HP PA-RISC. */
-	EM_VPP500      Machine = 17 /* Fujitsu VPP500. */
-	EM_SPARC32PLUS Machine = 18 /* SPARC v8plus. */
-	EM_960         Machine = 19 /* Intel 80960. */
-	EM_PPC         Machine = 20 /* PowerPC 32-bit. */
-	EM_PPC64       Machine = 21 /* PowerPC 64-bit. */
-	EM_S390        Machine = 22 /* IBM System/390. */
-	EM_V800        Machine = 36 /* NEC V800. */
-	EM_FR20        Machine = 37 /* Fujitsu FR20. */
-	EM_RH32        Machine = 38 /* TRW RH-32. */
-	EM_RCE         Machine = 39 /* Motorola RCE. */
-	EM_ARM         Machine = 40 /* ARM. */
-	EM_SH          Machine = 42 /* Hitachi SH. */
-	EM_SPARCV9     Machine = 43 /* SPARC v9 64-bit. */
-	EM_TRICORE     Machine = 44 /* Siemens TriCore embedded processor. */
-	EM_ARC         Machine = 45 /* Argonaut RISC Core. */
-	EM_H8_300      Machine = 46 /* Hitachi H8/300. */
-	EM_H8_300H     Machine = 47 /* Hitachi H8/300H. */
-	EM_H8S         Machine = 48 /* Hitachi H8S. */
-	EM_H8_500      Machine = 49 /* Hitachi H8/500. */
-	EM_IA_64       Machine = 50 /* Intel IA-64 Processor. */
-	EM_MIPS_X      Machine = 51 /* Stanford MIPS-X. */
-	EM_COLDFIRE    Machine = 52 /* Motorola ColdFire. */
-	EM_68HC12      Machine = 53 /* Motorola M68HC12. */
-	EM_MMA         Machine = 54 /* Fujitsu MMA. */
-	EM_PCP         Machine = 55 /* Siemens PCP. */
-	EM_NCPU        Machine = 56 /* Sony nCPU. */
-	EM_NDR1        Machine = 57 /* Denso NDR1 microprocessor. */
-	EM_STARCORE    Machine = 58 /* Motorola Star*Core processor. */
-	EM_ME16        Machine = 59 /* Toyota ME16 processor. */
-	EM_ST100       Machine = 60 /* STMicroelectronics ST100 processor. */
-	EM_TINYJ       Machine = 61 /* Advanced Logic Corp. TinyJ processor. */
-	EM_X86_64      Machine = 62 /* Advanced Micro Devices x86-64 */
+	EM_NONE        Machine = 0   /* Unknown machine. */
+	EM_M32         Machine = 1   /* AT&T WE32100. */
+	EM_SPARC       Machine = 2   /* Sun SPARC. */
+	EM_386         Machine = 3   /* Intel i386. */
+	EM_68K         Machine = 4   /* Motorola 68000. */
+	EM_88K         Machine = 5   /* Motorola 88000. */
+	EM_860         Machine = 7   /* Intel i860. */
+	EM_MIPS        Machine = 8   /* MIPS R3000 Big-Endian only. */
+	EM_S370        Machine = 9   /* IBM System/370. */
+	EM_MIPS_RS3_LE Machine = 10  /* MIPS R3000 Little-Endian. */
+	EM_PARISC      Machine = 15  /* HP PA-RISC. */
+	EM_VPP500      Machine = 17  /* Fujitsu VPP500. */
+	EM_SPARC32PLUS Machine = 18  /* SPARC v8plus. */
+	EM_960         Machine = 19  /* Intel 80960. */
+	EM_PPC         Machine = 20  /* PowerPC 32-bit. */
+	EM_PPC64       Machine = 21  /* PowerPC 64-bit. */
+	EM_S390        Machine = 22  /* IBM System/390. */
+	EM_V800        Machine = 36  /* NEC V800. */
+	EM_FR20        Machine = 37  /* Fujitsu FR20. */
+	EM_RH32        Machine = 38  /* TRW RH-32. */
+	EM_RCE         Machine = 39  /* Motorola RCE. */
+	EM_ARM         Machine = 40  /* ARM. */
+	EM_SH          Machine = 42  /* Hitachi SH. */
+	EM_SPARCV9     Machine = 43  /* SPARC v9 64-bit. */
+	EM_TRICORE     Machine = 44  /* Siemens TriCore embedded processor. */
+	EM_ARC         Machine = 45  /* Argonaut RISC Core. */
+	EM_H8_300      Machine = 46  /* Hitachi H8/300. */
+	EM_H8_300H     Machine = 47  /* Hitachi H8/300H. */
+	EM_H8S         Machine = 48  /* Hitachi H8S. */
+	EM_H8_500      Machine = 49  /* Hitachi H8/500. */
+	EM_IA_64       Machine = 50  /* Intel IA-64 Processor. */
+	EM_MIPS_X      Machine = 51  /* Stanford MIPS-X. */
+	EM_COLDFIRE    Machine = 52  /* Motorola ColdFire. */
+	EM_68HC12      Machine = 53  /* Motorola M68HC12. */
+	EM_MMA         Machine = 54  /* Fujitsu MMA. */
+	EM_PCP         Machine = 55  /* Siemens PCP. */
+	EM_NCPU        Machine = 56  /* Sony nCPU. */
+	EM_NDR1        Machine = 57  /* Denso NDR1 microprocessor. */
+	EM_STARCORE    Machine = 58  /* Motorola Star*Core processor. */
+	EM_ME16        Machine = 59  /* Toyota ME16 processor. */
+	EM_ST100       Machine = 60  /* STMicroelectronics ST100 processor. */
+	EM_TINYJ       Machine = 61  /* Advanced Logic Corp. TinyJ processor. */
+	EM_X86_64      Machine = 62  /* Advanced Micro Devices x86-64 */
+	EM_AARCH64     Machine = 183 /* ARM 64-bit Architecture (AArch64) */
 
 	/* Non-standard or deprecated. */
 	EM_486         Machine = 6      /* Intel i486. */
@@ -774,6 +776,256 @@
 func (i R_X86_64) String() string   { return stringName(uint32(i), rx86_64Strings, false) }
 func (i R_X86_64) GoString() string { return stringName(uint32(i), rx86_64Strings, true) }
 
+// Relocation types for AArch64 (aka arm64)
+type R_AARCH64 int
+
+const (
+	R_AARCH64_NONE                            R_AARCH64 = 0
+	R_AARCH64_P32_ABS32                       R_AARCH64 = 1
+	R_AARCH64_P32_ABS16                       R_AARCH64 = 2
+	R_AARCH64_P32_PREL32                      R_AARCH64 = 3
+	R_AARCH64_P32_PREL16                      R_AARCH64 = 4
+	R_AARCH64_P32_MOVW_UABS_G0                R_AARCH64 = 5
+	R_AARCH64_P32_MOVW_UABS_G0_NC             R_AARCH64 = 6
+	R_AARCH64_P32_MOVW_UABS_G1                R_AARCH64 = 7
+	R_AARCH64_P32_MOVW_SABS_G0                R_AARCH64 = 8
+	R_AARCH64_P32_LD_PREL_LO19                R_AARCH64 = 9
+	R_AARCH64_P32_ADR_PREL_LO21               R_AARCH64 = 10
+	R_AARCH64_P32_ADR_PREL_PG_HI21            R_AARCH64 = 11
+	R_AARCH64_P32_ADD_ABS_LO12_NC             R_AARCH64 = 12
+	R_AARCH64_P32_LDST8_ABS_LO12_NC           R_AARCH64 = 13
+	R_AARCH64_P32_LDST16_ABS_LO12_NC          R_AARCH64 = 14
+	R_AARCH64_P32_LDST32_ABS_LO12_NC          R_AARCH64 = 15
+	R_AARCH64_P32_LDST64_ABS_LO12_NC          R_AARCH64 = 16
+	R_AARCH64_P32_LDST128_ABS_LO12_NC         R_AARCH64 = 17
+	R_AARCH64_P32_TSTBR14                     R_AARCH64 = 18
+	R_AARCH64_P32_CONDBR19                    R_AARCH64 = 19
+	R_AARCH64_P32_JUMP26                      R_AARCH64 = 20
+	R_AARCH64_P32_CALL26                      R_AARCH64 = 21
+	R_AARCH64_P32_GOT_LD_PREL19               R_AARCH64 = 25
+	R_AARCH64_P32_ADR_GOT_PAGE                R_AARCH64 = 26
+	R_AARCH64_P32_LD32_GOT_LO12_NC            R_AARCH64 = 27
+	R_AARCH64_P32_TLSGD_ADR_PAGE21            R_AARCH64 = 81
+	R_AARCH64_P32_TLSGD_ADD_LO12_NC           R_AARCH64 = 82
+	R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21   R_AARCH64 = 103
+	R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC R_AARCH64 = 104
+	R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19    R_AARCH64 = 105
+	R_AARCH64_P32_TLSLE_MOVW_TPREL_G1         R_AARCH64 = 106
+	R_AARCH64_P32_TLSLE_MOVW_TPREL_G0         R_AARCH64 = 107
+	R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC      R_AARCH64 = 108
+	R_AARCH64_P32_TLSLE_ADD_TPREL_HI12        R_AARCH64 = 109
+	R_AARCH64_P32_TLSLE_ADD_TPREL_LO12        R_AARCH64 = 110
+	R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC     R_AARCH64 = 111
+	R_AARCH64_P32_TLSDESC_LD_PREL19           R_AARCH64 = 122
+	R_AARCH64_P32_TLSDESC_ADR_PREL21          R_AARCH64 = 123
+	R_AARCH64_P32_TLSDESC_ADR_PAGE21          R_AARCH64 = 124
+	R_AARCH64_P32_TLSDESC_LD32_LO12_NC        R_AARCH64 = 125
+	R_AARCH64_P32_TLSDESC_ADD_LO12_NC         R_AARCH64 = 126
+	R_AARCH64_P32_TLSDESC_CALL                R_AARCH64 = 127
+	R_AARCH64_P32_COPY                        R_AARCH64 = 180
+	R_AARCH64_P32_GLOB_DAT                    R_AARCH64 = 181
+	R_AARCH64_P32_JUMP_SLOT                   R_AARCH64 = 182
+	R_AARCH64_P32_RELATIVE                    R_AARCH64 = 183
+	R_AARCH64_P32_TLS_DTPMOD                  R_AARCH64 = 184
+	R_AARCH64_P32_TLS_DTPREL                  R_AARCH64 = 185
+	R_AARCH64_P32_TLS_TPREL                   R_AARCH64 = 186
+	R_AARCH64_P32_TLSDESC                     R_AARCH64 = 187
+	R_AARCH64_P32_IRELATIVE                   R_AARCH64 = 188
+	R_AARCH64_NULL                            R_AARCH64 = 256
+	R_AARCH64_ABS64                           R_AARCH64 = 257
+	R_AARCH64_ABS32                           R_AARCH64 = 258
+	R_AARCH64_ABS16                           R_AARCH64 = 259
+	R_AARCH64_PREL64                          R_AARCH64 = 260
+	R_AARCH64_PREL32                          R_AARCH64 = 261
+	R_AARCH64_PREL16                          R_AARCH64 = 262
+	R_AARCH64_MOVW_UABS_G0                    R_AARCH64 = 263
+	R_AARCH64_MOVW_UABS_G0_NC                 R_AARCH64 = 264
+	R_AARCH64_MOVW_UABS_G1                    R_AARCH64 = 265
+	R_AARCH64_MOVW_UABS_G1_NC                 R_AARCH64 = 266
+	R_AARCH64_MOVW_UABS_G2                    R_AARCH64 = 267
+	R_AARCH64_MOVW_UABS_G2_NC                 R_AARCH64 = 268
+	R_AARCH64_MOVW_UABS_G3                    R_AARCH64 = 269
+	R_AARCH64_MOVW_SABS_G0                    R_AARCH64 = 270
+	R_AARCH64_MOVW_SABS_G1                    R_AARCH64 = 271
+	R_AARCH64_MOVW_SABS_G2                    R_AARCH64 = 272
+	R_AARCH64_LD_PREL_LO19                    R_AARCH64 = 273
+	R_AARCH64_ADR_PREL_LO21                   R_AARCH64 = 274
+	R_AARCH64_ADR_PREL_PG_HI21                R_AARCH64 = 275
+	R_AARCH64_ADR_PREL_PG_HI21_NC             R_AARCH64 = 276
+	R_AARCH64_ADD_ABS_LO12_NC                 R_AARCH64 = 277
+	R_AARCH64_LDST8_ABS_LO12_NC               R_AARCH64 = 278
+	R_AARCH64_TSTBR14                         R_AARCH64 = 279
+	R_AARCH64_CONDBR19                        R_AARCH64 = 280
+	R_AARCH64_JUMP26                          R_AARCH64 = 282
+	R_AARCH64_CALL26                          R_AARCH64 = 283
+	R_AARCH64_LDST16_ABS_LO12_NC              R_AARCH64 = 284
+	R_AARCH64_LDST32_ABS_LO12_NC              R_AARCH64 = 285
+	R_AARCH64_LDST64_ABS_LO12_NC              R_AARCH64 = 286
+	R_AARCH64_LDST128_ABS_LO12_NC             R_AARCH64 = 299
+	R_AARCH64_GOT_LD_PREL19                   R_AARCH64 = 309
+	R_AARCH64_ADR_GOT_PAGE                    R_AARCH64 = 311
+	R_AARCH64_LD64_GOT_LO12_NC                R_AARCH64 = 312
+	R_AARCH64_TLSGD_ADR_PAGE21                R_AARCH64 = 513
+	R_AARCH64_TLSGD_ADD_LO12_NC               R_AARCH64 = 514
+	R_AARCH64_TLSIE_MOVW_GOTTPREL_G1          R_AARCH64 = 539
+	R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC       R_AARCH64 = 540
+	R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21       R_AARCH64 = 541
+	R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC     R_AARCH64 = 542
+	R_AARCH64_TLSIE_LD_GOTTPREL_PREL19        R_AARCH64 = 543
+	R_AARCH64_TLSLE_MOVW_TPREL_G2             R_AARCH64 = 544
+	R_AARCH64_TLSLE_MOVW_TPREL_G1             R_AARCH64 = 545
+	R_AARCH64_TLSLE_MOVW_TPREL_G1_NC          R_AARCH64 = 546
+	R_AARCH64_TLSLE_MOVW_TPREL_G0             R_AARCH64 = 547
+	R_AARCH64_TLSLE_MOVW_TPREL_G0_NC          R_AARCH64 = 548
+	R_AARCH64_TLSLE_ADD_TPREL_HI12            R_AARCH64 = 549
+	R_AARCH64_TLSLE_ADD_TPREL_LO12            R_AARCH64 = 550
+	R_AARCH64_TLSLE_ADD_TPREL_LO12_NC         R_AARCH64 = 551
+	R_AARCH64_TLSDESC_LD_PREL19               R_AARCH64 = 560
+	R_AARCH64_TLSDESC_ADR_PREL21              R_AARCH64 = 561
+	R_AARCH64_TLSDESC_ADR_PAGE21              R_AARCH64 = 562
+	R_AARCH64_TLSDESC_LD64_LO12_NC            R_AARCH64 = 563
+	R_AARCH64_TLSDESC_ADD_LO12_NC             R_AARCH64 = 564
+	R_AARCH64_TLSDESC_OFF_G1                  R_AARCH64 = 565
+	R_AARCH64_TLSDESC_OFF_G0_NC               R_AARCH64 = 566
+	R_AARCH64_TLSDESC_LDR                     R_AARCH64 = 567
+	R_AARCH64_TLSDESC_ADD                     R_AARCH64 = 568
+	R_AARCH64_TLSDESC_CALL                    R_AARCH64 = 569
+	R_AARCH64_COPY                            R_AARCH64 = 1024
+	R_AARCH64_GLOB_DAT                        R_AARCH64 = 1025
+	R_AARCH64_JUMP_SLOT                       R_AARCH64 = 1026
+	R_AARCH64_RELATIVE                        R_AARCH64 = 1027
+	R_AARCH64_TLS_DTPMOD64                    R_AARCH64 = 1028
+	R_AARCH64_TLS_DTPREL64                    R_AARCH64 = 1029
+	R_AARCH64_TLS_TPREL64                     R_AARCH64 = 1030
+	R_AARCH64_TLSDESC                         R_AARCH64 = 1031
+	R_AARCH64_IRELATIVE                       R_AARCH64 = 1032
+)
+
+var raarch64Strings = []intName{
+	{0, "R_AARCH64_NONE"},
+	{1, "R_AARCH64_P32_ABS32"},
+	{2, "R_AARCH64_P32_ABS16"},
+	{3, "R_AARCH64_P32_PREL32"},
+	{4, "R_AARCH64_P32_PREL16"},
+	{5, "R_AARCH64_P32_MOVW_UABS_G0"},
+	{6, "R_AARCH64_P32_MOVW_UABS_G0_NC"},
+	{7, "R_AARCH64_P32_MOVW_UABS_G1"},
+	{8, "R_AARCH64_P32_MOVW_SABS_G0"},
+	{9, "R_AARCH64_P32_LD_PREL_LO19"},
+	{10, "R_AARCH64_P32_ADR_PREL_LO21"},
+	{11, "R_AARCH64_P32_ADR_PREL_PG_HI21"},
+	{12, "R_AARCH64_P32_ADD_ABS_LO12_NC"},
+	{13, "R_AARCH64_P32_LDST8_ABS_LO12_NC"},
+	{14, "R_AARCH64_P32_LDST16_ABS_LO12_NC"},
+	{15, "R_AARCH64_P32_LDST32_ABS_LO12_NC"},
+	{16, "R_AARCH64_P32_LDST64_ABS_LO12_NC"},
+	{17, "R_AARCH64_P32_LDST128_ABS_LO12_NC"},
+	{18, "R_AARCH64_P32_TSTBR14"},
+	{19, "R_AARCH64_P32_CONDBR19"},
+	{20, "R_AARCH64_P32_JUMP26"},
+	{21, "R_AARCH64_P32_CALL26"},
+	{25, "R_AARCH64_P32_GOT_LD_PREL19"},
+	{26, "R_AARCH64_P32_ADR_GOT_PAGE"},
+	{27, "R_AARCH64_P32_LD32_GOT_LO12_NC"},
+	{81, "R_AARCH64_P32_TLSGD_ADR_PAGE21"},
+	{82, "R_AARCH64_P32_TLSGD_ADD_LO12_NC"},
+	{103, "R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21"},
+	{104, "R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC"},
+	{105, "R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19"},
+	{106, "R_AARCH64_P32_TLSLE_MOVW_TPREL_G1"},
+	{107, "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0"},
+	{108, "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC"},
+	{109, "R_AARCH64_P32_TLSLE_ADD_TPREL_HI12"},
+	{110, "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12"},
+	{111, "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC"},
+	{122, "R_AARCH64_P32_TLSDESC_LD_PREL19"},
+	{123, "R_AARCH64_P32_TLSDESC_ADR_PREL21"},
+	{124, "R_AARCH64_P32_TLSDESC_ADR_PAGE21"},
+	{125, "R_AARCH64_P32_TLSDESC_LD32_LO12_NC"},
+	{126, "R_AARCH64_P32_TLSDESC_ADD_LO12_NC"},
+	{127, "R_AARCH64_P32_TLSDESC_CALL"},
+	{180, "R_AARCH64_P32_COPY"},
+	{181, "R_AARCH64_P32_GLOB_DAT"},
+	{182, "R_AARCH64_P32_JUMP_SLOT"},
+	{183, "R_AARCH64_P32_RELATIVE"},
+	{184, "R_AARCH64_P32_TLS_DTPMOD"},
+	{185, "R_AARCH64_P32_TLS_DTPREL"},
+	{186, "R_AARCH64_P32_TLS_TPREL"},
+	{187, "R_AARCH64_P32_TLSDESC"},
+	{188, "R_AARCH64_P32_IRELATIVE"},
+	{256, "R_AARCH64_NULL"},
+	{257, "R_AARCH64_ABS64"},
+	{258, "R_AARCH64_ABS32"},
+	{259, "R_AARCH64_ABS16"},
+	{260, "R_AARCH64_PREL64"},
+	{261, "R_AARCH64_PREL32"},
+	{262, "R_AARCH64_PREL16"},
+	{263, "R_AARCH64_MOVW_UABS_G0"},
+	{264, "R_AARCH64_MOVW_UABS_G0_NC"},
+	{265, "R_AARCH64_MOVW_UABS_G1"},
+	{266, "R_AARCH64_MOVW_UABS_G1_NC"},
+	{267, "R_AARCH64_MOVW_UABS_G2"},
+	{268, "R_AARCH64_MOVW_UABS_G2_NC"},
+	{269, "R_AARCH64_MOVW_UABS_G3"},
+	{270, "R_AARCH64_MOVW_SABS_G0"},
+	{271, "R_AARCH64_MOVW_SABS_G1"},
+	{272, "R_AARCH64_MOVW_SABS_G2"},
+	{273, "R_AARCH64_LD_PREL_LO19"},
+	{274, "R_AARCH64_ADR_PREL_LO21"},
+	{275, "R_AARCH64_ADR_PREL_PG_HI21"},
+	{276, "R_AARCH64_ADR_PREL_PG_HI21_NC"},
+	{277, "R_AARCH64_ADD_ABS_LO12_NC"},
+	{278, "R_AARCH64_LDST8_ABS_LO12_NC"},
+	{279, "R_AARCH64_TSTBR14"},
+	{280, "R_AARCH64_CONDBR19"},
+	{282, "R_AARCH64_JUMP26"},
+	{283, "R_AARCH64_CALL26"},
+	{284, "R_AARCH64_LDST16_ABS_LO12_NC"},
+	{285, "R_AARCH64_LDST32_ABS_LO12_NC"},
+	{286, "R_AARCH64_LDST64_ABS_LO12_NC"},
+	{299, "R_AARCH64_LDST128_ABS_LO12_NC"},
+	{309, "R_AARCH64_GOT_LD_PREL19"},
+	{311, "R_AARCH64_ADR_GOT_PAGE"},
+	{312, "R_AARCH64_LD64_GOT_LO12_NC"},
+	{513, "R_AARCH64_TLSGD_ADR_PAGE21"},
+	{514, "R_AARCH64_TLSGD_ADD_LO12_NC"},
+	{539, "R_AARCH64_TLSIE_MOVW_GOTTPREL_G1"},
+	{540, "R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC"},
+	{541, "R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21"},
+	{542, "R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC"},
+	{543, "R_AARCH64_TLSIE_LD_GOTTPREL_PREL19"},
+	{544, "R_AARCH64_TLSLE_MOVW_TPREL_G2"},
+	{545, "R_AARCH64_TLSLE_MOVW_TPREL_G1"},
+	{546, "R_AARCH64_TLSLE_MOVW_TPREL_G1_NC"},
+	{547, "R_AARCH64_TLSLE_MOVW_TPREL_G0"},
+	{548, "R_AARCH64_TLSLE_MOVW_TPREL_G0_NC"},
+	{549, "R_AARCH64_TLSLE_ADD_TPREL_HI12"},
+	{550, "R_AARCH64_TLSLE_ADD_TPREL_LO12"},
+	{551, "R_AARCH64_TLSLE_ADD_TPREL_LO12_NC"},
+	{560, "R_AARCH64_TLSDESC_LD_PREL19"},
+	{561, "R_AARCH64_TLSDESC_ADR_PREL21"},
+	{562, "R_AARCH64_TLSDESC_ADR_PAGE21"},
+	{563, "R_AARCH64_TLSDESC_LD64_LO12_NC"},
+	{564, "R_AARCH64_TLSDESC_ADD_LO12_NC"},
+	{565, "R_AARCH64_TLSDESC_OFF_G1"},
+	{566, "R_AARCH64_TLSDESC_OFF_G0_NC"},
+	{567, "R_AARCH64_TLSDESC_LDR"},
+	{568, "R_AARCH64_TLSDESC_ADD"},
+	{569, "R_AARCH64_TLSDESC_CALL"},
+	{1024, "R_AARCH64_COPY"},
+	{1025, "R_AARCH64_GLOB_DAT"},
+	{1026, "R_AARCH64_JUMP_SLOT"},
+	{1027, "R_AARCH64_RELATIVE"},
+	{1028, "R_AARCH64_TLS_DTPMOD64"},
+	{1029, "R_AARCH64_TLS_DTPREL64"},
+	{1030, "R_AARCH64_TLS_TPREL64"},
+	{1031, "R_AARCH64_TLSDESC"},
+	{1032, "R_AARCH64_IRELATIVE"},
+}
+
+func (i R_AARCH64) String() string   { return stringName(uint32(i), raarch64Strings, false) }
+func (i R_AARCH64) GoString() string { return stringName(uint32(i), raarch64Strings, true) }
+
 // Relocation types for Alpha.
 type R_ALPHA int
 
Index: libgo/go/syscall/exec_linux.go
===================================================================
--- a/src/libgo/go/syscall/exec_linux.go	(.../tags/gcc_4_9_1_release)
+++ b/src/libgo/go/syscall/exec_linux.go	(.../branches/gcc-4_9-branch)
@@ -43,7 +43,7 @@
 	// Declare all variables at top in case any
 	// declarations require heap allocation (e.g., err1).
 	var (
-		r1     Pid_t
+		r1     uintptr
 		err1   Errno
 		nextfd int
 		i      int
@@ -65,7 +65,7 @@
 	// About to call fork.
 	// No more allocation or calls of non-assembly functions.
 	runtime_BeforeFork()
-	r1, err1 = raw_fork()
+	r1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)
 	if err1 != 0 {
 		runtime_AfterFork()
 		return 0, err1
Index: libobjc/encoding.c
===================================================================
--- a/src/libobjc/encoding.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libobjc/encoding.c	(.../branches/gcc-4_9-branch)
@@ -192,6 +192,8 @@
    ? MAX (MAX (COMPUTED, SPECIFIED), 64)				\
    : MAX (COMPUTED, SPECIFIED));})
 
+#define rs6000_special_adjust_field_align_p(FIELD, COMPUTED) \
+ (TARGET_ALTIVEC && TREE_CODE (TREE_TYPE (FIELD)) == VECTOR_TYPE)
 
 /* Skip a variable name, enclosed in quotes (").  */
 static inline
Index: libobjc/ChangeLog
===================================================================
--- a/src/libobjc/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libobjc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,16 @@
+2014-07-28  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	PR libobjc/61920
+	* encoding.c (rs6000_special_adjust_field_align_p): Use definition
+	that matches the 4.9 branch ABI.
+
+2014-07-27  Alan Modra  <amodra@gmail.com>
+	    Matthias Klose  <doko@ubuntu.com>
+
+	PR libobjc/61920
+
+	* encoding.c: Define rs6000_special_adjust_field_align_p.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgfortran/m4/in_pack.m4
===================================================================
--- a/src/libgfortran/m4/in_pack.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/in_pack.m4	(.../branches/gcc-4_9-branch)
@@ -79,7 +79,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = ('rtype_name` *)xmalloc (ssize * sizeof ('rtype_name`));
+  destptr = xmallocarray (ssize, sizeof ('rtype_name`));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/m4/pack.m4
===================================================================
--- a/src/libgfortran/m4/pack.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/pack.m4	(.../branches/gcc-4_9-branch)
@@ -168,8 +168,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof ('rtype_name`) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof ('rtype_name`));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/m4/spread.m4
===================================================================
--- a/src/libgfortran/m4/spread.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/spread.m4	(.../branches/gcc-4_9-branch)
@@ -102,8 +102,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof('rtype_name`));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof('rtype_name`));
       if (rs <= 0)
         return;
     }
@@ -245,7 +245,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof ('rtype_name`));
+      ret->base_addr = xmallocarray (ncopies, sizeof ('rtype_name`));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/m4/transpose.m4
===================================================================
--- a/src/libgfortran/m4/transpose.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/transpose.m4	(.../branches/gcc-4_9-branch)
@@ -61,7 +61,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof ('rtype_name`));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/m4/iforeach.m4
===================================================================
--- a/src/libgfortran/m4/iforeach.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/iforeach.m4	(.../branches/gcc-4_9-branch)
@@ -30,7 +30,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (rtype_name) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));
     }
   else
     {
@@ -133,7 +133,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (rtype_name) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));
     }
   else
     {
@@ -264,7 +264,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (rtype_name) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (rtype_name));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/m4/eoshift1.m4
===================================================================
--- a/src/libgfortran/m4/eoshift1.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/eoshift1.m4	(.../branches/gcc-4_9-branch)
@@ -106,8 +106,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/m4/eoshift3.m4
===================================================================
--- a/src/libgfortran/m4/eoshift3.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/eoshift3.m4	(.../branches/gcc-4_9-branch)
@@ -90,7 +90,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -108,8 +108,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/m4/shape.m4
===================================================================
--- a/src/libgfortran/m4/shape.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/shape.m4	(.../branches/gcc-4_9-branch)
@@ -50,7 +50,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof ('rtype_name`));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/m4/cshift1.m4
===================================================================
--- a/src/libgfortran/m4/cshift1.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/cshift1.m4	(.../branches/gcc-4_9-branch)
@@ -81,7 +81,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/m4/matmull.m4
===================================================================
--- a/src/libgfortran/m4/matmull.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/matmull.m4	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof ('rtype_name`) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof ('rtype_name`));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/m4/bessel.m4
===================================================================
--- a/src/libgfortran/m4/bessel.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/bessel.m4	(.../branches/gcc-4_9-branch)
@@ -56,7 +56,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * size);
+      ret->base_addr = xmallocarray (size, sizeof ('rtype_name`));
       ret->offset = 0;
     }
 
@@ -123,7 +123,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof ('rtype_name`) * size);
+      ret->base_addr = xmallocarray (size, sizeof ('rtype_name`));
       ret->offset = 0;
     }
 
@@ -163,7 +163,7 @@
 
   x2rev = GFC_REAL_'rtype_kind`_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined('rtype_name`_INFINITY)
       if (unlikely (last2 == -'rtype_name`_INFINITY))
Index: libgfortran/m4/unpack.m4
===================================================================
--- a/src/libgfortran/m4/unpack.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/unpack.m4	(.../branches/gcc-4_9-branch)
@@ -100,7 +100,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof ('rtype_name`));
+      ret->base_addr = xmallocarray (rs, sizeof ('rtype_name`));
     }
   else
     {
@@ -245,7 +245,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof ('rtype_name`));
+      ret->base_addr = xmallocarray (rs, sizeof ('rtype_name`));
     }
   else
     {
Index: libgfortran/m4/reshape.m4
===================================================================
--- a/src/libgfortran/m4/reshape.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/reshape.m4	(.../branches/gcc-4_9-branch)
@@ -115,11 +115,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof ('rtype_name`);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof ('rtype_name`));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/m4/ifunction_logical.m4
===================================================================
--- a/src/libgfortran/m4/ifunction_logical.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/ifunction_logical.m4	(.../branches/gcc-4_9-branch)
@@ -89,8 +89,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -99,7 +98,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
     }
   else
     {
Index: libgfortran/m4/ifunction.m4
===================================================================
--- a/src/libgfortran/m4/ifunction.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/ifunction.m4	(.../branches/gcc-4_9-branch)
@@ -85,10 +85,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -260,8 +259,7 @@
 
 	}
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -273,7 +271,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
 
     }
   else
@@ -417,8 +415,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (rtype_name) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -427,7 +424,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));
     }
   else
     {
Index: libgfortran/m4/matmul.m4
===================================================================
--- a/src/libgfortran/m4/matmul.m4	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/m4/matmul.m4	(.../branches/gcc-4_9-branch)
@@ -125,7 +125,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof ('rtype_name`) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof ('rtype_name`));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/runtime/in_pack_generic.c
===================================================================
--- a/src/libgfortran/runtime/in_pack_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/in_pack_generic.c	(.../branches/gcc-4_9-branch)
@@ -180,7 +180,7 @@
     return source->base_addr;
 
    /* Allocate storage for the destination.  */
-  destptr = xmalloc (ssize * size);
+  destptr = xmallocarray (ssize, size);
   dest = (char *)destptr;
   src = source->base_addr;
   stride0 = stride[0] * size;
Index: libgfortran/runtime/memory.c
===================================================================
--- a/src/libgfortran/runtime/memory.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/memory.c	(.../branches/gcc-4_9-branch)
@@ -25,8 +25,13 @@
 
 #include "libgfortran.h"
 #include <stdlib.h>
+#include <errno.h>
 
+#ifndef SIZE_MAX
+#define SIZE_MAX ((size_t)-1)
+#endif
 
+
 void *
 xmalloc (size_t n)
 {
@@ -44,12 +49,36 @@
 }
 
 
+void *
+xmallocarray (size_t nmemb, size_t size)
+{
+  void *p;
+
+  if (!nmemb || !size)
+    size = nmemb = 1;
+#define HALF_SIZE_T (((size_t) 1) << (__CHAR_BIT__ * sizeof (size_t) / 2))
+  else if (__builtin_expect ((nmemb | size) >= HALF_SIZE_T, 0)
+	   && nmemb > SIZE_MAX / size)
+    {
+      errno = ENOMEM;
+      os_error ("Integer overflow in xmallocarray");
+    }
+
+  p = malloc (nmemb * size);
+
+  if (!p)
+    os_error ("Memory allocation failed in xmallocarray");
+
+  return p;
+}
+
+
 /* calloc wrapper that aborts on error.  */
 
 void *
 xcalloc (size_t nmemb, size_t size)
 {
-  if (nmemb * size == 0)
+  if (!nmemb || !size)
     nmemb = size = 1;
 
   void *p = calloc (nmemb, size);
Index: libgfortran/runtime/convert_char.c
===================================================================
--- a/src/libgfortran/runtime/convert_char.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/convert_char.c	(.../branches/gcc-4_9-branch)
@@ -44,7 +44,7 @@
   gfc_charlen_type i, l;
 
   l = len > 0 ? len : 0;
-  *dst = xmalloc ((l + 1) * sizeof (gfc_char4_t));
+  *dst = xmallocarray ((l + 1), sizeof (gfc_char4_t));
 
   for (i = 0; i < l; i++)
     (*dst)[i] = src[i];
@@ -60,7 +60,7 @@
   gfc_charlen_type i, l;
 
   l = len > 0 ? len : 0;
-  *dst = xmalloc ((l + 1) * sizeof (unsigned char));
+  *dst = xmalloc (l + 1);
 
   for (i = 0; i < l; i++)
     (*dst)[i] = src[i];
Index: libgfortran/runtime/environ.c
===================================================================
--- a/src/libgfortran/runtime/environ.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/runtime/environ.c	(.../branches/gcc-4_9-branch)
@@ -837,7 +837,7 @@
     }
   else
     {
-      elist = xmalloc (unit_count * sizeof (exception_t));
+      elist = xmallocarray (unit_count, sizeof (exception_t));
       do_count = 0;
       p = val;
       do_parse ();
Index: libgfortran/intrinsics/string_intrinsics_inc.c
===================================================================
--- a/src/libgfortran/intrinsics/string_intrinsics_inc.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/string_intrinsics_inc.c	(.../branches/gcc-4_9-branch)
@@ -164,7 +164,7 @@
   else
     {
       /* Allocate space for result string.  */
-      *dest = xmalloc (*len * sizeof (CHARTYPE));
+      *dest = xmallocarray (*len, sizeof (CHARTYPE));
 
       /* Copy string if necessary.  */
       memcpy (*dest, src, *len * sizeof (CHARTYPE));
@@ -442,7 +442,7 @@
     *dest = &zero_length_string;
   else
     {
-      CHARTYPE *tmp = xmalloc (*rlen * sizeof (CHARTYPE));
+      CHARTYPE *tmp = xmallocarray (*rlen, sizeof (CHARTYPE));
       memcpy (tmp, res, reslen * sizeof (CHARTYPE));
       MEMSET (&tmp[reslen], ' ', *rlen - reslen);
       *dest = tmp;
Index: libgfortran/intrinsics/pack_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/pack_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/pack_generic.c	(.../branches/gcc-4_9-branch)
@@ -152,8 +152,8 @@
 	  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);
 
 	  ret->offset = 0;
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (size * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, size);
 
 	  if (total == 0)
 	    return;      /* In this case, nothing remains to be done.  */
@@ -519,7 +519,7 @@
 
       ret->offset = 0;
 
-      ret->base_addr = xmalloc (size * total);
+      ret->base_addr = xmallocarray (total, size);
 
       if (total == 0)
 	return;
Index: libgfortran/intrinsics/transpose_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/transpose_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/transpose_generic.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,7 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (size * size0 ((array_t*)ret));
+      ret->base_addr = xmallocarray (size0 ((array_t*)ret), size);
       ret->offset = 0;
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/intrinsics/cshift0.c
===================================================================
--- a/src/libgfortran/intrinsics/cshift0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/cshift0.c	(.../branches/gcc-4_9-branch)
@@ -79,8 +79,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
         }
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/intrinsics/spread_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/spread_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/spread_generic.c	(.../branches/gcc-4_9-branch)
@@ -100,7 +100,7 @@
 	  GFC_DIMENSION_SET(ret->dim[n], 0, ub, stride);
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * size);
+      ret->base_addr = xmallocarray (rs, size);
 
       if (rs <= 0)
 	return;
@@ -245,7 +245,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * size);
+      ret->base_addr = xmallocarray (ncopies, size);
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/intrinsics/unpack_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/unpack_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/unpack_generic.c	(.../branches/gcc-4_9-branch)
@@ -125,7 +125,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * size);
+      ret->base_addr = xmallocarray (rs, size);
     }
   else
     {
Index: libgfortran/intrinsics/eoshift0.c
===================================================================
--- a/src/libgfortran/intrinsics/eoshift0.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/eoshift0.c	(.../branches/gcc-4_9-branch)
@@ -86,8 +86,8 @@
 
         }
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/intrinsics/eoshift2.c
===================================================================
--- a/src/libgfortran/intrinsics/eoshift2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/eoshift2.c	(.../branches/gcc-4_9-branch)
@@ -78,8 +78,8 @@
       ret->offset = 0;
       ret->dtype = array->dtype;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
         {
Index: libgfortran/intrinsics/reshape_generic.c
===================================================================
--- a/src/libgfortran/intrinsics/reshape_generic.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/intrinsics/reshape_generic.c	(.../branches/gcc-4_9-branch)
@@ -99,11 +99,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-	alloc_size = 1;
+	alloc_size = 0; /* xmalloc will allocate 1 byte.  */
       else
-	alloc_size = rs * size;
+	alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, size);
 
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,80 @@
+2014-10-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/63460
+	* io/unit.c (init_units): Initialize the DELIM flag to
+	UNSPECIFIED for the STDIN unit so that the flag is
+	correctly set later.
+
+2014-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-08-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* runtime/memory.c (xmallocarray): Avoid division for the common case.
+
+2014-08-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR libgfortran/62188
+	* m4/bessel.m4: Avoid indexing off the end of an array.
+	* generated/bessel_r10.c: Regenerated.
+	* generated/bessel_r16.c: Ditto.
+	* generated/bessel_r4.c: Ditto.
+	* generated/bessel_r8.c: Ditto.
+
+2014-07-31  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Backport from mainline
+	CVE-2014-5044
+        * libgfortran.h (xmallocarray): New prototype.
+        * runtime/memory.c (xmallocarray): New function.
+        (xcalloc): Check for nonzero separately instead of multiplying.
+        * generated/*.c: Regenerated.
+        * intrinsics/cshift0.c (cshift0): Call xmallocarray instead of
+        xmalloc.
+        * intrinsics/eoshift0.c (eoshift0): Likewise.
+        * intrinsics/eoshift2.c (eoshift2): Likewise.
+        * intrinsics/pack_generic.c (pack_internal): Likewise.
+        (pack_s_internal): Likewise.
+        * intrinsics/reshape_generic.c (reshape_internal): Likewise.
+        * intrinsics/spread_generic.c (spread_internal): Likewise.
+        (spread_internal_scalar): Likewise.
+        * intrinsics/string_intrinsics_inc.c (string_trim): Likewise.
+        (string_minmax): Likewise.
+        * intrinsics/transpose_generic.c (transpose_internal): Likewise.
+        * intrinsics/unpack_generic.c (unpack_internal): Likewise.
+        * io/list_read.c (nml_touch_nodes): Don't cast xmalloc return value.
+        * io/transfer.c (st_set_nml_var): Call xmallocarray instead of
+        xmalloc.
+        * io/unit.c (get_internal_unit): Likewise.
+        (filename_from_unit): Don't cast xmalloc return value.
+        * io/write.c (nml_write_obj): Likewise, formatting.
+        * m4/bessel.m4 (bessel_jn_r'rtype_kind`): Call xmallocarray
+        instead of xmalloc.
+        (besse_yn_r'rtype_kind`): Likewise.
+        * m4/cshift1.m4 (cshift1): Likewise.
+        * m4/eoshift1.m4 (eoshift1): Likewise.
+        * m4/eoshift3.m4 (eoshift3): Likewise.
+        * m4/iforeach.m4: Likewise.
+        * m4/ifunction.m4: Likewise.
+        * m4/ifunction_logical.m4 (name`'rtype_qual`_'atype_code):
+        Likewise.
+        * m4/in_pack.m4 (internal_pack_'rtype_ccode`): Likewise.
+        * m4/matmul.m4 (matmul_'rtype_code`): Likewise.
+        * m4/matmull.m4 (matmul_'rtype_code`): Likewise.
+        * m4/pack.m4 (pack_'rtype_code`): Likewise.
+        * m4/reshape.m4 (reshape_'rtype_ccode`): Likewise.
+        * m4/shape.m4 (shape_'rtype_kind`): Likewise.
+        * m4/spread.m4 (spread_'rtype_code`): Likewise.
+        (spread_scalar_'rtype_code`): Likewise.
+        * m4/transpose.m4 (transpose_'rtype_code`): Likewise.
+        * m4/unpack.m4 (unpack0_'rtype_code`): Likewise.
+        (unpack1_'rtype_code`): Likewise.
+        * runtime/convert_char.c (convert_char1_to_char4): Likewise.
+        (convert_char4_to_char1): Simplify.
+        * runtime/environ.c (init_unformatted): Call xmallocarray instead
+        of xmalloc.
+        * runtime/in_pack_generic.c (internal_pack): Likewise.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libgfortran/generated/spread_r10.c
===================================================================
--- a/src/libgfortran/generated/spread_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r10.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_10));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_10));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_10));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_10));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxloc1_4_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/norm2_r4.c
===================================================================
--- a/src/libgfortran/generated/norm2_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r4.c	(.../branches/gcc-4_9-branch)
@@ -101,10 +101,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/parity_l2.c
===================================================================
--- a/src/libgfortran/generated/parity_l2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/eoshift3_4.c
===================================================================
--- a/src/libgfortran/generated/eoshift3_4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift3_4.c	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -107,8 +107,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/transpose_c8.c
===================================================================
--- a/src/libgfortran/generated/transpose_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c8.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_8) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_8));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/eoshift1_8.c
===================================================================
--- a/src/libgfortran/generated/eoshift1_8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift1_8.c	(.../branches/gcc-4_9-branch)
@@ -105,8 +105,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/reshape_r16.c
===================================================================
--- a/src/libgfortran/generated/reshape_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r16.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_16);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/bessel_r4.c
===================================================================
--- a/src/libgfortran/generated/bessel_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r4.c	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_4));
       ret->offset = 0;
     }
 
@@ -122,7 +122,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_4));
       ret->offset = 0;
     }
 
@@ -162,7 +162,7 @@
 
   x2rev = GFC_REAL_4_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_4_INFINITY)
       if (unlikely (last2 == -GFC_REAL_4_INFINITY))
Index: libgfortran/generated/any_l2.c
===================================================================
--- a/src/libgfortran/generated/any_l2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l2.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_2));
     }
   else
     {
Index: libgfortran/generated/product_r4.c
===================================================================
--- a/src/libgfortran/generated/product_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/iany_i1.c
===================================================================
--- a/src/libgfortran/generated/iany_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/parity_l16.c
===================================================================
--- a/src/libgfortran/generated/parity_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/in_pack_r4.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r4.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_4 *)xmalloc (ssize * sizeof (GFC_REAL_4));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_4));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/product_i2.c
===================================================================
--- a/src/libgfortran/generated/product_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/iparity_i4.c
===================================================================
--- a/src/libgfortran/generated/iparity_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/reshape_c4.c
===================================================================
--- a/src/libgfortran/generated/reshape_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c4.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_4);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/maxloc0_4_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iall_i8.c
===================================================================
--- a/src/libgfortran/generated/iall_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/sum_r16.c
===================================================================
--- a/src/libgfortran/generated/sum_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/sum_i1.c
===================================================================
--- a/src/libgfortran/generated/sum_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/in_pack_i2.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i2.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_2 *)xmalloc (ssize * sizeof (GFC_INTEGER_2));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_2));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/transpose_r10.c
===================================================================
--- a/src/libgfortran/generated/transpose_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r10.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_10));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_16_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/spread_i1.c
===================================================================
--- a/src/libgfortran/generated/spread_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i1.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_1));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_1));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_1));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_1));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxloc0_16_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxval_r16.c
===================================================================
--- a/src/libgfortran/generated/maxval_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/product_c10.c
===================================================================
--- a/src/libgfortran/generated/product_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_r16.c
===================================================================
--- a/src/libgfortran/generated/matmul_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r16.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc0_4_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iany_i2.c
===================================================================
--- a/src/libgfortran/generated/iany_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/sum_r4.c
===================================================================
--- a/src/libgfortran/generated/sum_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/unpack_c8.c
===================================================================
--- a/src/libgfortran/generated/unpack_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c8.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_8));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_c16.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c16.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_16 *)xmalloc (ssize * sizeof (GFC_COMPLEX_16));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_16));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/minloc0_4_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_c10.c
===================================================================
--- a/src/libgfortran/generated/spread_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c10.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_10));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_10));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_10));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_10));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxloc0_8_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_r4.c
===================================================================
--- a/src/libgfortran/generated/spread_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_4));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_4));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_4));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_4));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/minloc0_8_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_c8.c
===================================================================
--- a/src/libgfortran/generated/matmul_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c8.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_16_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/sum_i2.c
===================================================================
--- a/src/libgfortran/generated/sum_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/iparity_i16.c
===================================================================
--- a/src/libgfortran/generated/iparity_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/reshape_c16.c
===================================================================
--- a/src/libgfortran/generated/reshape_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c16.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_16);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/pack_c4.c
===================================================================
--- a/src/libgfortran/generated/pack_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c4.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_4) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_4));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/parity_l4.c
===================================================================
--- a/src/libgfortran/generated/parity_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/spread_i2.c
===================================================================
--- a/src/libgfortran/generated/spread_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i2.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_2));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_2));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_2));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_2));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/any_l4.c
===================================================================
--- a/src/libgfortran/generated/any_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_4_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_8_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_8_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/product_i4.c
===================================================================
--- a/src/libgfortran/generated/product_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/sum_c16.c
===================================================================
--- a/src/libgfortran/generated/sum_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
     }
   else
     {
Index: libgfortran/generated/transpose_c10.c
===================================================================
--- a/src/libgfortran/generated/transpose_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c10.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_10) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_10));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_16_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/transpose_r4.c
===================================================================
--- a/src/libgfortran/generated/transpose_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r4.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_4));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/cshift1_4.c
===================================================================
--- a/src/libgfortran/generated/cshift1_4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/cshift1_4.c	(.../branches/gcc-4_9-branch)
@@ -80,7 +80,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/generated/maxloc0_8_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/count_8_l.c
===================================================================
--- a/src/libgfortran/generated/count_8_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_8_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_i4.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i4.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_4 *)xmalloc (ssize * sizeof (GFC_INTEGER_4));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_4));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/minloc0_16_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_8_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/matmul_c16.c
===================================================================
--- a/src/libgfortran/generated/matmul_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c16.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minval_i1.c
===================================================================
--- a/src/libgfortran/generated/minval_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/shape_i16.c
===================================================================
--- a/src/libgfortran/generated/shape_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/shape_i16.c	(.../branches/gcc-4_9-branch)
@@ -49,7 +49,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/generated/iany_i4.c
===================================================================
--- a/src/libgfortran/generated/iany_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/product_i16.c
===================================================================
--- a/src/libgfortran/generated/product_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/unpack_i1.c
===================================================================
--- a/src/libgfortran/generated/unpack_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i1.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_1));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_1));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_1));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_i1.c
===================================================================
--- a/src/libgfortran/generated/matmul_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i1.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_1) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minval_r4.c
===================================================================
--- a/src/libgfortran/generated/minval_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/spread_i16.c
===================================================================
--- a/src/libgfortran/generated/spread_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_16));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_16));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_16));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_16));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/sum_i4.c
===================================================================
--- a/src/libgfortran/generated/sum_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/unpack_r10.c
===================================================================
--- a/src/libgfortran/generated/unpack_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r10.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_10));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/bessel_r16.c
===================================================================
--- a/src/libgfortran/generated/bessel_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r16.c	(.../branches/gcc-4_9-branch)
@@ -59,7 +59,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_16));
       ret->offset = 0;
     }
 
@@ -126,7 +126,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_16));
       ret->offset = 0;
     }
 
@@ -166,7 +166,7 @@
 
   x2rev = GFC_REAL_16_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_16_INFINITY)
       if (unlikely (last2 == -GFC_REAL_16_INFINITY))
Index: libgfortran/generated/norm2_r8.c
===================================================================
--- a/src/libgfortran/generated/norm2_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r8.c	(.../branches/gcc-4_9-branch)
@@ -101,10 +101,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/spread_i4.c
===================================================================
--- a/src/libgfortran/generated/spread_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_4));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_4));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_4));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_4));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/eoshift3_8.c
===================================================================
--- a/src/libgfortran/generated/eoshift3_8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift3_8.c	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -107,8 +107,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_4_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minval_i2.c
===================================================================
--- a/src/libgfortran/generated/minval_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/bessel_r8.c
===================================================================
--- a/src/libgfortran/generated/bessel_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r8.c	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_8));
       ret->offset = 0;
     }
 
@@ -122,7 +122,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_8));
       ret->offset = 0;
     }
 
@@ -162,7 +162,7 @@
 
   x2rev = GFC_REAL_8_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_8_INFINITY)
       if (unlikely (last2 == -GFC_REAL_8_INFINITY))
Index: libgfortran/generated/unpack_r4.c
===================================================================
--- a/src/libgfortran/generated/unpack_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r4.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_4));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/product_r8.c
===================================================================
--- a/src/libgfortran/generated/product_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/matmul_r4.c
===================================================================
--- a/src/libgfortran/generated/matmul_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r4.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/unpack_i2.c
===================================================================
--- a/src/libgfortran/generated/unpack_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i2.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_2));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_2));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_2));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/in_pack_r8.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r8.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_8 *)xmalloc (ssize * sizeof (GFC_REAL_8));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_8));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/maxloc1_4_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/reshape_c8.c
===================================================================
--- a/src/libgfortran/generated/reshape_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c8.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_8);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/iparity_i8.c
===================================================================
--- a/src/libgfortran/generated/iparity_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/count_1_l.c
===================================================================
--- a/src/libgfortran/generated/count_1_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_1_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_i2.c
===================================================================
--- a/src/libgfortran/generated/matmul_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i2.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_2) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_4_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/transpose_i16.c
===================================================================
--- a/src/libgfortran/generated/transpose_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_i16.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_INTEGER_16));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_16_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/transpose_i4.c
===================================================================
--- a/src/libgfortran/generated/transpose_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_i4.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_INTEGER_4));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_16_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc1_4_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/matmul_l16.c
===================================================================
--- a/src/libgfortran/generated/matmul_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_l16.c	(.../branches/gcc-4_9-branch)
@@ -88,7 +88,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof (GFC_LOGICAL_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_LOGICAL_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/maxloc1_8_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_4_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/product_r16.c
===================================================================
--- a/src/libgfortran/generated/product_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/sum_r8.c
===================================================================
--- a/src/libgfortran/generated/sum_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/norm2_r10.c
===================================================================
--- a/src/libgfortran/generated/norm2_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r10.c	(.../branches/gcc-4_9-branch)
@@ -101,10 +101,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/unpack_c10.c
===================================================================
--- a/src/libgfortran/generated/unpack_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c10.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_10));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_10));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_10));
     }
   else
     {
Index: libgfortran/generated/spread_r8.c
===================================================================
--- a/src/libgfortran/generated/spread_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_8));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_8));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_8));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_8));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/minloc1_16_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/spread_r16.c
===================================================================
--- a/src/libgfortran/generated/spread_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_r16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_REAL_16));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_16));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_REAL_16));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_16));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/pack_c8.c
===================================================================
--- a/src/libgfortran/generated/pack_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c8.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_8) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_8));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/minval_r10.c
===================================================================
--- a/src/libgfortran/generated/minval_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/parity_l8.c
===================================================================
--- a/src/libgfortran/generated/parity_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/minval_i4.c
===================================================================
--- a/src/libgfortran/generated/minval_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/any_l8.c
===================================================================
--- a/src/libgfortran/generated/any_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_4_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_8_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_4_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/unpack_i4.c
===================================================================
--- a/src/libgfortran/generated/unpack_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i4.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/product_i8.c
===================================================================
--- a/src/libgfortran/generated/product_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/count_2_l.c
===================================================================
--- a/src/libgfortran/generated/count_2_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_2_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/transpose_r8.c
===================================================================
--- a/src/libgfortran/generated/transpose_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r8.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_8));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/cshift1_8.c
===================================================================
--- a/src/libgfortran/generated/cshift1_8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/cshift1_8.c	(.../branches/gcc-4_9-branch)
@@ -80,7 +80,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/generated/matmul_i4.c
===================================================================
--- a/src/libgfortran/generated/matmul_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i4.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/pack_r10.c
===================================================================
--- a/src/libgfortran/generated/pack_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r10.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_10));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/minloc1_16_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/in_pack_i8.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i8.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_8 *)xmalloc (ssize * sizeof (GFC_INTEGER_8));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_8));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/transpose_r16.c
===================================================================
--- a/src/libgfortran/generated/transpose_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_r16.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_REAL_16));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_4_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxval_i1.c
===================================================================
--- a/src/libgfortran/generated/maxval_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/product_c16.c
===================================================================
--- a/src/libgfortran/generated/product_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_16));
     }
   else
     {
Index: libgfortran/generated/reshape_r4.c
===================================================================
--- a/src/libgfortran/generated/reshape_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r4.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_4);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/iany_i8.c
===================================================================
--- a/src/libgfortran/generated/iany_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/cshift1_16.c
===================================================================
--- a/src/libgfortran/generated/cshift1_16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/cshift1_16.c	(.../branches/gcc-4_9-branch)
@@ -80,7 +80,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
Index: libgfortran/generated/maxloc0_4_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_4_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_c16.c
===================================================================
--- a/src/libgfortran/generated/spread_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_16));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_16));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_16));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_16));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxval_r4.c
===================================================================
--- a/src/libgfortran/generated/maxval_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_4));
     }
   else
     {
Index: libgfortran/generated/minval_r8.c
===================================================================
--- a/src/libgfortran/generated/minval_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/unpack_i16.c
===================================================================
--- a/src/libgfortran/generated/unpack_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i16.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/sum_i8.c
===================================================================
--- a/src/libgfortran/generated/sum_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/pack_i1.c
===================================================================
--- a/src/libgfortran/generated/pack_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i1.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_1) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_1));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/any_l16.c
===================================================================
--- a/src/libgfortran/generated/any_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_16));
     }
   else
     {
Index: libgfortran/generated/spread_i8.c
===================================================================
--- a/src/libgfortran/generated/spread_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_i8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_INTEGER_8));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_INTEGER_8));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_INTEGER_8));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_INTEGER_8));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxval_i2.c
===================================================================
--- a/src/libgfortran/generated/maxval_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/unpack_r8.c
===================================================================
--- a/src/libgfortran/generated/unpack_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r8.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_8));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/all_l1.c
===================================================================
--- a/src/libgfortran/generated/all_l1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l1.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_1));
     }
   else
     {
Index: libgfortran/generated/matmul_r8.c
===================================================================
--- a/src/libgfortran/generated/matmul_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r8.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc0_4_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc0_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_4_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_8_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/pack_c10.c
===================================================================
--- a/src/libgfortran/generated/pack_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c10.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_10) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_10));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/pack_r4.c
===================================================================
--- a/src/libgfortran/generated/pack_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r4.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_4) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_4));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/transpose_c16.c
===================================================================
--- a/src/libgfortran/generated/transpose_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c16.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_16) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_16));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_8_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_4_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_16_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_i2.c
===================================================================
--- a/src/libgfortran/generated/pack_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i2.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_2) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_2));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/transpose_i8.c
===================================================================
--- a/src/libgfortran/generated/transpose_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_i8.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_INTEGER_8));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/eoshift1_16.c
===================================================================
--- a/src/libgfortran/generated/eoshift1_16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift1_16.c	(.../branches/gcc-4_9-branch)
@@ -105,8 +105,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/all_l2.c
===================================================================
--- a/src/libgfortran/generated/all_l2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l2.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_2));
     }
   else
     {
Index: libgfortran/generated/product_c4.c
===================================================================
--- a/src/libgfortran/generated/product_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
     }
   else
     {
Index: libgfortran/generated/iall_i1.c
===================================================================
--- a/src/libgfortran/generated/iall_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/reshape_i4.c
===================================================================
--- a/src/libgfortran/generated/reshape_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_i4.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_INTEGER_4);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/in_pack_r10.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r10.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_10 *)xmalloc (ssize * sizeof (GFC_REAL_10));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_10));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/in_pack_c4.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c4.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_4 *)xmalloc (ssize * sizeof (GFC_COMPLEX_4));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_4));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/all_l16.c
===================================================================
--- a/src/libgfortran/generated/all_l16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l16.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_16));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_8_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minval_i16.c
===================================================================
--- a/src/libgfortran/generated/minval_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/reshape_r10.c
===================================================================
--- a/src/libgfortran/generated/reshape_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r10.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_10);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/unpack_r16.c
===================================================================
--- a/src/libgfortran/generated/unpack_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_r16.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_16));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_REAL_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/maxval_i4.c
===================================================================
--- a/src/libgfortran/generated/maxval_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minval_i8.c
===================================================================
--- a/src/libgfortran/generated/minval_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/shape_i4.c
===================================================================
--- a/src/libgfortran/generated/shape_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/shape_i4.c	(.../branches/gcc-4_9-branch)
@@ -49,7 +49,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/generated/minloc1_4_i16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_8_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iall_i2.c
===================================================================
--- a/src/libgfortran/generated/iall_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc0_8_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/minloc1_16_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/unpack_i8.c
===================================================================
--- a/src/libgfortran/generated/unpack_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_i8.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_INTEGER_8));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/count_4_l.c
===================================================================
--- a/src/libgfortran/generated/count_4_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_4_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/sum_r10.c
===================================================================
--- a/src/libgfortran/generated/sum_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/sum_c4.c
===================================================================
--- a/src/libgfortran/generated/sum_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/pack_i16.c
===================================================================
--- a/src/libgfortran/generated/pack_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i16.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_16));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/matmul_i8.c
===================================================================
--- a/src/libgfortran/generated/matmul_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i8.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/maxloc0_16_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/spread_c4.c
===================================================================
--- a/src/libgfortran/generated/spread_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_4));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_4));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_4));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_4));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/maxval_r10.c
===================================================================
--- a/src/libgfortran/generated/maxval_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/pack_i4.c
===================================================================
--- a/src/libgfortran/generated/pack_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i4.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_4));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/maxloc1_4_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/matmul_r10.c
===================================================================
--- a/src/libgfortran/generated/matmul_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_r10.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_REAL_10) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_10));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minloc1_4_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_l4.c
===================================================================
--- a/src/libgfortran/generated/matmul_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_l4.c	(.../branches/gcc-4_9-branch)
@@ -88,7 +88,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof (GFC_LOGICAL_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_LOGICAL_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/reshape_r8.c
===================================================================
--- a/src/libgfortran/generated/reshape_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_r8.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_REAL_8);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/in_pack_c10.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c10.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_10 *)xmalloc (ssize * sizeof (GFC_COMPLEX_10));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_10));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/all_l4.c
===================================================================
--- a/src/libgfortran/generated/all_l4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l4.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_4));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/norm2_r16.c
===================================================================
--- a/src/libgfortran/generated/norm2_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/norm2_r16.c	(.../branches/gcc-4_9-branch)
@@ -105,10 +105,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/reshape_c10.c
===================================================================
--- a/src/libgfortran/generated/reshape_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_c10.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_COMPLEX_10);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/unpack_c16.c
===================================================================
--- a/src/libgfortran/generated/unpack_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c16.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_16));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_16));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxval_r8.c
===================================================================
--- a/src/libgfortran/generated/maxval_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_r8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_8));
     }
   else
     {
Index: libgfortran/generated/transpose_c4.c
===================================================================
--- a/src/libgfortran/generated/transpose_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/transpose_c4.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,8 @@
       GFC_DIMENSION_SET(ret->dim[1], 0, GFC_DESCRIPTOR_EXTENT(source,0) - 1,
 			GFC_DESCRIPTOR_EXTENT(source, 1));
 
-      ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_4) * size0 ((array_t *) ret));
+      ret->base_addr = xmallocarray (size0 ((array_t *) ret), 
+                                     sizeof (GFC_COMPLEX_4));
       ret->offset = 0;
     } else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/eoshift1_4.c
===================================================================
--- a/src/libgfortran/generated/eoshift1_4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift1_4.c	(.../branches/gcc-4_9-branch)
@@ -105,8 +105,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/minval_r16.c
===================================================================
--- a/src/libgfortran/generated/minval_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minval_r16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_16));
     }
   else
     {
Index: libgfortran/generated/iany_i16.c
===================================================================
--- a/src/libgfortran/generated/iany_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iany_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc0_16_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/sum_c10.c
===================================================================
--- a/src/libgfortran/generated/sum_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_10));
     }
   else
     {
Index: libgfortran/generated/iall_i4.c
===================================================================
--- a/src/libgfortran/generated/iall_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i4.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/minloc1_4_r16.c
===================================================================
--- a/src/libgfortran/generated/minloc1_4_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_4_r16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc0_8_r16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_8_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_8_r16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_r8.c
===================================================================
--- a/src/libgfortran/generated/pack_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r8.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_8) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_8));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/matmul_c10.c
===================================================================
--- a/src/libgfortran/generated/matmul_c10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c10.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_10) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/maxloc0_16_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_r16.c
===================================================================
--- a/src/libgfortran/generated/pack_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_r16.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_REAL_16) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_16));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/minloc1_16_i8.c
===================================================================
--- a/src/libgfortran/generated/minloc1_16_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_16_i8.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc0_16_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc0_16_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_16_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/unpack_c4.c
===================================================================
--- a/src/libgfortran/generated/unpack_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/unpack_c4.c	(.../branches/gcc-4_9-branch)
@@ -99,7 +99,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_4));
     }
   else
     {
@@ -244,7 +244,7 @@
 	  rs *= extent[n];
 	}
       ret->offset = 0;
-      ret->base_addr = xmalloc (rs * sizeof (GFC_COMPLEX_4));
+      ret->base_addr = xmallocarray (rs, sizeof (GFC_COMPLEX_4));
     }
   else
     {
Index: libgfortran/generated/iparity_i1.c
===================================================================
--- a/src/libgfortran/generated/iparity_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/product_c8.c
===================================================================
--- a/src/libgfortran/generated/product_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_c8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_i16.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i16.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_16 *)xmalloc (ssize * sizeof (GFC_INTEGER_16));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_16));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/minloc0_8_i4.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_i4.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_c4.c
===================================================================
--- a/src/libgfortran/generated/matmul_c4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_c4.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_COMPLEX_4) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/reshape_i8.c
===================================================================
--- a/src/libgfortran/generated/reshape_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_i8.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_INTEGER_8);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/in_pack_c8.c
===================================================================
--- a/src/libgfortran/generated/in_pack_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_c8.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_COMPLEX_8 *)xmalloc (ssize * sizeof (GFC_COMPLEX_8));
+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_8));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/bessel_r10.c
===================================================================
--- a/src/libgfortran/generated/bessel_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/bessel_r10.c	(.../branches/gcc-4_9-branch)
@@ -55,7 +55,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_10));
       ret->offset = 0;
     }
 
@@ -122,7 +122,7 @@
     {
       size_t size = n2 < n1 ? 0 : n2-n1+1; 
       GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);
-      ret->base_addr = xmalloc (sizeof (GFC_REAL_10) * size);
+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_10));
       ret->offset = 0;
     }
 
@@ -162,7 +162,7 @@
 
   x2rev = GFC_REAL_10_LITERAL(2.)/x;
 
-  for (i = 2; i <= n1+n2; i++)
+  for (i = 2; i <= n2 - n1; i++)
     {
 #if defined(GFC_REAL_10_INFINITY)
       if (unlikely (last2 == -GFC_REAL_10_INFINITY))
Index: libgfortran/generated/iall_i16.c
===================================================================
--- a/src/libgfortran/generated/iall_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iall_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_i1.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/reshape_i16.c
===================================================================
--- a/src/libgfortran/generated/reshape_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/reshape_i16.c	(.../branches/gcc-4_9-branch)
@@ -111,11 +111,11 @@
       ret->offset = 0;
 
       if (unlikely (rs < 1))
-        alloc_size = 1;
+        alloc_size = 0;
       else
-        alloc_size = rs * sizeof (GFC_INTEGER_16);
+        alloc_size = rs;
 
-      ret->base_addr = xmalloc (alloc_size);
+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;
     }
 
Index: libgfortran/generated/count_16_l.c
===================================================================
--- a/src/libgfortran/generated/count_16_l.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/count_16_l.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i1.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/maxloc1_4_i4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_i4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_i4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxval_i8.c
===================================================================
--- a/src/libgfortran/generated/maxval_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/eoshift3_16.c
===================================================================
--- a/src/libgfortran/generated/eoshift3_16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/eoshift3_16.c	(.../branches/gcc-4_9-branch)
@@ -89,7 +89,7 @@
     {
       int i;
 
-      ret->base_addr = xmalloc (size * arraysize);
+      ret->base_addr = xmallocarray (arraysize, size);
       ret->offset = 0;
       ret->dtype = array->dtype;
       for (i = 0; i < GFC_DESCRIPTOR_RANK (array); i++)
@@ -107,8 +107,8 @@
 	  GFC_DIMENSION_SET(ret->dim[i], 0, ub, str);
 
         }
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (size * arraysize);
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (arraysize, size);
 
     }
   else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/shape_i8.c
===================================================================
--- a/src/libgfortran/generated/shape_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/shape_i8.c	(.../branches/gcc-4_9-branch)
@@ -49,7 +49,7 @@
     {
       GFC_DIMENSION_SET(ret->dim[0], 0, rank - 1, 1);
       ret->offset = 0;
-      ret->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      ret->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
 
   stride = GFC_DESCRIPTOR_STRIDE(ret,0);
Index: libgfortran/generated/maxloc0_4_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i16.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/maxloc1_4_r10.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_4_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_4_r10.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));
     }
   else
     {
Index: libgfortran/generated/maxloc1_8_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_8_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_8_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r10.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r10.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/iparity_i2.c
===================================================================
--- a/src/libgfortran/generated/iparity_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/iparity_i2.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_2));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_r4.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc0_16_r8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_16_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_16_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_16) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/sum_i16.c
===================================================================
--- a/src/libgfortran/generated/sum_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/maxloc0_4_i8.c
===================================================================
--- a/src/libgfortran/generated/maxloc0_4_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc0_4_i8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_4) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/pack_c16.c
===================================================================
--- a/src/libgfortran/generated/pack_c16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_c16.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_COMPLEX_16) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_16));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/maxloc1_16_i16.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i16.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_r4.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_r4.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_r4.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/sum_c8.c
===================================================================
--- a/src/libgfortran/generated/sum_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/sum_c8.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_COMPLEX_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_8));
     }
   else
     {
Index: libgfortran/generated/maxloc1_16_i2.c
===================================================================
--- a/src/libgfortran/generated/maxloc1_16_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxloc1_16_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/parity_l1.c
===================================================================
--- a/src/libgfortran/generated/parity_l1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/parity_l1.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
Index: libgfortran/generated/maxval_i16.c
===================================================================
--- a/src/libgfortran/generated/maxval_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/maxval_i16.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -286,8 +285,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -299,7 +297,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
 
     }
   else
@@ -472,8 +470,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -482,7 +479,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));
     }
   else
     {
Index: libgfortran/generated/spread_c8.c
===================================================================
--- a/src/libgfortran/generated/spread_c8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/spread_c8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,8 @@
 	}
       ret->offset = 0;
 
-      /* xmalloc allocates a single byte for zero size.  */
-      ret->base_addr = xmalloc (rs * sizeof(GFC_COMPLEX_8));
+      /* xmallocarray allocates a single byte for zero size.  */
+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_8));
       if (rs <= 0)
         return;
     }
@@ -244,7 +244,7 @@
 
   if (ret->base_addr == NULL)
     {
-      ret->base_addr = xmalloc (ncopies * sizeof (GFC_COMPLEX_8));
+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_8));
       ret->offset = 0;
       GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);
     }
Index: libgfortran/generated/matmul_i16.c
===================================================================
--- a/src/libgfortran/generated/matmul_i16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_i16.c	(.../branches/gcc-4_9-branch)
@@ -124,7 +124,7 @@
         }
 
       retarray->base_addr
-	= xmalloc (sizeof (GFC_INTEGER_16) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/pack_i8.c
===================================================================
--- a/src/libgfortran/generated/pack_i8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/pack_i8.c	(.../branches/gcc-4_9-branch)
@@ -167,8 +167,8 @@
 
 	  ret->offset = 0;
 
-	  /* xmalloc allocates a single byte for zero size.  */
-	  ret->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * total);
+	  /* xmallocarray allocates a single byte for zero size.  */
+	  ret->base_addr = xmallocarray (total, sizeof (GFC_INTEGER_8));
 
 	  if (total == 0)
 	    return;
Index: libgfortran/generated/any_l1.c
===================================================================
--- a/src/libgfortran/generated/any_l1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/any_l1.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_1));
     }
   else
     {
Index: libgfortran/generated/minloc1_8_i2.c
===================================================================
--- a/src/libgfortran/generated/minloc1_8_i2.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc1_8_i2.c	(.../branches/gcc-4_9-branch)
@@ -98,10 +98,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -294,8 +293,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -307,7 +305,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
 
     }
   else
@@ -485,8 +483,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -495,7 +492,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));
     }
   else
     {
Index: libgfortran/generated/minloc0_8_r8.c
===================================================================
--- a/src/libgfortran/generated/minloc0_8_r8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/minloc0_8_r8.c	(.../branches/gcc-4_9-branch)
@@ -58,7 +58,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -199,7 +199,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else
     {
@@ -367,7 +367,7 @@
       GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);
       retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;
       retarray->offset = 0;
-      retarray->base_addr = xmalloc (sizeof (GFC_INTEGER_8) * rank);
+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));
     }
   else if (unlikely (compile_options.bounds_check))
     {
Index: libgfortran/generated/matmul_l8.c
===================================================================
--- a/src/libgfortran/generated/matmul_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/matmul_l8.c	(.../branches/gcc-4_9-branch)
@@ -88,7 +88,7 @@
         }
           
       retarray->base_addr
-	= xmalloc (sizeof (GFC_LOGICAL_8) * size0 ((array_t *) retarray));
+	= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_LOGICAL_8));
       retarray->offset = 0;
     }
     else if (unlikely (compile_options.bounds_check))
Index: libgfortran/generated/product_r10.c
===================================================================
--- a/src/libgfortran/generated/product_r10.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_r10.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_REAL_10) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_10));
     }
   else
     {
Index: libgfortran/generated/product_i1.c
===================================================================
--- a/src/libgfortran/generated/product_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/product_i1.c	(.../branches/gcc-4_9-branch)
@@ -97,10 +97,9 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
-      retarray->base_addr = xmalloc (alloc_size);
+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
       if (alloc_size == 0)
 	{
 	  /* Make sure we have a zero-sized array.  */
@@ -272,8 +271,7 @@
 
 	}
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
@@ -285,7 +283,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
 
     }
   else
@@ -430,8 +428,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -440,7 +437,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));
     }
   else
     {
Index: libgfortran/generated/all_l8.c
===================================================================
--- a/src/libgfortran/generated/all_l8.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/all_l8.c	(.../branches/gcc-4_9-branch)
@@ -101,8 +101,7 @@
       retarray->offset = 0;
       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;
 
-      alloc_size = sizeof (GFC_LOGICAL_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)
-    		   * extent[rank-1];
+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];
 
       if (alloc_size == 0)
 	{
@@ -111,7 +110,7 @@
 	  return;
 	}
       else
-	retarray->base_addr = xmalloc (alloc_size);
+	retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_LOGICAL_8));
     }
   else
     {
Index: libgfortran/generated/in_pack_r16.c
===================================================================
--- a/src/libgfortran/generated/in_pack_r16.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_r16.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_REAL_16 *)xmalloc (ssize * sizeof (GFC_REAL_16));
+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_16));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/generated/in_pack_i1.c
===================================================================
--- a/src/libgfortran/generated/in_pack_i1.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/generated/in_pack_i1.c	(.../branches/gcc-4_9-branch)
@@ -76,7 +76,7 @@
     return source->base_addr;
 
   /* Allocate storage for the destination.  */
-  destptr = (GFC_INTEGER_1 *)xmalloc (ssize * sizeof (GFC_INTEGER_1));
+  destptr = xmallocarray (ssize, sizeof (GFC_INTEGER_1));
   dest = destptr;
   src = source->base_addr;
   stride0 = stride[0];
Index: libgfortran/libgfortran.h
===================================================================
--- a/src/libgfortran/libgfortran.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/libgfortran.h	(.../branches/gcc-4_9-branch)
@@ -768,6 +768,9 @@
 extern void *xmalloc (size_t) __attribute__ ((malloc));
 internal_proto(xmalloc);
 
+extern void *xmallocarray (size_t, size_t) __attribute__ ((malloc));
+internal_proto(xmallocarray);
+
 extern void *xcalloc (size_t, size_t) __attribute__ ((malloc));
 internal_proto(xcalloc);
 
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-4_9-branch)
@@ -2407,7 +2407,7 @@
 {
   index_type len = strlen (nl->var_name) + 1;
   int dim;
-  char * ext_name = (char*)xmalloc (len + 1);
+  char * ext_name = xmalloc (len + 1);
   memcpy (ext_name, nl->var_name, len-1);
   memcpy (ext_name + len - 1, "%", 2);
   for (nl = nl->next; nl; nl = nl->next)
Index: libgfortran/io/unit.c
===================================================================
--- a/src/libgfortran/io/unit.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/unit.c	(.../branches/gcc-4_9-branch)
@@ -454,7 +454,7 @@
     {
       iunit->rank = GFC_DESCRIPTOR_RANK (dtp->internal_unit_desc);
       iunit->ls = (array_loop_spec *)
-	xmalloc (iunit->rank * sizeof (array_loop_spec));
+	xmallocarray (iunit->rank, sizeof (array_loop_spec));
       dtp->internal_unit_len *=
 	init_loop_spec (dtp->internal_unit_desc, iunit->ls, &start_record);
 
@@ -580,6 +580,7 @@
       u->flags.position = POSITION_ASIS;
       u->flags.sign = SIGN_SUPPRESS;
       u->flags.decimal = DECIMAL_POINT;
+      u->flags.delim = DELIM_UNSPECIFIED;
       u->flags.encoding = ENCODING_DEFAULT;
       u->flags.async = ASYNC_NO;
       u->flags.round = ROUND_UNSPECIFIED;
Index: libgfortran/io/transfer.c
===================================================================
--- a/src/libgfortran/io/transfer.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/transfer.c	(.../branches/gcc-4_9-branch)
@@ -3786,9 +3786,9 @@
   if (nml->var_rank > 0)
     {
       nml->dim = (descriptor_dimension*)
-		   xmalloc (nml->var_rank * sizeof (descriptor_dimension));
+	xmallocarray (nml->var_rank, sizeof (descriptor_dimension));
       nml->ls = (array_loop_spec*)
-		  xmalloc (nml->var_rank * sizeof (array_loop_spec));
+	xmallocarray (nml->var_rank, sizeof (array_loop_spec));
     }
   else
     {
Index: libgfortran/io/write.c
===================================================================
--- a/src/libgfortran/io/write.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libgfortran/io/write.c	(.../branches/gcc-4_9-branch)
@@ -1864,7 +1864,7 @@
 	      base_var_name_len = base ? strlen (base->var_name) : 0;
 	      ext_name_len = base_name_len + base_var_name_len 
 		+ strlen (obj->var_name) + obj->var_rank * NML_DIGITS + 1;
-	      ext_name = (char*)xmalloc (ext_name_len);
+	      ext_name = xmalloc (ext_name_len);
 
 	      memcpy (ext_name, base_name, base_name_len);
 	      clen = strlen (obj->var_name + base_var_name_len);
@@ -1893,7 +1893,7 @@
 	      /* Now obj_name.  */
 
 	      obj_name_len = strlen (obj->var_name) + 1;
-	      obj_name = xmalloc (obj_name_len+1);
+	      obj_name = xmalloc (obj_name_len + 1);
 	      memcpy (obj_name, obj->var_name, obj_name_len-1);
 	      memcpy (obj_name + obj_name_len-1, "%", 2);
 
Index: libada/Makefile.in
===================================================================
--- a/src/libada/Makefile.in	(.../tags/gcc_4_9_1_release)
+++ b/src/libada/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,7 @@
 PICFLAG = @PICFLAG@
 GNATLIBFLAGS= -W -Wall -gnatpg -nostdinc
 GNATLIBCFLAGS= -g -O2
-GNATLIBCFLAGS_FOR_C = -W -Wall $(GNATLIBCFLAGS) \
+GNATLIBCFLAGS_FOR_C = -W -Wall $(GNATLIBCFLAGS) $(CFLAGS_FOR_TARGET) \
 	-fexceptions -DIN_RTS @have_getipinfo@
 
 host_subdir = @host_subdir@
Index: libada/ChangeLog
===================================================================
--- a/src/libada/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libada/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,7 @@
+2014-08-12  Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* Makefile.in: Add CFLAGS_FOR_TARGET to GNATLIBCFLAGS_FOR_C.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libffi/src/powerpc/linux64_closure.S
===================================================================
--- a/src/libffi/src/powerpc/linux64_closure.S	(.../tags/gcc_4_9_1_release)
+++ b/src/libffi/src/powerpc/linux64_closure.S	(.../branches/gcc-4_9-branch)
@@ -381,7 +381,8 @@
 	.align 3
 .LEFDE1:
 
-# if defined __ELF__ && defined __linux__
+#endif
+
+#if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2
 	.section	.note.GNU-stack,"",@progbits
-# endif
 #endif
Index: libffi/src/powerpc/linux64.S
===================================================================
--- a/src/libffi/src/powerpc/linux64.S	(.../tags/gcc_4_9_1_release)
+++ b/src/libffi/src/powerpc/linux64.S	(.../branches/gcc-4_9-branch)
@@ -254,7 +254,8 @@
 	.align 3
 .LEFDE1:
 
-# if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2
+#endif
+
+#if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2
 	.section	.note.GNU-stack,"",@progbits
-# endif
 #endif
Index: libffi/ChangeLog
===================================================================
--- a/src/libffi/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libffi/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,9 @@
+2014-09-11  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/powerpc/linux64.S: Emit .note.GNU-stack even when
+	POWERPC64 is not defined.
+	* src/powerpc/linux64_closure.S: Likewise.  Also test _CALL_ELF == 2.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libcpp/directives.c
===================================================================
--- a/src/libcpp/directives.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/directives.c	(.../branches/gcc-4_9-branch)
@@ -549,6 +549,11 @@
       if (is_def_or_undef && node == pfile->spec_nodes.n_defined)
 	cpp_error (pfile, CPP_DL_ERROR,
 		   "\"defined\" cannot be used as a macro name");
+      else if (is_def_or_undef
+	    && (node == pfile->spec_nodes.n__has_include__
+	     || node == pfile->spec_nodes.n__has_include_next__))
+	cpp_error (pfile, CPP_DL_ERROR,
+		   "\"__has_include__\" cannot be used as a macro name");
       else if (! (node->flags & NODE_POISONED))
 	return node;
     }
@@ -2601,3 +2606,12 @@
       node->directive_index = i;
     }
 }
+
+/* Extract header file from a bracket include. Parsing starts after '<'.
+   The string is malloced and must be freed by the caller.  */
+char *
+_cpp_bracket_include(cpp_reader *pfile)
+{
+  return glue_header_name (pfile);
+}
+
Index: libcpp/files.c
===================================================================
--- a/src/libcpp/files.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/files.c	(.../branches/gcc-4_9-branch)
@@ -1023,6 +1023,9 @@
   int sysp = pfile->line_table->highest_line > 1 && pfile->buffer ? pfile->buffer->sysp : 0;
   bool print_dep = CPP_OPTION (pfile, deps.style) > (angle_brackets || !!sysp);
 
+  if (pfile->state.in__has_include__)
+    return;
+
   errno = file->err_no;
   if (print_dep && CPP_OPTION (pfile, deps.missing_files) && errno == ENOENT)
     {
@@ -1939,3 +1942,18 @@
   return bsearch (&d, pchf->entries, pchf->count, sizeof (struct pchf_entry),
 		  pchf_compare) != NULL;
 }
+
+/* Return true if the file FNAME is found in the appropriate include file path
+   as indicated by ANGLE_BRACKETS.  */
+
+bool
+_cpp_has_header (cpp_reader *pfile, const char *fname, int angle_brackets,
+		 enum include_type type)
+{
+  cpp_dir *start_dir = search_path_head (pfile, fname, angle_brackets, type);
+  _cpp_file *file = _cpp_find_file (pfile, fname, start_dir,
+				    /*fake=*/false, angle_brackets,
+				    /*implicit_preinclude=*/false);
+  return file->err_no != ENOENT;
+}
+
Index: libcpp/identifiers.c
===================================================================
--- a/src/libcpp/identifiers.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/identifiers.c	(.../branches/gcc-4_9-branch)
@@ -72,6 +72,8 @@
   s->n_false		= cpp_lookup (pfile, DSC("false"));
   s->n__VA_ARGS__       = cpp_lookup (pfile, DSC("__VA_ARGS__"));
   s->n__VA_ARGS__->flags |= NODE_DIAGNOSTIC;
+  s->n__has_include__   = cpp_lookup (pfile, DSC("__has_include__"));
+  s->n__has_include_next__ = cpp_lookup (pfile, DSC("__has_include_next__"));
 }
 
 /* Tear down the identifier hash table.  */
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,20 @@
+libcpp/
+
+2014-10-08  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	Implement SD-6: SG10 Feature Test Recommendations
+	* internal.h (lexer_state, spec_nodes): Add in__has_include__.
+	* directives.c: Support __has_include__ builtin.
+	* expr.c (parse_has_include): New function to parse __has_include__
+	builtin; (eval_token()): Use it.
+	* files.c (_cpp_has_header()): New funtion to look for header;
+	(open_file_failed()): Not an error to not find a header file for
+	__has_include__.
+	* identifiers.c (_cpp_init_hashtable()): Add entry for __has_include__.
+	* pch.c (cpp_read_state): Lookup __has_include__.
+	* traditional.c (enum ls, _cpp_scan_out_logical_line()): Walk through
+	__has_include__ statements.
+
 2014-07-16  Release Manager
 
 	* GCC 4.9.1 released.
Index: libcpp/traditional.c
===================================================================
--- a/src/libcpp/traditional.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/traditional.c	(.../branches/gcc-4_9-branch)
@@ -74,7 +74,9 @@
 	 ls_defined_close,	/* Looking for ')' of defined().  */
 	 ls_hash,		/* After # in preprocessor conditional.  */
 	 ls_predicate,		/* After the predicate, maybe paren?  */
-	 ls_answer};		/* In answer to predicate.  */
+	 ls_answer,		/* In answer to predicate.  */
+	 ls_has_include,	/* After __has_include__.  */
+	 ls_has_include_close};	/* Looking for ')' of __has_include__.  */
 
 /* Lexing TODO: Maybe handle space in escaped newlines.  Stop lex.c
    from recognizing comments and directives during its lexing pass.  */
@@ -524,6 +526,13 @@
 		  lex_state = ls_defined;
 		  continue;
 		}
+	      else if (pfile->state.in_expression
+		       && (node == pfile->spec_nodes.n__has_include__
+			|| node == pfile->spec_nodes.n__has_include_next__))
+		{
+		  lex_state = ls_has_include;
+		  continue;
+		}
 	    }
 	  break;
 
@@ -547,6 +556,8 @@
 		lex_state = ls_answer;
 	      else if (lex_state == ls_defined)
 		lex_state = ls_defined_close;
+	      else if (lex_state == ls_has_include)
+		lex_state = ls_has_include_close;
 	    }
 	  break;
 
@@ -584,7 +595,8 @@
 		      goto new_context;
 		    }
 		}
-	      else if (lex_state == ls_answer || lex_state == ls_defined_close)
+	      else if (lex_state == ls_answer || lex_state == ls_defined_close
+			|| lex_state == ls_has_include_close)
 		lex_state = ls_none;
 	    }
 	  break;
@@ -665,7 +677,8 @@
 	lex_state = ls_none;
       else if (lex_state == ls_hash
 	       || lex_state == ls_predicate
-	       || lex_state == ls_defined)
+	       || lex_state == ls_defined
+	       || lex_state == ls_has_include)
 	lex_state = ls_none;
 
       /* ls_answer and ls_defined_close keep going until ')'.  */
Index: libcpp/pch.c
===================================================================
--- a/src/libcpp/pch.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/pch.c	(.../branches/gcc-4_9-branch)
@@ -833,6 +833,8 @@
     s->n_true		= cpp_lookup (r, DSC("true"));
     s->n_false		= cpp_lookup (r, DSC("false"));
     s->n__VA_ARGS__     = cpp_lookup (r, DSC("__VA_ARGS__"));
+    s->n__has_include__ = cpp_lookup (r, DSC("__has_include__"));
+    s->n__has_include_next__ = cpp_lookup (r, DSC("__has_include_next__"));
   }
 
   old_state = r->state;
Index: libcpp/expr.c
===================================================================
--- a/src/libcpp/expr.c	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/expr.c	(.../branches/gcc-4_9-branch)
@@ -64,6 +64,8 @@
 static unsigned int interpret_int_suffix (cpp_reader *, const uchar *, size_t);
 static void check_promotion (cpp_reader *, const struct op *);
 
+static cpp_num parse_has_include (cpp_reader *, enum include_type);
+
 /* Token type abuse to create unary plus and minus operators.  */
 #define CPP_UPLUS ((enum cpp_ttype) (CPP_LAST_CPP_OP + 1))
 #define CPP_UMINUS ((enum cpp_ttype) (CPP_LAST_CPP_OP + 2))
@@ -1041,6 +1043,10 @@
     case CPP_NAME:
       if (token->val.node.node == pfile->spec_nodes.n_defined)
 	return parse_defined (pfile);
+      else if (token->val.node.node == pfile->spec_nodes.n__has_include__)
+	return parse_has_include (pfile, IT_INCLUDE);
+      else if (token->val.node.node == pfile->spec_nodes.n__has_include_next__)
+	return parse_has_include (pfile, IT_INCLUDE_NEXT);
       else if (CPP_OPTION (pfile, cplusplus)
 	       && (token->val.node.node == pfile->spec_nodes.n_true
 		   || token->val.node.node == pfile->spec_nodes.n_false))
@@ -2065,3 +2071,72 @@
 
   return lhs;
 }
+
+/* Handle meeting "__has_include__" in a preprocessor expression.  */
+static cpp_num
+parse_has_include (cpp_reader *pfile, enum include_type type)
+{
+  cpp_num result;
+  bool paren = false;
+  cpp_hashnode *node = 0;
+  const cpp_token *token;
+  bool bracket = false;
+  char *fname = 0;
+
+  result.unsignedp = false;
+  result.high = 0;
+  result.overflow = false;
+  result.low = 0;
+
+  pfile->state.in__has_include__++;
+
+  token = cpp_get_token (pfile);
+  if (token->type == CPP_OPEN_PAREN)
+    {
+      paren = true;
+      token = cpp_get_token (pfile);
+    }
+
+  if (token->type == CPP_STRING || token->type == CPP_HEADER_NAME)
+    {
+      if (token->type == CPP_HEADER_NAME)
+	bracket = true;
+      fname = XNEWVEC (char, token->val.str.len - 1);
+      memcpy (fname, token->val.str.text + 1, token->val.str.len - 2);
+      fname[token->val.str.len - 2] = '\0';
+      node = token->val.node.node;
+    }
+  else if (token->type == CPP_LESS)
+    {
+      bracket = true;
+      fname = _cpp_bracket_include (pfile);
+    }
+  else
+    cpp_error (pfile, CPP_DL_ERROR,
+	       "operator \"__has_include__\" requires a header string");
+
+  if (fname)
+    {
+      int angle_brackets = (bracket ? 1 : 0);
+
+      if (_cpp_has_header (pfile, fname, angle_brackets, type))
+	result.low = 1;
+      else
+	result.low = 0;
+
+      XDELETEVEC (fname);
+    }
+
+  if (paren && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)
+    cpp_error (pfile, CPP_DL_ERROR,
+	       "missing ')' after \"__has_include__\"");
+
+  /* A possible controlling macro of the form #if !__has_include__ ().
+     _cpp_parse_expr checks there was no other junk on the line.  */
+  if (node)
+    pfile->mi_ind_cmacro = node;
+
+  pfile->state.in__has_include__--;
+
+  return result;
+}
Index: libcpp/internal.h
===================================================================
--- a/src/libcpp/internal.h	(.../tags/gcc_4_9_1_release)
+++ b/src/libcpp/internal.h	(.../branches/gcc-4_9-branch)
@@ -258,6 +258,9 @@
   /* Nonzero when parsing arguments to a function-like macro.  */
   unsigned char parsing_args;
 
+  /* Nonzero if in a __has_include__ or __has_include_next__ statement.  */
+  unsigned char in__has_include__;
+
   /* Nonzero if prevent_expansion is true only because output is
      being discarded.  */
   unsigned char discarding_output;
@@ -279,6 +282,8 @@
   cpp_hashnode *n_true;			/* C++ keyword true */
   cpp_hashnode *n_false;		/* C++ keyword false */
   cpp_hashnode *n__VA_ARGS__;		/* C99 vararg macros */
+  cpp_hashnode *n__has_include__;	/* __has_include__ operator */
+  cpp_hashnode *n__has_include_next__;	/* __has_include_next__ operator */
 };
 
 typedef struct _cpp_line_note _cpp_line_note;
@@ -645,6 +650,8 @@
 extern bool _cpp_read_file_entries (cpp_reader *, FILE *);
 extern const char *_cpp_get_file_name (_cpp_file *);
 extern struct stat *_cpp_get_file_stat (_cpp_file *);
+extern bool _cpp_has_header (cpp_reader *, const char *, int,
+			     enum include_type);
 
 /* In expr.c */
 extern bool _cpp_parse_expr (cpp_reader *, bool);
@@ -680,6 +687,7 @@
 extern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *,
 				 linenum_type, unsigned int);
 extern void _cpp_pop_buffer (cpp_reader *);
+extern char *_cpp_bracket_include (cpp_reader *);
 
 /* In directives.c */
 struct _cpp_dir_only_callbacks
Index: .
===================================================================
--- a/src/.	(.../tags/gcc_4_9_1_release)
+++ b/src/.	(.../branches/gcc-4_9-branch)

Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk:r210615,214798,215049,215136,215176
