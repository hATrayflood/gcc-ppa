# DP: updates from the 4.9 branch upto 20160413 (r234931).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Wed Apr 13 13:05:49 CEST 2016
Wed Apr 13 11:05:49 UTC 2016 (revision 234931)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_4_9_3_release svn://gcc.gnu.org/svn/gcc/branches/gcc-4_9-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libitm/ChangeLog
===================================================================
--- a/src/libitm/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libitm/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2015-07-03  Carlos SÃ¡nchez de La Lama  <csanchezdll@gmail.com>
+
+	PR target/52482
+	* config/powerpc/sjlj.S: Port to Xcode 2.5.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libitm/config/powerpc/sjlj.S
===================================================================
--- a/src/libitm/config/powerpc/sjlj.S	(.../tags/gcc_4_9_3_release)
+++ b/src/libitm/config/powerpc/sjlj.S	(.../branches/gcc-4_9-branch)
@@ -83,16 +83,16 @@
 	bl	\name
 .endm
 #elif defined(_CALL_DARWIN)
-.macro FUNC name
+.macro FUNC
 	.globl	_$0
 _$0:
 .endmacro
-.macro END name
+.macro END
 .endmacro
-.macro HIDDEN name
+.macro HIDDEN
 	.private_extern _$0
 .endmacro
-.macro CALL name
+.macro CALL
 	bl	_$0
 .endmacro
 # ifdef __ppc64__
Index: Makefile.in
===================================================================
--- a/src/Makefile.in	(.../tags/gcc_4_9_3_release)
+++ b/src/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -47879,6 +47879,7 @@
 
 
 configure-target-libffi: maybe-all-target-newlib maybe-all-target-libgloss
+configure-target-libffi: maybe-all-target-libstdc++-v3
 
 configure-target-libjava: maybe-all-target-newlib maybe-all-target-libgloss
 configure-target-libjava: maybe-all-target-libstdc++-v3
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,24 @@
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	PR lto/67709
+	2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	* testsuite/libgomp.fortran/declare-simd-4.f90: New test.
+
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/68960
+	* testsuite/libgomp.c/pr68960.c: New test.
+
+2016-01-26  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69110
+	* testsuite/libgomp.c/pr69110.c: New test.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libgomp/testsuite/libgomp.fortran/declare-simd-4.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/declare-simd-4.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/declare-simd-4.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+! { dg-do run { target { vect_simd_clones && lto } } }
+! { dg-options "-fno-inline -flto -fno-use-linker-plugin" }
+! { dg-additional-sources declare-simd-3.f90 }
+! { dg-additional-options "-msse2" { target sse2_runtime } }
+! { dg-additional-options "-mavx" { target avx_runtime } }
+
+include 'declare-simd-2.f90'
Index: libgomp/testsuite/libgomp.c/pr68960.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr68960.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr68960.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,25 @@
+/* PR middle-end/68960 */
+/* { dg-do run } */
+
+int
+main ()
+{
+  int temp[257] __attribute__ ((aligned (256))) = { 0 };
+  #pragma omp parallel private (temp) num_threads (2)
+  {
+    int *p = &temp[0];
+    asm volatile ("" : "+g" (p));
+    if (((__UINTPTR_TYPE__) p) & 255)
+      __builtin_abort ();
+  }
+  #pragma omp parallel num_threads (2)
+  #pragma omp single
+  #pragma omp task firstprivate (temp)
+  {
+    int *p = &temp[0];
+    asm volatile ("" : "+g" (p));
+    if (((__UINTPTR_TYPE__) p) & 255)
+      __builtin_abort ();
+  }
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/pr69110.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr69110.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr69110.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-ftree-parallelize-loops=2 -O1 -fno-tree-loop-im" } */
+
+#define N 1000
+
+unsigned int i = 0;
+
+static void __attribute__((noinline, noclone))
+foo (void)
+{
+  unsigned int z;
+  for (z = 0; z < N; ++z)
+    ++i;
+}
+
+extern void abort (void);
+
+int
+main (void)
+{
+  foo ();
+  if (i != N)
+    abort ();
+
+  return 0;
+}
Index: libsanitizer/asan/asan_mac.h
===================================================================
--- a/src/libsanitizer/asan/asan_mac.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libsanitizer/asan/asan_mac.h	(.../branches/gcc-4_9-branch)
@@ -41,7 +41,9 @@
   MACOS_VERSION_SNOW_LEOPARD,
   MACOS_VERSION_LION,
   MACOS_VERSION_MOUNTAIN_LION,
-  MACOS_VERSION_MAVERICKS
+  MACOS_VERSION_MAVERICKS,
+  MACOS_VERSION_YOSEMITE,
+  MACOS_VERSION_UNKNOWN_NEWER
 };
 
 // Used by asan_malloc_mac.cc and asan_mac.cc
Index: libsanitizer/asan/asan_mac.cc
===================================================================
--- a/src/libsanitizer/asan/asan_mac.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libsanitizer/asan/asan_mac.cc	(.../branches/gcc-4_9-branch)
@@ -70,7 +70,12 @@
         case '1': return MACOS_VERSION_LION;
         case '2': return MACOS_VERSION_MOUNTAIN_LION;
         case '3': return MACOS_VERSION_MAVERICKS;
-        default: return MACOS_VERSION_UNKNOWN;
+        case '4': return MACOS_VERSION_YOSEMITE;
+        default:
+          if (IsDigit(version[1]))
+            return MACOS_VERSION_UNKNOWN_NEWER;
+          else
+            return MACOS_VERSION_UNKNOWN;
       }
     }
     default: return MACOS_VERSION_UNKNOWN;
@@ -136,6 +141,23 @@
   }
 }
 
+bool DyldNeedsEnvVariable() {
+// If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if
+// DYLD_INSERT_LIBRARIES is not set.
+
+#if SANITIZER_IOSSIM
+  // GetMacosVersion will not work for the simulator, whose kernel version
+  // is tied to the host. Use a weak linking hack for the simulator.
+  // This API was introduced in the same version of the OS as the dyld
+  // optimization.
+
+  // Check for presence of a symbol that is available on OS X 10.11+, iOS 9.0+.
+  return (dlsym(RTLD_NEXT, "mach_memory_info") == nullptr);
+#else
+  return (GetMacosVersion() <= MACOS_VERSION_YOSEMITE);
+#endif
+}
+
 void MaybeReexec() {
   if (!flags()->allow_reexec) return;
   // Make sure the dynamic ASan runtime library is preloaded so that the
@@ -148,8 +170,9 @@
   uptr old_env_len = dyld_insert_libraries ?
       internal_strlen(dyld_insert_libraries) : 0;
   uptr fname_len = internal_strlen(info.dli_fname);
-  if (!dyld_insert_libraries ||
-      !REAL(strstr)(dyld_insert_libraries, info.dli_fname)) {
+  bool lib_is_in_env =
+      dyld_insert_libraries && REAL(strstr)(dyld_insert_libraries, info.dli_fname);
+  if (DyldNeedsEnvVariable() && !lib_is_in_env) {
     // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime
     // library.
     char program_name[1024];
@@ -180,6 +203,10 @@
     }
     execv(program_name, *_NSGetArgv());
   } else {
+
+    if (!lib_is_in_env)
+      return;
+
     // DYLD_INSERT_LIBRARIES is set and contains the runtime library.
     if (old_env_len == fname_len) {
       // It's just the runtime library name - fine to unset the variable.
Index: libsanitizer/ChangeLog
===================================================================
--- a/src/libsanitizer/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libsanitizer/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,11 @@
+2016-04-05  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR sanitizer/70474
+	* asan/asan_mac.cc (GetMacosVersionInternal): Cherry pick
+	upstream r241487, 221379 and r224315.
+	(void MaybeReexec): Cherry pick upstream r241487.
+	* asan/asan_mac.h (enum MacosVersion): Cherry pick upstream r224315.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libstdc++-v3/configure
===================================================================
--- a/src/libstdc++-v3/configure	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/configure	(.../branches/gcc-4_9-branch)
@@ -17489,6 +17489,68 @@
 
 
 
+
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -std=c++11"
+
+  case "$host" in
+    *-*-solaris2.*)
+      # Solaris 12 introduced the C++11 <math.h> overloads.  A backport to
+      # a Solaris 11.3 SRU is likely, maybe even a Solaris 10 patch.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for C++11 <math.h> overloads" >&5
+$as_echo_n "checking for C++11 <math.h> overloads... " >&6; }
+      if test "${glibcxx_cv_math11_overload+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <math.h>
+	   #undef isfinite
+	   namespace std {
+	     inline bool isfinite(float __x)
+	     { return __builtin_isfinite(__x); }
+	   }
+
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_math11_overload=no
+else
+  glibcxx_cv_math11_overload=yes
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+      # autoheader cannot handle indented templates.
+
+
+      if test $glibcxx_cv_math11_overload = yes; then
+        $as_echo "#define __CORRECT_ISO_CPP11_MATH_H_PROTO 1" >>confdefs.h
+
+      fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_math11_overload" >&5
+$as_echo "$glibcxx_cv_math11_overload" >&6; }
+      ;;
+  esac
+
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for EOWNERDEAD" >&5
 $as_echo_n "checking for EOWNERDEAD... " >&6; }
 if test "${glibcxx_cv_system_error1+set}" = set; then :
Index: libstdc++-v3/src/c++11/random.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/random.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/src/c++11/random.cc	(.../branches/gcc-4_9-branch)
@@ -30,6 +30,7 @@
 # include <cpuid.h>
 #endif
 
+#include <cerrno>
 #include <cstdio>
 
 #ifdef _GLIBCXX_HAVE_UNISTD_H
@@ -129,13 +130,27 @@
 #endif
 
     result_type __ret;
+    void* p = &__ret;
+    size_t n = sizeof(result_type);
 #ifdef _GLIBCXX_HAVE_UNISTD_H
-    read(fileno(static_cast<FILE*>(_M_file)),
-	 static_cast<void*>(&__ret), sizeof(result_type));
+    do
+      {
+	const int e = read(fileno(static_cast<FILE*>(_M_file)), p, n);
+	if (e > 0)
+	  {
+	    n -= e;
+	    p = static_cast<char*>(p) + e;
+	  }
+	else if (e != -1 || errno != EINTR)
+	  __throw_runtime_error(__N("random_device could not be read"));
+      }
+    while (n > 0);
 #else
-    std::fread(static_cast<void*>(&__ret), sizeof(result_type),
-	       1, static_cast<FILE*>(_M_file));
+    const size_t e = std::fread(p, n, 1, static_cast<FILE*>(_M_file));
+    if (e != 1)
+      __throw_runtime_error(__N("random_device could not be read"));
 #endif
+
     return __ret;
   }
 
Index: libstdc++-v3/configure.ac
===================================================================
--- a/src/libstdc++-v3/configure.ac	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/configure.ac	(.../branches/gcc-4_9-branch)
@@ -178,6 +178,7 @@
 
 # Checks for operating systems support that doesn't require linking.
 GLIBCXX_CHECK_STDIO_PROTO
+GLIBCXX_CHECK_MATH11_PROTO
 GLIBCXX_CHECK_SYSTEM_ERROR
 
 # For the streamoff typedef.
Index: libstdc++-v3/include/std/functional
===================================================================
--- a/src/libstdc++-v3/include/std/functional	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/std/functional	(.../branches/gcc-4_9-branch)
@@ -1312,7 +1312,7 @@
 
       // Call unqualified
       template<typename... _Args, typename _Result
-	= decltype( std::declval<_Functor>()(
+	= decltype( std::declval<_Functor&>()(
 	      _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -1326,7 +1326,7 @@
       // Call as const
       template<typename... _Args, typename _Result
 	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
-		       typename add_const<_Functor>::type>::type>()(
+		       typename add_const<_Functor>::type&>::type>()(
 	      _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -1340,7 +1340,7 @@
       // Call as volatile
       template<typename... _Args, typename _Result
 	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
-                       typename add_volatile<_Functor>::type>::type>()(
+                       typename add_volatile<_Functor>::type&>::type>()(
 	      _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -1354,7 +1354,7 @@
       // Call as const volatile
       template<typename... _Args, typename _Result
 	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
-                       typename add_cv<_Functor>::type>::type>()(
+                       typename add_cv<_Functor>::type&>::type>()(
 	      _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
 				  std::declval<tuple<_Args...>&>() )... ) )>
 	_Result
@@ -2051,7 +2051,7 @@
       static _Res
       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
       {
-	return __callable_functor(**_Base::_M_get_pointer(__functor))(
+	return std::__callable_functor(**_Base::_M_get_pointer(__functor))(
 	      std::forward<_ArgTypes>(__args)...);
       }
     };
@@ -2066,7 +2066,7 @@
       static void
       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
       {
-	__callable_functor(**_Base::_M_get_pointer(__functor))(
+	std::__callable_functor(**_Base::_M_get_pointer(__functor))(
 	    std::forward<_ArgTypes>(__args)...);
       }
     };
@@ -2146,8 +2146,9 @@
       typedef _Res _Signature_type(_ArgTypes...);
 
       template<typename _Functor>
-	using _Invoke = decltype(__callable_functor(std::declval<_Functor&>())
-				 (std::declval<_ArgTypes>()...) );
+	using _Invoke
+	  = decltype(std::__callable_functor(std::declval<_Functor&>())
+		     (std::declval<_ArgTypes>()...) );
 
       // Used so the return type convertibility checks aren't done when
       // performing overload resolution for copy construction/assignment.
Index: libstdc++-v3/include/bits/shared_ptr.h
===================================================================
--- a/src/libstdc++-v3/include/bits/shared_ptr.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/shared_ptr.h	(.../branches/gcc-4_9-branch)
@@ -556,19 +556,25 @@
 	_M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 	{ _M_weak_this._M_assign(__p, __n); }
 
-      template<typename _Tp1>
+      template<typename _Tp1, typename _Tp2>
 	friend void
-	__enable_shared_from_this_helper(const __shared_count<>& __pn,
-					 const enable_shared_from_this* __pe,
-					 const _Tp1* __px) noexcept
-	{
-	  if (__pe != 0)
-	    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
-	}
+	__enable_shared_from_this_helper(const __shared_count<>&,
+					 const enable_shared_from_this<_Tp1>*,
+					 const _Tp2*) noexcept;
 
       mutable weak_ptr<_Tp>  _M_weak_this;
     };
 
+  template<typename _Tp1, typename _Tp2>
+    inline void
+    __enable_shared_from_this_helper(const __shared_count<>& __pn,
+				     const enable_shared_from_this<_Tp1>*
+				     __pe, const _Tp2* __px) noexcept
+    {
+      if (__pe != nullptr)
+	__pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
+    }
+
   /**
    *  @brief  Create an object that is owned by a shared_ptr.
    *  @param  __a     An allocator.
Index: libstdc++-v3/include/bits/regex_compiler.h
===================================================================
--- a/src/libstdc++-v3/include/bits/regex_compiler.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/regex_compiler.h	(.../branches/gcc-4_9-branch)
@@ -116,8 +116,10 @@
 	void
 	_M_insert_bracket_matcher(bool __neg);
 
+      // Returns true if successfully matched one term and should continue.
+      // Returns false if the compiler should move on.
       template<bool __icase, bool __collate>
-	void
+	bool
 	_M_expression_term(pair<bool, _CharT>& __last_char,
 			   _BracketMatcher<_TraitsT, __icase, __collate>&
 			   __matcher);
@@ -342,8 +344,8 @@
 #endif
       }
 
-      void
-      _M_add_collating_element(const _StringT& __s)
+      _StringT
+      _M_add_collate_element(const _StringT& __s)
       {
 	auto __st = _M_traits.lookup_collatename(__s.data(),
 						 __s.data() + __s.size());
@@ -353,6 +355,7 @@
 #ifdef _GLIBCXX_DEBUG
 	_M_is_ready = false;
 #endif
+	return __st;
       }
 
       void
Index: libstdc++-v3/include/bits/basic_string.h
===================================================================
--- a/src/libstdc++-v3/include/bits/basic_string.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/basic_string.h	(.../branches/gcc-4_9-branch)
@@ -384,7 +384,6 @@
       template<class _Iterator>
         static void
         _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
-	_GLIBCXX_NOEXCEPT
         {
 	  for (; __k1 != __k2; ++__k1, ++__p)
 	    traits_type::assign(*__p, *__k1); // These types are off.
Index: libstdc++-v3/include/bits/regex_scanner.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex_scanner.tcc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/regex_scanner.tcc	(.../branches/gcc-4_9-branch)
@@ -97,6 +97,12 @@
       auto __c = *_M_current++;
       const char* __pos;
 
+      if (std::strchr(_M_spec_char, _M_ctype.narrow(__c, '\0')) == nullptr)
+	{
+	  _M_token = _S_token_ord_char;
+	  _M_value.assign(1, __c);
+	  return;
+	}
       if (__c == '\\')
 	{
 	  if (_M_current == _M_end)
Index: libstdc++-v3/include/bits/regex_executor.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex_executor.tcc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/regex_executor.tcc	(.../branches/gcc-4_9-branch)
@@ -144,7 +144,10 @@
     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
     _M_lookahead(_State<_TraitsT> __state)
     {
-      _ResultsVec __what(_M_cur_results.size());
+      // Backreferences may refer to captured content.
+      // We may want to make this faster by not copying,
+      // but let's not be clever prematurely.
+      _ResultsVec __what(_M_cur_results);
       auto __sub = std::unique_ptr<_Executor>(new _Executor(_M_current,
 							    _M_end,
 							    __what,
Index: libstdc++-v3/include/bits/shared_ptr_base.h
===================================================================
--- a/src/libstdc++-v3/include/bits/shared_ptr_base.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/shared_ptr_base.h	(.../branches/gcc-4_9-branch)
@@ -1506,19 +1506,25 @@
 	_M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 	{ _M_weak_this._M_assign(__p, __n); }
 
-      template<typename _Tp1>
+      template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
 	friend void
-	__enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,
-					 const __enable_shared_from_this* __pe,
-					 const _Tp1* __px) noexcept
-	{
-	  if (__pe != 0)
-	    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
-	}
+	__enable_shared_from_this_helper(const __shared_count<_Lp1>&,
+					 const __enable_shared_from_this<_Tp1,
+					 _Lp1>*, const _Tp2*) noexcept;
 
       mutable __weak_ptr<_Tp, _Lp>  _M_weak_this;
     };
 
+  template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
+    inline void
+    __enable_shared_from_this_helper(const __shared_count<_Lp1>& __pn,
+				     const __enable_shared_from_this<_Tp1,
+				     _Lp1>* __pe,
+				     const _Tp2* __px) noexcept
+    {
+      if (__pe != nullptr)
+	__pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
+    }
 
   template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
     inline __shared_ptr<_Tp, _Lp>
Index: libstdc++-v3/include/bits/valarray_before.h
===================================================================
--- a/src/libstdc++-v3/include/bits/valarray_before.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/valarray_before.h	(.../branches/gcc-4_9-branch)
@@ -331,14 +331,24 @@
       { return pow(__x, __y); }
   };
 
+  template<typename _Tp, bool _IsValidValarrayValue = !__is_abstract(_Tp)>
+    struct __fun_with_valarray
+    {
+      typedef _Tp result_type;
+    };
 
+  template<typename _Tp>
+    struct __fun_with_valarray<_Tp, false>
+    {
+      // No result type defined for invalid value types.
+    };
+
   // We need these bits in order to recover the return type of
   // some functions/operators now that we're no longer using
   // function templates.
   template<typename, typename _Tp>
-    struct __fun
+    struct __fun : __fun_with_valarray<_Tp>
     {
-      typedef _Tp result_type;
     };
 
   // several specializations for relational operators.
Index: libstdc++-v3/include/bits/alloc_traits.h
===================================================================
--- a/src/libstdc++-v3/include/bits/alloc_traits.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/alloc_traits.h	(.../branches/gcc-4_9-branch)
@@ -406,7 +406,7 @@
        *  Calls @c __a.destroy(__p) if that expression is well-formed,
        *  otherwise calls @c __p->~_Tp()
       */
-      template <class _Tp>
+      template<typename _Tp>
 	static void destroy(_Alloc& __a, _Tp* __p)
 	{ _S_destroy(__a, __p); }
 
@@ -434,6 +434,130 @@
       { return _S_select(__rhs, 0); }
     };
 
+  /// Partial specialization for std::allocator.
+  template<typename _Tp>
+    struct allocator_traits<allocator<_Tp>>
+    {
+      /// The allocator type
+      using allocator_type = allocator<_Tp>;
+      /// The allocated type
+      using value_type = _Tp;
+
+      /// The allocator's pointer type.
+      using pointer = _Tp*;
+
+      /// The allocator's const pointer type.
+      using const_pointer = const _Tp*;
+
+      /// The allocator's void pointer type.
+      using void_pointer = void*;
+
+      /// The allocator's const void pointer type.
+      using const_void_pointer = const void*;
+
+      /// The allocator's difference type
+      using difference_type = std::ptrdiff_t;
+
+      /// The allocator's size type
+      using size_type = std::size_t;
+
+      /// How the allocator is propagated on copy assignment
+      using propagate_on_container_copy_assignment = false_type;
+
+      /// How the allocator is propagated on move assignment
+      using propagate_on_container_move_assignment = true_type;
+
+      /// How the allocator is propagated on swap
+      using propagate_on_container_swap = false_type;
+
+      template<typename _Up>
+	using rebind_alloc = allocator<_Up>;
+
+      template<typename _Up>
+	using rebind_traits = allocator_traits<allocator<_Up>>;
+
+      /**
+       *  @brief  Allocate memory.
+       *  @param  __a  An allocator.
+       *  @param  __n  The number of objects to allocate space for.
+       *
+       *  Calls @c a.allocate(n)
+      */
+      static pointer
+      allocate(allocator_type& __a, size_type __n)
+      { return __a.allocate(__n); }
+
+      /**
+       *  @brief  Allocate memory.
+       *  @param  __a  An allocator.
+       *  @param  __n  The number of objects to allocate space for.
+       *  @param  __hint Aid to locality.
+       *  @return Memory of suitable size and alignment for @a n objects
+       *          of type @c value_type
+       *
+       *  Returns <tt> a.allocate(n, hint) </tt>
+      */
+      static pointer
+      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
+      { return __a.allocate(__n, __hint); }
+
+      /**
+       *  @brief  Deallocate memory.
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to the memory to deallocate.
+       *  @param  __n  The number of objects space was allocated for.
+       *
+       *  Calls <tt> a.deallocate(p, n) </tt>
+      */
+      static void
+      deallocate(allocator_type& __a, pointer __p, size_type __n)
+      { __a.deallocate(__p, __n); }
+
+      /**
+       *  @brief  Construct an object of type @a _Up
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
+       *  @param  __args Constructor arguments.
+       *
+       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
+      */
+      template<typename _Up, typename... _Args>
+	static void
+	construct(allocator_type& __a, _Up* __p, _Args&&... __args)
+	{ __a.construct(__p, std::forward<_Args>(__args)...); }
+
+      /**
+       *  @brief  Destroy an object of type @a _Up
+       *  @param  __a  An allocator.
+       *  @param  __p  Pointer to the object to destroy
+       *
+       *  Calls @c __a.destroy(__p).
+      */
+      template<typename _Up>
+	static void
+	destroy(allocator_type& __a, _Up* __p)
+	{ __a.destroy(__p); }
+
+      /**
+       *  @brief  The maximum supported allocation size
+       *  @param  __a  An allocator.
+       *  @return @c __a.max_size()
+      */
+      static size_type
+      max_size(const allocator_type& __a) noexcept
+      { return __a.max_size(); }
+
+      /**
+       *  @brief  Obtain an allocator to use when copying a container.
+       *  @param  __rhs  An allocator.
+       *  @return @c __rhs
+      */
+      static allocator_type
+      select_on_container_copy_construction(const allocator_type& __rhs)
+      { return __rhs; }
+    };
+
+
   template<typename _Alloc>
     inline void
     __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
Index: libstdc++-v3/include/bits/regex_compiler.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex_compiler.tcc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/bits/regex_compiler.tcc	(.../branches/gcc-4_9-branch)
@@ -419,8 +419,7 @@
 	    __last_char.first = true;
 	    __last_char.second = _M_value[0];
 	  }
-      while (!_M_match_token(_ScannerT::_S_token_bracket_end))
-	_M_expression_term(__last_char, __matcher);
+      while (_M_expression_term(__last_char, __matcher));
       __matcher._M_ready();
       _M_stack.push(_StateSeqT(
 		      _M_nfa,
@@ -429,22 +428,32 @@
 
   template<typename _TraitsT>
   template<bool __icase, bool __collate>
-    void
+    bool
     _Compiler<_TraitsT>::
     _M_expression_term(pair<bool, _CharT>& __last_char,
 		       _BracketMatcher<_TraitsT, __icase, __collate>& __matcher)
 
     {
+      if (_M_match_token(_ScannerT::_S_token_bracket_end))
+	return false;
+
       if (_M_match_token(_ScannerT::_S_token_collsymbol))
-	__matcher._M_add_collating_element(_M_value);
+	{
+	  auto __symbol = __matcher._M_add_collate_element(_M_value);
+	  if (__symbol.size() == 1)
+	    {
+	      __last_char.first = true;
+	      __last_char.second = __symbol[0];
+	    }
+	}
       else if (_M_match_token(_ScannerT::_S_token_equiv_class_name))
 	__matcher._M_add_equivalence_class(_M_value);
       else if (_M_match_token(_ScannerT::_S_token_char_class_name))
 	__matcher._M_add_character_class(_M_value, false);
-      // POSIX doesn't permit '-' as a start-range char (say [a-z--0]),
-      // except when the '-' is the first character in the bracket expression
-      // ([--0]). ECMAScript treats all '-' after a range as a normal character.
-      // Also see above, where _M_expression_term gets called.
+      // POSIX doesn't allow '-' as a start-range char (say [a-z--0]),
+      // except when the '-' is the first or last character in the bracket
+      // expression ([--0]). ECMAScript treats all '-' after a range as a
+      // normal character. Also see above, where _M_expression_term gets called.
       //
       // As a result, POSIX rejects [-----], but ECMAScript doesn't.
       // Boost (1.57.0) always uses POSIX style even in its ECMAScript syntax.
@@ -455,10 +464,14 @@
 	{
 	  if (!__last_char.first)
 	    {
+	      __matcher._M_add_char(_M_value[0]);
 	      if (_M_value[0] == '-'
 		  && !(_M_flags & regex_constants::ECMAScript))
-		__throw_regex_error(regex_constants::error_range);
-	      __matcher._M_add_char(_M_value[0]);
+		{
+		  if (_M_match_token(_ScannerT::_S_token_bracket_end))
+		    return false;
+		  __throw_regex_error(regex_constants::error_range);
+		}
 	      __last_char.first = true;
 	      __last_char.second = _M_value[0];
 	    }
@@ -492,6 +505,8 @@
 						     _M_value[0]));
       else
 	__throw_regex_error(regex_constants::error_brack);
+
+      return true;
     }
 
   template<typename _TraitsT>
Index: libstdc++-v3/include/c_global/cmath
===================================================================
--- a/src/libstdc++-v3/include/c_global/cmath	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/c_global/cmath	(.../branches/gcc-4_9-branch)
@@ -557,6 +557,8 @@
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus >= 201103L
+
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr int
   fpclassify(float __x)
   { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
@@ -571,6 +573,7 @@
   fpclassify(long double __x)
   { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
 				FP_SUBNORMAL, FP_ZERO, __x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
@@ -578,6 +581,7 @@
     fpclassify(_Tp __x)
     { return __x != 0 ? FP_NORMAL : FP_ZERO; }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isfinite(float __x)
   { return __builtin_isfinite(__x); }
@@ -589,6 +593,7 @@
   constexpr bool
   isfinite(long double __x)
   { return __builtin_isfinite(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
@@ -596,6 +601,7 @@
     isfinite(_Tp __x)
     { return true; }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isinf(float __x)
   { return __builtin_isinf(__x); }
@@ -607,6 +613,7 @@
   constexpr bool
   isinf(long double __x)
   { return __builtin_isinf(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
@@ -614,6 +621,7 @@
     isinf(_Tp __x)
     { return false; }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isnan(float __x)
   { return __builtin_isnan(__x); }
@@ -625,6 +633,7 @@
   constexpr bool
   isnan(long double __x)
   { return __builtin_isnan(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
@@ -632,6 +641,7 @@
     isnan(_Tp __x)
     { return false; }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isnormal(float __x)
   { return __builtin_isnormal(__x); }
@@ -643,6 +653,7 @@
   constexpr bool
   isnormal(long double __x)
   { return __builtin_isnormal(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
@@ -650,6 +661,7 @@
     isnormal(_Tp __x)
     { return __x != 0 ? true : false; }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   // The front-end doesn't provide a type generic builtin (libstdc++/58625).
   constexpr bool
   signbit(float __x)
@@ -662,6 +674,7 @@
   constexpr bool
   signbit(long double __x)
   { return __builtin_signbitl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
@@ -669,6 +682,7 @@
     signbit(_Tp __x)
     { return __x < 0 ? true : false; }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isgreater(float __x, float __y)
   { return __builtin_isgreater(__x, __y); }
@@ -680,6 +694,7 @@
   constexpr bool
   isgreater(long double __x, long double __y)
   { return __builtin_isgreater(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename
@@ -691,6 +706,7 @@
       return __builtin_isgreater(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isgreaterequal(float __x, float __y)
   { return __builtin_isgreaterequal(__x, __y); }
@@ -702,6 +718,7 @@
   constexpr bool
   isgreaterequal(long double __x, long double __y)
   { return __builtin_isgreaterequal(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename
@@ -713,6 +730,7 @@
       return __builtin_isgreaterequal(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isless(float __x, float __y)
   { return __builtin_isless(__x, __y); }
@@ -724,6 +742,7 @@
   constexpr bool
   isless(long double __x, long double __y)
   { return __builtin_isless(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename
@@ -735,6 +754,7 @@
       return __builtin_isless(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   islessequal(float __x, float __y)
   { return __builtin_islessequal(__x, __y); }
@@ -746,6 +766,7 @@
   constexpr bool
   islessequal(long double __x, long double __y)
   { return __builtin_islessequal(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename
@@ -757,6 +778,7 @@
       return __builtin_islessequal(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   islessgreater(float __x, float __y)
   { return __builtin_islessgreater(__x, __y); }
@@ -768,6 +790,7 @@
   constexpr bool
   islessgreater(long double __x, long double __y)
   { return __builtin_islessgreater(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename
@@ -779,6 +802,7 @@
       return __builtin_islessgreater(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr bool
   isunordered(float __x, float __y)
   { return __builtin_isunordered(__x, __y); }
@@ -790,6 +814,7 @@
   constexpr bool
   isunordered(long double __x, long double __y)
   { return __builtin_isunordered(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename
@@ -855,7 +880,11 @@
     signbit(_Tp __f)
     {
       typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
-      return __builtin_signbit(__type(__f));
+      return sizeof(__type) == sizeof(float)
+	? __builtin_signbitf(__type(__f))
+	: sizeof(__type) == sizeof(double)
+	? __builtin_signbit(__type(__f))
+	: __builtin_signbitl(__type(__f));
     }
 
   template<typename _Tp>
@@ -1180,6 +1209,7 @@
   using ::truncl;
 
   /// Additional overloads.
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   acosh(float __x)
   { return __builtin_acoshf(__x); }
@@ -1187,6 +1217,7 @@
   constexpr long double
   acosh(long double __x)
   { return __builtin_acoshl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1194,6 +1225,7 @@
     acosh(_Tp __x)
     { return __builtin_acosh(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   asinh(float __x)
   { return __builtin_asinhf(__x); }
@@ -1201,6 +1233,7 @@
   constexpr long double
   asinh(long double __x)
   { return __builtin_asinhl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1208,6 +1241,7 @@
     asinh(_Tp __x)
     { return __builtin_asinh(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   atanh(float __x)
   { return __builtin_atanhf(__x); }
@@ -1215,6 +1249,7 @@
   constexpr long double
   atanh(long double __x)
   { return __builtin_atanhl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1222,6 +1257,7 @@
     atanh(_Tp __x)
     { return __builtin_atanh(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   cbrt(float __x)
   { return __builtin_cbrtf(__x); }
@@ -1229,6 +1265,7 @@
   constexpr long double
   cbrt(long double __x)
   { return __builtin_cbrtl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1236,6 +1273,7 @@
     cbrt(_Tp __x)
     { return __builtin_cbrt(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   copysign(float __x, float __y)
   { return __builtin_copysignf(__x, __y); }
@@ -1243,6 +1281,7 @@
   constexpr long double
   copysign(long double __x, long double __y)
   { return __builtin_copysignl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1252,6 +1291,7 @@
       return copysign(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   erf(float __x)
   { return __builtin_erff(__x); }
@@ -1259,6 +1299,7 @@
   constexpr long double
   erf(long double __x)
   { return __builtin_erfl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1266,6 +1307,7 @@
     erf(_Tp __x)
     { return __builtin_erf(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   erfc(float __x)
   { return __builtin_erfcf(__x); }
@@ -1273,6 +1315,7 @@
   constexpr long double
   erfc(long double __x)
   { return __builtin_erfcl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1280,6 +1323,7 @@
     erfc(_Tp __x)
     { return __builtin_erfc(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   exp2(float __x)
   { return __builtin_exp2f(__x); }
@@ -1287,6 +1331,7 @@
   constexpr long double
   exp2(long double __x)
   { return __builtin_exp2l(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1294,6 +1339,7 @@
     exp2(_Tp __x)
     { return __builtin_exp2(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   expm1(float __x)
   { return __builtin_expm1f(__x); }
@@ -1301,6 +1347,7 @@
   constexpr long double
   expm1(long double __x)
   { return __builtin_expm1l(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1308,6 +1355,7 @@
     expm1(_Tp __x)
     { return __builtin_expm1(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   fdim(float __x, float __y)
   { return __builtin_fdimf(__x, __y); }
@@ -1315,6 +1363,7 @@
   constexpr long double
   fdim(long double __x, long double __y)
   { return __builtin_fdiml(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1324,6 +1373,7 @@
       return fdim(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   fma(float __x, float __y, float __z)
   { return __builtin_fmaf(__x, __y, __z); }
@@ -1331,6 +1381,7 @@
   constexpr long double
   fma(long double __x, long double __y, long double __z)
   { return __builtin_fmal(__x, __y, __z); }
+#endif
 
   template<typename _Tp, typename _Up, typename _Vp>
     constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
@@ -1340,6 +1391,7 @@
       return fma(__type(__x), __type(__y), __type(__z));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   fmax(float __x, float __y)
   { return __builtin_fmaxf(__x, __y); }
@@ -1347,6 +1399,7 @@
   constexpr long double
   fmax(long double __x, long double __y)
   { return __builtin_fmaxl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1356,6 +1409,7 @@
       return fmax(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   fmin(float __x, float __y)
   { return __builtin_fminf(__x, __y); }
@@ -1363,6 +1417,7 @@
   constexpr long double
   fmin(long double __x, long double __y)
   { return __builtin_fminl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1372,6 +1427,7 @@
       return fmin(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   hypot(float __x, float __y)
   { return __builtin_hypotf(__x, __y); }
@@ -1379,6 +1435,7 @@
   constexpr long double
   hypot(long double __x, long double __y)
   { return __builtin_hypotl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1388,6 +1445,7 @@
       return hypot(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr int
   ilogb(float __x)
   { return __builtin_ilogbf(__x); }
@@ -1395,6 +1453,7 @@
   constexpr int
   ilogb(long double __x)
   { return __builtin_ilogbl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr
@@ -1403,6 +1462,7 @@
     ilogb(_Tp __x)
     { return __builtin_ilogb(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   lgamma(float __x)
   { return __builtin_lgammaf(__x); }
@@ -1410,6 +1470,7 @@
   constexpr long double
   lgamma(long double __x)
   { return __builtin_lgammal(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1417,6 +1478,7 @@
     lgamma(_Tp __x)
     { return __builtin_lgamma(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr long long
   llrint(float __x)
   { return __builtin_llrintf(__x); }
@@ -1424,6 +1486,7 @@
   constexpr long long
   llrint(long double __x)
   { return __builtin_llrintl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1431,6 +1494,7 @@
     llrint(_Tp __x)
     { return __builtin_llrint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr long long
   llround(float __x)
   { return __builtin_llroundf(__x); }
@@ -1438,6 +1502,7 @@
   constexpr long long
   llround(long double __x)
   { return __builtin_llroundl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1445,6 +1510,7 @@
     llround(_Tp __x)
     { return __builtin_llround(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   log1p(float __x)
   { return __builtin_log1pf(__x); }
@@ -1452,6 +1518,7 @@
   constexpr long double
   log1p(long double __x)
   { return __builtin_log1pl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1459,6 +1526,7 @@
     log1p(_Tp __x)
     { return __builtin_log1p(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   // DR 568.
   constexpr float
   log2(float __x)
@@ -1467,6 +1535,7 @@
   constexpr long double
   log2(long double __x)
   { return __builtin_log2l(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1474,6 +1543,7 @@
     log2(_Tp __x)
     { return __builtin_log2(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   logb(float __x)
   { return __builtin_logbf(__x); }
@@ -1481,6 +1551,7 @@
   constexpr long double
   logb(long double __x)
   { return __builtin_logbl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1488,6 +1559,7 @@
     logb(_Tp __x)
     { return __builtin_logb(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr long
   lrint(float __x)
   { return __builtin_lrintf(__x); }
@@ -1495,6 +1567,7 @@
   constexpr long
   lrint(long double __x)
   { return __builtin_lrintl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1502,6 +1575,7 @@
     lrint(_Tp __x)
     { return __builtin_lrint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr long
   lround(float __x)
   { return __builtin_lroundf(__x); }
@@ -1509,6 +1583,7 @@
   constexpr long
   lround(long double __x)
   { return __builtin_lroundl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1516,6 +1591,7 @@
     lround(_Tp __x)
     { return __builtin_lround(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   nearbyint(float __x)
   { return __builtin_nearbyintf(__x); }
@@ -1523,6 +1599,7 @@
   constexpr long double
   nearbyint(long double __x)
   { return __builtin_nearbyintl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1530,6 +1607,7 @@
     nearbyint(_Tp __x)
     { return __builtin_nearbyint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   nextafter(float __x, float __y)
   { return __builtin_nextafterf(__x, __y); }
@@ -1537,6 +1615,7 @@
   constexpr long double
   nextafter(long double __x, long double __y)
   { return __builtin_nextafterl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1546,6 +1625,7 @@
       return nextafter(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   nexttoward(float __x, long double __y)
   { return __builtin_nexttowardf(__x, __y); }
@@ -1553,6 +1633,7 @@
   constexpr long double
   nexttoward(long double __x, long double __y)
   { return __builtin_nexttowardl(__x, __y); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1560,6 +1641,7 @@
     nexttoward(_Tp __x, long double __y)
     { return __builtin_nexttoward(__x, __y); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   remainder(float __x, float __y)
   { return __builtin_remainderf(__x, __y); }
@@ -1567,6 +1649,7 @@
   constexpr long double
   remainder(long double __x, long double __y)
   { return __builtin_remainderl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1576,6 +1659,7 @@
       return remainder(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   remquo(float __x, float __y, int* __pquo)
   { return __builtin_remquof(__x, __y, __pquo); }
@@ -1583,6 +1667,7 @@
   inline long double
   remquo(long double __x, long double __y, int* __pquo)
   { return __builtin_remquol(__x, __y, __pquo); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -1592,6 +1677,7 @@
       return remquo(__type(__x), __type(__y), __pquo);
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   rint(float __x)
   { return __builtin_rintf(__x); }
@@ -1599,6 +1685,7 @@
   constexpr long double
   rint(long double __x)
   { return __builtin_rintl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1606,6 +1693,7 @@
     rint(_Tp __x)
     { return __builtin_rint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   round(float __x)
   { return __builtin_roundf(__x); }
@@ -1613,6 +1701,7 @@
   constexpr long double
   round(long double __x)
   { return __builtin_roundl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1620,6 +1709,7 @@
     round(_Tp __x)
     { return __builtin_round(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   scalbln(float __x, long __ex)
   { return __builtin_scalblnf(__x, __ex); }
@@ -1627,6 +1717,7 @@
   constexpr long double
   scalbln(long double __x, long __ex)
   { return __builtin_scalblnl(__x, __ex); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1634,6 +1725,7 @@
     scalbln(_Tp __x, long __ex)
     { return __builtin_scalbln(__x, __ex); }
  
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   scalbn(float __x, int __ex)
   { return __builtin_scalbnf(__x, __ex); }
@@ -1641,6 +1733,7 @@
   constexpr long double
   scalbn(long double __x, int __ex)
   { return __builtin_scalbnl(__x, __ex); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1648,6 +1741,7 @@
     scalbn(_Tp __x, int __ex)
     { return __builtin_scalbn(__x, __ex); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   tgamma(float __x)
   { return __builtin_tgammaf(__x); }
@@ -1655,6 +1749,7 @@
   constexpr long double
   tgamma(long double __x)
   { return __builtin_tgammal(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -1662,6 +1757,7 @@
     tgamma(_Tp __x)
     { return __builtin_tgamma(__x); }
  
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   constexpr float
   trunc(float __x)
   { return __builtin_truncf(__x); }
@@ -1669,6 +1765,7 @@
   constexpr long double
   trunc(long double __x)
   { return __builtin_truncl(__x); }
+#endif
 
   template<typename _Tp>
     constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
Index: libstdc++-v3/include/tr1/cmath
===================================================================
--- a/src/libstdc++-v3/include/tr1/cmath	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/include/tr1/cmath	(.../branches/gcc-4_9-branch)
@@ -419,6 +419,7 @@
   /// Additional overloads [8.16.4].
   using std::acos;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   acosh(float __x)
   { return __builtin_acoshf(__x); }
@@ -426,6 +427,7 @@
   inline long double
   acosh(long double __x)
   { return __builtin_acoshl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -435,6 +437,7 @@
 
   using std::asin;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   asinh(float __x)
   { return __builtin_asinhf(__x); }
@@ -442,6 +445,7 @@
   inline long double
   asinh(long double __x)
   { return __builtin_asinhl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -452,6 +456,7 @@
   using std::atan;
   using std::atan2;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   atanh(float __x)
   { return __builtin_atanhf(__x); }
@@ -459,6 +464,7 @@
   inline long double
   atanh(long double __x)
   { return __builtin_atanhl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -466,6 +472,7 @@
     atanh(_Tp __x)
     { return __builtin_atanh(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   cbrt(float __x)
   { return __builtin_cbrtf(__x); }
@@ -473,6 +480,7 @@
   inline long double
   cbrt(long double __x)
   { return __builtin_cbrtl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -482,6 +490,7 @@
 
   using std::ceil;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   copysign(float __x, float __y)
   { return __builtin_copysignf(__x, __y); }
@@ -489,6 +498,7 @@
   inline long double
   copysign(long double __x, long double __y)
   { return __builtin_copysignl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -501,6 +511,7 @@
   using std::cos;
   using std::cosh;  
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   erf(float __x)
   { return __builtin_erff(__x); }
@@ -508,6 +519,7 @@
   inline long double
   erf(long double __x)
   { return __builtin_erfl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -515,6 +527,7 @@
     erf(_Tp __x)
     { return __builtin_erf(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   erfc(float __x)
   { return __builtin_erfcf(__x); }
@@ -522,6 +535,7 @@
   inline long double
   erfc(long double __x)
   { return __builtin_erfcl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -531,6 +545,7 @@
 
   using std::exp;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   exp2(float __x)
   { return __builtin_exp2f(__x); }
@@ -538,6 +553,7 @@
   inline long double
   exp2(long double __x)
   { return __builtin_exp2l(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -545,6 +561,7 @@
     exp2(_Tp __x)
     { return __builtin_exp2(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   expm1(float __x)
   { return __builtin_expm1f(__x); }
@@ -552,6 +569,7 @@
   inline long double
   expm1(long double __x)
   { return __builtin_expm1l(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -568,6 +586,7 @@
   using ::fabs;
 
 #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   fabs(float __x)
   { return __builtin_fabsf(__x); }
@@ -575,6 +594,7 @@
   inline long double
   fabs(long double __x)
   { return __builtin_fabsl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -583,6 +603,7 @@
     { return __builtin_fabs(__x); }
 #endif
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   fdim(float __x, float __y)
   { return __builtin_fdimf(__x, __y); }
@@ -590,6 +611,7 @@
   inline long double
   fdim(long double __x, long double __y)
   { return __builtin_fdiml(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -601,6 +623,7 @@
 
   using std::floor;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   fma(float __x, float __y, float __z)
   { return __builtin_fmaf(__x, __y, __z); }
@@ -608,6 +631,7 @@
   inline long double
   fma(long double __x, long double __y, long double __z)
   { return __builtin_fmal(__x, __y, __z); }
+#endif
 
   template<typename _Tp, typename _Up, typename _Vp>
     inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
@@ -617,6 +641,7 @@
       return fma(__type(__x), __type(__y), __type(__z));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   fmax(float __x, float __y)
   { return __builtin_fmaxf(__x, __y); }
@@ -624,6 +649,7 @@
   inline long double
   fmax(long double __x, long double __y)
   { return __builtin_fmaxl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -633,6 +659,7 @@
       return fmax(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   fmin(float __x, float __y)
   { return __builtin_fminf(__x, __y); }
@@ -640,6 +667,7 @@
   inline long double
   fmin(long double __x, long double __y)
   { return __builtin_fminl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -652,6 +680,7 @@
   using std::fmod;
   using std::frexp;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   hypot(float __x, float __y)
   { return __builtin_hypotf(__x, __y); }
@@ -659,6 +688,7 @@
   inline long double
   hypot(long double __x, long double __y)
   { return __builtin_hypotl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -668,6 +698,7 @@
       return hypot(__type(__y), __type(__x));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline int
   ilogb(float __x)
   { return __builtin_ilogbf(__x); }
@@ -675,6 +706,7 @@
   inline int
   ilogb(long double __x)
   { return __builtin_ilogbl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -684,6 +716,7 @@
 
   using std::ldexp;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   lgamma(float __x)
   { return __builtin_lgammaf(__x); }
@@ -691,6 +724,7 @@
   inline long double
   lgamma(long double __x)
   { return __builtin_lgammal(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -698,6 +732,7 @@
     lgamma(_Tp __x)
     { return __builtin_lgamma(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline long long
   llrint(float __x)
   { return __builtin_llrintf(__x); }
@@ -705,6 +740,7 @@
   inline long long
   llrint(long double __x)
   { return __builtin_llrintl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -712,6 +748,7 @@
     llrint(_Tp __x)
     { return __builtin_llrint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline long long
   llround(float __x)
   { return __builtin_llroundf(__x); }
@@ -719,6 +756,7 @@
   inline long long
   llround(long double __x)
   { return __builtin_llroundl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -729,6 +767,7 @@
   using std::log;
   using std::log10;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   log1p(float __x)
   { return __builtin_log1pf(__x); }
@@ -736,6 +775,7 @@
   inline long double
   log1p(long double __x)
   { return __builtin_log1pl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -744,6 +784,7 @@
     { return __builtin_log1p(__x); }
 
   // DR 568.
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   log2(float __x)
   { return __builtin_log2f(__x); }
@@ -751,6 +792,7 @@
   inline long double
   log2(long double __x)
   { return __builtin_log2l(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -758,6 +800,7 @@
     log2(_Tp __x)
     { return __builtin_log2(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   logb(float __x)
   { return __builtin_logbf(__x); }
@@ -765,6 +808,7 @@
   inline long double
   logb(long double __x)
   { return __builtin_logbl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -774,6 +818,7 @@
       return __builtin_logb(__x);
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline long
   lrint(float __x)
   { return __builtin_lrintf(__x); }
@@ -781,6 +826,7 @@
   inline long
   lrint(long double __x)
   { return __builtin_lrintl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -788,6 +834,7 @@
     lrint(_Tp __x)
     { return __builtin_lrint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline long
   lround(float __x)
   { return __builtin_lroundf(__x); }
@@ -795,6 +842,7 @@
   inline long
   lround(long double __x)
   { return __builtin_lroundl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -802,6 +850,7 @@
     lround(_Tp __x)
     { return __builtin_lround(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   nearbyint(float __x)
   { return __builtin_nearbyintf(__x); }
@@ -809,6 +858,7 @@
   inline long double
   nearbyint(long double __x)
   { return __builtin_nearbyintl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -816,6 +866,7 @@
     nearbyint(_Tp __x)
     { return __builtin_nearbyint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   nextafter(float __x, float __y)
   { return __builtin_nextafterf(__x, __y); }
@@ -823,6 +874,7 @@
   inline long double
   nextafter(long double __x, long double __y)
   { return __builtin_nextafterl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -832,6 +884,7 @@
       return nextafter(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   nexttoward(float __x, long double __y)
   { return __builtin_nexttowardf(__x, __y); }
@@ -839,6 +892,7 @@
   inline long double
   nexttoward(long double __x, long double __y)
   { return __builtin_nexttowardl(__x, __y); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -846,6 +900,7 @@
     nexttoward(_Tp __x, long double __y)
     { return __builtin_nexttoward(__x, __y); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   remainder(float __x, float __y)
   { return __builtin_remainderf(__x, __y); }
@@ -853,6 +908,7 @@
   inline long double
   remainder(long double __x, long double __y)
   { return __builtin_remainderl(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -862,6 +918,7 @@
       return remainder(__type(__x), __type(__y));
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   remquo(float __x, float __y, int* __pquo)
   { return __builtin_remquof(__x, __y, __pquo); }
@@ -869,6 +926,7 @@
   inline long double
   remquo(long double __x, long double __y, int* __pquo)
   { return __builtin_remquol(__x, __y, __pquo); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
@@ -878,6 +936,7 @@
       return remquo(__type(__x), __type(__y), __pquo);
     }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   rint(float __x)
   { return __builtin_rintf(__x); }
@@ -885,6 +944,7 @@
   inline long double
   rint(long double __x)
   { return __builtin_rintl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -892,6 +952,7 @@
     rint(_Tp __x)
     { return __builtin_rint(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   round(float __x)
   { return __builtin_roundf(__x); }
@@ -899,6 +960,7 @@
   inline long double
   round(long double __x)
   { return __builtin_roundl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -906,6 +968,7 @@
     round(_Tp __x)
     { return __builtin_round(__x); }
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   scalbln(float __x, long __ex)
   { return __builtin_scalblnf(__x, __ex); }
@@ -913,6 +976,7 @@
   inline long double
   scalbln(long double __x, long __ex)
   { return __builtin_scalblnl(__x, __ex); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -920,6 +984,7 @@
     scalbln(_Tp __x, long __ex)
     { return __builtin_scalbln(__x, __ex); }
  
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   scalbn(float __x, int __ex)
   { return __builtin_scalbnf(__x, __ex); }
@@ -927,6 +992,7 @@
   inline long double
   scalbn(long double __x, int __ex)
   { return __builtin_scalbnl(__x, __ex); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -940,6 +1006,7 @@
   using std::tan;
   using std::tanh;
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   tgamma(float __x)
   { return __builtin_tgammaf(__x); }
@@ -947,6 +1014,7 @@
   inline long double
   tgamma(long double __x)
   { return __builtin_tgammal(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -954,6 +1022,7 @@
     tgamma(_Tp __x)
     { return __builtin_tgamma(__x); }
  
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   trunc(float __x)
   { return __builtin_truncf(__x); }
@@ -961,6 +1030,7 @@
   inline long double
   trunc(long double __x)
   { return __builtin_truncl(__x); }
+#endif
 
   template<typename _Tp>
     inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
@@ -994,6 +1064,7 @@
   // the discussion about this issue here:
   // http://gcc.gnu.org/ml/gcc-patches/2012-09/msg01278.html
 
+#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
   inline float
   pow(float __x, float __y)
   { return std::pow(__x, __y); }
@@ -1001,6 +1072,7 @@
   inline long double
   pow(long double __x, long double __y)
   { return std::pow(__x, __y); }
+#endif
 
   template<typename _Tp, typename _Up>
     inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,208 @@
+2016-03-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2016-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60976
+	* include/bits/alloc_traits.h (allocator_traits<allocator<_Tp>>):
+	Define partial specialization.
+	* testsuite/20_util/shared_ptr/cons/58659.cc: Add construct and
+	destroy members to std::allocator explicit specialization.
+
+2016-02-23  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2015-11-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+	* acinclude.m4 (GLIBCXX_CHECK_MATH11_PROTO): New test.
+	* configure.ac: Use it.
+	* configure: Regenerate.
+	* config.h.in: Regenerate.
+
+	* include/c_global/cmath [__cplusplus >= 201103L]
+	(std::fpclassify): Wrap in !__CORRECT_ISO_CPP11_MATH_H_PROTO.
+	(std::isfinite): Likewise.
+	(std::isinf): Likewise.
+	(std::isnan): Likewise.
+	(std::isnormal): Likewise.
+	(std::signbit): Likewise.
+	(std::isgreater): Likewise.
+	(std::isgreaterequal): Likewise.
+	(std::isless): Likewise.
+	(std::islessequal): Likewise.
+	(std::islessgreater): Likewise.
+	(std::isunordered): Likewise.
+	(std::acosh): Likewise.
+	(std::asinh): Likewise.
+	(std::atanh): Likewise.
+	(std::cbrt): Likewise.
+	(std::copysign): Likewise.
+	(std::erf): Likewise.
+	(std::erfc): Likewise.
+	(std::exp2): Likewise.
+	(std::expm1): Likewise.
+	(std::fdim): Likewise.
+	(std::fma): Likewise.
+	(std::fmax): Likewise.
+	(std::fmin): Likewise.
+	(std::hypot): Likewise.
+	(std::ilogb): Likewise.
+	(std::lgamma): Likewise.
+	(std::llrint): Likewise.
+	(std::llround): Likewise.
+	(std::log1p): Likewise.
+	(std::log2): Likewise.
+	(std::logb): Likewise.
+	(std::lrint): Likewise.
+	(std::lround): Likewise.
+	(std::nearbyint): Likewise.
+	(std::nextafter): Likewise.
+	(std::nexttoward): Likewise.
+	(std::remainder): Likewise.
+	(std::remquo): Likewise.
+	(std::rint): Likewise.
+	(std::round): Likewise.
+	(std::scalbln): Likewise.
+	(std::scalbn): Likewise.
+	(std::tgamma): Likewise.
+	(std::trunc): Likewise.
+	* include/tr1/cmath [_GLIBCXX_USE_C99_MATH_TR1] (std::tr1::acosh):
+	Wrap in !__CORRECT_ISO_CPP11_MATH_H_PROTO.
+	(std::tr1::asinh): Likewise.
+	(std::tr1::atanh): Likewise.
+	(std::tr1::cbrt): Likewise.
+	(std::tr1::copysign): Likewise.
+	(std::tr1::erf): Likewise.
+	(std::tr1::erfc): Likewise.
+	(std::tr1::exp2): Likewise.
+	(std::tr1::expm1): Likewise.
+	(std::tr1::fabs): Likewise.
+	(std::tr1::fdim): Likewise.
+	(std::tr1::fma): Likewise.
+	(std::tr1::fmax): Likewise.
+	(std::tr1::fmin): Likewise.
+	(std::tr1::hypot): Likewise.
+	(std::tr1::ilogb): Likewise.
+	(std::tr1::lgamma): Likewise.
+	(std::tr1::llrint): Likewise.
+	(std::tr1::llround): Likewise.
+	(std::tr1::log1p): Likewise.
+	(std::tr1::log2): Likewise.
+	(std::tr1::logb): Likewise.
+	(std::tr1::lrint): Likewise.
+	(std::tr1::lround): Likewise.
+	(std::tr1::nearbyint): Likewise.
+	(std::tr1::nextafter): Likewise.
+	(std::tr1::nexttoward): Likewise.
+	(std::tr1::remainder): Likewise.
+	(std::tr1::remquo): Likewise.
+	(std::tr1::rint): Likewise.
+	(std::tr1::scalbln): Likewise.
+	(std::tr1::scalbn): Likewise.
+	(std::tr1::tgamma): Likewise.
+	(std::tr1::trunc): Likewise.
+	(std::tr1::pow): Likewise.
+
+	* testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc:
+	Restrict dg-xfail-if, dg-excess-errors to *-*-solaris2.10*.
+
+2016-02-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/69116
+	* include/bits/valarray_before.h (__fun, __fun_with_valarray): Only
+	define result_type for types which can be safely used with valarrays.
+	* testsuite/26_numerics/valarray/69116.cc: New.
+
+2016-01-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60637
+	* include/c_global/cmath (signbit) [__cplusplus < 201103L]: Use
+	__builtin_signbitf or __builtin_signbitl as appropriate.
+	* testsuite/26_numerics/headers/cmath/60637.cc: New.
+
+2016-01-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/69092
+	* include/bits/basic_string.h (basic_string::_S_copy_chars<_Iterator>):
+	Remove _GLIBCXX_NOEXCEPT.
+	testsuite/21_strings/basic_string/cons/char/69092.cc: New.
+
+	PR libstdc++/68995
+	* include/std/functional (_Function_handler::_M_invoke): Qualify
+	__callable_functor.
+	* testsuite/20_util/function/68995.cc: New.
+
+2015-12-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/68912
+	* include/std/functional (_Bind::operator()): Use lvalue functor to
+	deduce return type.
+	* testsuite/20_util/bind/68912.cc: New.
+
+	Backport from mainline
+	2015-12-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/56383
+	* testsuite/20_util/enable_shared_from_this/56383.cc: New.
+	* include/bits/shared_ptr_base.h (__enable_shared_from_this): Make
+	friend declaration match previous declaration of
+	__enable_shared_from_this_helper.
+	* include/bits/shared_ptr.h (enable_shared_from_this): Likewise.
+
+2015-12-15  Tim Shen  <timshen@google.com>
+
+	Backport from mainline
+	2015-12-15  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/68863
+	* include/bits/regex_executor.tcc (_Executor::_M_lookahead):
+	Copy the captured content for lookahead, so that the backreferences
+	inside can refer to them.
+	* testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc:
+	New testcase.
+
+2015-10-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/65142
+	* src/c++11/random.cc (random_device::_M_getval()): Check read result
+	and retry after short reads.
+
+2015-09-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2015-04-27  Dmitry Prokoptsev  <dprokoptsev@gmail.com>
+		    Michael Hanselmann  <public@hansmi.ch>
+
+	PR libstdc++/62258
+	* libsupc++/eh_ptr.cc (rethrow_exception): Increment count of
+	uncaught exceptions.
+	* testsuite/18_support/exception_ptr/62258.cc: New.
+
+2015-08-28  Tim Shen  <timshen@google.com>
+
+	Backport from mainline
+	2015-08-28  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/67362
+	* include/bits/regex_scanner.tcc (_Scanner<>::_M_scan_normal):
+	Always returns ordinary char token if the char isn't
+	considered a special char.
+	* testsuite/28_regex/regression.cc: New test file for collecting
+	regression testcases from, typically, bugzilla.
+
+2015-08-05  Tim Shen  <timshen@google.com>
+
+	Backported from mainline
+	2015-07-29  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/67015
+	* include/bits/regex_compiler.h (_Compiler<>::_M_expression_term,
+	_BracketMatcher<>::_M_add_collating_element): Change signature
+	to make checking the and of bracket expression easier.
+	* include/bits/regex_compiler.tcc (_Compiler<>::_M_expression_term):
+	Treat '-' as a valid literal if it's at the end of bracket expression.
+	* testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc:
+	New testcases.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libstdc++-v3/libsupc++/eh_ptr.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/eh_ptr.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/libsupc++/eh_ptr.cc	(.../branches/gcc-4_9-branch)
@@ -245,6 +245,9 @@
   __GXX_INIT_DEPENDENT_EXCEPTION_CLASS(dep->unwindHeader.exception_class);
   dep->unwindHeader.exception_cleanup = __gxx_dependent_exception_cleanup;
 
+  __cxa_eh_globals *globals = __cxa_get_globals ();
+  globals->uncaughtExceptions += 1;
+
 #ifdef _GLIBCXX_SJLJ_EXCEPTIONS
   _Unwind_SjLj_RaiseException (&dep->unwindHeader);
 #else
Index: libstdc++-v3/testsuite/28_regex/regression.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/regression.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/regression.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,42 @@
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <testsuite_hooks.h>
+#include <testsuite_regex.h>
+
+using namespace __gnu_test;
+using namespace std;
+
+// PR libstdc++/67362
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  regex re("((.)", regex_constants::basic);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
+
Index: libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/68863.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11" }
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 28.11.2 regex_match
+
+#include <regex>
+#include <testsuite_hooks.h>
+#include <testsuite_regex.h>
+
+using namespace __gnu_test;
+using namespace std;
+
+// libstdc++/68863
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  VERIFY(!std::regex_match("aa", std::regex("(.)(?!\\1).")));
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc	(.../branches/gcc-4_9-branch)
@@ -82,6 +82,22 @@
     VERIFY(e.code() == std::regex_constants::error_range);
   }
   std::regex re("[-----]", std::regex::ECMAScript);
+
+  VERIFY(!regex_match("b", regex("[-ac]", regex_constants::extended)));
+  VERIFY(!regex_match("b", regex("[ac-]", regex_constants::extended)));
+  VERIFY(regex_match("b", regex("[^-ac]", regex_constants::extended)));
+  VERIFY(regex_match("b", regex("[^ac-]", regex_constants::extended)));
+  VERIFY(regex_match("&", regex("[%--]", regex_constants::extended)));
+  VERIFY(regex_match(".", regex("[--@]", regex_constants::extended)));
+  try
+  {
+    regex("[a--@]", regex_constants::extended);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+  }
+  VERIFY(regex_match("].", regex("[][.hyphen.]-0]*", regex_constants::extended)));
 }
 
 void
@@ -115,6 +131,44 @@
   VERIFY(regex_match_debug("w", re));
 }
 
+// libstdc++/67015
+void
+test05()
+{
+  bool test __attribute__((unused)) = true;
+
+  regex lanana_namespace("^[a-z0-9]+$", regex::extended);
+  regex lsb_namespace("^_?([a-z0-9_.]+-, regex::extended)+[a-z0-9]+$");
+  regex debian_dpkg_conffile_cruft("dpkg-(old|dist|new|tmp, regex::extended)$");
+  regex debian_cron_namespace("^[a-z0-9][a-z0-9-]*$", regex::extended);
+  VERIFY(regex_match("test", debian_cron_namespace));
+  VERIFY(!regex_match("-a", debian_cron_namespace));
+  VERIFY(regex_match("a-", debian_cron_namespace));
+  regex debian_cron_namespace_ok("^[a-z0-9][-a-z0-9]*$", regex::extended);
+  VERIFY(regex_match("test", debian_cron_namespace_ok));
+  VERIFY(!regex_match("-a", debian_cron_namespace_ok));
+  VERIFY(regex_match("a-", debian_cron_namespace_ok));
+}
+
+// libstdc++/67015
+void
+test06()
+{
+  bool test __attribute__((unused)) = true;
+
+  regex lanana_namespace("^[a-z0-9]+$");
+  regex lsb_namespace("^_?([a-z0-9_.]+-)+[a-z0-9]+$");
+  regex debian_dpkg_conffile_cruft("dpkg-(old|dist|new|tmp)$");
+  regex debian_cron_namespace("^[a-z0-9][a-z0-9-]*$");
+  VERIFY(regex_match("test", debian_cron_namespace));
+  VERIFY(!regex_match("-a", debian_cron_namespace));
+  VERIFY(regex_match("a-", debian_cron_namespace));
+  regex debian_cron_namespace_ok("^[a-z0-9][-a-z0-9]*$");
+  VERIFY(regex_match("test", debian_cron_namespace_ok));
+  VERIFY(!regex_match("-a", debian_cron_namespace_ok));
+  VERIFY(regex_match("a-", debian_cron_namespace_ok));
+}
+
 int
 main()
 {
@@ -122,5 +176,8 @@
   test02();
   test03();
   test04();
+  test05();
+  test06();
+
   return 0;
 }
Index: libstdc++-v3/testsuite/18_support/exception_ptr/62258.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/18_support/exception_ptr/62258.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/18_support/exception_ptr/62258.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,61 @@
+// { dg-options "-std=gnu++11" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/62258
+
+#include <exception>
+#include <testsuite_hooks.h>
+
+struct check_on_destruct
+{
+  ~check_on_destruct();
+};
+
+check_on_destruct::~check_on_destruct()
+{
+  VERIFY(std::uncaught_exception());
+}
+
+int main ()
+{
+  VERIFY(!std::uncaught_exception());
+
+  try
+    {
+      check_on_destruct check;
+
+      try
+        {
+          throw 1;
+        }
+      catch (...)
+        {
+          VERIFY(!std::uncaught_exception());
+
+          std::rethrow_exception(std::current_exception());
+        }
+    }
+  catch (...)
+    {
+      VERIFY(!std::uncaught_exception());
+    }
+
+  VERIFY(!std::uncaught_exception());
+}
Index: libstdc++-v3/testsuite/21_strings/basic_string/cons/char/69092.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/69092.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/69092.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,58 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+// PR libstdc++/69092
+
+#include <string>
+#include <iterator>
+
+struct hate_T_iterator : std::iterator<std::forward_iterator_tag, char> {
+    explicit hate_T_iterator(char* p) : p(p) {}
+    char* p;
+
+    hate_T_iterator& operator++() { ++p; return *this; }
+
+    hate_T_iterator operator++(int)
+    {
+      hate_T_iterator r = *this;
+      ++*this; return r;
+    }
+
+    char& operator*() const
+    {
+      if (*p == 'T')
+        throw 1;
+      return *p;
+    }
+
+    char* operator->() const { return p; }
+
+    bool operator== (hate_T_iterator other) const { return p == other.p;}
+    bool operator!= (hate_T_iterator other) const { return p != other.p;}
+};
+
+int main()
+{
+  char test_str[4] = "ATA";
+  try {
+    std::string s(hate_T_iterator(test_str), hate_T_iterator(test_str+3));
+  }
+  catch(int) {
+  }
+}
Index: libstdc++-v3/testsuite/26_numerics/valarray/69116.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/26_numerics/valarray/69116.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/26_numerics/valarray/69116.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+// libstdc++/69116
+
+#include <exception>
+#include <valarray>
+
+template<typename T>
+  void foo(const T&) { }
+
+struct X : std::exception // makes namespace std an associated namespace
+{
+  virtual void pure() = 0;
+
+  typedef void(*func_type)(const X&);
+
+  void operator+(func_type) const;
+  void operator-(func_type) const;
+  void operator*(func_type) const;
+  void operator/(func_type) const;
+  void operator%(func_type) const;
+  void operator<<(func_type) const;
+  void operator>>(func_type) const;
+};
+
+void foo(X& x)
+{
+  x + foo;
+  x - foo;
+  x * foo;
+  x / foo;
+  x % foo;
+  x << foo;
+  x >> foo;
+}
Index: libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc	(.../branches/gcc-4_9-branch)
@@ -20,7 +20,7 @@
 // { dg-do compile }
 // { dg-add-options no_pch }
 
-// { dg-xfail-if "" { { *-*-linux* *-*-gnu* *-*-darwin* *-*-solaris2.1[0-9]* hppa*-*-hpux* *-*-mingw* } || { uclibc || newlib } } { "*" } { "" } }
+// { dg-xfail-if "" { { *-*-linux* *-*-gnu* *-*-darwin* *-*-solaris2.10* hppa*-*-hpux* *-*-mingw* } || { uclibc || newlib } } { "*" } { "" } }
 // { dg-excess-errors "" { target { { *-*-linux* *-*-gnu* *-*-darwin* *-*-solaris2.1[0-9]* hppa*-*-hpux* *-*-mingw* } || { uclibc || newlib } } } }
 
 #include <math.h>
Index: libstdc++-v3/testsuite/26_numerics/headers/cmath/60637.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/26_numerics/headers/cmath/60637.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/26_numerics/headers/cmath/60637.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+// Copyright (C) 2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++98 -ffast-math" }
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  long double ld = -5.3165867831218916301793863361917824e-2467L;
+  VERIFY( std::signbit(ld) == 1 );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/enable_shared_from_this/56383.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/enable_shared_from_this/56383.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/20_util/enable_shared_from_this/56383.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,56 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <memory>
+#include <testsuite_hooks.h>
+
+struct A : std::enable_shared_from_this<A>
+{
+    void* a() { return shared_from_this().get(); }
+};
+
+struct B : std::enable_shared_from_this<B>
+{
+};
+
+struct D : A, B
+{
+};
+
+void test01()
+{
+  bool test = false;
+
+  auto d = std::make_shared<D>();
+  try
+  {
+      d->a();
+  }
+  catch (const std::bad_weak_ptr&)
+  {
+    test = true;
+  }
+  VERIFY(test);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/shared_ptr/cons/58659.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/shared_ptr/cons/58659.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/20_util/shared_ptr/cons/58659.cc	(.../branches/gcc-4_9-branch)
@@ -51,6 +51,14 @@
         allocated = false;
       }
 
+      template<typename _Up, typename... _Args>
+        void construct(_Up* __p, _Args&&... __args)
+        { ::new(__p) _Up(std::forward<_Args>(__args)...); }
+
+      template<typename _Up>
+        void destroy(_Up* __p)
+        { __p->~_Up(); }
+
       static char storage[sizeof(spcd)];
       static bool allocated;
     };
Index: libstdc++-v3/testsuite/20_util/function/68995.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/function/68995.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/20_util/function/68995.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,32 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include <tr1/memory>
+#include <functional>
+#include <tr1/functional>
+
+std::tr1::shared_ptr<int> test() { return {}; }
+
+std::function<std::tr1::shared_ptr<int>()> func = test;
+std::function<std::tr1::shared_ptr<int>()> funcr = std::ref(test);
+
+void test2(std::tr1::shared_ptr<int>) { }
+
+std::function<void(std::tr1::shared_ptr<int>)> func2 = std::ref(test2);
Index: libstdc++-v3/testsuite/20_util/bind/68912.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/bind/68912.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/testsuite/20_util/bind/68912.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include<functional>
+
+struct Wrong {};
+struct A {};
+struct B {};
+struct C{};
+struct D{};
+
+struct X {
+  A operator()(int, double) & { return {}; }
+  Wrong operator()(int, double) && {return {}; }
+
+  B operator()(int, double) const & { return {}; }
+  Wrong operator()(int, double) const && {return {}; }
+
+  C operator()(int, double) volatile & { return {}; }
+  Wrong operator()(int, double) volatile && {return {}; }
+
+  D operator()(int, double) const volatile & { return {}; }
+  Wrong operator()(int, double) const volatile && {return {}; }
+};
+
+void test01()
+{
+  auto bound = std::bind(X{}, 5, std::placeholders::_1);
+  A res = bound(1.0);
+  const auto bound_c = bound;
+  B res_c = bound_c(1.0);
+  volatile auto bound_v = bound;
+  C res_v = bound_v(1.0);
+  volatile const auto bound_cv = bound;
+  D res_cv = bound_cv(1.0);
+}
Index: libstdc++-v3/config.h.in
===================================================================
--- a/src/libstdc++-v3/config.h.in	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/config.h.in	(.../branches/gcc-4_9-branch)
@@ -882,6 +882,11 @@
 /* Define to 1 if mutex_timedlock is available. */
 #undef _GTHREAD_USE_MUTEX_TIMEDLOCK
 
+/* Define if all C++11 overloads are available in <math.h>.  */
+#if __cplusplus >= 201103L
+#undef __CORRECT_ISO_CPP11_MATH_H_PROTO
+#endif
+
 #if defined (HAVE__ACOSF) && ! defined (HAVE_ACOSF)
 # define HAVE_ACOSF 1
 # define acosf _acosf
Index: libstdc++-v3/acinclude.m4
===================================================================
--- a/src/libstdc++-v3/acinclude.m4	(.../tags/gcc_4_9_3_release)
+++ b/src/libstdc++-v3/acinclude.m4	(.../branches/gcc-4_9-branch)
@@ -1897,6 +1897,52 @@
 ])
 
 dnl
+dnl Check whether required C++11 overloads are present in <math.h>.
+dnl
+AC_DEFUN([GLIBCXX_CHECK_MATH11_PROTO], [
+
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -std=c++11"
+
+  case "$host" in
+    *-*-solaris2.*)
+      # Solaris 12 introduced the C++11 <math.h> overloads.  A backport to
+      # a Solaris 11.3 SRU is likely, maybe even a Solaris 10 patch.
+      AC_MSG_CHECKING([for C++11 <math.h> overloads])
+      AC_CACHE_VAL(glibcxx_cv_math11_overload, [
+	AC_COMPILE_IFELSE([AC_LANG_SOURCE(
+	  [#include <math.h>
+	   #undef isfinite
+	   namespace std {
+	     inline bool isfinite(float __x)
+	     { return __builtin_isfinite(__x); }
+	   }
+	])],
+	[glibcxx_cv_math11_overload=no],
+	[glibcxx_cv_math11_overload=yes]
+      )])
+
+      # autoheader cannot handle indented templates.
+      AH_VERBATIM([__CORRECT_ISO_CPP11_MATH_H_PROTO],
+        [/* Define if all C++11 overloads are available in <math.h>.  */
+#if __cplusplus >= 201103L
+#undef __CORRECT_ISO_CPP11_MATH_H_PROTO
+#endif])
+
+      if test $glibcxx_cv_math11_overload = yes; then
+        AC_DEFINE(__CORRECT_ISO_CPP11_MATH_H_PROTO)
+      fi
+      AC_MSG_RESULT([$glibcxx_cv_math11_overload])
+      ;;
+  esac
+
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  AC_LANG_RESTORE
+])
+
+dnl
 dnl Check whether macros, etc are present for <system_error>
 dnl
 AC_DEFUN([GLIBCXX_CHECK_SYSTEM_ERROR], [
Index: configure.ac
===================================================================
--- a/src/configure.ac	(.../tags/gcc_4_9_3_release)
+++ b/src/configure.ac	(.../branches/gcc-4_9-branch)
@@ -1660,6 +1660,9 @@
       ISL_CHECK_VERSION(0,12)
       if test "${gcc_cv_isl}" = no ; then
         ISL_CHECK_VERSION(0,14)
+        if test "${gcc_cv_isl}" = no ; then
+          ISL_CHECK_VERSION(0,15)
+        fi
       fi
     fi
   fi
Index: ChangeLog
===================================================================
--- a/src/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,18 @@
+2015-12-04  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-01  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	PR libffi/65726
+	* Makefile.def (lang_env_dependencies): Make libffi depend
+	on cxx.
+	* Makefile.in: Regenerate.
+
+2015-11-18  Matthias Klose  <doko@ubuntu.com>
+
+	* configure.ac: Permit also ISL 0.15 with CLooG.
+	* configure: Regenerate.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: contrib/ChangeLog
===================================================================
--- a/src/contrib/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/contrib/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2015-09-11  Markus Trippelsdorf  <markus@trippelsdorf.de>
+
+	* download_prerequisites: Make sure that script is run from
+	top level source directory.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: contrib/download_prerequisites
===================================================================
--- a/src/contrib/download_prerequisites	(.../tags/gcc_4_9_3_release)
+++ b/src/contrib/download_prerequisites	(.../branches/gcc-4_9-branch)
@@ -24,6 +24,11 @@
 # ISL Library and CLooG.
 GRAPHITE_LOOP_OPT=yes
 
+if [ ! -e gcc/BASE-VER ] ; then
+	echo "You must run this script in the top level GCC source directory."
+	exit 1
+fi
+
 # Necessary to build GCC.
 MPFR=mpfr-2.4.2
 GMP=gmp-4.3.2
Index: libatomic/Makefile.in
===================================================================
--- a/src/libatomic/Makefile.in	(.../tags/gcc_4_9_3_release)
+++ b/src/libatomic/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -465,12 +465,6 @@
 
 distclean-libtool:
 	-rm -f libtool config.lt
-
-# GNU Make needs to see an explicit $(MAKE) variable in the command it
-# runs to enable its job server during parallel builds.  Hence the
-# comments below.
-all-multi:
-	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
 install-multi:
 	$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)
 
@@ -764,6 +758,13 @@
 %_.lo: Makefile
 	$(LTCOMPILE) $(M_DEPS) $(M_SIZE) $(M_IFUNC) -c -o $@ $(M_SRC)
 
+# Override the automake generated all-multi rule to guarantee that all-multi
+# is not run in parallel with the %_.lo rules which generate $(DEPDIR)/*.Ppo
+# makefile fragments to avoid broken *.Ppo getting included into the Makefile
+# when it is reloaded during the build of all-multi.
+all-multi: $(libatomic_la_LIBADD)
+	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
Index: libatomic/ChangeLog
===================================================================
--- a/src/libatomic/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libatomic/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,12 @@
+2016-01-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline:
+	2016-01-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR other/67627
+	* Makefile.am (all-multi): Add dependency.
+	* Makefile.in: Regenerate.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libatomic/Makefile.am
===================================================================
--- a/src/libatomic/Makefile.am	(.../tags/gcc_4_9_3_release)
+++ b/src/libatomic/Makefile.am	(.../branches/gcc-4_9-branch)
@@ -139,3 +139,10 @@
 
 libatomic_convenience_la_SOURCES = $(libatomic_la_SOURCES)
 libatomic_convenience_la_LIBADD = $(libatomic_la_LIBADD)
+
+# Override the automake generated all-multi rule to guarantee that all-multi
+# is not run in parallel with the %_.lo rules which generate $(DEPDIR)/*.Ppo
+# makefile fragments to avoid broken *.Ppo getting included into the Makefile
+# when it is reloaded during the build of all-multi.
+all-multi: $(libatomic_la_LIBADD)
+	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
Index: configure
===================================================================
--- a/src/configure	(.../tags/gcc_4_9_3_release)
+++ b/src/configure	(.../branches/gcc-4_9-branch)
@@ -6072,6 +6072,55 @@
   fi
 
 
+        if test "${gcc_cv_isl}" = no ; then
+
+  if test "${ENABLE_ISL_CHECK}" = yes ; then
+    _isl_saved_CFLAGS=$CFLAGS
+    _isl_saved_LDFLAGS=$LDFLAGS
+    _isl_saved_LIBS=$LIBS
+
+    CFLAGS="${_isl_saved_CFLAGS} ${islinc} ${gmpinc}"
+    LDFLAGS="${_isl_saved_LDFLAGS} ${isllibs}"
+    LIBS="${_isl_saved_LIBS} -lisl"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for version 0.15 of ISL" >&5
+$as_echo_n "checking for version 0.15 of ISL... " >&6; }
+    if test "$cross_compiling" = yes; then :
+  gcc_cv_isl=yes
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <isl/version.h>
+   #include <string.h>
+int
+main ()
+{
+if (strncmp (isl_version (), "isl-0.15", strlen ("isl-0.15")) != 0)
+     return 1;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  gcc_cv_isl=yes
+else
+  gcc_cv_isl=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_isl" >&5
+$as_echo "$gcc_cv_isl" >&6; }
+
+    CFLAGS=$_isl_saved_CFLAGS
+    LDFLAGS=$_isl_saved_LDFLAGS
+    LIBS=$_isl_saved_LIBS
+  fi
+
+
+        fi
       fi
     fi
   fi
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,71 @@
+2016-03-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2016-03-16  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/38239
+	* config/gmon-sol2.c [__i386__] (_mcount): Save and restore
+	call-clobbered registers.
+	(internal_mcount): Remove __i386__ handling.
+
+2015-12-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (__canonicalize_funcptr_for_compare): Remove code
+	to initialize call to __dl_fixup once.
+
+2015-12-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (__canonicalize_funcptr_for_compare): Initialize
+	fixup values if saved GOT address doesn't match runtime address.
+	(fixup_branch_offset): Reorder list.
+
+2015-10-19  Venkataramanan Kumar  <Venkataramanan.kumar@amd.com>
+
+	Backport from mainline
+	2015-10-09  Venkataramanan kumar  <venkataramanan.kumar@amd.com>
+
+	 * config/i386/cpuinfo.c (get_amd_cpu): Detect bdver4.
+	(__cpu_indicator_init): Fix model selection for AMD CPUs.
+
+2015-09-23  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (__kernel_cmpxchg2): Reorder error checks.
+	(__sync_fetch_and_##OP##_##WIDTH): Change result to match type of
+	__kernel_cmpxchg2.
+	(__sync_##OP##_and_fetch_##WIDTH): Likewise.
+	(__sync_val_compare_and_swap_##WIDTH): Likewise.
+	(__sync_bool_compare_and_swap_##WIDTH): Likewise.
+	(__sync_lock_test_and_set_##WIDTH): Likewise.
+	(__sync_lock_release_##WIDTH): Likewise.
+	(__sync_fetch_and_##OP##_4): Change result to match type of
+	__kernel_cmpxchg.
+	(__sync_##OP##_and_fetch_4): Likewise.
+	(__sync_val_compare_and_swap_4): Likewise.
+	(__sync_bool_compare_and_swap_4): likewise.
+	(__sync_lock_test_and_set_4): Likewise.
+	(__sync_lock_release_4): Likewise.
+	(FETCH_AND_OP_2): Add long long variants.
+	(OP_AND_FETCH_2): Likewise.
+	(COMPARE_AND_SWAP_2 ): Likewise.
+	(SYNC_LOCK_TEST_AND_SET_2): Likewise.
+	(SYNC_LOCK_RELEASE_2): Likewise.
+	(__sync_bool_compare_and_swap_##WIDTH): Correct return.
+
+2015-07-23  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	Backport from mainline:
+	2015-07-22  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	* config/nios2/linux-atomic.c (<asm/unistd.h>): Remove #include.
+	(EFAULT,EBUSY,ENOSYS): Delete unused #defines.
+
+2015-07-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (__kernel_cmpxchg): Reorder arguments to
+	better match light-weight syscall argument order.
+	(__kernel_cmpxchg2): Likewise.
+	Adjust callers.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libgcc/config/i386/cpuinfo.c
===================================================================
--- a/src/libgcc/config/i386/cpuinfo.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgcc/config/i386/cpuinfo.c	(.../branches/gcc-4_9-branch)
@@ -153,6 +153,9 @@
       /* Bulldozer version 3 "Steamroller"  */
       if (model >= 0x30 && model <= 0x4f)
 	__cpu_model.__cpu_subtype = AMDFAM15H_BDVER3;
+      /* Bulldozer version 4 "Excavator"   */
+      if (model >= 0x60 && model <= 0x7f)
+	__cpu_model.__cpu_subtype = AMDFAM15H_BDVER4;
       break;
     /* AMD Family 16h "btver2" */
     case 0x16:
@@ -397,7 +400,7 @@
       if (family == 0x0f)
 	{
 	  family += extended_family;
-	  model += (extended_model << 4);
+	  model += extended_model;
 	}
 
       /* Get CPU type.  */
Index: libgcc/config/pa/linux-atomic.c
===================================================================
--- a/src/libgcc/config/pa/linux-atomic.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgcc/config/pa/linux-atomic.c	(.../branches/gcc-4_9-branch)
@@ -46,18 +46,17 @@
 
 /* Kernel helper for compare-and-exchange a 32-bit value.  */
 static inline long
-__kernel_cmpxchg (int oldval, int newval, int *mem)
+__kernel_cmpxchg (int *mem, int oldval, int newval)
 {
   register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
+  register int lws_old asm("r25") = oldval;
+  register int lws_new asm("r24") = newval;
   register long lws_ret   asm("r28");
   register long lws_errno asm("r21");
-  register int lws_old asm("r25") = oldval;
-  register int lws_new asm("r24") = newval;
   asm volatile (	"ble	0xb0(%%sr2, %%r0)	\n\t"
-			"ldi	%5, %%r20		\n\t"
-	: "=r" (lws_ret), "=r" (lws_errno), "=r" (lws_mem),
-	  "=r" (lws_old), "=r" (lws_new)
-	: "i" (LWS_CAS), "2" (lws_mem), "3" (lws_old), "4" (lws_new)
+			"ldi	%2, %%r20		\n\t"
+	: "=r" (lws_ret), "=r" (lws_errno)
+	: "i" (LWS_CAS), "r" (lws_mem), "r" (lws_old), "r" (lws_new)
 	: "r1", "r20", "r22", "r23", "r29", "r31", "memory"
   );
   if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
@@ -73,27 +72,33 @@
 }
 
 static inline long
-__kernel_cmpxchg2 (const void *oldval, const void *newval, void *mem,
+__kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,
 		   int val_size)
 {
   register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
-  register long lws_ret   asm("r28");
-  register long lws_errno asm("r21");
   register unsigned long lws_old asm("r25") = (unsigned long) oldval;
   register unsigned long lws_new asm("r24") = (unsigned long) newval;
   register int lws_size asm("r23") = val_size;
+  register long lws_ret   asm("r28");
+  register long lws_errno asm("r21");
   asm volatile (	"ble	0xb0(%%sr2, %%r0)	\n\t"
-			"ldi	%2, %%r20		\n\t"
-	: "=r" (lws_ret), "=r" (lws_errno)
-	: "i" (2), "r" (lws_mem), "r" (lws_old), "r" (lws_new), "r" (lws_size)
+			"ldi	%6, %%r20		\n\t"
+	: "=r" (lws_ret), "=r" (lws_errno), "+r" (lws_mem),
+	  "+r" (lws_old), "+r" (lws_new), "+r" (lws_size)
+	: "i" (2)
 	: "r1", "r20", "r22", "r29", "r31", "fr4", "memory"
   );
+
+  /* If the kernel LWS call is successful, lws_ret contains 0.  */
+  if (__builtin_expect (lws_ret == 0, 1))
+    return 0;
+
   if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
     __builtin_trap ();
 
-  /* If the kernel LWS call fails, return EBUSY */
-  if (!lws_errno && lws_ret)
-    lws_errno = -EBUSY;
+  /* If the kernel LWS call fails with no error, return -EBUSY */
+  if (__builtin_expect (!lws_errno, 0))
+    return -EBUSY;
 
   return lws_errno;
 }
@@ -111,17 +116,24 @@
   __sync_fetch_and_##OP##_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
     TYPE tmp, newval;							\
-    int failure;							\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
       newval = PFX_OP (tmp INF_OP val);					\
-      failure = __kernel_cmpxchg2 (&tmp, &newval, ptr, INDEX);		\
+      failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
 									\
     return tmp;								\
   }
 
+FETCH_AND_OP_2 (add,   , +, long long, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, long long, 8, 3)
+FETCH_AND_OP_2 (or,    , |, long long, 8, 3)
+FETCH_AND_OP_2 (and,   , &, long long, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, long long, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, long long, 8, 3)
+
 FETCH_AND_OP_2 (add,   , +, short, 2, 1)
 FETCH_AND_OP_2 (sub,   , -, short, 2, 1)
 FETCH_AND_OP_2 (or,    , |, short, 2, 1)
@@ -141,17 +153,24 @@
   __sync_##OP##_and_fetch_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
     TYPE tmp, newval;							\
-    int failure;							\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
       newval = PFX_OP (tmp INF_OP val);					\
-      failure = __kernel_cmpxchg2 (&tmp, &newval, ptr, INDEX);		\
+      failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
 									\
     return PFX_OP (tmp INF_OP val);					\
   }
 
+OP_AND_FETCH_2 (add,   , +, long long, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, long long, 8, 3)
+OP_AND_FETCH_2 (or,    , |, long long, 8, 3)
+OP_AND_FETCH_2 (and,   , &, long long, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, long long, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, long long, 8, 3)
+
 OP_AND_FETCH_2 (add,   , +, short, 2, 1)
 OP_AND_FETCH_2 (sub,   , -, short, 2, 1)
 OP_AND_FETCH_2 (or,    , |, short, 2, 1)
@@ -170,11 +189,12 @@
   int HIDDEN								\
   __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
   {									\
-    int failure, tmp;							\
+    int tmp;								\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
-      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);	\
+      failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
     return tmp;								\
@@ -191,11 +211,12 @@
   int HIDDEN								\
   __sync_##OP##_and_fetch_4 (int *ptr, int val)				\
   {									\
-    int tmp, failure;							\
+    int tmp;								\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
-      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);	\
+      failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
     return PFX_OP (tmp INF_OP val);					\
@@ -216,7 +237,7 @@
 				       TYPE newval)			\
   {									\
     TYPE actual_oldval;							\
-    int fail;								\
+    long fail;								\
 									\
     while (1)								\
       {									\
@@ -225,7 +246,7 @@
 	if (__builtin_expect (oldval != actual_oldval, 0))		\
 	  return actual_oldval;						\
 									\
-	fail = __kernel_cmpxchg2 (&actual_oldval, &newval, ptr, INDEX);	\
+	fail = __kernel_cmpxchg2 (ptr, &actual_oldval, &newval, INDEX);	\
 									\
 	if (__builtin_expect (!fail, 1))				\
 	  return actual_oldval;						\
@@ -236,10 +257,11 @@
   __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
 					TYPE newval)			\
   {									\
-    int failure = __kernel_cmpxchg2 (&oldval, &newval, ptr, INDEX);	\
-    return (failure != 0);						\
+    long failure = __kernel_cmpxchg2 (ptr, &oldval, &newval, INDEX);	\
+    return (failure == 0);						\
   }
 
+COMPARE_AND_SWAP_2 (long long, 8, 3)
 COMPARE_AND_SWAP_2 (short, 2, 1)
 COMPARE_AND_SWAP_2 (char, 1, 0)
 
@@ -246,7 +268,8 @@
 int HIDDEN
 __sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
-  int actual_oldval, fail;
+  long fail;
+  int actual_oldval;
     
   while (1)
     {
@@ -255,7 +278,7 @@
       if (__builtin_expect (oldval != actual_oldval, 0))
 	return actual_oldval;
 
-      fail = __kernel_cmpxchg (actual_oldval, newval, ptr);
+      fail = __kernel_cmpxchg (ptr, actual_oldval, newval);
   
       if (__builtin_expect (!fail, 1))
 	return actual_oldval;
@@ -265,7 +288,7 @@
 bool HIDDEN
 __sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
-  int failure = __kernel_cmpxchg (oldval, newval, ptr);
+  long failure = __kernel_cmpxchg (ptr, oldval, newval);
   return (failure == 0);
 }
 
@@ -274,16 +297,17 @@
   __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
   {									\
     TYPE oldval;							\
-    int failure;							\
+    long failure;							\
 									\
     do {								\
       oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
-      failure = __kernel_cmpxchg2 (&oldval, &val, ptr, INDEX);		\
+      failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);		\
     } while (failure != 0);						\
 									\
     return oldval;							\
   }
 
+SYNC_LOCK_TEST_AND_SET_2 (long long, 8, 3)
 SYNC_LOCK_TEST_AND_SET_2 (short, 2, 1)
 SYNC_LOCK_TEST_AND_SET_2 (signed char, 1, 0)
 
@@ -290,11 +314,12 @@
 int HIDDEN
 __sync_lock_test_and_set_4 (int *ptr, int val)
 {
-  int failure, oldval;
+  long failure;
+  int oldval;
 
   do {
     oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
-    failure = __kernel_cmpxchg (oldval, val, ptr);
+    failure = __kernel_cmpxchg (ptr, oldval, val);
   } while (failure != 0);
 
   return oldval;
@@ -304,14 +329,16 @@
   void HIDDEN							\
   __sync_lock_release_##WIDTH (TYPE *ptr)			\
   {								\
-    TYPE failure, oldval, zero = 0;				\
+    TYPE oldval, zero = 0;					\
+    long failure;						\
 								\
     do {							\
       oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);		\
-      failure = __kernel_cmpxchg2 (&oldval, &zero, ptr, INDEX);	\
+      failure = __kernel_cmpxchg2 (ptr, &oldval, &zero, INDEX);	\
     } while (failure != 0);					\
   }
 
+SYNC_LOCK_RELEASE_2 (long long, 8, 3)
 SYNC_LOCK_RELEASE_2 (short, 2, 1)
 SYNC_LOCK_RELEASE_2 (signed char, 1, 0)
 
@@ -318,10 +345,11 @@
 void HIDDEN
 __sync_lock_release_4 (int *ptr)
 {
-  int failure, oldval;
+  long failure;
+  int oldval;
 
   do {
-    oldval = *ptr;
-    failure = __kernel_cmpxchg (oldval, 0, ptr);
+    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
+    failure = __kernel_cmpxchg (ptr, oldval, 0);
   } while (failure != 0);
 }
Index: libgcc/config/pa/fptr.c
===================================================================
--- a/src/libgcc/config/pa/fptr.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgcc/config/pa/fptr.c	(.../branches/gcc-4_9-branch)
@@ -40,7 +40,7 @@
    the template should it be necessary to change the current branch
    position.  */
 #define NOFFSETS 2
-static int fixup_branch_offset[NOFFSETS] = { 32, -4 };
+static int fixup_branch_offset[NOFFSETS] = { -4, 32 };
 
 #define GET_FIELD(X, FROM, TO) \
   ((X) >> (31 - (TO)) & ((1 << ((TO) - (FROM) + 1)) - 1))
@@ -64,9 +64,10 @@
 unsigned int
 __canonicalize_funcptr_for_compare (fptr_t fptr)
 {
-  static unsigned int fixup_plabel[2];
-  static fixup_t fixup;
-  unsigned int *plabel, *got;
+  static unsigned int fixup_plabel[2] __attribute__((used));
+  fixup_t fixup;
+  unsigned int *got, *iptr, *plabel;
+  int i;
 
   /* -1 and page 0 are special.  -1 is used in crtend to mark the end of
      a list of function pointers.  Also return immediately if the plabel
@@ -87,42 +88,33 @@
   if (got !=  &_GLOBAL_OFFSET_TABLE_)
     return plabel[0];
 
-  /* Initialize our plabel for calling fixup if we haven't done so already.
-     This code needs to be thread safe but we don't have to be too careful
-     as the result is invariant.  */
-  if (!fixup)
+  /* Find the first "bl" branch in the offset search list.  This is a
+     call to _dl_fixup or a magic branch to fixup at the beginning of the
+     trampoline template.  The fixup function does the actual runtime
+     resolution of function descriptors.  We only look for "bl" branches
+     with a 17-bit pc-relative displacement.  */
+  for (i = 0; i < NOFFSETS; i++)
     {
-      int i;
-      unsigned int *iptr;
+      iptr = (unsigned int *) (got[-2] + fixup_branch_offset[i]);
+      if ((*iptr & 0xfc00e000) == 0xe8000000)
+	break;
+    }
 
-      /* Find the first "bl" branch in the offset search list.  This is a
-	 call to fixup or a magic branch to fixup at the beginning of the
-	 trampoline template.  The fixup function does the actual runtime
-	 resolution of function descriptors.  We only look for "bl" branches
-	 with a 17-bit pc-relative displacement.  */
-      for (i = 0; i < NOFFSETS; i++)
-	{
-	  iptr = (unsigned int *) (got[-2] + fixup_branch_offset[i]);
-	  if ((*iptr & 0xfc00e000) == 0xe8000000)
-	    break;
-	}
+  /* This should not happen... */
+  if (i == NOFFSETS)
+    return ~0;
 
-      /* This should not happen... */
-      if (i == NOFFSETS)
-	return ~0;
+  /* Extract the 17-bit displacement from the instruction.  */
+  iptr += SIGN_EXTEND (GET_FIELD (*iptr, 19, 28) |
+		       GET_FIELD (*iptr, 29, 29) << 10 |
+		       GET_FIELD (*iptr, 11, 15) << 11 |
+		       GET_FIELD (*iptr, 31, 31) << 16, 17);
 
-      /* Extract the 17-bit displacement from the instruction.  */
-      iptr += SIGN_EXTEND (GET_FIELD (*iptr, 19, 28) |
-			   GET_FIELD (*iptr, 29, 29) << 10 |
-			   GET_FIELD (*iptr, 11, 15) << 11 |
-			   GET_FIELD (*iptr, 31, 31) << 16, 17);
+  /* Build a plabel for an indirect call to _dl_fixup.  */
+  fixup_plabel[0] = (unsigned int) iptr + 8;	/* address of fixup */
+  fixup_plabel[1] = got[-1];			/* ltp for fixup */
+  fixup = (fixup_t) ((int) fixup_plabel | 3);
 
-      /* Build a plabel for an indirect call to fixup.  */
-      fixup_plabel[0] = (unsigned int) iptr + 8;  /* address of fixup */
-      fixup_plabel[1] = got[-1];		  /* ltp for fixup */
-      fixup = (fixup_t) ((int) fixup_plabel | 3);
-    }
-
   /* Call fixup to resolve the function address.  got[1] contains the
      link_map pointer and plabel[1] the relocation offset.  */
   fixup ((struct link_map *) got[1], plabel[1]);
Index: libgcc/config/nios2/linux-atomic.c
===================================================================
--- a/src/libgcc/config/nios2/linux-atomic.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgcc/config/nios2/linux-atomic.c	(.../branches/gcc-4_9-branch)
@@ -20,11 +20,6 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
-#include <asm/unistd.h>
-#define EFAULT  14
-#define EBUSY   16
-#define ENOSYS  38
-
 /* We implement byte, short and int versions of each atomic operation
    using the kernel helper defined below.  There is no support for
    64-bit operations yet.  */
Index: libgcc/config/gmon-sol2.c
===================================================================
--- a/src/libgcc/config/gmon-sol2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgcc/config/gmon-sol2.c	(.../branches/gcc-4_9-branch)
@@ -43,11 +43,7 @@
 
 extern void monstartup (char *, char *);
 extern void _mcleanup (void);
-#ifdef __i386__
-static void internal_mcount (void) __attribute__ ((used));
-#else
 static void internal_mcount (char *, unsigned short *) __attribute__ ((used));
-#endif
 static void moncontrol (int);
 
 struct phdr {
@@ -222,8 +218,19 @@
 /* Solaris 2 libraries use _mcount.  */
 #if defined __i386__
 asm(".globl _mcount\n"
+    "	.type	_mcount, @function\n"
     "_mcount:\n"
-    "	jmp	internal_mcount\n");
+    /* Save and restore the call-clobbered registers.  */
+    "	pushl	%eax\n"
+    "	pushl	%ecx\n"
+    "	pushl	%edx\n"
+    "	movl	12(%esp), %edx\n"
+    "	movl	4(%ebp), %eax\n"
+    "	call	internal_mcount\n"
+    "	popl	%edx\n"
+    "	popl	%ecx\n"
+    "	popl	%eax\n"
+    "	ret\n");
 #elif defined __x86_64__
 /* See GLIBC for additional information about this technique.  */
 asm(".globl _mcount\n" 
@@ -298,11 +305,7 @@
 #endif
 
 static void
-#ifdef __i386__
-internal_mcount (void)
-#else
 internal_mcount (char *selfpc, unsigned short *frompcindex)
-#endif
 {
   struct tostruct *top;
   struct tostruct *prevtop;
@@ -309,21 +312,6 @@
   long toindex;
   static char already_setup;
 
-#ifdef __i386__
-  char *selfpc;
-  unsigned short *frompcindex;
-
-  /* Find the return address for mcount and the return address for mcount's
-     caller.  */
-
-  /* selfpc = pc pushed by mcount call.
-     This identifies the function that was just entered.  */
-  selfpc = (void *) __builtin_return_address (0);
-  /* frompcindex = pc in preceding frame.
-     This identifies the caller of the function just entered.  */
-  frompcindex = (void *) __builtin_return_address (1);
-#endif
-
   if(!already_setup) {
     extern char etext[];
 
Index: gcc/tree-vrp.c
===================================================================
--- a/src/gcc/tree-vrp.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-vrp.c	(.../branches/gcc-4_9-branch)
@@ -9021,7 +9021,8 @@
       innerop = gimple_assign_rhs1 (def_stmt);
 
       if (TREE_CODE (innerop) == SSA_NAME
-	  && !POINTER_TYPE_P (TREE_TYPE (innerop)))
+	  && !POINTER_TYPE_P (TREE_TYPE (innerop))
+	  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop))
 	{
 	  value_range_t *vr = get_value_range (innerop);
 
@@ -9051,8 +9052,8 @@
 		  else
 		    location = gimple_location (stmt);
 		  warning_at (location, OPT_Wstrict_overflow,
-		      "assuming signed overflow does not occur when "
-		      "simplifying conditional");
+			      "assuming signed overflow does not occur when "
+			      "simplifying conditional");
 		}
 
 	      tree newconst = fold_convert (TREE_TYPE (innerop), op1);
Index: gcc/tree-ssa-tail-merge.c
===================================================================
--- a/src/gcc/tree-ssa-tail-merge.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-ssa-tail-merge.c	(.../branches/gcc-4_9-branch)
@@ -1618,6 +1618,7 @@
 
       gimple_debug_bind_reset_value (stmt);
       update_stmt (stmt);
+      break;
     }
 }
 
Index: gcc/c-family/c-ppoutput.c
===================================================================
--- a/src/gcc/c-family/c-ppoutput.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/c-family/c-ppoutput.c	(.../branches/gcc-4_9-branch)
@@ -33,7 +33,7 @@
   const cpp_token *prev;	/* Previous token.  */
   const cpp_token *source;	/* Source token for spacing.  */
   int src_line;			/* Line number currently being written.  */
-  unsigned char printed;	/* Nonzero if something output at line.  */
+  bool printed;			/* True if something output at line.  */
   bool first_time;		/* pp_file_change hasn't been called yet.  */
   const char *src_file;		/* Current source file.  */
 } print;
@@ -151,7 +151,7 @@
 
   /* Initialize the print structure.  */
   print.src_line = 1;
-  print.printed = 0;
+  print.printed = false;
   print.prev = 0;
   print.outf = out_stream;
   print.first_time = 1;
@@ -202,12 +202,16 @@
 	    {
 	      do_line_change (pfile, token, loc, false);
 	      putc (' ', print.outf);
+	      print.printed = true;
 	    }
 	  else if (print.source->flags & PREV_WHITE
 		   || (print.prev
 		       && cpp_avoid_paste (pfile, print.prev, token))
 		   || (print.prev == NULL && token->type == CPP_HASH))
-	    putc (' ', print.outf);
+	    {
+	      putc (' ', print.outf);
+	      print.printed = true;
+	    }
 	}
       else if (token->flags & PREV_WHITE)
 	{
@@ -218,6 +222,7 @@
 	      && !in_pragma)
 	    do_line_change (pfile, token, loc, false);
 	  putc (' ', print.outf);
+	  print.printed = true;
 	}
 
       avoid_paste = false;
@@ -235,7 +240,7 @@
 	    fprintf (print.outf, "%s %s", space, name);
 	  else
 	    fprintf (print.outf, "%s", name);
-	  print.printed = 1;
+	  print.printed = true;
 	  in_pragma = true;
 	}
       else if (token->type == CPP_PRAGMA_EOL)
@@ -246,9 +251,9 @@
       else
 	{
 	  if (cpp_get_options (parse_in)->debug)
-	      linemap_dump_location (line_table, token->src_loc,
-				     print.outf);
+	    linemap_dump_location (line_table, token->src_loc, print.outf);
 	  cpp_output_token (token, print.outf);
+	  print.printed = true;
 	}
 
       /* CPP_COMMENT tokens and raw-string literal tokens can
@@ -298,7 +303,7 @@
       size_t len = pfile->out.cur - pfile->out.base;
       maybe_print_line (pfile->out.first_line);
       fwrite (pfile->out.base, 1, len, print.outf);
-      print.printed = 1;
+      print.printed = true;
       if (!CPP_OPTION (pfile, discard_comments))
 	account_for_newlines (pfile->out.base, len);
     }
@@ -319,7 +324,7 @@
     {
       putc ('\n', stream);
       print.src_line++;
-      print.printed = 0;
+      print.printed = false;
     }
 
   if (!flag_no_line_commands
@@ -360,7 +365,7 @@
   /* End any previous line of text.  */
   if (print.printed)
     putc ('\n', stream);
-  print.printed = 0;
+  print.printed = false;
 
   if (!flag_no_line_commands)
     {
@@ -429,7 +434,7 @@
   if (!CPP_OPTION (pfile, traditional))
     {
       int spaces = LOCATION_COLUMN (src_loc) - 2;
-      print.printed = 1;
+      print.printed = true;
 
       while (-- spaces >= 0)
 	putc (' ', print.outf);
@@ -470,6 +475,7 @@
     fputs ((const char *) NODE_NAME (node), print.outf);
 
   putc ('\n', print.outf);
+  print.printed = false;
   linemap_resolve_location (line_table, line,
 			    LRK_MACRO_DEFINITION_LOCATION,
 			    &map);
@@ -521,7 +527,7 @@
     {
       putc ('\n', print.outf);
       print.src_line++;
-      print.printed = 0;
+      print.printed = false;
     }
 
   for (q = define_queue; q;)
@@ -530,6 +536,7 @@
       fputs ("#define ", print.outf);
       fputs (q->macro, print.outf);
       putc ('\n', print.outf);
+      print.printed = false;
       print.src_line++;
       oq = q;
       q = q->next;
@@ -573,6 +580,7 @@
     }
 
   putc ('\n', print.outf);
+  print.printed = false;
   print.src_line++;
 }
 
@@ -638,6 +646,7 @@
   maybe_print_line (line);
   fputs ("#pragma ", print.outf);
   cpp_output_line (pfile, print.outf);
+  print.printed = false;
   print.src_line++;
 }
 
@@ -651,6 +660,7 @@
       fputs ((const char *) cpp_macro_definition (pfile, node),
 	     print.outf);
       putc ('\n', print.outf);
+      print.printed = false;
       print.src_line++;
     }
 
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,20 @@
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/57580
+	* c-ppoutput.c (print): Change printed field to bool.
+	(init_pp_output): Set print.printed to false instead of 0.
+	(scan_translation_unit): Fix up formatting.  Set print.printed
+	to true after printing something other than newline.
+	(scan_translation_unit_trad): Set print.printed to true instead of 1.
+	(maybe_print_line_1): Set print.printed to false instead of 0.
+	(print_line_1): Likewise.
+	(do_line_change): Set print.printed to true instead of 1.
+	(cb_define, dump_queued_macros, cb_include, cb_def_pragma,
+	dump_macro): Set print.printed to false after printing newline.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: gcc/c/c-parser.c
===================================================================
--- a/src/gcc/c/c-parser.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/c/c-parser.c	(.../branches/gcc-4_9-branch)
@@ -1161,7 +1161,8 @@
 static tree c_parser_attributes (c_parser *);
 static struct c_type_name *c_parser_type_name (c_parser *);
 static struct c_expr c_parser_initializer (c_parser *);
-static struct c_expr c_parser_braced_init (c_parser *, tree, bool);
+static struct c_expr c_parser_braced_init (c_parser *, tree, bool,
+					   struct obstack *);
 static void c_parser_initelt (c_parser *, struct obstack *);
 static void c_parser_initval (c_parser *, struct c_expr *,
 			      struct obstack *);
@@ -4088,7 +4089,7 @@
 c_parser_initializer (c_parser *parser)
 {
   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
-    return c_parser_braced_init (parser, NULL_TREE, false);
+    return c_parser_braced_init (parser, NULL_TREE, false, NULL);
   else
     {
       struct c_expr ret;
@@ -4108,7 +4109,8 @@
    top-level initializer in a declaration.  */
 
 static struct c_expr
-c_parser_braced_init (c_parser *parser, tree type, bool nested_p)
+c_parser_braced_init (c_parser *parser, tree type, bool nested_p,
+		      struct obstack *outer_obstack)
 {
   struct c_expr ret;
   struct obstack braced_init_obstack;
@@ -4117,7 +4119,10 @@
   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));
   c_parser_consume_token (parser);
   if (nested_p)
-    push_init_level (0, &braced_init_obstack);
+    {
+      finish_implicit_inits (outer_obstack);
+      push_init_level (0, &braced_init_obstack);
+    }
   else
     really_start_incremental_init (type);
   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
@@ -4364,7 +4369,8 @@
   struct c_expr init;
   gcc_assert (!after || c_dialect_objc ());
   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE) && !after)
-    init = c_parser_braced_init (parser, NULL_TREE, true);
+    init = c_parser_braced_init (parser, NULL_TREE, true,
+				 braced_init_obstack);
   else
     {
       location_t loc = c_parser_peek_token (parser)->location;
@@ -7564,7 +7570,7 @@
       error_at (type_loc, "compound literal has variable size");
       type = error_mark_node;
     }
-  init = c_parser_braced_init (parser, type, false);
+  init = c_parser_braced_init (parser, type, false, NULL);
   finish_init ();
   maybe_warn_string_init (type, init);
 
Index: gcc/c/c-typeck.c
===================================================================
--- a/src/gcc/c/c-typeck.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/c/c-typeck.c	(.../branches/gcc-4_9-branch)
@@ -7164,6 +7164,29 @@
     }
 }
 
+/* Called when we see an open brace for a nested initializer.  Finish
+   off any pending levels with implicit braces.  */
+void
+finish_implicit_inits (struct obstack *braced_init_obstack)
+{
+  while (constructor_stack->implicit)
+    {
+      if ((TREE_CODE (constructor_type) == RECORD_TYPE
+	   || TREE_CODE (constructor_type) == UNION_TYPE)
+	  && constructor_fields == 0)
+	process_init_element (pop_init_level (1, braced_init_obstack),
+			      true, braced_init_obstack);
+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE
+	       && constructor_max_index
+	       && tree_int_cst_lt (constructor_max_index,
+				   constructor_index))
+	process_init_element (pop_init_level (1, braced_init_obstack),
+			      true, braced_init_obstack);
+      else
+	break;
+    }
+}
+
 /* Push down into a subobject, for initialization.
    If this is for an explicit set of braces, IMPLICIT is 0.
    If it is because the next element belongs at a lower level,
@@ -7175,32 +7198,6 @@
   struct constructor_stack *p;
   tree value = NULL_TREE;
 
-  /* If we've exhausted any levels that didn't have braces,
-     pop them now.  If implicit == 1, this will have been done in
-     process_init_element; do not repeat it here because in the case
-     of excess initializers for an empty aggregate this leads to an
-     infinite cycle of popping a level and immediately recreating
-     it.  */
-  if (implicit != 1)
-    {
-      while (constructor_stack->implicit)
-	{
-	  if ((TREE_CODE (constructor_type) == RECORD_TYPE
-	       || TREE_CODE (constructor_type) == UNION_TYPE)
-	      && constructor_fields == 0)
-	    process_init_element (pop_init_level (1, braced_init_obstack),
-				  true, braced_init_obstack);
-	  else if (TREE_CODE (constructor_type) == ARRAY_TYPE
-		   && constructor_max_index
-		   && tree_int_cst_lt (constructor_max_index,
-				       constructor_index))
-	    process_init_element (pop_init_level (1, braced_init_obstack),
-				  true, braced_init_obstack);
-	  else
-	    break;
-	}
-    }
-
   /* Unless this is an explicit brace, we need to preserve previous
      content if any.  */
   if (implicit)
@@ -7611,6 +7608,7 @@
     }
 
   constructor_designated = 1;
+  finish_implicit_inits (braced_init_obstack);
   push_init_level (2, braced_init_obstack);
   return 0;
 }
@@ -8941,6 +8939,7 @@
 	      p = p->next;
 	      if (!p)
 		break;
+	      finish_implicit_inits (braced_init_obstack);
 	      push_init_level (2, braced_init_obstack);
 	      p->stack = constructor_stack;
 	      if (p->range_end && tree_int_cst_equal (p->index, p->range_end))
Index: gcc/c/c-tree.h
===================================================================
--- a/src/gcc/c/c-tree.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/c/c-tree.h	(.../branches/gcc-4_9-branch)
@@ -608,6 +608,7 @@
 extern void start_init (tree, tree, int);
 extern void finish_init (void);
 extern void really_start_incremental_init (tree);
+extern void finish_implicit_inits (struct obstack *);
 extern void push_init_level (int, struct obstack *);
 extern struct c_expr pop_init_level (int, struct obstack *);
 extern void set_init_index (tree, tree, struct obstack *);
Index: gcc/cgraph.c
===================================================================
--- a/src/gcc/cgraph.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cgraph.c	(.../branches/gcc-4_9-branch)
@@ -2527,13 +2527,14 @@
 
   if (avail > AVAIL_OVERWRITABLE)
     for (cs = node->callers; cs != NULL; cs = cs->next_caller)
-      if (!cs->indirect_inlining_edge)
+      if (!cs->indirect_inlining_edge
+	  && !cs->caller->thunk.thunk_p)
         redirect_callers->safe_push (cs);
   return false;
 }
 
 /* Collect all callers of NODE and its aliases that are known to lead to NODE
-   (i.e. are not overwritable).  */
+   (i.e. are not overwritable) and that are not thunks.  */
 
 vec<cgraph_edge_p> 
 collect_callers_of_node (struct cgraph_node *node)
Index: gcc/optabs.c
===================================================================
--- a/src/gcc/optabs.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/optabs.c	(.../branches/gcc-4_9-branch)
@@ -7374,9 +7374,9 @@
 
    *PTARGET_BOOL is an optional place to store the boolean success/failure.
    *PTARGET_OVAL is an optional place to store the old value from memory.
-   Both target parameters may be NULL to indicate that we do not care about
-   that return value.  Both target parameters are updated on success to
-   the actual location of the corresponding result.
+   Both target parameters may be NULL or const0_rtx to indicate that we do
+   not care about that return value.  Both target parameters are updated on
+   success to the actual location of the corresponding result.
 
    MEMMODEL is the memory model variant to use.
 
@@ -7401,6 +7401,9 @@
   /* Make sure we always have some place to put the return oldval.
      Further, make sure that place is distinct from the input expected,
      just in case we need that path down below.  */
+  if (ptarget_oval && *ptarget_oval == const0_rtx)
+    ptarget_oval = NULL;
+
   if (ptarget_oval == NULL
       || (target_oval = *ptarget_oval) == NULL
       || reg_overlap_mentioned_p (expected, target_oval))
@@ -7411,6 +7414,9 @@
     {
       enum machine_mode bool_mode = insn_data[icode].operand[0].mode;
 
+      if (ptarget_bool && *ptarget_bool == const0_rtx)
+	ptarget_bool = NULL;
+
       /* Make sure we always have a place for the bool operand.  */
       if (ptarget_bool == NULL
 	  || (target_bool = *ptarget_bool) == NULL
@@ -7474,9 +7480,10 @@
   if (libfunc != NULL)
     {
       rtx addr = convert_memory_address (ptr_mode, XEXP (mem, 0));
-      target_oval = emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,
-					     mode, 3, addr, ptr_mode,
-					     expected, mode, desired, mode);
+      rtx target = emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,
+					    mode, 3, addr, ptr_mode,
+					    expected, mode, desired, mode);
+      emit_move_insn (target_oval, target);
 
       /* Compute the boolean return value only if requested.  */
       if (ptarget_bool)
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-4_9-branch)
@@ -1 +1 @@
-20150626
+20160413
Index: gcc/postreload.c
===================================================================
--- a/src/gcc/postreload.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/postreload.c	(.../branches/gcc-4_9-branch)
@@ -1094,7 +1094,6 @@
 reload_combine_recognize_pattern (rtx insn)
 {
   rtx set, reg, src;
-  unsigned int regno;
 
   set = single_set (insn);
   if (set == NULL_RTX)
@@ -1106,8 +1105,21 @@
       || hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] != 1)
     return false;
 
-  regno = REGNO (reg);
+  unsigned int regno = REGNO (reg);
+  machine_mode mode = GET_MODE (reg);
 
+  if (reg_state[regno].use_index < 0
+      || reg_state[regno].use_index >= RELOAD_COMBINE_MAX_USES)
+    return false;
+
+  for (int i = reg_state[regno].use_index;
+       i < RELOAD_COMBINE_MAX_USES; i++)
+    {
+      struct reg_use *use = reg_state[regno].reg_use + i;
+      if (GET_MODE (*use->usep) != mode)
+	return false;
+    }
+
   /* Look for (set (REGX) (CONST_INT))
      (set (REGX) (PLUS (REGX) (REGY)))
      ...
@@ -1128,8 +1140,6 @@
       && REG_P (XEXP (src, 1))
       && rtx_equal_p (XEXP (src, 0), reg)
       && !rtx_equal_p (XEXP (src, 1), reg)
-      && reg_state[regno].use_index >= 0
-      && reg_state[regno].use_index < RELOAD_COMBINE_MAX_USES
       && last_label_ruid < reg_state[regno].use_ruid)
     {
       rtx base = XEXP (src, 1);
Index: gcc/tree.c
===================================================================
--- a/src/gcc/tree.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree.c	(.../branches/gcc-4_9-branch)
@@ -1119,8 +1119,10 @@
 {
   const_tree const t = (const_tree) x;
 
-  return (TREE_INT_CST_HIGH (t) ^ TREE_INT_CST_LOW (t)
-	  ^ TYPE_UID (TREE_TYPE (t)));
+  hashval_t hash = TYPE_UID (TREE_TYPE (t));
+  hash = iterative_hash_host_wide_int (TREE_INT_CST_HIGH (t), hash);
+  hash = iterative_hash_host_wide_int (TREE_INT_CST_LOW (t), hash);
+  return hash;
 }
 
 /* Return nonzero if the value represented by *X (an INTEGER_CST tree node)
Index: gcc/ipa-cp.c
===================================================================
--- a/src/gcc/ipa-cp.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ipa-cp.c	(.../branches/gcc-4_9-branch)
@@ -1411,6 +1411,18 @@
   return ret;
 }
 
+/* Return true if on the way cfrom CS->caller to the final (non-alias and
+   non-thunk) destination, the call passes through a thunk.  */
+
+static bool
+call_passes_through_thunk_p (struct cgraph_edge *cs)
+{
+  struct cgraph_node *alias_or_thunk = cs->callee;
+  while (alias_or_thunk->alias)
+    alias_or_thunk = cgraph_alias_target (alias_or_thunk);
+  return alias_or_thunk->thunk.thunk_p;
+}
+
 /* Propagate constants from the caller to the callee of CS.  INFO describes the
    caller.  */
 
@@ -1419,7 +1431,7 @@
 {
   struct ipa_node_params *callee_info;
   enum availability availability;
-  struct cgraph_node *callee, *alias_or_thunk;
+  struct cgraph_node *callee;
   struct ipa_edge_args *args;
   bool ret = false;
   int i, args_count, parms_count;
@@ -1439,10 +1451,7 @@
   /* If this call goes through a thunk we must not propagate to the first (0th)
      parameter.  However, we might need to uncover a thunk from below a series
      of aliases first.  */
-  alias_or_thunk = cs->callee;
-  while (alias_or_thunk->alias)
-    alias_or_thunk = cgraph_alias_target (alias_or_thunk);
-  if (alias_or_thunk->thunk.thunk_p)
+  if (call_passes_through_thunk_p (cs))
     {
       ret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info,
 							       0));
@@ -2837,7 +2846,9 @@
 	  struct ipa_jump_func *jump_func;
 	  tree t;
 
-          if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs)))
+          if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))
+             || (i == 0
+                 && call_passes_through_thunk_p (cs)))
             {
               newval = NULL_TREE;
               break;
Index: gcc/tree-scalar-evolution.c
===================================================================
--- a/src/gcc/tree-scalar-evolution.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-scalar-evolution.c	(.../branches/gcc-4_9-branch)
@@ -935,27 +935,25 @@
 	      limit++;
 
 	      evol = *evolution_of_loop;
+	      evol = add_to_evolution
+		  (loop->num,
+		   chrec_convert (type, evol, at_stmt),
+		   code, rhs1, at_stmt);
 	      res = follow_ssa_edge
 		(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, &evol, limit);
-
 	      if (res == t_true)
-		*evolution_of_loop = add_to_evolution
-		  (loop->num,
-		   chrec_convert (type, evol, at_stmt),
-		   code, rhs1, at_stmt);
-
+		*evolution_of_loop = evol;
 	      else if (res == t_false)
 		{
+		  *evolution_of_loop = add_to_evolution
+		      (loop->num,
+		       chrec_convert (type, *evolution_of_loop, at_stmt),
+		       code, rhs0, at_stmt);
 		  res = follow_ssa_edge
 		    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi,
 		     evolution_of_loop, limit);
-
 		  if (res == t_true)
-		    *evolution_of_loop = add_to_evolution
-		      (loop->num,
-		       chrec_convert (type, *evolution_of_loop, at_stmt),
-		       code, rhs0, at_stmt);
-
+		    ;
 		  else if (res == t_dont_know)
 		    *evolution_of_loop = chrec_dont_know;
 		}
@@ -968,15 +966,15 @@
 	    {
 	      /* Match an assignment under the form:
 		 "a = b + ...".  */
+	      *evolution_of_loop = add_to_evolution
+		  (loop->num, chrec_convert (type, *evolution_of_loop,
+					     at_stmt),
+		   code, rhs1, at_stmt);
 	      res = follow_ssa_edge
 		(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi,
 		 evolution_of_loop, limit);
 	      if (res == t_true)
-		*evolution_of_loop = add_to_evolution
-		  (loop->num, chrec_convert (type, *evolution_of_loop,
-					     at_stmt),
-		   code, rhs1, at_stmt);
-
+		;	
 	      else if (res == t_dont_know)
 		*evolution_of_loop = chrec_dont_know;
 	    }
@@ -986,15 +984,15 @@
 	{
 	  /* Match an assignment under the form:
 	     "a = ... + c".  */
+	  *evolution_of_loop = add_to_evolution
+	      (loop->num, chrec_convert (type, *evolution_of_loop,
+					 at_stmt),
+	       code, rhs0, at_stmt);
 	  res = follow_ssa_edge
 	    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi,
 	     evolution_of_loop, limit);
 	  if (res == t_true)
-	    *evolution_of_loop = add_to_evolution
-	      (loop->num, chrec_convert (type, *evolution_of_loop,
-					 at_stmt),
-	       code, rhs0, at_stmt);
-
+	    ;
 	  else if (res == t_dont_know)
 	    *evolution_of_loop = chrec_dont_know;
 	}
@@ -1019,13 +1017,13 @@
 	  if (TREE_CODE (rhs1) == SSA_NAME)
 	    limit++;
 
+	  *evolution_of_loop = add_to_evolution
+	      (loop->num, chrec_convert (type, *evolution_of_loop, at_stmt),
+	       MINUS_EXPR, rhs1, at_stmt);
 	  res = follow_ssa_edge (loop, SSA_NAME_DEF_STMT (rhs0), halting_phi,
 				 evolution_of_loop, limit);
 	  if (res == t_true)
-	    *evolution_of_loop = add_to_evolution
-	      (loop->num, chrec_convert (type, *evolution_of_loop, at_stmt),
-	       MINUS_EXPR, rhs1, at_stmt);
-
+	    ;
 	  else if (res == t_dont_know)
 	    *evolution_of_loop = chrec_dont_know;
 	}
Index: gcc/configure
===================================================================
--- a/src/gcc/configure	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/configure	(.../branches/gcc-4_9-branch)
@@ -21552,7 +21552,7 @@
 if test "${with_plugin_ld+set}" = set; then :
   withval=$with_plugin_ld; if test x"$withval" != x; then
    ORIGINAL_PLUGIN_LD_FOR_TARGET="$withval"
-   PLUGIN_LD_SUFFIX=`echo $withval | sed -e "s,$target_alias-,,"`
+   PLUGIN_LD_SUFFIX="$withval"
  fi
 fi
 
@@ -24810,7 +24810,7 @@
 else
   gcc_cv_as_ix86_filds=no
   if test x$gcc_cv_as != x; then
-    $as_echo 'filds mem; fists mem' > conftest.s
+    $as_echo 'filds (%ebp); fists (%ebp)' > conftest.s
     if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
   { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
   (eval $ac_try) 2>&5
@@ -24841,7 +24841,7 @@
 else
   gcc_cv_as_ix86_fildq=no
   if test x$gcc_cv_as != x; then
-    $as_echo 'fildq mem; fistpq mem' > conftest.s
+    $as_echo 'fildq (%ebp); fistpq (%ebp)' > conftest.s
     if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
   { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
   (eval $ac_try) 2>&5
@@ -27947,6 +27947,8 @@
 
   # Check whether isl_schedule_constraints_compute_schedule is available;
   # it's new in ISL-0.13.
+  # Check whether isl_options_set_schedule_serialize_sccs is available;
+  # it's new in ISL-0.15.
   saved_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $ISLINC"
   saved_LIBS="$LIBS"
@@ -27975,6 +27977,29 @@
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_schedule_constraints_compute_schedule" >&5
 $as_echo "$ac_has_isl_schedule_constraints_compute_schedule" >&6; }
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking Checking for isl_options_set_schedule_serialize_sccs" >&5
+$as_echo_n "checking Checking for isl_options_set_schedule_serialize_sccs... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <isl/schedule.h>
+int
+main ()
+{
+isl_options_set_schedule_serialize_sccs (NULL, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_has_isl_options_set_schedule_serialize_sccs=yes
+else
+  ac_has_isl_options_set_schedule_serialize_sccs=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_options_set_schedule_serialize_sccs" >&5
+$as_echo "$ac_has_isl_options_set_schedule_serialize_sccs" >&6; }
+
   LIBS="$saved_LIBS"
   CFLAGS="$saved_CFLAGS"
 
@@ -27983,6 +28008,12 @@
 $as_echo "#define HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE 1" >>confdefs.h
 
   fi
+
+  if test x"$ac_has_isl_options_set_schedule_serialize_sccs" = x"yes"; then
+
+$as_echo "#define HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS 1" >>confdefs.h
+
+  fi
 fi
 
 
Index: gcc/graphite-blocking.c
===================================================================
--- a/src/gcc/graphite-blocking.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-blocking.c	(.../branches/gcc-4_9-branch)
@@ -24,6 +24,7 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
Index: gcc/builtins.c
===================================================================
--- a/src/gcc/builtins.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/builtins.c	(.../branches/gcc-4_9-branch)
@@ -9997,6 +9997,8 @@
 
   mode = TYPE_MODE (TREE_TYPE (arg));
 
+  bool is_ibm_extended = MODE_COMPOSITE_P (mode);
+
   /* If there is no optab, try generic code.  */
   switch (DECL_FUNCTION_CODE (fndecl))
     {
@@ -10006,10 +10008,18 @@
       {
 	/* isinf(x) -> isgreater(fabs(x),DBL_MAX).  */
 	tree const isgr_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);
-	tree const type = TREE_TYPE (arg);
+	tree type = TREE_TYPE (arg);
 	REAL_VALUE_TYPE r;
 	char buf[128];
 
+	if (is_ibm_extended)
+	  {
+	    /* NaN and Inf are encoded in the high-order double value
+	       only.  The low-order value is not significant.  */
+	    type = double_type_node;
+	    mode = DFmode;
+	    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);
+	  }
 	get_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));
 	real_from_string (&r, buf);
 	result = build_call_expr (isgr_fn, 2,
@@ -10022,10 +10032,18 @@
       {
 	/* isfinite(x) -> islessequal(fabs(x),DBL_MAX).  */
 	tree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);
-	tree const type = TREE_TYPE (arg);
+	tree type = TREE_TYPE (arg);
 	REAL_VALUE_TYPE r;
 	char buf[128];
 
+	if (is_ibm_extended)
+	  {
+	    /* NaN and Inf are encoded in the high-order double value
+	       only.  The low-order value is not significant.  */
+	    type = double_type_node;
+	    mode = DFmode;
+	    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);
+	  }
 	get_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));
 	real_from_string (&r, buf);
 	result = build_call_expr (isle_fn, 2,
@@ -10045,21 +10063,72 @@
 	/* isnormal(x) -> isgreaterequal(fabs(x),DBL_MIN) &
 	   islessequal(fabs(x),DBL_MAX).  */
 	tree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);
-	tree const isge_fn = builtin_decl_explicit (BUILT_IN_ISGREATEREQUAL);
-	tree const type = TREE_TYPE (arg);
+	tree type = TREE_TYPE (arg);
+	tree orig_arg, max_exp, min_exp;
+	machine_mode orig_mode = mode;
 	REAL_VALUE_TYPE rmax, rmin;
 	char buf[128];
 
+	orig_arg = arg = builtin_save_expr (arg);
+	if (is_ibm_extended)
+	  {
+	    /* Use double to test the normal range of IBM extended
+	       precision.  Emin for IBM extended precision is
+	       different to emin for IEEE double, being 53 higher
+	       since the low double exponent is at least 53 lower
+	       than the high double exponent.  */
+	    type = double_type_node;
+	    mode = DFmode;
+	    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);
+	  }
+	arg = fold_build1_loc (loc, ABS_EXPR, type, arg);
+
 	get_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));
 	real_from_string (&rmax, buf);
-	sprintf (buf, "0x1p%d", REAL_MODE_FORMAT (mode)->emin - 1);
+	sprintf (buf, "0x1p%d", REAL_MODE_FORMAT (orig_mode)->emin - 1);
 	real_from_string (&rmin, buf);
-	arg = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));
-	result = build_call_expr (isle_fn, 2, arg,
-				  build_real (type, rmax));
-	result = fold_build2 (BIT_AND_EXPR, integer_type_node, result,
-			      build_call_expr (isge_fn, 2, arg,
-					       build_real (type, rmin)));
+	max_exp = build_real (type, rmax);
+	min_exp = build_real (type, rmin);
+
+	max_exp = build_call_expr (isle_fn, 2, arg, max_exp);
+	if (is_ibm_extended)
+	  {
+	    /* Testing the high end of the range is done just using
+	       the high double, using the same test as isfinite().
+	       For the subnormal end of the range we first test the
+	       high double, then if its magnitude is equal to the
+	       limit of 0x1p-969, we test whether the low double is
+	       non-zero and opposite sign to the high double.  */
+	    tree const islt_fn = builtin_decl_explicit (BUILT_IN_ISLESS);
+	    tree const isgt_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);
+	    tree gt_min = build_call_expr (isgt_fn, 2, arg, min_exp);
+	    tree eq_min = fold_build2 (EQ_EXPR, integer_type_node,
+				       arg, min_exp);
+	    tree as_complex = build1 (VIEW_CONVERT_EXPR,
+				      complex_double_type_node, orig_arg);
+	    tree hi_dbl = build1 (REALPART_EXPR, type, as_complex);
+	    tree lo_dbl = build1 (IMAGPART_EXPR, type, as_complex);
+	    tree zero = build_real (type, dconst0);
+	    tree hilt = build_call_expr (islt_fn, 2, hi_dbl, zero);
+	    tree lolt = build_call_expr (islt_fn, 2, lo_dbl, zero);
+	    tree logt = build_call_expr (isgt_fn, 2, lo_dbl, zero);
+	    tree ok_lo = fold_build1 (TRUTH_NOT_EXPR, integer_type_node,
+				      fold_build3 (COND_EXPR,
+						   integer_type_node,
+						   hilt, logt, lolt));
+	    eq_min = fold_build2 (TRUTH_ANDIF_EXPR, integer_type_node,
+				  eq_min, ok_lo);
+	    min_exp = fold_build2 (TRUTH_ORIF_EXPR, integer_type_node,
+				   gt_min, eq_min);
+	  }
+	else
+	  {
+	    tree const isge_fn
+	      = builtin_decl_explicit (BUILT_IN_ISGREATEREQUAL);
+	    min_exp = build_call_expr (isge_fn, 2, arg, min_exp);
+	  }
+	result = fold_build2 (BIT_AND_EXPR, integer_type_node,
+			      max_exp, min_exp);
 	return result;
       }
     default:
@@ -10154,6 +10223,15 @@
 	  return real_isnan (&r) ? integer_one_node : integer_zero_node;
 	}
 
+      {
+	bool is_ibm_extended = MODE_COMPOSITE_P (TYPE_MODE (TREE_TYPE (arg)));
+	if (is_ibm_extended)
+	  {
+	    /* NaN and Inf are encoded in the high-order double value
+	       only.  The low-order value is not significant.  */
+	    arg = fold_build1_loc (loc, NOP_EXPR, double_type_node, arg);
+	  }
+      }
       arg = builtin_save_expr (arg);
       return fold_build2_loc (loc, UNORDERED_EXPR, type, arg, arg);
 
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-4_9-branch)
@@ -11192,7 +11192,8 @@
       DECL_STATIC_DESTRUCTOR (new_decl) = 0;
       new_node
 	= cgraph_copy_node_for_versioning (old_node, new_decl, vNULL, NULL);
-      cgraph_call_function_insertion_hooks (new_node);
+      if (old_node->in_other_partition)
+	new_node->in_other_partition = 1;
     }
   if (new_node == NULL)
     return new_node;
Index: gcc/tree-chrec.c
===================================================================
--- a/src/gcc/tree-chrec.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-chrec.c	(.../branches/gcc-4_9-branch)
@@ -730,12 +730,12 @@
 	/* There is no evolution in this loop.  */
 	return initial_condition (chrec);
 
+      else if (flow_loop_nested_p (loop, chloop))
+	return hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec),
+							loop_num);
+
       else
-	{
-	  gcc_assert (flow_loop_nested_p (loop, chloop));
-	  return hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec),
-							  loop_num);
-	}
+	return chrec_dont_know;
 
     default:
       return chrec;
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,1224 @@
+2016-04-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-04-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/70566
+	* config/arm/thumb2.md (tst + branch-> lsls + branch
+	peephole below *orsi_not_shiftsi_si): Require that condition
+	register is dead after the peephole.
+	(second peephole after the above): Likewise.
+
+2016-04-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/70630
+	* config/sparc/sparc.c (sparc_compute_frame_size): Add parentheses.
+
+2016-04-11  Alan Modra  <amodra@gmail.com>
+
+	PR target/70117
+	* builtins.c (fold_builtin_classify): For IBM extended precision,
+	look at just the high-order double to test for NaN.
+	(fold_builtin_interclass_mathfn): Similarly for Inf.  For isnormal
+	test just the high double for Inf but both doubles for subnormal
+	limit.
+
+2016-04-05  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/predicates.md (integer_store_memory_operand): Accept
+	REG+D operands with a large offset when reload_in_progress is true.
+	(floating_point_store_memory_operand): Likewise.
+
+2016-04-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/70510
+	* config/i386/sse.md (iptr): Add V16SI and V8DI modes.
+
+2016-04-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+	    Jakub Jelinek <jakub@redhat.com>
+
+	PR middle-end/70457
+	* tree-inline.c (estimate_num_insn): Use gimple_call_builtin_p
+	to ensure a call statement is compatible with a built-in's
+	prototype.
+	* tree-ssa-math-opts.c (execute_cse_sincos_1): Likewise.
+	(execute_cse_sincos): Likewise.
+	(execute_optimize_widening_mul): Likewise.
+
+2016-03-31  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/arm/sync.md (arm_atomic_loaddi2_ldrd): Fix output template
+	for non-unified syntax.
+
+2016-03-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/70460
+	* ira.c (indirect_jump_optimize): Don't substitute LABEL_REF
+	with operand from REG_LABEL_OPERAND, instead substitute
+	SET_SRC or REG_EQUAL note content if it is a LABEL_REF.
+	Don't do anything for REG_NON_LOCAL_GOTO jumps.
+
+2016-03-31  Alan Modra  <amodra@gmail.com>
+
+	Backport from mainline
+	2016-02-16  Alan Modra  <amodra@gmail.com>
+	PR target/68973
+	* config/rs6000/rs6000.md (reload_vsx_from_gprsf): Rewrite splitter.
+	(p8_mtvsrd_df, p8_mtvsrd_sf): New.
+	(p8_mtvsrd_1, p8_mtvsrd_2): Delete.
+	(p8_mtvsrwz): New.
+	(p8_mtvsrwz_1, p8_mtvsrwz_2): Delete.
+	(p8_xxpermdi_<mode>): Take two DF inputs rather than one TF.
+	(p8_fmrgow_<mode>): Likewise.
+	(reload_vsx_from_gpr<mode>): Adjust for above.  Use "wa" for
+	clobber constraint.
+	(reload_fpr_from_gpr<mode>): Adjust for above.  Use "d" for
+	op0 constraint.
+	(reload_vsx_from_gprsf): Use p8_mtvsrd_sf rather than attempting
+	to use movdi_internal64.  Remove op0_di.
+	* config/rs6000/vsx.md (vsx_xscvspdpn_directmove): Make op1 SFmode.
+
+2016-03-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69875
+	* config/arm/arm.h (TARGET_HAVE_LPAE): Define.
+	* config/arm/unspecs.md (VUNSPEC_LDRD_ATOMIC): New value.
+	* config/arm/sync.md (arm_atomic_loaddi2_ldrd): New pattern.
+	(atomic_loaddi_1): Delete.
+	(atomic_loaddi): Rewrite expander using the above changes.
+
+2016-03-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/70327
+	* config/i386/i386.md (movxi): Use ix86_expand_vector_move instead
+	of ix86_expand_move.
+	(movoi): Ditto.
+	(movti): Use general_operand for operand 1 predicate.
+
+2016-03-21  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2016-03-18  Tom de Vries  <tom@codesourcery.com>
+
+	PR ipa/70161
+	* passes.c (execute_one_ipa_transform_pass): Add missing argument to
+	execute_function_dump.
+
+2016-03-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/70188
+	* config/pa/constraints.md: Revert 2015-02-13 change.  Use
+	define_constraint for "Q" and "T" constraints.
+
+2016-03-16  Alan Modra  <amodra@gmail.com>
+
+	PR rtl-optimization/69195
+	PR rtl-optimization/47992
+	* ira.c (indirect_jump_optimize): Ignore artificial defs.
+	Add comments.
+
+2016-03-15  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-03-04  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR rtl-optimization/69941
+	* postreload.c (reload_combine_recognize_pattern): Ensure all uses of
+	the reg share its mode.
+
+2016-03-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2016-03-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/62281
+	* config/i386/sol2.h (STACK_REALIGN_DEFAULT): Define.
+
+	Revert:
+	2014-02-11  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libgomp/60107
+	* config/i386/sol2-9.h: New file.
+	* config.gcc (i[34567]86-*-solaris2* | x86_64-*-solaris2.1[0-9]*,
+	*-*-solaris2.9*): Use it.
+
+2016-03-10  Alan Modra  <amodra@gmail.com>
+
+	PR rtl-optimization/69195
+	PR rtl-optimization/47992
+	* ira.c (recorded_label_ref): Delete.
+	(update_equiv_regs): Return void.
+	(indirect_jump_optimize): New function.
+	(ira): Call indirect_jump_optimize and delete_trivially_dead_insns
+	before regstat_compute_ri.  Don't rebuild_jump_labels here.
+
+2016-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/70059
+	* config/i386/sse.md (vec_set_lo_<mode><mask_name>,
+	<extract_type_2>_vinsert<shuffletype><extract_suf_2>_mask): Formatting
+	fixes.
+	(vec_set_hi_<mode><mask_name>): Likewise.  Swap VEC_CONCAT operands.
+
+2016-03-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/70007
+	* gcse.c (compute_ld_motion_mems): Tidy up and also invalidate memory
+	references present in REG_EQUAL notes attached to non-SET patterns.
+
+2016-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.md (*altivec_lvxl_<mode>_internal): Output
+	correct instruction.
+
+2016-02-17  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-12  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR c/69522
+	* c-parser.c (c_parser_braced_init): New arg outer_obstack.  All
+	callers changed.  If nested_p is true, use it to call
+	finish_implicit_inits.
+	* c-tree.h (finish_implicit_inits): Declare.
+	* c-typeck.c (finish_implicit_inits): New function.  Move code
+	from ...
+	(push_init_level): ... here.
+	(set_designator, process_init_element): Call finish_implicit_inits.
+
+2016-02-16  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-15  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR rtl-optimization/69752
+	* ira.c (update_equiv_regs): When looking for more than a single SET,
+	also take other side effects into account.
+
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	PR lto/67709
+	2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	* omp-low.c (simd_clone_create): Remove call to
+	symtab->call_cgraph_insertion_hooks.
+
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	* omp-low.c (simd_clone_create): Set in_other_partition
+	for created clones.
+
+2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/67260
+	* config/sh/sh.md (sibcall_value_pcrel): Replace =&k scratch reg with
+	fixed R1_REG scratch reg.
+
+2016-02-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69715
+	* tree-ssa.c (execute_update_addresses_taken): Mark non-decl
+	LHS on calls as non-rewritable.
+
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69579
+	* tree-ssa-loop-ivcanon.c (propagate_constants_for_unrolling):
+	Do not propagate through abnormal PHI results.
+
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69574
+	* tree-chrec.c (hide_evolution_in_other_loops_than_loop): Instead
+	of asserting return chrec_dont_know.
+
+2016-02-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-01-18  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/69308
+	* gimple.c (gimple_could_trap_p_1): Handle GIMPLE_COND.
+
+	2015-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62217
+	* tree-ssa-dom.c (cprop_operand): Avoid propagating copies
+	into BIVs.
+
+	2015-06-18  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-06-03  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/66375
+	* tree-scalar-evolution.c (follow_ssa_edge_binary): First
+	add to the evolution before following SSA edges.
+
+	2015-06-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-06-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/66413
+	* tree-inline.c (insert_init_debug_bind): Unshare value.
+
+	2015-07-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/66794
+	* gimple-ssa-isolate-paths.c (gimple_ssa_isolate_erroneous_paths):
+	Free post-dominators.
+
+	2015-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/66823
+	* tree-if-conv.c (memrefs_read_or_written_unconditionally): Fix
+	inverted predicate.
+
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69432
+	* config/i386/i386.c (expand_small_movmem_or_setmem,
+	expand_set_or_movmem_prologue_epilogue_by_misaligned_moves): Spelling
+	fixes.
+	(ix86_expand_set_or_movmem): Call do_pending_stack_adjust () early
+	if dynamic_check != -1.
+
+	2016-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/67653
+	* gimplify.c (gimplify_asm_expr): Warn if it is too late to
+	attempt to mark memory input operand addressable and
+	call prepare_gimple_addressable in that case.  Don't adjust
+	input_location for diagnostics, use error_at instead.
+
+	2016-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/68955
+	PR rtl-optimization/64557
+	* dse.c (record_store, check_mem_read_rtx): Don't call get_addr
+	here.  Fix up formatting.
+	* alias.c (get_addr): Handle VALUE +/- CONST_SCALAR_INT_P.
+
+	2016-01-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69214
+	* tree-vrp.c (simplify_cond_using_ranges): Don't propagate
+	innerop into a comparison if SSA_NAME_OCCURS_IN_ABNORMAL_PHI.
+	Formatting fix.
+
+2016-02-11  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2016-02-11  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/69713
+	* config/sh/sh.md (casesi_worker_0): Add T_REG use.
+
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/68960
+	* gimple-expr.c (copy_var_decl): If var has DECL_USER_ALIGN set, copy
+	it and DECL_ALIGN too.
+
+	2016-01-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69015
+	* ifcvt.c (find_cond_trap): Give up if returnjump_p (jump).
+
+	2015-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/68376
+	PR rtl-optimization/68670
+	* ifcvt.c (noce_try_abs): For one_cmpl allow < 0, >= 0
+	or > -1 conditions regardless of negate, and disallow
+	all other conditions.
+
+	2015-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/68376
+	* ifcvt.c (noce_try_abs): Disable one_cmpl optimization if
+	encountering x <= 0 ? ~x : x or x > 0 ? ~x : x.
+
+	2015-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/68680
+	* calls.c (special_function_p): Return ECF_MAY_BE_ALLOCA for
+	BUILT_IN_ALLOCA{,_WITH_ALIGN}.  Don't check for __builtin_alloca
+	by name.
+
+	2015-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/66432
+	* tree-inline.c (copy_debug_stmt): If
+	gimple_debug_source_bind_get_value is DECL_ORIGIN of a PARM_DECL
+	in decl_debug_args, don't call remap_gimple_op_r on it.
+
+	2015-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/67770
+	* config/i386/i386.md (simple_return): Disable if
+	ix86_static_chain_on_stack is true.
+
+2016-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69644
+	* config/rs6000/rs6000.c (rs6000_expand_atomic_compare_and_swap):
+	Force oldval into register if it does not satisfy reg_or_short_operand
+	predicate.  Fix up formatting.
+
+2016-02-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/67032
+	* config/i386/i386.c (geode_cost): Increase cost of MMX and SSE moves.
+
+2016-02-02  Alan Modra  <amodra@gmail.com>
+
+	PR target/69548
+	* config/rs6000/predicates.md (quad_int_reg_operand): Don't
+	allow subregs.
+
+2016-01-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69355
+	* tree-sra.c (analyze_access_subtree): Correct hole detection when
+	total_scalarization fails.
+
+2016-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2016-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69551
+	* config/i386/i386.c (ix86_expand_vector_set) <case V4SImode>: For
+	SSE1, copy target into the temporary reg first before recursing
+	on it.
+
+2016-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/69459
+	* config/i386/constraints.md (C): Only accept constant zero operand.
+	(BC): New constraint.
+	* config/i386/sse.md (*mov<mode>_internal): Use BC constraint
+	instead of C constraint.
+	* doc/md.texi (Machine Constraints): Update description
+	of C constraint.
+
+2016-01-26  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69110
+	* tree-data-ref.c (initialize_data_dependence_relation): Handle
+	DR_NUM_DIMENSIONS == 0.
+
+2016-01-25  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	PR tree-optimization/PR64091
+	2014-11-27  Richard Biener  <rguenther@suse.de>
+
+	* tree-ssa-tail-merge.c (update_debug_stmt): After resetting
+	the stmt break from the loop over use operands.
+
+2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69403
+	* config/arm/thumb2.md (*thumb2_ior_scc_strict_it): Convert to
+	define_insn_and_split.  Ensure operands[1] and operands[0] do not
+	get assigned the same register.
+
+2016-01-22  Bernd Schmidt <bschmidt@redhat.com>
+
+	PR target/63681
+	* cfgrtl.c (cfg_layout_initialize): Weaken assert to only trigger if
+	flag_reorder_blocks_and_partition.
+	* hw-doloop.c (reorg_loops): Avoid reordering if that flag is set.
+
+2016-01-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_save_gprs_to_fprs): Add CFA_REGISTER
+	reg note to the GPR -> FPR save instructions.
+
+2016-01-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-09-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/67439
+	* config/arm/arm.md (*arm32_movhf): Remove !arm_restrict_it from
+	predicate.  Set predicable_short_it attr to "no".
+
+2016-01-19  Sergei Trofimovich <siarheit@google.com>
+
+	Backport from mainline
+	PR other/60465
+	* config/ia64/ia64.c (ia64_expand_load_address): Use gprel64
+	for local symbolic operands.
+	* config/ia64/predicates.md (local_symbolic_operand64): New
+	predicate.
+
+2016-01-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2016-01-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/68799
+	* gimple-ssa-strength-reduction.c (create_phi_basis): Directly
+	look up phi candidates in the statement-candidate map.
+	(phi_add_costs): Likewise.
+	(record_phi_increments): Likewise.
+	(phi_incr_cost): Likewise.
+	(ncd_with_phi): Likewise.
+	(all_phi_incrs_profitable): Likewise.
+
+2016-01-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/68648
+	* config/arm/arm.md (*andsi_iorsi3_notsi): Try to simplify
+	the complement of operands[3] during splitting.
+
+2016-01-12  Jeff Law  <law@redhat.com>
+
+	PR target/63347
+	* haifa-sched.c (prune_ready_list): If we have a SCHED_GROUP_P insn
+	that needs to be queued, just queue it for a single cycle.
+
+2016-01-12  Renlin Li  <renlin.li@arm.com>
+
+	PR target/69082
+	Backport from mainline.
+	2015-08-24  Renlin Li  <renlin.li@arm.com>
+
+	* config/arm/arm-protos.h (arm_valid_symbolic_address_p): Declare.
+	* config/arm/arm.c (arm_valid_symbolic_address_p): Define.
+	* config/arm/arm.md (arm_movt): Use arm_valid_symbolic_address_p.
+	* config/arm/constraints.md ("j"): Add check for high code.
+
+2016-01-12  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline.
+	2015-12-09  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	PR rtl-optimization/67609
+	* config/aarch64/aarch64.c
+	(aarch64_cannot_change_mode_class): Don't permit word_mode
+	subregs of full vector modes.
+	* config/aarch64/aarch64.md (aarch64_movdi_<mode>low): Use
+	zero_extract rather than truncate.
+	(aarch64_movdi_<mode>high): Likewise.
+
+2016-01-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_emit_move_sequence): Handle floating point
+	reloads for other unsupported memory operands.
+
+2016-01-11  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/66616
+	* ipa-cp.c (propagate_constants_accross_call): Move thuk check...
+	(call_passes_through_thunk_p): ...here.
+	(find_more_scalar_values_for_callers_subset): Perform thunk checks
+	like propagate_constants_accross_call does.
+	* cgraphclones.c (duplicate_thunk_for_node): Copy can_change_signature
+	flag from the node to the new flag.
+
+2016-01-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2015-12-15  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/68851
+	* cgraph.c (collect_callers_of_node_1): Do not collect thunks.
+	(collect_callers): Change comment.
+
+2015-12-25  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-25  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/freebsd64.h: Delete FREEBSD_DYNAMIC_LINKER32/64
+	defines. Use FBSD_DYNAMIC_LINKER instead.
+	Rename and simplify LINK_OS_FREEBSD_SPEC_DEF32/64 to
+	LINK_OS_FREEBSD_SPEC_DEF.
+
+2015-12-22  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	PR target/68872
+	* config/rs6000/rs6000.h (ASM_CPU_SPEC): For -mcpu=powerpc64le,
+	pass %(asm_cpu_power8).
+
+2015-12-18  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68729
+	* config/pa/pa.c (pa_emit_move_sequence): Reorganize handling of
+	floating-point reloads. Only reload operands that are not valid
+	floating-point memory operands.
+
+2015-12-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68779
+	* config/pa/pa.md (atomic_loaddi): Honor -mdisable-fpregs.
+	(atomic_loaddi_1): Likewise.
+	(atomic_storedi): Likewise.
+	(atomic_storedi_1): Likewise.
+	Move all atomic patterns to end of file.
+
+2015-12-09  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-09  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/freebsd64.h: Remove the redefinition of WCHAR_TYPE.
+
+2015-12-10  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/61515
+	PR tree-optimization/46590
+	Backport from mainline.
+	* tree-ssa-threadedge.c (invalidate_equivalences): Walk the unwinding
+	stack rather than looking at every SSA_NAME's value.
+
+2015-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-12-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/68701
+	* config/i386/i386.c (ix86_option_override_internal): Enable
+	-maccumulate-outgoing-args when %ebp is fixed due to stack
+	realignment requirements.
+
+2015-12-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68729
+	* config/pa/pa.c (pa_emit_move_sequence): Don't check that mode is
+	consistent with modes of the input and output operands when doing
+	reloads to and from floating point registers.  Do reload for all
+	address forms.
+
+2015-12-08  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>
+
+	Backport from mainline.
+	2015-03-16  Max Ostapenko  <m.ostapenko@partner.samsung.com>
+
+	PR sanitizer/64820
+	* cfgexpand.c (align_base): New function.
+	(alloc_stack_frame_space): Call it.
+	(expand_stack_vars): Align prev_frame to be sure
+	data->asan_vec elements aligned properly.
+
+2015-12-04  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-12-01  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/freebsd64.h (ELFv2_ABI_CHECK): Add new macro.
+	(SUBSUBTARGET_OVERRIDE_OPTIONS): Use it to decide whether to set
+	rs6000_current_abi to ABI_AIX or ABI_ELFv2.
+
+2015-12-02  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline.
+	2014-04-22  Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>
+
+	* config/arm/arm.c (arm_hard_regno_mode_ok): Loosen
+	restrictions on core registers for DImode values in Thumb2.
+
+2015-11-25  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/67954
+	* lra-constraints.c (curr_insn_transform): Add check on scratch
+	pseudo when change class to NO_REGS.  Add an assert.
+
+2015-11-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-11-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+	            Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR rtl-optimization/67226
+	* calls.c (store_one_arg): Take into account
+	crtl->args.pretend_args_size when checking for overlap between
+	arg->value and argblock + arg->locate.offset during sibcall
+	optimization.
+
+2015-11-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-11-24  Bernd Schmidt <bschmidt@redhat.com>
+	            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR rtl-optimization/68194
+	PR rtl-optimization/68328
+	PR rtl-optimization/68185
+	* ree.c (combine_reaching_defs): Reject copy_needed case if
+	copies_list is not empty.
+
+2015-11-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-11-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/68363
+	* config/aarch64/aarch64.c (aarch64_madd_needs_nop): Reject arguments
+	that are not INSN_P.
+
+2015-11-19  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from the gcc-5-branch
+
+	2015-07-21  Mike Frysinger  <vapier@gentoo.org>
+		    Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>
+
+	* configure.ac: Add check for new options in isl-0.15.
+	* config.in, configure: Rebuilt.
+	* graphite-blocking.c: Include <isl/constraint.h>
+	* graphite-interchange.c,  graphite-poly.c: Likewise.
+	* graphhite-scop-detection.c, graphite-sese-to-poly.c: Likewise.
+	* graphite.c, graphite-poly.c: Likewise.
+	* graphite-dependences.c: Include <isl/constraint.h>.
+	(max_number_of_out_dimensions): Returns isl_stat.
+	(extend_schedule_1): Likewise
+	(extend_schedule): Corresponding changes.
+	* graphite-optimize-isl.c: Include <isl/constraint.h> and
+	<isl/union_set.h>.
+	(getSingleMap): Change return type of isl_stat.
+	(optimize_isl): Conditionally use
+	isl_options_set_schedule_serialize_sccs.
+	* graphite-poly.h (isl_stat, isl_stat_ok): Define fallbacks
+	if not HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS.
+
+2015-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR lto/61313
+	* configure.ac (PLUGIN_LD_SUFFIX): Do not touch the value specified
+	by the user.
+	* configure: Regenerate.
+
+2015-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/68408
+	* config/sparc/sp-elf.h (CTORS_SECTION_ASM_OP): Undefine.
+	(DTORS_SECTION_ASM_OP): Likewise.
+
+2015-11-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/67265
+	* config/i386/i386.c (ix86_adjust_stack_and_probe): Remove obsolete
+	assertion on the CFA register.
+
+2015-11-11  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	Backport from mainline
+	2015-05-18  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/freebsd-spec.h (FBSD_STARTFILE_SPEC): Add the bits to build
+	pie executables.
+	(FBSD_ENDFILE_SPEC): Likewise.
+	* config/i386/freebsd.h (STARTFILE_SPEC): Remove and use the one from
+	config/freebsd-spec.h.
+	(ENDFILE_SPEC): Likewise.
+
+	2015-11-02  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/freebsd64.h (ASM_SPEC32): Adust spec to handle
+	PIE executables.
+
+	Backport from mainline
+	2015-03-04  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/rs6000/t-freebsd64: Remove 32-bit soft-float multilibs.
+
+2015-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/67265
+	* ira.c (ira_setup_eliminable_regset): Do not necessarily create the
+	frame pointer for stack checking if non-call exceptions aren't used.
+	* config/i386/i386.c (ix86_finalize_stack_realign_flags): Likewise.
+
+2015-11-10  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Partial backport from trunk r228751.
+	PR tree-optimization/68238
+	2015-10-13  Richard Biener  <rguenther@suse.de>
+
+	* tree-vect-loop.c (vect_estimate_min_profitable_iters): Use
+	LOOP_VINFO_COMP_ALIAS_DDRS to estimate alias versioning cost.
+
+2015-11-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/57845
+	* config/sparc/sparc.c (sparc_function_value_1): In 32-bit mode, do
+	not promote the mode for aggregate types.
+
+2015-11-09  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2014-09-12  Wilco Dijkstra  <wilco.dijkstra@arm.com>
+
+	* ree.c (combine_reaching_defs): Ensure inserted copy don't change
+	the number of hard registers.
+
+2015-11-02  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2015-10-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/67794
+	* tree-sra.c (replace_removed_params_ssa_names): Do not distinguish
+	between types of statements but accept original definitions as a
+	parameter.
+	(ipa_sra_modify_function_body): Use FOR_EACH_SSA_DEF_OPERAND to
+	iterate over definitions.
+
+2015-10-27  Caroline Tice  <cmtice@google.com>
+
+	(from Richard Biener)
+	* tree.c (int_cst_hash_hash):  Replace XORs with more efficient
+	calls to iterative_hash_host_wide_int.
+
+2015-10-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-10-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR middle-end/67989
+	* optabs.c (expand_atomic_compare_and_swap): Handle case when
+	ptarget_oval or ptarget_bool are const0_rtx.
+
+2015-10-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/67929
+	* config/arm/arm.c (vfp3_const_double_for_bits): Rewrite.
+	* config/arm/constraints.md (Dp): Update callsite.
+	* config/arm/predicates.md (const_double_vcvt_power_of_two): Likewise.
+
+2015-10-25  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR middle-end/68079
+	* dojump.c (do_compare_and_jump): Canonicalize both function and
+	method types.
+
+2015-10-15  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2015-10-14  Peter Bergner  <bergner@vnet.ibm.com>
+		    Torvald Riegel  <triegel@redhat.com>
+
+	PR target/67281
+	* config/rs6000/htm.md (UNSPEC_HTM_FENCE): New.
+	(tabort, tabort<wd>c, tabort<wd>ci, tbegin, tcheck, tend,
+	trechkpt, treclaim, tsr, ttest): Rename define_insns from this...
+	(*tabort, *tabort<wd>c, *tabort<wd>ci, *tbegin, *tcheck, *tend,
+	*trechkpt, *treclaim, *tsr, *ttest): ...to this.  Add memory barrier.
+	(tabort, tabort<wd>c, tabort<wd>ci, tbegin, tcheck, tend,
+	trechkpt, treclaim, tsr, ttest): New define_expands.
+	* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Define
+	__TM_FENCE__ for htm.
+	* doc/extend.texi: Update documentation for htm builtins.
+
+2015-10-02  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* sync.md (atomic_load<mode>): Fix output modifier for lda.
+	(atomic_store<mode>): Likewise for stl.
+
+2015-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-06-09  Shiva Chen  <shiva0217@gmail.com>
+
+	* sync.md (atomic_load<mode>): Add conditional code for lda/ldr
+	(atomic_store<mode>): Likewise.
+
+2015-09-28  Daniel Hellstrom  <daniel@gaisler.com>
+
+	* config/sparc/t-rtems: Remove -muser-mode. Add ut699, at697f and leon.
+
+2015-09-28  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/driver-sparc.c: map LEON to leon3
+
+2015-09-28  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sparc.opt: Rename mask from USER_MODE to SV_MODE
+	  and make it inverse to change default
+	* config/sparc/sync.md: Only use supervisor ASI for CASA when in
+	  supervisor mode
+	* doc/invoke.texi: Document change of default
+
+2015-09-28  Daniel Cederman  <cederman@gaisler.com>
+
+	* config/sparc/sparc.c (sparc_function_value_regno_p): Do not return
+	true on %f0 for a target without FPU.
+	* config/sparc/sparc.md (untyped_call): Do not save %f0 for a target
+	without FPU.
+	(untyped_return): Do not load %f0 for a target without FPU.
+
+2015-09-25  Tobias Burnus  <burnus@net-b.de>
+
+	* doc/invoke.texi (-fsanitize): Update URLs.
+2015-09-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/67619
+	* except.c (expand_builtin_eh_return): Use copy_addr_to_reg to copy
+	the address to a register.
+
+2015-09-19  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_function_ok_for_sibcall): Remove special treatment
+	of TARGET_ELF32.
+
+2015-09-18  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR middle-end/67401
+	* optabs.c (expand_atomic_compare_and_swap): Move result of emitting
+	sync_compare_and_swap_optab libcall to target_oval.
+
+2015-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/66790
+	* df-problems.c (LIVE): Amend documentation.
+
+2015-09-12  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_move_double): Enhance to handle HIGH
+	CONSTANT_P operands.
+
+2015-09-09  Alan Modra  <amodra@gmail.com>
+
+	PR target/67378
+	* config/rs6000/rs6000.c (rs6000_secondary_reload_gpr): Find
+	reload replacement for PRE_MODIFY address reg.
+
+2015-09-02  Alan Modra  <amodra@gmail.com>
+
+	PR target/67417
+	* config/rs6000/predicates.md (current_file_function_operand): Don't
+	return true for weak symbols.
+	* config/rs6000/rs6000.c (rs6000_function_ok_for_sibcall): Likewise.
+
+2015-08-27  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline:
+	2015-08-27  Pat Haugen  <pthaugen@us.ibm.com>
+
+	* config/rs6000/vector.md (vec_shr_<mode>): Fix to do a shift
+	instead of a rotate.
+
+2015-08-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from mainline:
+	2015-08-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/67211
+	* config/rs6000/rs6000-cpus.def (ISA_2_7_MASKS_SERVER): Set
+	-mefficient-unaligned-vsx on ISA 2.7.
+
+	* config/rs6000/rs6000.opt (-mefficient-unaligned-vsx): Convert
+	option to a masked option.
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Rework
+	logic for -mefficient-unaligned-vsx so that it is set via an arch
+	ISA option, instead of being set if -mtune=power8 is set. Move
+	-mefficient-unaligned-vsx and -mallow-movmisalign handling to be
+	near other default option handling.
+
+2015-08-18  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline:
+	2015-08-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/67028
+	* combine.c (simplify_comparison): Fix comment.  Rearrange code.
+	Add test to see if a const_int fits in the new mode.
+
+2015-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66648
+	* config/i386/i386.c (ix86_expand_set_or_movmem): Emit main loop
+	execution guard when min_size is less than size_needed.
+
+2015-08-04  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline:
+	2015-07-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/66731
+	* config/aarch64/aarch64.md (fnmul<mode>3): Handle -frounding-math.
+
+2015-08-03  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline:
+	2015-08-03  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* config/rs6000/htm.md (tabort.): Restrict the source operand to
+	using a base register.
+
+2015-08-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/67060
+	* config/pa/pa.md (call_reg_64bit): Remove reg:DI 1 clobber.
+	Adjust splits to match new pattern.
+
+2015-08-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport form mainline r226496.
+	2015-08-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/66731
+	* config/arm/vfp.md (negmuldf3_vfp): Add new pattern.
+	(negmulsf3_vfp): Likewise.
+	(muldf3negdf_vfp): Disable for -frounding-math.
+	(mulsf3negsf_vfp): Likewise.
+	* config/arm/arm.c (arm_new_rtx_costs): Fix NEG cost for VNMUL,
+	fix MULT cost with -frounding-math.
+
+2015-07-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/66891
+	* calls.c (expand_call): Wrap precompute_register_parameters with
+	NO_DEFER_POP/OK_DEFER_POP to prevent deferred pops.
+
+	2015-07-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/58066
+	* config/i386/i386.md (*tls_global_dynamic_64_<mode>): Depend on SP_REG.
+	(*tls_local_dynamic_base_64_<mode>): Ditto.
+	(*tls_local_dynamic_base_64_largepic): Ditto.
+	(tls_global_dynamic_64_<mode>): Update expander pattern.
+	(tls_local_dynamic_base_64_<mode>): Ditto.
+
+	2015-07-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/58066
+	* calls.c (expand_call): Precompute register parameters before stack
+	alignment is performed.
+
+	2014-05-08  Wei Mi  <wmi@google.com>
+
+	PR target/58066
+	* config/i386/i386.c (ix86_compute_frame_layout): Update
+	preferred_stack_boundary for call, expanded from tls descriptor.
+	* config/i386/i386.md (*tls_global_dynamic_32_gnu): Update RTX
+	to depend on SP register.
+	(*tls_local_dynamic_base_32_gnu): Ditto.
+	(*tls_local_dynamic_32_once): Ditto.
+	(tls_global_dynamic_64_<mode>): Set
+	ix86_tls_descriptor_calls_expanded_in_cfun.
+	(tls_local_dynamic_base_64_<mode>): Ditto.
+	(tls_global_dynamic_32): Set
+	ix86_tls_descriptor_calls_expanded_in_cfun. Update RTX
+	to depend on SP register.
+	(tls_local_dynamic_base_32): Ditto.
+
+2015-07-25  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2015-07-24  Tom de Vries  <tom@codesourcery.com>
+
+	* graphite-sese-to-poly.c (is_reduction_operation_p): Limit
+	flag_associative_math to FLOAT_TYPE_P.  Honour
+	TYPE_OVERFLOW_WRAPS for INTEGRAL_TYPE_P. Don't allow any other types.
+
+2015-07-25  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2015-07-16  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/65249
+	* config/sh/sh.md (movdi): Split simple reg move to two movsi
+	when the destination is R0.
+
+2015-07-24  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from mainline r226159.
+	2015-07-24  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/aarch64/aarch64-elf-raw.h (LINK_SPEC): Handle -h, -static,
+	-shared, -symbolic, -rdynamic.
+
+2015-07-24  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from mainline r226158.
+	2015-07-24  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/65711
+	* config/aarch64/aarch64-linux.h (LINUX_TARGET_LINK_SPEC): Move
+	-dynamic-linker within %{!static %{!shared, and -rdynamic within
+	%{!static.
+
+2015-07-21  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2015-07-21 trunk r226046.
+
+	PR target/66956
+	* config/avr/avr-dimode.md (<extend_u>mulsidi3_insn)
+	(<extend_u>mulsidi3): Don't use if !AVR_HAVE_MUL.
+
+2015-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66922
+	* config/i386/i386.c (ix86_expand_pinsr): Reject insertions
+	to misaligned positions.
+
+2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66866
+	* config/i386/i386.c (ix86_expand_pinsr): Reject non-lowpart
+	source subregs.
+
+2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (movdi_to_sse): Use gen_lowpart
+	and gen_higpart instead of gen_rtx_SUBREG.
+	* config/i386/i386.md
+	(floatdi<X87MODEF:mode>2_i387_with_xmm splitter): Ditto.
+	(read-modify peephole2): Use gen_lowpart instead of
+	gen_rtx_SUBREG for operand 5.
+
+2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66814
+	* config/i386/predicates.md (nonimmediate_gr_operand): New predicate.
+	* config/i386/i386.md (not peephole2): Use nonimmediate_gr_operand.
+	(varous peephole2s): Use {GENERAL,SSE,MMX}_REGNO_P instead of
+	{GENERAL,SSE,MMX}_REG_P where appropriate.
+
+2015-07-10  Mantas Mikaitis  <Mantas.Mikaitis@arm.com>
+
+	* config/arm/arm.h (TARGET_NEON_FP): Remove conditional definition,
+	define to zero if !TARGET_NEON.
+	(TARGET_ARM_FP): Add !TARGET_SOFT_FLOAT into the conditional
+	definition.
+
+2015-07-09  Iain Sandoe  <iain@codesourcery.com>
+
+	PR target/66523
+	* config/darwin.c (darwin_mark_decl_preserved): Exclude 'L' label
+	names from preservation.
+
+2015-07-07  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport form mainline
+	2015-07-07  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/66780
+	* config/sh/sh.md (symGOT_load): Revert a part of 2015-03-03
+	change for target/65249.
+
+2015-07-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline r224725
+	2015-06-22  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/65914
+	* config/rs6000/predicates.md (altivec_register_operand): Permit
+	virtual stack registers.
+	(vsx_register_operand): Likewise.
+	(vfloat_operand): Likewise.
+	(vint_operand): Likewise.
+	(vlogical_operand): Likewise.
+
+2015-07-04  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/66114
+	* config/pa/pa.md (indirect_jump): Use pmode_register_operand instead
+	of register_operand.  Remove constraint.
+
+2015-07-03  Jack Howarth  <howarth.at.gcc@gmail.com>
+
+	PR target/66509
+	* configure.ac: Fix filds and fildq test for 64-bit.
+	* configure: Regenerated.
+
+2015-07-01  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2015-06-30  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/64833
+	* config/sh/sh.md (casesi_worker_1): Set length to 8 when
+	flag_pic is set.
+
+2015-07-01  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline
+	2015-06-24  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/63408
+	* config/arm/arm.c (vfp3_const_double_for_fract_bits): Disable
+	for negative numbers.
+
+2015-06-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/leon.md (leon_load): Enable for all LEON variants if
+	-mfix-ut699 is not specified.
+	(leon3_load): Rename into...
+	(ut699_load): ...this.  Enable for all LEON variants if -mfix-ut699
+	is specified.
+
+2015-06-28  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2015-06-24  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/66563
+	* config/sh/sh.md (GOTaddr2picreg): Add a new operand for
+	an additional element of the unspec vector.  Modify indices
+	of operands.
+	(builtin_setjmp_receiver): Pass const0_rtx to gen_GOTaddr2picreg.
+	* config/sh/sh.c (prepare_move_operands): Pass incremented
+	const_int to gen_GOTaddr2picreg.
+	(sh_expand_prologue): Pass const0_rtx to gen_GOTaddr2picreg.
+
+2015-06-27  Uros Bizjak  <ubizjak@gmail.com>
+	    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/66412
+	* config/i386/i386.md (various splitters): Use shallow_copy_rtx
+	before doing PUT_MODE or PUT_CODE on operands to avoid
+	in-place RTX modification.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
@@ -21,8 +1247,8 @@
 	Backport from mainline r212178.
 	2014-06-30  Joseph Myers  <joseph@codesourcery.com>
 
-        * var-tracking.c (add_stores): Return instead of asserting if old
-        and new values for conditional store are the same.
+	* var-tracking.c (add_stores): Return instead of asserting if old
+	and new values for conditional store are the same.
 
 2015-06-23  Ludovic CourtÃ¨s  <ludo@gnu.org>
 
Index: gcc/testsuite/gcc.target/powerpc/pr69548.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr69548.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr69548.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do assemble { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -Os -mbig" } */
+
+__int128
+quad_exchange (__int128 *ptr, __int128 newval)
+{
+  return __atomic_exchange_n (ptr, newval, __ATOMIC_RELAXED);
+}
Index: gcc/testsuite/gcc.target/powerpc/htm-tabort-no-r0.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/htm-tabort-no-r0.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/htm-tabort-no-r0.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_htm_ok } */
+/* { dg-options "-O2 -mhtm -ffixed-r3 -ffixed-r4 -ffixed-r5 -ffixed-r6 -ffixed-r7 -ffixed-r8 -ffixed-r9 -ffixed-r10 -ffixed-r11 -ffixed-r12" } */
+
+/* { dg-final { scan-assembler-not "tabort\\.\[ \t\]0" } } */
+
+int
+foo (void)
+{
+  return __builtin_tabort (10);
+}
Index: gcc/testsuite/gcc.target/powerpc/pr68872.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr68872.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr68872.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* PR target/68872 */
+/* { dg-do assemble { target { powerpc64le-*-* } } } */
+/* { dg-options "-mcpu=powerpc64le" } */
+
+/* Verify that -mcpu=powerpc64le passes -mpower8/-mpwr8 to the assembler.  */
+
+long
+bar (unsigned char *ptr, unsigned char val)
+{
+  long ret;
+  asm volatile ("stbcx. %0,0,%1" :: "r" (val), "r" (ptr));
+  asm volatile ("mfcr %0,8" : "=r" (ret) ::);
+  return ret;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-cg.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-cg.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-cg.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* Test code generation of vector built-ins.  We don't have this for
+   most of ours today.  As new built-ins are added, please add to this
+   test case.  Update as necessary to add VSX, P8-vector, P9-vector,
+   etc. */
+
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec -O0" } */
+
+#include <altivec.h>
+
+static vector signed int i, *pi;
+static int int1;
+
+void
+b()
+{
+  i = __builtin_altivec_lvxl (int1, pi);
+  i = vec_lvxl (int1, pi);
+}
+
+/* { dg-final { scan-assembler-times "lvxl" 2 } } */
Index: gcc/testsuite/gcc.target/powerpc/vec-shr.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-shr.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-shr.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-inline" } */
+
+#include <stdlib.h>
+
+typedef struct { double r, i; } complex;
+#define LEN 30
+complex c[LEN];
+double d[LEN];
+
+void
+foo (complex *c, double *d, int len1)
+{
+  int i;
+  for (i = 0; i < len1; i++)
+    {
+      c[i].r = d[i];
+      c[i].i = 0.0;
+    }
+}
+
+int
+main (void)
+{
+  int i;
+  for (i = 0; i < LEN; i++)
+    d[i] = (double) i;
+  foo (c, d, LEN);
+  for (i=0;i<LEN;i++)
+    if ((c[i].r != (double) i) || (c[i].i != 0.0))
+      abort ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.target/powerpc/pr70117.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr70117.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr70117.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,92 @@
+/* { dg-do run { target { powerpc*-*-linux* powerpc*-*-darwin* powerpc*-*-aix* rs6000-*-* } } } */
+/* { dg-options "-std=c99 -mlong-double-128 -O2" } */
+
+#include <float.h>
+
+union gl_long_double_union
+{
+  struct { double hi; double lo; } dd;
+  long double ld;
+};
+
+/* This is gnulib's LDBL_MAX which, being 107 bits in precision, is
+   slightly larger than gcc's 106 bit precision LDBL_MAX.  */
+volatile union gl_long_double_union gl_LDBL_MAX =
+  { { DBL_MAX, DBL_MAX / (double)134217728UL / (double)134217728UL } };
+
+volatile double min_denorm = 0x1p-1074;
+volatile double ld_low = 0x1p-969;
+volatile double dinf = 1.0/0.0;
+volatile double dnan = 0.0/0.0;
+
+int
+main (void)
+{
+  long double ld;
+
+  ld = gl_LDBL_MAX.ld;
+  if (__builtin_isinfl (ld))
+    __builtin_abort ();
+  ld = -gl_LDBL_MAX.ld;
+  if (__builtin_isinfl (ld))
+    __builtin_abort ();
+
+  ld = gl_LDBL_MAX.ld;
+  if (!__builtin_isfinite (ld))
+    __builtin_abort ();
+  ld = -gl_LDBL_MAX.ld;
+  if (!__builtin_isfinite (ld))
+    __builtin_abort ();
+
+  ld = ld_low;
+  if (!__builtin_isnormal (ld))
+    __builtin_abort ();
+  ld = -ld_low;
+  if (!__builtin_isnormal (ld))
+    __builtin_abort ();
+
+  ld = -min_denorm;
+  ld += ld_low;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+  ld = min_denorm;
+  ld -= ld_low;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+
+  ld = 0.0;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+  ld = -0.0;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+
+  ld = LDBL_MAX;
+  if (!__builtin_isnormal (ld))
+    __builtin_abort ();
+  ld = -LDBL_MAX;
+  if (!__builtin_isnormal (ld))
+    __builtin_abort ();
+
+  ld = gl_LDBL_MAX.ld;
+  if (!__builtin_isnormal (ld))
+    __builtin_abort ();
+  ld = -gl_LDBL_MAX.ld;
+  if (!__builtin_isnormal (ld))
+    __builtin_abort ();
+
+  ld = dinf;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+  ld = -dinf;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+
+  ld = dnan;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+  ld = -dnan;
+  if (__builtin_isnormal (ld))
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_relaxed.x
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_relaxed.x	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_relaxed.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+#include <stdatomic.h>
+
+atomic_ullong foo;
+int glob;
+
+int
+main (void)
+{
+  atomic_load_explicit (&foo, memory_order_relaxed);
+  return glob;
+}
Index: gcc/testsuite/gcc.target/arm/macro_defs1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/macro_defs1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/macro_defs1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-march=*" } { "-march=armv6-m" } } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-marm" } { "" } } */
+/* { dg-options "-march=armv6-m -mthumb" } */
+
+#ifdef __ARM_NEON_FP
+#error __ARM_NEON_FP should not be defined
+#endif
+
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_7.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_7.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v7a_ok } */
+/* { dg-add-options arm_arch_v7a } */
+
+#include "atomic_loaddi_seq_cst.x"
+
+/* { dg-final { scan-assembler-times "ldrexd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-times "dmb\tsy" 1 } } */
Index: gcc/testsuite/gcc.target/arm/macro_defs2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/macro_defs2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/macro_defs2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv7ve -mcpu=cortex-a15 -mfpu=neon-vfpv4" } */
+/* { dg-add-options arm_neon } */
+/* { dg-require-effective-target arm_neon_ok } */
+
+#ifndef __ARM_NEON_FP
+#error  __ARM_NEON_FP is not defined but should be
+#endif
+
+#ifndef __ARM_FP
+#error  __ARM_FP is not defined but should be
+#endif
+
+
Index: gcc/testsuite/gcc.target/arm/pr63408.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr63408.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr63408.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+/* { dg-do run }  */
+/* { dg-options "-O2" } */
+void abort (void) __attribute__ ((noreturn));
+float __attribute__((noinline))
+f(float a, int b)
+{
+  return a - (((float)b / 0x7fffffff) * 100);
+}
+
+int
+main (void)
+{
+  float a[] = { 100.0, 0.0, 0.0};
+  int b[] = { 0x7fffffff, 0x7fffffff/100.0f, -0x7fffffff / 100.0f};
+  float c[] = { 0.0, -1.0, 1.0 };
+  int i;
+
+  for (i = 0; i < (sizeof(a) / sizeof (float)); i++)
+    if (f (a[i], b[i]) != c[i])
+	abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_seq_cst.x
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_seq_cst.x	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_seq_cst.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+#include <stdatomic.h>
+
+atomic_ullong foo;
+int glob;
+
+int
+main (void)
+{
+  atomic_load_explicit (&foo, memory_order_seq_cst);
+  return glob;
+}
Index: gcc/testsuite/gcc.target/arm/pr67439_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr67439_1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr67439_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-options "-O1 -mfp16-format=ieee -march=armv7-a -mfpu=neon -mthumb -mrestrict-it" } */
+
+__fp16 h0 = -1.0;
+
+void
+f (__fp16 *p)
+{
+  h0 = 1.0;
+}
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_8.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_8.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v7ve_ok } */
+/* { dg-add-options arm_arch_v7ve } */
+
+#include "atomic_loaddi_seq_cst.x"
+
+/* { dg-final { scan-assembler-times "ldrd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-times "dmb\tsy" 1 } } */
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v7a_ok } */
+/* { dg-add-options arm_arch_v7a } */
+
+#include "atomic_loaddi_acquire.x"
+
+/* { dg-final { scan-assembler-times "ldrexd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-times "dmb\tsy" 1 } } */
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_9.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_9.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-add-options arm_arch_v8a } */
+
+#include "atomic_loaddi_seq_cst.x"
+
+/* { dg-final { scan-assembler-times "ldaexd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-not "dmb\tsy" } } */
Index: gcc/testsuite/gcc.target/arm/stl-cond.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/stl-cond.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/stl-cond.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arm_ok } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-options "-O2 -marm" } */
+/* { dg-add-options arm_arch_v8a } */
+
+struct backtrace_state
+{
+  int threaded;
+  int lock_alloc;
+};
+
+void foo (struct backtrace_state *state)
+{
+  if (state->threaded)
+    __sync_lock_release (&state->lock_alloc);
+}
+
+/* { dg-final { scan-assembler "stlne" } } */
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v7ve_ok } */
+/* { dg-add-options arm_arch_v7ve } */
+
+#include "atomic_loaddi_acquire.x"
+
+/* { dg-final { scan-assembler-times "ldrd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-times "dmb\tsy" 1 } } */
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_relaxed_cond.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_relaxed_cond.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_relaxed_cond.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,20 @@
+/* { dg-do assemble } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-add-options arm_arch_v8a } */
+
+/* Check that if we conditionalise the atomic load we put the condition
+   code in the right place to create valid assembly.  */
+
+#include <stdatomic.h>
+
+atomic_ullong foo;
+int glob;
+
+int
+main (int argc, char *argv[])
+{
+  if (argc > 2)
+    atomic_load_explicit (&foo, memory_order_relaxed);
+  return glob;
+}
Index: gcc/testsuite/gcc.target/arm/vnmul-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/vnmul-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/vnmul-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -fno-rounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmuld" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmuls" } } */
+  return -a * b;
+}
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_3.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-add-options arm_arch_v8a } */
+
+#include "atomic_loaddi_acquire.x"
+
+/* { dg-final { scan-assembler-times "ldaexd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-not "dmb\tsy" } } */
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_acquire.x
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_acquire.x	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_acquire.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+#include <stdatomic.h>
+
+atomic_ullong foo;
+int glob;
+
+int
+main (void)
+{
+  atomic_load_explicit (&foo, memory_order_acquire);
+  return glob;
+}
Index: gcc/testsuite/gcc.target/arm/vnmul-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/vnmul-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/vnmul-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -frounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler-not "fnmuld" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler-not "fnmuls" } } */
+  return -a * b;
+}
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_4.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v7a_ok } */
+/* { dg-add-options arm_arch_v7a } */
+
+#include "atomic_loaddi_relaxed.x"
+
+/* { dg-final { scan-assembler-times "ldrexd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-not "dmb\tsy" } } */
Index: gcc/testsuite/gcc.target/arm/vnmul-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/vnmul-3.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/vnmul-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -fno-rounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmuld" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmuls" } } */
+  return -(a * b);
+}
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_5.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_5.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v7ve_ok } */
+/* { dg-add-options arm_arch_v7ve } */
+
+#include "atomic_loaddi_relaxed.x"
+
+/* { dg-final { scan-assembler-times "ldrd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-not "dmb\tsy" } } */
\ No newline at end of file
Index: gcc/testsuite/gcc.target/arm/macro_defs0.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/macro_defs0.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/macro_defs0.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-march=*" } {"-march=armv7-m"} } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-marm" } { "" } } */
+/* { dg-options "-march=armv7-m -mcpu=cortex-m3 -mfloat-abi=soft -mthumb" } */
+
+#ifdef __ARM_FP
+#error __ARM_FP should not be defined
+#endif
+
+#ifdef __ARM_NEON_FP
+#error __ARM_NEON_FP should not be defined
+#endif
Index: gcc/testsuite/gcc.target/arm/vnmul-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/vnmul-4.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/vnmul-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -frounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmuld" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmuls" } } */
+  return -(a * b);
+}
Index: gcc/testsuite/gcc.target/arm/atomic_loaddi_6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_6.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/atomic_loaddi_6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c11 -O" } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-add-options arm_arch_v8a } */
+
+#include "atomic_loaddi_relaxed.x"
+
+/* { dg-final { scan-assembler-times "ldrd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-not "dmb\tsy" } } */
\ No newline at end of file
Index: gcc/testsuite/gcc.target/m68k/pr63347.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/m68k/pr63347.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/m68k/pr63347.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,46 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=5208" } */
+
+#include <stdlib.h>
+
+void __attribute__ ((noinline))
+oof()
+{
+  asm volatile ("" ::: "memory");
+}
+int print_info(unsigned int *ip_addr)
+{
+    int invalid = 0;
+
+    if (ip_addr) {
+        unsigned int haddr = *ip_addr;
+        oof("stuff");
+        if (0x0 == haddr) {
+            invalid = 1;
+        }
+        oof("stuff2");
+    } else {
+        invalid = 1;
+    }
+
+    return invalid;
+}
+
+int main(int argc, char *argv[])
+{
+    unsigned int myaddr;
+    int ret;
+
+    myaddr = 0x0;
+    ret = print_info(&myaddr);
+    if (!ret)
+        abort ();
+
+    myaddr = 0x01020304;
+    ret = print_info(&myaddr);
+    if (ret)
+        abort ();
+    exit (0);
+}
+
+
Index: gcc/testsuite/gcc.target/aarch64/fnmul-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/fnmul-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/fnmul-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -a * b;
+}
Index: gcc/testsuite/gcc.target/aarch64/fnmul-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/fnmul-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/fnmul-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -frounding-math" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fneg\\td\[0-9\]+, d\[0-9\]+" } } */
+  /* { dg-final { scan-assembler "fmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fneg\\ts\[0-9\]+, s\[0-9\]+" } } */
+  /* { dg-final { scan-assembler "fmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -a * b;
+}
Index: gcc/testsuite/gcc.target/aarch64/pr68363_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr68363_1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr68363_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-mfix-cortex-a53-835769" } */
+
+int
+foo (int i)
+{
+  switch (i)
+    {
+    case 0:
+    case 2:
+    case 5:
+      return 0;
+    case 7:
+    case 11:
+    case 13:
+      return 1;
+    }
+  return -1;
+}
Index: gcc/testsuite/gcc.target/aarch64/fnmul-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/fnmul-3.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/fnmul-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -(a * b);
+}
Index: gcc/testsuite/gcc.target/aarch64/fnmul-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/fnmul-4.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/fnmul-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -frounding-math" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -(a * b);
+}
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundps-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundps-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundps-1.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_ceil_ps(x)
 #define ROUND_MODE _MM_FROUND_CEIL
Index: gcc/testsuite/gcc.target/i386/pr69551.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr69551.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr69551.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+/* PR target/69551 */
+/* { dg-do run { target sse_runtime } } */
+/* { dg-options "-O2 -mno-sse2 -msse" } */
+
+typedef unsigned char v16qi __attribute__ ((vector_size (16)));
+typedef unsigned int v4si __attribute__ ((vector_size (16)));
+
+char __attribute__ ((noinline, noclone))
+test (v4si vec)
+{
+  vec[1] = 0x5fb856;
+  return ((v16qi) vec)[0];
+}
+
+int
+main ()
+{
+  char z = test ((v4si) { -1, -1, -1, -1 });
+
+  if (z != -1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr66648.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66648.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66648.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -mstringop-strategy=unrolled_loop -mtune=nocona" } */
+
+#define PATTERN 0xdeadbeef
+#define SIZE    32
+
+struct S { int i; char str[SIZE]; int j; };
+
+void __attribute__((noclone, noinline))
+my_memcpy (char *, const char *, unsigned int);
+
+void
+my_memcpy (char *dst, const char *src, unsigned int len)
+{
+  if (len < 8)
+    __builtin_abort ();
+
+  __builtin_memcpy (dst, src, len);
+}
+
+int
+main (void)
+{
+  const char str[SIZE]= "1234567890123456789012345678901";
+  struct S *s = __builtin_malloc (sizeof (struct S));
+
+  s->j = PATTERN;
+  my_memcpy (s->str, str, SIZE);
+  if (s->j != PATTERN)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr70007.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr70007.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr70007.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* PR rtl-optimization/70007 */
+/* { dg-do run { target bmi2 } } */
+/* { dg-options "-O -fgcse -mbmi2 -Wno-psabi" } */
+/* { dg-require-effective-target int128 } */
+
+#include "bmi2-check.h"
+
+typedef unsigned short v32u16 __attribute__ ((vector_size (32)));
+typedef unsigned long long v32u64 __attribute__ ((vector_size (32)));
+typedef unsigned __int128 u128;
+typedef unsigned __int128 v32u128 __attribute__ ((vector_size (32)));
+
+u128
+foo (v32u16 v32u16_0, v32u64 v32u64_0, v32u64 v32u64_1)
+{
+  do {
+    v32u16_0[13] |= v32u64_1[3] = (v32u64_1[3] >> 19) | (v32u64_1[3] << 45);
+    v32u64_1 %= ~v32u64_1;
+    v32u64_0 *= (v32u64) v32u16_0;
+  } while (v32u64_0[0]);
+  return v32u64_1[3];
+}
+
+static void
+bmi2_test ()
+{
+  u128 x = foo((v32u16){(unsigned short) ~0xba31, 0x47c6}, (v32u64){64}, (v32u64){0, 0x8b217e2514d23242, 0xac569b6dff9f82, 0x9d4cffe03c139c});
+  if (x != 0x3c74da5ca328d09)
+    __builtin_abort();
+}
Index: gcc/testsuite/gcc.target/i386/pr66412.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66412.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66412.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -g" } */
+
+int a, b, c, d;
+
+void
+fn1 ()
+{
+  short e;
+  unsigned short g;
+  
+  for (c = 0; c < 1; c++)
+    d = 0;
+  g = ((a == 0) ^ d) % 8;
+  e = g << 1;
+  b = e && 1;
+}
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundss-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-3.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-3.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_floor_ss(x, x)
 #define ROUND_MODE _MM_FROUND_FLOOR
Index: gcc/testsuite/gcc.target/i386/pr68680.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr68680.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr68680.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR tree-optimization/68680 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-protector-strong" } */
+
+int foo (char *);
+
+int
+bar (unsigned long x)
+{
+  char a[x];
+  return foo (a);
+}
+
+/* Verify that this function is stack protected.  */
+/* { dg-final { scan-assembler "stack_chk_fail" } } */
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundsd-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-3.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-3.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128d
 #define FP_T double
-#define ASM_SUFFIX "l"
 
 #define ROUND_INTRIN(x, mode) _mm_floor_sd(x, x)
 #define ROUND_MODE _MM_FROUND_FLOOR
Index: gcc/testsuite/gcc.target/i386/readeflags-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/readeflags-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/readeflags-1.c	(.../branches/gcc-4_9-branch)
@@ -9,10 +9,11 @@
 #define EFLAGS_TYPE unsigned int
 #endif
 
-static EFLAGS_TYPE
+__attribute__((noinline, noclone))
+EFLAGS_TYPE
 readeflags_test (unsigned int a, unsigned int b)
 {
-  unsigned x = (a == b);
+  volatile char x = (a == b);
   return __readeflags ();
 }
 
Index: gcc/testsuite/gcc.target/i386/pr66891.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66891.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66891.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2" } */
+
+__attribute__((__stdcall__)) void fn1();
+
+int a;
+
+static void fn2() {
+  for (;;)
+    ;
+}
+
+void fn3() {
+  fn1(0);
+  fn2(a == 0);
+}
Index: gcc/testsuite/gcc.target/i386/pr66703.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66703.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66703.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,4 @@
+/* { dg-do run { target { ia32 } } } */
+/* { dg-options "-O0 -mtune=pentium" } */
+
+#include "readeflags-1.c"
Index: gcc/testsuite/gcc.target/i386/pr58066.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr58066.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr58066.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target tls_native } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fPIC -fomit-frame-pointer -O2 -fdump-rtl-final" } */
+
+/* Check whether the stack frame starting addresses of tls expanded calls
+   in foo and goo are 16bytes aligned.  */
+static __thread char ccc1;
+void* foo()
+{
+ return &ccc1;
+}
+
+__thread char ccc2;
+void* goo()
+{
+ return &ccc2;
+}
+
+/* { dg-final { scan-rtl-dump "Function foo.*set\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*plus\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*const_int -8.*UNSPEC_TLS.*Function goo" "final" } } */
+/* { dg-final { scan-rtl-dump "Function goo.*set\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*plus\[^\r\n\]*sp\\)\[\r\n\]\[^\r\n\]*const_int -8.*UNSPEC_TLS" "final" } } */
+/* { dg-final { cleanup-rtl-dump "final" } } */
Index: gcc/testsuite/gcc.target/i386/pr68701-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr68701-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr68701-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O -ffixed-ebp -mno-accumulate-outgoing-args" } */
+
+/* { dg-warning "fixed ebp register requires" "" { target *-*-* } 0 } */
+
+void foo (void);
+
+int
+main (int argc, char *argv[])
+{
+  foo ();
+  return argc - 1;
+}
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundps-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundps-2.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN _mm_round_ps
 #define ROUND_MODE _MM_FROUND_NINT
Index: gcc/testsuite/gcc.target/i386/pr70327.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr70327.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr70327.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* PR target/70327 */
+/* { dg-do compile } */
+/* { dg-require-effective-target int128 } */
+/* { dg-options "-mavx512f" } */
+
+typedef unsigned __int128 v4ti __attribute__ ((vector_size (64)));
+
+void
+foo (v4ti v)
+{
+  foo(v);
+}
Index: gcc/testsuite/gcc.target/i386/pr67265.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr67265.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr67265.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* PR target/67265 */
+/* Reduced testcase by Johannes Dewender <gnu@JonnyJD.net> */
+
+/* { dg-do compile } */
+/* { dg-options "-O -fstack-check -fPIC" } */
+
+int a, b, c, d, e;
+
+void foo (void)
+{
+  __asm__("" : "+r"(c), "+r"(e), "+r"(d), "+r"(a) : ""(b), "mg"(foo), "mm"(c));
+}
Index: gcc/testsuite/gcc.target/i386/pr67770.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr67770.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr67770.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,40 @@
+/* PR target/67770 */
+/* { dg-do run { target ia32 } } */
+/* { dg-require-effective-target trampolines } */
+/* { dg-options "-O2" } */
+
+#ifndef NO_TRAMPOLINES
+__attribute__ ((noinline)) void
+foo (int i, void (* __attribute__ ((regparm (3))) bar) (int))
+{
+  bar (i);
+}
+#endif
+
+int
+main ()
+{
+#ifndef NO_TRAMPOLINES
+  int p = 0;
+
+  __attribute__ ((regparm (3), noinline)) void
+  bar (int i)
+  {
+    if (__builtin_expect (i, 0))
+      ++p;
+  }
+
+  foo (0, bar);
+  bar (0);
+
+  if (p != 0)
+    __builtin_abort ();
+
+  foo (1, bar);
+  bar (1);
+
+  if (p != 2)
+    __builtin_abort ();
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundss-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-4.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-4.c	(.../branches/gcc-4_9-branch)
@@ -36,7 +36,7 @@
 static float
 do_round (float f, int type)
 {
-  short saved_cw, new_cw, clr_mask;
+  unsigned short saved_cw, new_cw, clr_mask;
   float ret;
 
   if ((type & 4))
@@ -50,16 +50,15 @@
       clr_mask = ~0x0C3F;
     }
 
-  __asm__ ("flds %0" : : "m" (*&f));
+  __asm__ ("fnstcw %0" : "=m" (saved_cw));
 
-  __asm__ ("fstcw %0" : "=m" (*&saved_cw));
   new_cw = saved_cw & clr_mask;
   new_cw |= type;
-  __asm__ ("fldcw %0" : : "m" (*&new_cw));
 
-  __asm__ ("frndint\n"
-	   "fstps %0\n" : "=m" (*&ret));
-  __asm__ ("fldcw %0" : : "m" (*&saved_cw));
+  __asm__ ("fldcw %2\n\t"
+	   "frndint\n\t"
+	   "fldcw %3" : "=t" (ret)
+		      : "0" (f), "m" (new_cw), "m" (saved_cw));
   return ret;
 }
 
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundsd-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-4.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-4.c	(.../branches/gcc-4_9-branch)
@@ -36,7 +36,7 @@
 static double
 do_round (double f, int type)
 {
-  short saved_cw, new_cw, clr_mask;
+  unsigned short saved_cw, new_cw, clr_mask;
   double ret;
 
   if ((type & 4))
@@ -50,16 +50,15 @@
       clr_mask = ~0x0C3F;
     }
 
-  __asm__ ("fldl %0" : : "m" (*&f));
+  __asm__ ("fnstcw %0" : "=m" (saved_cw));
 
-  __asm__ ("fstcw %0" : "=m" (*&saved_cw));
   new_cw = saved_cw & clr_mask;
   new_cw |= type;
-  __asm__ ("fldcw %0" : : "m" (*&new_cw));
 
-  __asm__ ("frndint\n"
-	   "fstpl %0\n" : "=m" (*&ret));
-  __asm__ ("fldcw %0" : : "m" (*&saved_cw));
+  __asm__ ("fldcw %2\n\t"
+	   "frndint\n\t"
+	   "fldcw %3" : "=t" (ret)
+		      : "0" (f), "m" (new_cw), "m" (saved_cw));
   return ret;
 }
 
Index: gcc/testsuite/gcc.target/i386/sse4_1-round.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-round.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-round.h	(.../branches/gcc-4_9-branch)
@@ -28,7 +28,7 @@
 static FP_T
 do_round (FP_T f, int type)
 {
-  short saved_cw, new_cw, clr_mask;
+  unsigned short saved_cw, new_cw, clr_mask;
   FP_T ret;
 
   if ((type & 4))
@@ -42,16 +42,15 @@
       clr_mask = ~0x0C3F;
     }
 
-  __asm__ ("fld" ASM_SUFFIX " %0" : : "m" (*&f));
+  __asm__ ("fnstcw %0" : "=m" (saved_cw));
 
-  __asm__ ("fstcw %0" : "=m" (*&saved_cw));
   new_cw = saved_cw & clr_mask;
   new_cw |= type;
-  __asm__ ("fldcw %0" : : "m" (*&new_cw));
 
-  __asm__ ("frndint\n"
-	   "fstp" ASM_SUFFIX " %0\n" : "=m" (*&ret));
-  __asm__ ("fldcw %0" : : "m" (*&saved_cw));
+  __asm__ ("fldcw %2\n\t"
+	   "frndint\n\t"
+	   "fldcw %3" : "=t" (ret)
+		      : "0" (f), "m" (new_cw), "m" (saved_cw));
   return ret;
 }
 
Index: gcc/testsuite/gcc.target/i386/pr68701-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr68701-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr68701-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O -ffixed-ebp -mno-accumulate-outgoing-args -mstackrealign -msse" } */
+
+/* { dg-warning "fixed ebp register requires" "" { target *-*-* } 0 } */
+
+typedef float V __attribute__((vector_size(16)));
+
+void bar (V a)
+{
+  volatile V b = a;
+}
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundps-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundps-3.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundps-3.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_floor_ps(x)
 #define ROUND_MODE _MM_FROUND_FLOOR
Index: gcc/testsuite/gcc.target/i386/pr66922.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66922.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66922.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -msse2" } */
+/* { dg-require-effective-target sse2 } */
+
+#include "sse2-check.h"
+
+struct S 
+{
+  int:31;
+  int:2;
+  int f0:16;
+  int f1;
+  int f2;
+};
+
+static void 
+sse2_test (void)
+{
+  struct S a = { 1, 0, 0 };
+
+  if (a.f0 != 1)
+    __builtin_abort(); 
+}
Index: gcc/testsuite/gcc.target/i386/pr67265-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr67265-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr67265-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fstack-check" } */
+
+void foo (int n)
+{
+  volatile char arr[64 * 1024];
+
+  arr[n] = 1;
+}
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundss-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-1.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_ceil_ss(x, x)
 #define ROUND_MODE _MM_FROUND_CEIL
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundsd-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-1.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128d
 #define FP_T double
-#define ASM_SUFFIX "l"
 
 #define ROUND_INTRIN(x, mode) _mm_ceil_sd(x, x)
 #define ROUND_MODE _MM_FROUND_CEIL
Index: gcc/testsuite/gcc.target/i386/avx512f-pr70059.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx512f-pr70059.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx512f-pr70059.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* PR target/70059 */
+/* { dg-do run } */
+/* { dg-require-effective-target avx512f } */
+/* { dg-options "-O2 -mavx512f" } */
+
+#include "avx512f-check.h"
+
+__attribute__((noinline, noclone)) __m512i
+foo (__m256i a, __m256i b)
+{
+  __m512i r = _mm512_undefined_si512 ();
+  r = _mm512_inserti64x4 (r, a, 0);
+  r = _mm512_inserti64x4 (r, b, 1);
+  return r;
+}
+
+static void
+avx512f_test (void)
+{
+  union256i_q a, b;
+  union512i_q r;
+  long long r_ref[8];
+  int i;
+  for (i = 0; i < 4; i++)
+    {
+      a.a[i] = 0x0101010101010101ULL * i;
+      b.a[i] = 0x1010101010101010ULL * i;
+      r_ref[i] = a.a[i];
+      r_ref[i + 4] = b.a[i];
+    }
+  r.x = foo (a.x, b.x);
+  check_union512i_q (r, r_ref);
+}
Index: gcc/testsuite/gcc.target/i386/pr69459.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr69459.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr69459.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,42 @@
+/* PR target/69549 */
+/* { dg-do run { target sse2_runtime } } */
+/* { dg-options "-O2 -msse2" } */
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+typedef unsigned char v16u8 __attribute__ ((vector_size (16)));
+typedef unsigned short v16u16 __attribute__ ((vector_size (16)));
+typedef unsigned int v16u32 __attribute__ ((vector_size (16)));
+typedef unsigned long long v16u64 __attribute__ ((vector_size (16)));
+
+u64 __attribute__((noinline, noclone))
+foo (u8 u8_0, u16 u16_3, v16u8 v16u8_0, v16u16 v16u16_0, v16u32 v16u32_0, v16u64 v16u64_0, v16u8 v16u8_1, v16u16 v16u16_1, v16u32 v16u32_1, v16u64 v16u64_1, v16u8 v16u8_2, v16u16 v16u16_2, v16u32 v16u32_2, v16u64 v16u64_2, v16u8 v16u8_3, v16u16 v16u16_3, v16u32 v16u32_3, v16u64 v16u64_3)
+{
+  v16u64_0 /= (v16u64){u16_3, ((0))} | 1;
+  v16u64_1 += (v16u64)~v16u32_0;
+  v16u16_1 /= (v16u16){-v16u64_3[1]} | 1;
+  v16u64_3[1] -= 0x1fffffff;
+  v16u32_2 /= (v16u32)-v16u64_0 | 1;
+  v16u32_1 += ~v16u32_1;
+  v16u16_3 %= (v16u16){0xfff, v16u32_2[3], v16u8_0[14]} | 1;
+  v16u64_3 -= (v16u64)v16u32_2;
+  if (v16u64_1[1] >= 1) {
+    v16u64_0 %= (v16u64){v16u32_0[1]} | 1;
+    v16u32_1[1] %= 0x5fb856;
+    v16u64_1 |= -v16u64_0;
+  }
+  v16u8_0 *= (v16u8)v16u32_1;
+  return u8_0 + v16u8_0 [12] + v16u8_0 [13] + v16u8_0 [14] + v16u8_0 [15] + v16u16_0 [0] + v16u16_0 [1] + v16u32_0 [0] + v16u32_0 [1] + v16u32_0 [2] + v16u32_0 [3] + v16u64_0 [0] + v16u64_0 [1] + v16u8_1 [9] + v16u8_1 [10] + v16u8_1 [11] + v16u8_1 [15] + v16u16_1 [0] + v16u16_1 [1] + v16u16_1 [3] + v16u64_1 [0] + v16u64_1 [1] + v16u8_2 [3] + v16u8_2 [4] + v16u8_2 [5] + v16u8_2 [0] + v16u32_2 [1] + v16u32_2 [2] + v16u32_2 [3] + v16u64_2 [0] + v16u64_2 [1] + v16u8_3 [0] + v16u16_3 [6] + v16u16_3[7] + v16u32_3[1] + v16u32_3[2] + v16u64_3[0] + v16u64_3[1];
+}
+
+int
+main ()
+{
+  u64 x = foo(1, 1, (v16u8){1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, (v16u16){1, 1}, (v16u32){1}, (v16u64){1}, (v16u8){1}, (v16u16){1, 1}, (v16u32){1}, (v16u64){1}, (v16u8){1, 1, 1, 1, 1}, (v16u16){1}, (v16u32){1}, (v16u64){1}, (v16u8){1}, (v16u16){1}, (v16u32){1}, (v16u64){1});
+
+  if (x != 0xffffffffe0000209)
+    __builtin_abort();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr66814.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66814.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66814.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,4 @@
+/* { dg-do compile { target { ia32 } } } */
+/* { dg-options "-march=i586 -mavx512f -O2" } */
+
+#include "avx512f-klogic-2.c"
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundss-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundss-2.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128
 #define FP_T float
-#define ASM_SUFFIX "s"
 
 #define ROUND_INTRIN(x, mode) _mm_round_ss(x, x, mode)
 #define ROUND_MODE _MM_FROUND_NINT
Index: gcc/testsuite/gcc.target/i386/sse4_1-roundsd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse4_1-roundsd-2.c	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,6 @@
 
 #define VEC_T __m128d
 #define FP_T double
-#define ASM_SUFFIX "l"
 
 #define ROUND_INTRIN(x, mode) _mm_round_sd(x, x, mode)
 #define ROUND_MODE _MM_FROUND_NINT
Index: gcc/testsuite/gcc.target/s390/gpr2fprsavecfi.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/gpr2fprsavecfi.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/s390/gpr2fprsavecfi.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 -mzarch -fdwarf2-cfi-asm" } */
+
+char *gl[100];
+
+long
+foo ()
+{
+  long r = 0;
+  char bla[100];
+  int i;
+
+  __builtin_memcpy (bla, gl, 100);
+
+  for (i = 0; i < 100; i++)
+    r += bla[i];
+
+  return r;
+}
+
+/* { dg-final { scan-assembler-not "cfi_def_cfa_register" } } */
+/* { dg-final { scan-assembler "cfi_register" } } */
+/* { dg-final { scan-assembler "cfi_def_cfa_offset" } } */
Index: gcc/testsuite/gcc.target/ia64/pr60465-gprel64-c37.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/ia64/pr60465-gprel64-c37.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/ia64/pr60465-gprel64-c37.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile { target ia64-*-* } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler-not "@ltoffx" } } */
+
+/* A bit of https://bugzilla.redhat.com/show_bug.cgi?id=33354
+   where many stores to static variables overflow .sdata */
+
+static const char *s90;
+void f() { s90 = "string 90"; }
+const char * g() { return s90; }
Index: gcc/testsuite/gcc.target/ia64/pr60465-gprel64.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/ia64/pr60465-gprel64.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/ia64/pr60465-gprel64.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+/* { dg-do compile { target ia64-*-* } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler-not "@ltoffx" } } */
+
+/* Test imitates early ld.so setup in glibc
+   where no dynamic relocations must be present. */
+
+struct rtld_global
+{
+    long *p[77];
+};
+
+struct rtld_global _rtld_local __attribute__ ((visibility ("hidden"), section (".sdata")));
+
+static void __attribute__ ((unused, noinline))
+elf_get_dynamic_info (struct rtld_global * g, long * dyn)
+{
+  long **info = g->p;
+
+  info[(0x6ffffeff - *dyn) + 66] = dyn;
+}
+
+void __attribute__ ((unused, noinline))
+_dl_start (long * dyn)
+{
+  elf_get_dynamic_info(&_rtld_local, dyn);
+}
Index: gcc/testsuite/gcc.target/sparc/sparc-ret.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/sparc-ret.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/sparc-ret.c	(.../branches/gcc-4_9-branch)
@@ -1,24 +0,0 @@
-/* { dg-do compile } */
-/* { dg-skip-if "no register windows" { *-*-* } { "-mflat" } { "" } } */
-/* { dg-require-effective-target ilp32 } */
-/* { dg-options "-mcpu=ultrasparc -O" } */
-
-/* Make sure that Ultrasparc return insn do not read below the stack.  */
-
-int bar (int a, int b, int c, int d, int e, int f, int g, int h)
-{
-  int res;
-
-  toto (&res);
-  return h;
-}
-/* { dg-final { scan-assembler "return\[ \t\]*%i7\\+8\n\[^\n\]*ld\[ \t\]*\\\[%sp\\+96\\\]" } } */
-
-int bar2 ()
-{
-  int res;
-
-  toto (&res);
-  return res;
-}
-/* { dg-final { scan-assembler "return\[ \t\]*%i7\\+8\n\[^\n\]*nop" } } */
Index: gcc/testsuite/gcc.target/sparc/sparc-ret-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/sparc-ret-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/sparc-ret-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* PR target/57845 */
+
+/* { dg-do compile } */
+/* { dg-options "-freg-struct-return" } */
+
+struct S { short int i; };
+
+struct S foo (short int i)
+{
+  struct S s;
+  s.i = i;
+  return s;
+}
Index: gcc/testsuite/gcc.target/sparc/sparc-ret-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/sparc-ret-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/sparc-ret-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-skip-if "no register windows" { *-*-* } { "-mflat" } { "" } } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-mcpu=ultrasparc -O" } */
+
+/* Make sure that Ultrasparc return insn do not read below the stack.  */
+
+int bar (int a, int b, int c, int d, int e, int f, int g, int h)
+{
+  int res;
+
+  toto (&res);
+  return h;
+}
+/* { dg-final { scan-assembler "return\[ \t\]*%i7\\+8\n\[^\n\]*ld\[ \t\]*\\\[%sp\\+96\\\]" } } */
+
+int bar2 ()
+{
+  int res;
+
+  toto (&res);
+  return res;
+}
+/* { dg-final { scan-assembler "return\[ \t\]*%i7\\+8\n\[^\n\]*nop" } } */
Index: gcc/testsuite/gcc.target/sh/torture/pr67260.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/torture/pr67260.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.target/sh/torture/pr67260.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* { dg-additional-options "-std=gnu99 -fPIC" }  */
+/* { dg-do compile }  */
+
+#pragma GCC visibility push(hidden)
+
+double _Complex foo (double _Complex arg);
+
+double _Complex
+bar (double _Complex arg)
+{
+  return foo (arg);
+}
Index: gcc/testsuite/lib/gcc-gdb-test.exp
===================================================================
--- a/src/gcc/testsuite/lib/gcc-gdb-test.exp	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/lib/gcc-gdb-test.exp	(.../branches/gcc-4_9-branch)
@@ -52,8 +52,8 @@
     puts $fd "quit"
     close $fd
 
-    send_log "Spawning: $gdb_name -nx -nw -quiet -x $cmd_file ./$output_file\n"
-    set res [remote_spawn target "$gdb_name -nx -nw -quiet -x $cmd_file ./$output_file"]
+    send_log "Spawning: $gdb_name -nx -nw -quiet -batch -x $cmd_file ./$output_file\n"
+    set res [remote_spawn target "$gdb_name -nx -nw -quiet -batch -x $cmd_file ./$output_file"]
     if { $res < 0 || $res == "" } {
 	unsupported "$testname"
 	file delete $cmd_file
Index: gcc/testsuite/lib/gcc-simulate-thread.exp
===================================================================
--- a/src/gcc/testsuite/lib/gcc-simulate-thread.exp	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/lib/gcc-simulate-thread.exp	(.../branches/gcc-4_9-branch)
@@ -49,8 +49,8 @@
 
     set message "thread simulation test"
 
-    send_log "Spawning: $gdb_name -nx -nw -quiet -x $cmd_file ./$exec_file\n"
-    set res [remote_spawn target "$gdb_name -nx -nw  -x $cmd_file ./$exec_file"]
+    send_log "Spawning: $gdb_name -nx -nw -batch -x $cmd_file ./$exec_file\n"
+    set res [remote_spawn target "$gdb_name -nx -nw -batch -x $cmd_file ./$exec_file"]
     if { $res < 0 || $res == "" } {
 	unsupported "$testcase $message"
 	return
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_9-branch)
@@ -2707,7 +2707,9 @@
 # Creates a series of routines that return 1 if the given architecture
 # can be selected and a routine to give the flags to select that architecture
 # Note: Extra flags may be added to disable options from newer compilers
-# (Thumb in particular - but others may be added in the future)
+# (Thumb in particular - but others may be added in the future).
+# -march=armv7ve is special and is handled explicitly after this loop because
+# it needs more than one predefine check to identify.
 # Usage: /* { dg-require-effective-target arm_arch_v5_ok } */
 #        /* { dg-add-options arm_arch_v5 } */
 #	 /* { dg-require-effective-target arm_arch_v5_multilib } */
@@ -2722,7 +2724,6 @@
 				     v6z "-march=armv6z" __ARM_ARCH_6Z__
 				     v6m "-march=armv6-m -mthumb" __ARM_ARCH_6M__
 				     v7a "-march=armv7-a" __ARM_ARCH_7A__
-				     v7ve "-march=armv7ve" __ARM_ARCH_7A__
 				     v7r "-march=armv7-r" __ARM_ARCH_7R__
 				     v7m "-march=armv7-m -mthumb" __ARM_ARCH_7M__
 				     v7em "-march=armv7e-m -mthumb" __ARM_ARCH_7EM__
@@ -2756,6 +2757,26 @@
     }]
 }
 
+# Same functions as above but for -march=armv7ve.  To uniquely identify
+# -march=armv7ve we need to check for __ARM_ARCH_7A__ as well as
+# __ARM_FEATURE_IDIV otherwise it aliases with armv7-a.
+
+proc check_effective_target_arm_arch_v7ve_ok { } {
+  if { [ string match "*-marm*" "-march=armv7ve" ] &&
+	![check_effective_target_arm_arm_ok] } {
+		return 0
+    }
+  return [check_no_compiler_messages arm_arch_v7ve_ok assembly {
+  #if !defined (__ARM_ARCH_7A__) || !defined (__ARM_FEATURE_IDIV)
+  #error !armv7ve
+  #endif
+  } "-march=armv7ve" ]
+}
+
+proc add_options_for_arm_arch_v7ve { flags } {
+    return "$flags -march=armv7ve"
+}
+
 # Return 1 if this is an ARM target where -marm causes ARM to be
 # used (not Thumb)
 
@@ -5852,3 +5873,12 @@
     }
 }
 
+# Return 1 if target supports __builtin_eh_return
+proc check_effective_target_builtin_eh_return { } {
+    return [check_no_compiler_messages builtin_eh_return object {
+	void test (long l, void *p)
+	{
+	    __builtin_eh_return (l, p);
+	}
+    } "" ]
+}
Index: gcc/testsuite/gfortran.dg/gomp/pr69128.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr69128.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr69128.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+! PR fortran/69128
+! { dg-do compile }
+
+program test
+  implicit none
+  interface
+    subroutine use(b, c)
+      real, allocatable :: b(:), c(:)
+    end subroutine
+  end interface
+  real, allocatable :: a(:,:), b(:), c(:)
+  integer :: dim1, dim2, i,j
+  dim1=10000
+  dim2=500
+  allocate(a(dim1,dim2),b(dim1),c(dim1))
+  call random_number(a)
+
+!$omp parallel workshare
+  b(:) = maxval(a(:,:), dim=2)
+  c(:) = sum(a(:,:), dim=2)
+!$omp end parallel workshare
+  call use(b, c)
+end program
Index: gcc/testsuite/gfortran.dg/allocate_with_arrayspec_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocate_with_arrayspec_1.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocate_with_arrayspec_1.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+
+MODULE mo_test
+
+  integer :: n = 0
+CONTAINS
+
+  FUNCTION nquery()
+    INTEGER :: nquery
+    WRITE (0,*) "hello!"
+    n = n + 1
+    nquery = n
+  END FUNCTION nquery
+
+END MODULE mo_test
+
+
+! ----------------------------------------------------------------------
+! MAIN PROGRAM
+! ----------------------------------------------------------------------
+PROGRAM example
+   USE mo_test
+   INTEGER, ALLOCATABLE :: query_buf(:)
+   ALLOCATE(query_buf(nquery()))
+   if (n /= 1 .or. size(query_buf) /= n) call abort()
+END PROGRAM example
+
+! { dg-final { scan-tree-dump-times "nquery" 5 "original" } }
Index: gcc/testsuite/gfortran.dg/namelist_84.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/namelist_84.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/namelist_84.f90	(.../branches/gcc-4_9-branch)
@@ -17,12 +17,11 @@
    write(10, mylist)
    rewind(10)
    mystring = "xxxxx"
-   read(10,mylist)
-   if (any(mystring /= (/ 'mon', 'tue', 'wed', 'thu', 'fri' /))) call abort
    rewind(10)
    do i=1,5
      read(10,'(a)') internal_unit
-     if (scan(internal_unit,"""'").ne.0) call abort
+     if (i.eq.2 .and. internal_unit .ne. " MYSTRING=mon  tue  wed  thu  fri  ,") call abort
+     if (scan(internal_unit,"""'").ne.0) print *, internal_unit
    end do
    close(10)
 end program
Index: gcc/testsuite/gfortran.dg/generic_31.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/generic_31.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/generic_31.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+! { dg-do run }
+!
+! PR fortran/66929
+! Check that the specific FIRST symbol is used for the call to FOO,
+! so that the J argument is not assumed to be present
+
+module m
+  interface foo
+    module procedure first
+  end interface foo
+contains
+  elemental function bar(j) result(r)
+    integer, intent(in), optional :: j
+    integer :: r, s(2)
+    ! We used to have NULL dereference here, in case of a missing J argument
+    s = foo(j, [3, 7])
+    r = sum(s)
+  end function bar
+  elemental function first(i, j) result(r)
+    integer, intent(in), optional :: i
+    integer, intent(in) :: j
+    integer :: r
+    if (present(i)) then
+      r = i
+    else
+      r = -5
+    end if
+  end function first
+end module m
+program p
+  use m
+  integer :: i
+  i = bar()
+  if (i /= -10) call abort
+end program p
Index: gcc/testsuite/gfortran.dg/pr58754.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr58754.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr58754.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+!
+! Tests the fix for PR58754
+!
+  type :: char_type
+    character, allocatable :: chr (:)
+  end type
+  character, allocatable :: c(:)
+  type(char_type) :: d
+  character :: t(1) = ["w"]
+
+  allocate (c (1), source = t)
+  if (any (c .ne. t)) call abort
+  c = ["a"]
+  if (any (c .ne. ["a"])) call abort
+  deallocate (c)
+
+! Check allocatable character components, whilst we are about it.
+  allocate (d%chr (2), source = [t, char (ichar (t) + 1)])
+  if (any (d%chr .ne. ["w", "x"])) call abort
+  d%chr = ["a","b","c","d"]
+  if (any (d%chr .ne. ["a","b","c","d"])) call abort
+  deallocate (d%chr)
+end
Index: gcc/testsuite/gfortran.dg/pr56852.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr56852.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr56852.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! Test the fix for pr56852, where an ICE would occur after the error.
+!
+! Contributed by Lorenz Huedepohl  <bugs@stellardeath.org>
+!
+program test
+  implicit none
+  real :: a(4)
+  ! integer :: i
+  read(0) (a(i),i=1,4) ! { dg-error "has no IMPLICIT type" }
+end program
Index: gcc/testsuite/gfortran.dg/pr66465.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr66465.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr66465.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+! { dg-do compile }
+!
+! Tests the fix for PR66465, in which the arguments of the call to
+! ASSOCIATED were falsly detected to have different type/kind.
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+  interface
+     real function HandlerInterface (arg)
+       real :: arg
+     end
+  end interface
+
+  type TextHandlerTestCase
+     procedure (HandlerInterface), nopass, pointer :: handlerOut=>null()
+  end type
+
+  type(TextHandlerTestCase) this
+
+  procedure (HandlerInterface), pointer :: procPtr=>null()
+
+  print*, associated(procPtr, this%handlerOut)
+end
Index: gcc/testsuite/gfortran.dg/class_allocate_20.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/class_allocate_20.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/class_allocate_20.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,32 @@
+! { dg-do run }
+!
+! PR fortran/64921
+! Test that the finalization wrapper procedure get the always_explicit
+! attribute so that the array is not passed without descriptor from 
+! T3's finalization wrapper procedure to T2's one.
+!
+! Contributed by Mat Cross  <mathewc@nag.co.uk>
+
+Program test
+  Implicit None
+  Type :: t1
+    Integer, Allocatable :: i
+  End Type
+  Type :: t2
+    Integer, Allocatable :: i
+  End Type
+  Type, Extends (t1) :: t3
+    Type (t2) :: j
+  End Type
+  Type, Extends (t3) :: t4
+    Integer, Allocatable :: k
+  End Type
+  Call s
+  Print *, 'ok'
+Contains
+  Subroutine s
+    Class (t1), Allocatable :: x
+    Allocate (t4 :: x)
+  End Subroutine
+End Program
+! { dg-output "ok" }
Index: gcc/testsuite/gfortran.dg/pr60126.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr60126.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr60126.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR fortran/60126 - ICE on pointer rank remapping
+! Based on testcase by Michel Valin <mfvalin at gmail dot com>
+
+subroutine simple_bug_demo
+  implicit none
+  interface
+     function offset_ptr_R4(nelements) result (dest)
+       implicit none
+       real, pointer, dimension(:) :: dest
+       integer, intent(IN) :: nelements
+     end function offset_ptr_R4
+  end interface
+
+  real, dimension(:,:), pointer :: R2D
+
+  R2D(-2:2,-3:3) => offset_ptr_R4(100)
+end
Index: gcc/testsuite/gfortran.dg/namelist_38.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/namelist_38.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/namelist_38.f90	(.../branches/gcc-4_9-branch)
@@ -5,6 +5,7 @@
 program main
   implicit none
   character(len=3) :: a
+  character(25) :: b
   namelist /foo/ a
 
   open(10, status="scratch", delim="quote")
@@ -28,9 +29,12 @@
   open(10, status="scratch", delim="none")
   a = "a'a"
   write(10,foo) 
-  rewind 10
-  a = ""
-  read (10,foo)
-  if (a.ne."a'a") call abort
-  close (10)
+  rewind (10)
+  read(10,"(a)") b
+  if (b .ne. "&FOO") call abort
+  read(10,"(a)") b
+  if (b .ne. " A=a'a") call abort
+  read(10,"(a)") b
+  if (b .ne. " /") call abort
+  close(10)
 end program main
Index: gcc/testsuite/gfortran.dg/generic_30.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/generic_30.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/generic_30.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,41 @@
+! { dg-do compile }
+!
+! PR fortran/66929
+! Generic procedures as actual argument used to lead to
+! a NULL pointer dereference in gfc_get_proc_ifc_for_expr
+! because the generic symbol was used as procedure symbol,
+! instead of the specific one.
+
+module iso_varying_string
+  type, public :: varying_string
+     character(LEN=1), dimension(:), allocatable :: chars
+  end type varying_string
+  interface operator(/=)
+     module procedure op_ne_VS_CH
+  end interface operator (/=)
+  interface trim
+     module procedure trim_
+  end interface
+contains
+  elemental function op_ne_VS_CH (string_a, string_b) result (op_ne)
+    type(varying_string), intent(in) :: string_a
+    character(LEN=*), intent(in)     :: string_b
+    logical                          :: op_ne
+    op_ne = .true.
+  end function op_ne_VS_CH
+  elemental function trim_ (string) result (trim_string)
+    type(varying_string), intent(in) :: string
+    type(varying_string)             :: trim_string
+    trim_string = varying_string(["t", "r", "i", "m", "m", "e", "d"])
+  end function trim_
+end module iso_varying_string
+module syntax_rules
+  use iso_varying_string, string_t => varying_string
+contains
+  subroutine set_rule_type_and_key
+    type(string_t) :: key
+    if (trim (key) /= "") then
+      print *, "non-empty"
+    end if
+  end subroutine set_rule_type_and_key
+end module syntax_rules
Index: gcc/testsuite/gfortran.dg/prof/dynamic_dispatch_6.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/prof/dynamic_dispatch_6.f03	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/prof/dynamic_dispatch_6.f03	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,68 @@
+! { dg-require-profiling "-fprofile-generate" }
+! { dg-options "-Ofast" }
+!
+! PR 45076: [OOP] gfortran.dg/dynamic_dispatch_6.f03 ICEs with -fprofile-use
+!
+! Contributed by Damian Rouson <damian@rouson.net>
+
+module field_module
+  implicit none
+  private
+  public :: field
+  type ,abstract :: field 
+  end type
+end module
+
+module periodic_5th_order_module
+  use field_module ,only : field
+  implicit none
+  type ,extends(field) :: periodic_5th_order
+  end type
+end module
+
+module field_factory_module
+  implicit none
+  private
+  public :: field_factory
+  type, abstract :: field_factory 
+  contains 
+    procedure(create_interface), deferred :: create 
+  end type 
+  abstract interface 
+    function create_interface(this) 
+      use field_module ,only : field
+      import :: field_factory
+      class(field_factory), intent(in) :: this 
+      class(field) ,pointer :: create_interface
+    end function
+  end interface 
+end module
+
+module periodic_5th_factory_module
+  use field_factory_module , only : field_factory
+  implicit none
+  private
+  public :: periodic_5th_factory
+  type, extends(field_factory) :: periodic_5th_factory 
+  contains 
+    procedure :: create=>new_periodic_5th_order
+  end type 
+contains
+  function new_periodic_5th_order(this) 
+    use field_module ,only : field
+    use periodic_5th_order_module ,only : periodic_5th_order
+    class(periodic_5th_factory), intent(in) :: this
+    class(field) ,pointer :: new_periodic_5th_order
+  end function
+end module
+
+program main 
+  use field_module ,only : field 
+  use field_factory_module ,only : field_factory
+  use periodic_5th_factory_module ,only : periodic_5th_factory
+  implicit none 
+  class(field) ,pointer :: u
+  class(field_factory), allocatable :: field_creator 
+  allocate (periodic_5th_factory ::  field_creator) 
+  u => field_creator%create() 
+end program
Index: gcc/testsuite/gfortran.dg/prof/prof.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/prof/prof.exp	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/prof/prof.exp	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,56 @@
+# Copyright (C) 2001-2016 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Test the functionality of programs compiled with profile-directed block
+# ordering using -fprofile-generate followed by -fprofile-use.
+
+load_lib target-supports.exp
+
+# Some targets don't support tree profiling.
+if { ![check_profiling_available "-fprofile-generate"] } {
+    return
+}
+
+# The procedures in profopt.exp need these parameters.
+set tool gfortran
+set prof_ext "gcda"
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# Load support procs.
+load_lib profopt.exp
+
+# Save and override the default list defined in profopt.exp.
+set treeprof_save_profopt_options $PROFOPT_OPTIONS
+set PROFOPT_OPTIONS [list {}]
+
+# These are globals used by profopt-execute.  The first is options
+# needed to generate profile data, the second is options to use the
+# profile data.
+set profile_option "-fprofile-generate -D_PROFILE_GENERATE"
+set feedback_option "-fprofile-use -D_PROFILE_USE"
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.f*]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+        continue
+    }
+    profopt-execute $src
+}
+
+set PROFOPT_OPTIONS $treeprof_save_profopt_options
Index: gcc/testsuite/gfortran.dg/proc_ptr_47.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/proc_ptr_47.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/proc_ptr_47.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,37 @@
+! { dg-do run }
+! Tests the fix for PR68196
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+  type AA
+    integer :: i
+    procedure(foo), pointer :: funct
+  end type
+  class(AA), allocatable :: my_AA
+  type(AA) :: res
+
+  allocate (my_AA, source = AA (1, foo))
+
+  res = my_AA%funct ()
+
+  if (res%i .ne. 3) call abort
+  if (.not.associated (res%funct)) call abort
+  if (my_AA%i .ne. 4) call abort
+  if (associated (my_AA%funct)) call abort
+
+contains
+  function foo(A)
+    class(AA), allocatable :: A
+    type(AA) foo
+
+    if (.not.allocated (A)) then
+      allocate (A, source = AA (2, foo))
+    endif
+
+    select type (A)
+      type is (AA)
+        foo = AA (3, foo)
+        A = AA (4, NULL ())
+    end select
+  end function
+end
Index: gcc/testsuite/gfortran.dg/fmt_pf.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/fmt_pf.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/fmt_pf.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,226 @@
+! { dg-do run }
+! PR70235 Incorrect output with PF format.
+! Test case provided by Antoine Gardeux.
+program pr70235
+use ISO_FORTRAN_ENV
+    implicit none
+    integer, parameter :: j(size(real_kinds)+4)=[REAL_KINDS, [4, 4, 4, 4]]
+    logical :: l_skip(4) = .false.
+    integer :: i
+    integer :: n_tst = 0, n_cnt = 0, n_skip = 0
+    character(len=20) :: s, s1
+
+!   Check that the default rounding mode is to nearest and to even on tie.
+    do i=1,size(real_kinds)
+      if (i == 1) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(1)), &
+                                  real(9.49999905,kind=j(1)),  &
+                                  real(9.5,kind=j(1)), real(8.5,kind=j(1))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(1)), &
+                                       real(98765.0,kind=j(1))
+      else if (i == 2) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(2)), &
+                                  real(9.49999905,kind=j(2)),  &
+                                  real(9.5,kind=j(2)), real(8.5,kind=j(2))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(2)), &
+                                       real(98765.0,kind=j(2))
+      else if (i == 3) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(3)), &
+                                  real(9.49999905,kind=j(3)),  &
+                                  real(9.5,kind=j(3)), real(8.5,kind=j(3))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(3)), &
+                                       real(98765.0,kind=j(3))
+      else if (i == 4) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(4)), &
+                                  real(9.49999905,kind=j(4)),  &
+                                  real(9.5,kind=j(4)), real(8.5,kind=j(4))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(4)), &
+                                       real(98765.0,kind=j(4))
+      end if
+      if (s /= '-9.5 9.5 10.  8.' .or. s1 /= ' 987.4E+03 98.76E+03') then
+        l_skip(i) = .true.
+!        print "('Unsupported rounding for real(',i0,')')", j(i)
+      end if
+    end do
+        
+
+! Original test.
+    call checkfmt("(-6PF8.3)", 1.0e4,    "   0.010")
+    call checkfmt("(-6PF8.3)",   0.0,    "   0.000")
+
+! Test for the bug in comment 6.
+    call checkfmt("(-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("( 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(ru,-8pf18.3)", 643.125, "             0.001")
+    call checkfmt("(ru,-7pf18.3)", 643.125, "             0.001")
+    call checkfmt("(ru,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(ru,-5pf18.3)", 643.125, "             0.007")
+    call checkfmt("(ru,-4pf18.3)", 643.125, "             0.065")
+    call checkfmt("(ru,-3pf18.3)", 643.125, "             0.644")
+    call checkfmt("(ru,-2pf18.3)", 643.125, "             6.432")
+    call checkfmt("(ru,-1pf18.3)", 643.125, "            64.313")
+    call checkfmt("(ru, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rd,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rd,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rd,-6pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rd,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rd,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rd,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rd,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rd,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rd, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rz,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rz,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rz,-6pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rz,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rz,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rz,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rz,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rz,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rz, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rc,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rc,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rc,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(rc,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rc,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rc,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rc,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rc,-1pf18.3)", 643.125, "            64.313")
+    call checkfmt("(rc, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rn,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rn,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rn,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(rn,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rn,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rn,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rn,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rn,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rn, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rp,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rp,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rp,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(rp,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rp,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rp,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rp,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rp,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rp, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("( 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(ru,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(ru,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(ru,-6pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(ru,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(ru,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(ru,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(ru,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(ru,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(ru, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rd,-8pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rd,-7pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rd,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rd,-5pf18.3)", -643.125, "            -0.007")
+    call checkfmt("(rd,-4pf18.3)", -643.125, "            -0.065")
+    call checkfmt("(rd,-3pf18.3)", -643.125, "            -0.644")
+    call checkfmt("(rd,-2pf18.3)", -643.125, "            -6.432")
+    call checkfmt("(rd,-1pf18.3)", -643.125, "           -64.313")
+    call checkfmt("(rd, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rz,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rz,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rz,-6pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rz,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rz,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rz,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rz,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rz,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(rz, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rc,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rc,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rc,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rc,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rc,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rc,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rc,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rc,-1pf18.3)", -643.125, "           -64.313")
+    call checkfmt("(rc, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rn,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rn,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rn,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rn,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rn,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rn,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rn,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rn,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(rn, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rp,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rp,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rp,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rp,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rp,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rp,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rp,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rp,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(rp, 0pf18.3)", -643.125, "          -643.125")
+
+    ! print *, n_tst, n_cnt, n_skip
+    if (n_cnt /= 0) call abort
+    if (all(.not. l_skip)) print *, "All kinds rounded to nearest"
+
+contains
+    subroutine checkfmt(fmt, x, cmp)
+        implicit none
+        integer :: i
+        character(len=*), intent(in) :: fmt
+        real, intent(in) :: x
+        character(len=*), intent(in) :: cmp
+        do i=1,size(real_kinds)
+          if (i == 1) then
+            write(s, fmt) real(x,kind=j(1))
+          else if (i == 2) then
+            write(s, fmt) real(x,kind=j(2))
+          else if (i == 3) then
+            write(s, fmt) real(x,kind=j(3))
+          else if (i == 4) then
+            write(s, fmt) real(x,kind=j(4))
+          end if
+          n_tst = n_tst + 1
+          if (s /= cmp) then
+            if (l_skip(i)) then
+              n_skip = n_skip + 1
+            else
+              print "(a,1x,a,' expected: ',1x,a)", fmt, s, cmp
+              n_cnt = n_cnt + 1
+            end if
+          end if
+        end do
+        
+    end subroutine
+end program
+! { dg-output "All kinds rounded to nearest" { xfail { i?86-*-solaris2.9* hppa*-*-hpux* } } }
Index: gcc/testsuite/gfortran.dg/include_6.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/include_6.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/include_6.f90	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 ! { dg-do compile }
 ! { dg-options "-I gfortran.log" }
-! { dg-warning "is not a directory" "" { target *-*-* } 0 }
+! { dg-error "is not a directory" "" { target *-*-* } 0 }
 end 
 
Index: gcc/testsuite/gfortran.dg/forall_17.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/forall_17.f90	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/forall_17.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-ffrontend-optimize" }
+! PR fortran/66385 - this used to ICE
+! Original test case by Mianzhi Wang
+program test
+  double precision::aa(30)
+  double precision::a(3,3),b
+  b=1d0
+  forall(i=1:3)
+    a(:,i)=b*[1d0,2d0,3d0]
+  end forall
+
+  forall(i=1:10)
+    aa(10*[0,1,2]+i)=1d0
+  end forall
+
+end program
Index: gcc/testsuite/gcc.c-torture/execute/pr67226.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr67226.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr67226.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,42 @@
+struct assembly_operand
+{
+  int type, value, symtype, symflags, marker;
+};
+
+struct assembly_operand to_input, from_input;
+
+void __attribute__ ((__noinline__, __noclone__))
+assemblez_1 (int internal_number, struct assembly_operand o1)
+{
+  if (o1.type != from_input.type)
+    __builtin_abort ();
+}
+
+void __attribute__ ((__noinline__, __noclone__))
+t0 (struct assembly_operand to, struct assembly_operand from)
+{
+  if (to.value == 0)
+    assemblez_1 (32, from);
+  else
+    __builtin_abort ();
+}
+
+int
+main (void)
+{
+  to_input.value = 0;
+  to_input.type = 1;
+  to_input.symtype = 2;
+  to_input.symflags = 3;
+  to_input.marker = 4;
+
+  from_input.value = 5;
+  from_input.type = 6;
+  from_input.symtype = 7;
+  from_input.symflags = 8;
+  from_input.marker = 9;
+
+  t0 (to_input, from_input);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr68376-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr68376-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr68376-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+/* PR rtl-optimization/68376 */
+
+int a, b, c = 1;
+signed char d;
+
+int
+main ()
+{
+  for (; a < 1; a++)
+    for (; b < 1; b++)
+      {
+	signed char e = ~d;
+	if (d < 1)
+	  e = d;
+	d = e;
+	if (!c)
+	  __builtin_abort ();
+      }
+
+  if (d != 0)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr70460.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr70460.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr70460.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* PR rtl-optimization/70460 */
+
+int c;
+
+__attribute__((noinline, noclone)) void
+foo (int x)
+{
+  static int b[] = { &&lab1 - &&lab0, &&lab2 - &&lab0 };
+  void *a = &&lab0 + b[x];
+  goto *a;
+lab1:
+  c += 2;
+lab2:
+  c++;
+lab0:
+  ;
+}
+
+int
+main ()
+{
+  foo (0);
+  if (c != 3)
+    __builtin_abort ();
+  foo (1);
+  if (c != 4)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr67929_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr67929_1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr67929_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+int __attribute__ ((noinline, noclone))
+foo (float a)
+{
+  return a * 4.9f;
+}
+
+
+int
+main (void)
+{
+  if (foo (10.0f) != 49)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr68328.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr68328.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr68328.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,44 @@
+int a, b, c = 1, d = 1, e;
+
+__attribute__ ((noinline, noclone))
+     int foo (void)
+{
+  asm volatile ("":::"memory");
+  return 4195552;
+}
+
+__attribute__ ((noinline, noclone))
+     void bar (int x, int y)
+{
+  asm volatile (""::"g" (x), "g" (y):"memory");
+  if (y == 0)
+    __builtin_abort ();
+}
+
+int
+baz (int x)
+{
+  char g, h;
+  int i, j;
+
+  foo ();
+  for (;;)
+    {
+      if (c)
+	h = d;
+      g = h < x ? h : 0;
+      i = (signed char) ((unsigned char) (g - 120) ^ 1);
+      j = i > 97;
+      if (a - j)
+	bar (0x123456, 0);
+      if (!b)
+	return e;
+    }
+}
+
+int
+main ()
+{
+  baz (2);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr70566.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr70566.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr70566.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+/* PR target/70566.  */
+
+#define NULL 0
+
+struct mystruct
+{
+  unsigned int f1 : 1;
+  unsigned int f2 : 1;
+  unsigned int f3 : 1;
+};
+
+__attribute__ ((noinline)) void
+myfunc (int a, void *b)
+{
+}
+__attribute__ ((noinline)) int
+myfunc2 (void *a)
+{
+  return 0;
+}
+
+static void
+set_f2 (struct mystruct *user, int f2)
+{
+  if (user->f2 != f2)
+    myfunc (myfunc2 (NULL), NULL);
+  else
+    __builtin_abort ();
+}
+
+__attribute__ ((noinline)) void
+foo (void *data)
+{
+  struct mystruct *user = data;
+  if (!user->f2)
+    set_f2 (user, 1);
+}
+
+int
+main (void)
+{
+  struct mystruct a;
+  a.f1 = 1;
+  a.f2 = 0;
+  foo (&a);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.c	(.../branches/gcc-4_9-branch)
@@ -2,7 +2,6 @@
 
    Ensure all expected transformations of builtin strstr occur and
    perform correctly in presence of redirect.  */
-/* { dg-options "-ffat-lto-objects" } */
 
 #define ASMNAME(cname)  ASMNAME2 (__USER_LABEL_PREFIX__, cname)
 #define ASMNAME2(prefix, cname) STRING (prefix) cname
Index: gcc/testsuite/gcc.c-torture/execute/builtins/memops-asm.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/builtins/memops-asm.x	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/builtins/memops-asm.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+# Different translation units may have different user name overrides
+# and we do not preserve enough context to known which one we want.
+
+set torture_eval_before_compile {
+  if {[string match {*-flto*} "$option"]} {
+    continue
+  }
+}
+
+return 0
Index: gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.x	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/builtins/strstr-asm.x	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+# Different translation units may have different user name overrides
+# and we do not preserve enough context to known which one we want.
+
+set torture_eval_before_compile {
+  if {[string match {*-flto*} "$option"]} {
+    continue
+  }
+}
+
+return 0
Index: gcc/testsuite/gcc.c-torture/execute/pr69403.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr69403.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr69403.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,20 @@
+/* PR target/69403.  */
+
+int a, b, c;
+
+__attribute__ ((__noinline__)) int
+fn1 ()
+{
+  if ((b | (a != (a & c))) == 1)
+    __builtin_abort ();
+  return 0;
+}
+
+int
+main (void)
+{
+  a = 5;
+  c = 1;
+  b = 6;
+  return fn1 ();
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr68376-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr68376-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr68376-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,73 @@
+/* PR rtl-optimization/68376 */
+
+extern void abort (void);
+
+__attribute__((noinline, noclone)) int
+f1 (int x)
+{
+  return x < 0 ? ~x : x;
+}
+
+__attribute__((noinline, noclone)) int
+f2 (int x)
+{
+  return x < 0 ? x : ~x;
+}
+
+__attribute__((noinline, noclone)) int
+f3 (int x)
+{
+  return x <= 0 ? ~x : x;
+}
+
+__attribute__((noinline, noclone)) int
+f4 (int x)
+{
+  return x <= 0 ? x : ~x;
+}
+
+__attribute__((noinline, noclone)) int
+f5 (int x)
+{
+  return x >= 0 ? ~x : x;
+}
+
+__attribute__((noinline, noclone)) int
+f6 (int x)
+{
+  return x >= 0 ? x : ~x;
+}
+
+__attribute__((noinline, noclone)) int
+f7 (int x)
+{
+  return x > 0 ? ~x : x;
+}
+
+__attribute__((noinline, noclone)) int
+f8 (int x)
+{
+  return x > 0 ? x : ~x;
+}
+
+int
+main ()
+{
+  if (f1 (5) != 5 || f1 (-5) != 4 || f1 (0) != 0)
+    abort ();
+  if (f2 (5) != -6 || f2 (-5) != -5 || f2 (0) != -1)
+    abort ();
+  if (f3 (5) != 5 || f3 (-5) != 4 || f3 (0) != -1)
+    abort ();
+  if (f4 (5) != -6 || f4 (-5) != -5 || f4 (0) != 0)
+    abort ();
+  if (f5 (5) != -6 || f5 (-5) != -5 || f5 (0) != -1)
+    abort ();
+  if (f6 (5) != 5 || f6 (-5) != 4 || f6 (0) != 0)
+    abort ();
+  if (f7 (5) != -6 || f7 (-5) != -5 || f7 (0) != 0)
+    abort ();
+  if (f8 (5) != 5 || f8 (-5) != 4 || f8 (0) != -1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr68185.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr68185.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr68185.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+int a, b, d = 1, e, f, o, u, w = 1, z;
+short c, q, t;
+
+int
+main ()
+{
+  char g;
+  for (; d; d--)
+    {
+      while (o)
+	for (; e;)
+	  {
+	    c = b;
+	    int h = o = z;
+	    for (; u;)
+	      for (; a;)
+		;
+	  }
+      if (t < 1)
+	g = w;
+      f = g;
+      g && (q = 1);
+    }
+
+  if (q != 1)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr69214.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr69214.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr69214.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* PR tree-optimization/69214 */
+
+extern void bar (void);
+extern int __setjmp (char *);
+
+void
+foo (char *p)
+{
+  int d = 0;
+  bar ();
+  if (__setjmp (p))
+    return;
+  long a = d;
+  d = 8;
+  if (!a)
+    bar ();
+}
Index: gcc/testsuite/gcc.dg/pr68670-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr68670-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr68670-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/68670 */
+/* { dg-do run } */
+/* { dg-options "-O2 -ftracer" } */
+
+#include "../gcc.c-torture/execute/pr68376-2.c"
Index: gcc/testsuite/gcc.dg/and-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/and-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/and-1.c	(.../branches/gcc-4_9-branch)
@@ -1,8 +1,8 @@
 /* { dg-do compile } */
 /* { dg-options "-O2" } */
 /* { dg-final { scan-assembler "and" { target powerpc*-*-* spu-*-* } } } */
-/* There should be no nand for this testcase (for either PPC or SPU). */
-/* { dg-final { scan-assembler-not "nand" { target powerpc*-*-* spu-*-* } } } */
+/* There should be no nand for this testcase for SPU. */
+/* { dg-final { scan-assembler-not "nand" { target spu-*-* } } } */
 
 int f(int y)
 {
Index: gcc/testsuite/gcc.dg/pr69522.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr69522.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr69522.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "" } */
+struct str {};
+struct {
+  struct str b;
+  float c[1];
+  int d[1];
+  float e[2];
+  int f[1];
+} a = {{}, 0, {0.5}, 0, 0, {0}};
Index: gcc/testsuite/gcc.dg/setjmp-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/setjmp-6.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/setjmp-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,25 @@
+/* PR69569 */
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+#include <setjmp.h>
+
+jmp_buf buf;
+
+struct str {
+    int Count;
+};
+int fun2(struct str *p1)
+{
+    int i = 1;
+    while (1) {
+	setjmp(buf);
+	break;
+    }
+    for (; i;) {
+	i = 0;
+	for (; i < (p1 ? p1->Count : 1); i++)
+	  fun2(p1);
+    }
+    return 1;
+}
Index: gcc/testsuite/gcc.dg/pr69195.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr69195.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr69195.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-dce -fno-forward-propagate" } */
+
+void __attribute__ ((noinline, noclone))
+foo (int *a, int n)
+{
+  int *lasta = a + n;
+  for (; a != lasta; a++)
+    {
+      *a *= 2;
+      a[1] = a[-1] + a[-2];
+    }
+}
+
+int
+main ()
+{
+  int a[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
+  int r[16] = { 1, 2, 6, 6, 16, 24, 44, 80,
+		136, 248, 432, 768, 1360, 2400, 4256, 3760 };
+  unsigned i;
+  foo (&a[2], 13);
+  for (i = 0; i < 8; ++i)
+    if (a[i] != r[i])
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/debug/pr66432.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/debug/pr66432.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/debug/pr66432.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+/* PR debug/66432 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -g" } */
+
+extern void baz (const char *, const char *) __attribute__ ((__noreturn__));
+
+void
+foo (int x, int y[x][x])
+{
+  if (x < 2)
+    baz ("", "");
+}
+
+void
+bar (void)
+{
+  int z[2][2] = { { 1, 2 }, { 3, 4 } };
+  foo (2, z);
+}
Index: gcc/testsuite/gcc.dg/graphite/interchange-15.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-15.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-15.c	(.../branches/gcc-4_9-branch)
@@ -49,6 +49,6 @@
 }
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
 
Index: gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,60 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define N 200
+
+unsigned int A[N][N], B[N][N], C[N][N];
+
+static void __attribute__((noinline))
+matmult (void)
+{
+  int i, j, k;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      A[i][j] = 0;
+
+  /* Loops J and K should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      for (k = 0; k < N; k++)
+	A[i][j] += B[i][k] * C[k][j];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned res = 0;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	B[i][j] = j;
+	C[i][j] = i;
+      }
+
+  matmult ();
+
+  for (i = 0; i < N; i++)
+    res += A[i][i];
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 529340000)
+    abort ();
+
+  return 0;
+}
+
+/* PRE destroys the perfect nest and we can't cope with that yet.  */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/graphite/interchange-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-12.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-12.c	(.../branches/gcc-4_9-branch)
@@ -53,5 +53,5 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/graphite/graphite.exp
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/graphite.exp	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/graphite.exp	(.../branches/gcc-4_9-branch)
@@ -41,8 +41,10 @@
 set scop_files        [lsort [glob -nocomplain $srcdir/$subdir/scop-*.c ] ]
 set id_files          [lsort [glob -nocomplain $srcdir/$subdir/id-*.c ] ]
 set run_id_files      [lsort [glob -nocomplain $srcdir/$subdir/run-id-*.c ] ]
-set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.c ] ]
-set block_files       [lsort [glob -nocomplain $srcdir/$subdir/block-*.c ] ]
+set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.c \
+			      $srcdir/$subdir/uns-interchange-*.c ] ]
+set block_files       [lsort [glob -nocomplain $srcdir/$subdir/block-*.c \
+			      $srcdir/$subdir/uns-block-*.c ] ]
 set vect_files        [lsort [glob -nocomplain $srcdir/$subdir/vect-*.c ] ]
 
 # Tests to be compiled.
Index: gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,55 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define NMAX 2000
+
+static unsigned int x[NMAX], a[NMAX][NMAX];
+
+static unsigned int __attribute__((noinline))
+mvt (long N)
+{
+  int i,j;
+
+  /* These two loops should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      x[i] += a[j][i];
+
+  return x[1];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int res;
+
+  for (i = 0; i < NMAX; i++)
+    for (j = 0; j < NMAX; j++)
+      a[i][j] = j;
+
+  for (i = 0; i < NMAX; i++)
+    x[i] = i;
+
+  res = mvt (NMAX);
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 2001)
+    abort ();
+
+  return 0;
+}
+
+/* PRE destroys the perfect nest and we can't cope with that yet.  */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
+
Index: gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,65 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define NMAX 2000
+
+static unsigned int x1[NMAX], x2[NMAX], a[NMAX][NMAX], y1[NMAX], y2[NMAX];
+
+static unsigned int __attribute__((noinline))
+mvt (long N)
+{
+
+  int i,j;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      x1[i] = x1[i] + a[i][j] * y1[j];
+
+  /* These two loops should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      x2[i] = x2[i] + a[j][i] * y2[j];
+
+  return x1[0] + x2[0];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int res;
+
+  for (i = 0; i < NMAX; i++)
+    for (j = 0; j < NMAX; j++)
+      a[i][j] = i + j;
+
+  for (i = 0; i < NMAX; i++)
+    {
+      x1[i] = 0;
+      x2[i] = 2*i;
+      y1[i] = 100 - i;
+      y2[i] = i;
+    }
+
+  res = mvt (NMAX);
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 199900000)
+    abort ();
+
+  return 0;
+}
+
+/* PRE destroys the perfect nest and we can't cope with that yet.  */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
+
Index: gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,58 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define N 200
+
+unsigned int A[N][N], B[N][N], C[N][N];
+
+static unsigned int __attribute__((noinline))
+matmult (void)
+{
+  int i, j, k;
+
+  /* Loops J and K should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	A[i][j] = 0;
+	for (k = 0; k < N; k++)
+	  A[i][j] += B[i][k] * C[k][j];
+      }
+
+  return A[0][0] + A[N-1][N-1];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int res;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	A[i][j] = 0;
+	B[i][j] = i - j;
+	C[i][j] = i + j;
+      }
+
+  res = matmult ();
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 2626800)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/graphite/uns-block-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-block-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-block-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,49 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define MAX 100
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int sum = 0;
+  unsigned int A[MAX * MAX];
+  unsigned int B[MAX * MAX];
+
+  /* These loops should be loop blocked.  */
+  for (i = 0; i < MAX; i++)
+    for (j = 0; j < MAX; j++)
+      {
+	A[i*MAX + j] = j;
+	B[i*MAX + j] = j;
+      }
+
+  /* These loops should be loop blocked.  */
+  for (i = 0; i < MAX; i++)
+    for (j = 0; j < MAX; j++)
+      A[i*MAX + j] += B[j*MAX + i];
+
+  /* These loops should be loop blocked.  */
+  for (i = 0; i < MAX; i++)
+    for (j = 0; j < MAX; j++)
+      sum += A[i*MAX + j];
+
+#if DEBUG
+  fprintf (stderr, "sum = %d \n", sum);
+#endif
+
+  if (sum != 990000)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/graphite/interchange-mvt.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c	(.../branches/gcc-4_9-branch)
@@ -59,6 +59,6 @@
 }
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
 
Index: gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,49 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define N 111
+#define M 111
+
+static unsigned int __attribute__((noinline))
+foo (unsigned int *x)
+{
+  int i, j;
+  unsigned int sum = 0;
+
+  for (j = 0; j < M; ++j)
+    for (i = 0;  i < N; ++i)
+      sum += x[M * i + j];
+
+  return sum;
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  unsigned int A[N*M];
+  int i;
+  unsigned int res;
+
+  for (i = 0; i < N*M; i++)
+    A[i] = 2;
+
+  res = foo (A);
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 24642)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/graphite/interchange-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-14.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-14.c	(.../branches/gcc-4_9-branch)
@@ -55,5 +55,5 @@
 }
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/graphite/interchange-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/interchange-9.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/interchange-9.c	(.../branches/gcc-4_9-branch)
@@ -44,5 +44,5 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/graphite/block-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/graphite/block-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/graphite/block-1.c	(.../branches/gcc-4_9-branch)
@@ -45,5 +45,5 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
Index: gcc/testsuite/gcc.dg/pr69015.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr69015.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr69015.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR target/69015 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-if-conversion" } */
+
+void
+foo (int c)
+{
+  if (c)
+    __builtin_trap ();
+}
Index: gcc/testsuite/gcc.dg/autopar/pr69110.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/autopar/pr69110.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/autopar/pr69110.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -ftree-parallelize-loops=2 -fno-tree-loop-im -fdump-tree-parloops-details" } */
+
+#define N 1000
+
+unsigned int i = 0;
+
+void
+foo (void)
+{
+  unsigned int z;
+  for (z = 0; z < N; ++z)
+    ++i;
+}
+
+/* { dg-final { scan-tree-dump-times "SUCCESS: may be parallelized" 0 "parloops" } } */
+/* { dg-final { scan-tree-dump-times "FAILED: data dependencies exist across iterations" 1 "parloops" } } */
Index: gcc/testsuite/gcc.dg/pr70161-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr70161-2.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr70161-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-ipa-all-graph -fipa-pta" } */
+
+void
+foo (void)
+{
+}
Index: gcc/testsuite/gcc.dg/lto/simd-function_0.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/simd-function_0.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/simd-function_0.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* { dg-lto-do link } */
+/* { dg-require-effective-target avx2 } */
+/* { dg-lto-options { { -fopenmp-simd -O3 -ffast-math -mavx2 -flto -flto-partition=max } } } */
+
+#define SIZE 4096
+float x[SIZE];
+
+
+#pragma omp declare simd
+float
+__attribute__ ((noinline))
+my_mul (float x, float y) {
+  return x * y;
+}
+
+__attribute__ ((noinline))
+int foo ()
+{
+  int i = 0;
+#pragma omp simd safelen (16)
+  for (i = 0; i < SIZE; i++)
+    x[i] = my_mul ((float)i, 9932.3323);
+  return (int)x[0];
+}
+
+int main ()
+{
+  int i = 0;
+  for (i = 0; i < SIZE; i++)
+    x[i] = my_mul ((float) i, 9932.3323);
+  foo ();
+  return (int)x[0];
+}
+
Index: gcc/testsuite/gcc.dg/lto/pr55113_0.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr55113_0.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr55113_0.c	(.../branches/gcc-4_9-branch)
@@ -1,8 +1,7 @@
 /* PR 55113 */
 /* { dg-lto-do link } */
 /* { dg-lto-options { { -flto -fshort-double -O0 } } }*/
-/* { dg-skip-if "PR60410" { x86_64-*-* || { i?86-*-* && lp64 } } } */
-/* { dg-skip-if "PR60410" { i?86-*-solaris2.1[0-9]* } } */
+/* { dg-skip-if "PR60410" { i?86-*-* x86_64-*-* } } */
 
 int 
 main(void)
Index: gcc/testsuite/gcc.dg/torture/pr68648.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68648.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68648.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+/* { dg-options "-std=gnu99" } */
+
+int __attribute__ ((noinline))
+foo (void)
+{
+  return 123;
+}
+
+int __attribute__ ((noinline))
+bar (void)
+{
+  int c = 1;
+  c |= 4294967295 ^ (foo () | 4073709551608);
+  return c;
+}
+
+int
+main ()
+{
+  if (bar () != 0x83fd4005)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.dg/torture/pr66794.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr66794.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr66794.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-w" } */
+
+int a, *b, e;
+static int **c = &b;
+
+struct
+{
+  int f0;
+} d;
+
+int *
+fn1 ()
+{
+  int f, **g = &b;
+  e = a;
+  for (; a;)
+    for (; d.f0; d.f0++)
+      ;
+  *g = &f;
+  return *c;
+}
Index: gcc/testsuite/gcc.dg/torture/pr69574.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr69574.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr69574.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+typedef unsigned mytype;
+
+struct S {
+    mytype *pu;
+};
+
+mytype f(struct S *e)
+{
+  mytype x;
+  if(&x != e->pu)
+    __builtin_memcpy(&x, e->pu, sizeof(unsigned));
+  return x;
+}
Index: gcc/testsuite/gcc.dg/torture/pr69941.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr69941.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr69941.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+ 
+int a = 0;
+int b = 0;
+int c = 0;
+int e = 0;
+int f = 0;
+int *g = &e;
+ 
+int fn1() { return b ? a : b; }
+ 
+int main() {
+  int h = fn1() <= 0x8000000000000000ULL; // h = 1;
+ 
+  int k = f; // k = 0;
+ 
+  long i = h ? k : k / h; // i = 0;
+ 
+  long l = (unsigned short)(i - 0x1800); // l = 0xe800
+ 
+  i = l ? l : c; // i = 0xe800;
+ 
+  *g = i; // *g = 0xe800; e = 0xe800;
+ 
+  unsigned char result = e >> 9; // result = 0x74;
+
+  if ((int)result != 0x74)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr67794.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr67794.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr67794.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+int *b;
+static void fn1(int *best, int *dmin) {
+  int a[64];
+  dmin = a;
+  __asm__ volatile("" : "+&r"(dmin) : ""(best));
+}
+
+__attribute__((always_inline)) static inline void fn2(int *best) { fn1(best, b); }
+
+void fn3(void) {
+  int c[1];
+  fn2(c);
+}
Index: gcc/testsuite/gcc.dg/torture/pr68955.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr68955.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr68955.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,41 @@
+/* PR rtl-optimization/68955 */
+/* { dg-do run } */
+/* { dg-output "ONE1ONE" } */
+
+int a, b, c, d, g, m;
+int i[7][7][5] = { { { 5 } }, { { 5 } },
+		   { { 5 }, { 5 }, { 5 }, { 5 }, { 5 }, { -1 } } };
+static int j = 11;
+short e, f, h, k, l;
+
+static void
+foo ()
+{
+  for (; e < 5; e++)
+    for (h = 3; h; h--)
+      {
+	for (g = 1; g < 6; g++)
+	  {
+	    m = c == 0 ? b : b / c;
+	    i[e][1][e] = i[1][1][1] | (m & l) && f;
+	  }
+	for (k = 0; k < 6; k++)
+	  {
+	    for (d = 0; d < 6; d++)
+	      i[1][e][h] = i[h][k][e] >= l;
+	    i[e + 2][h + 3][e] = 6 & l;
+	    i[2][1][2] = a;
+	    for (; j < 5;)
+	      for (;;)
+		;
+	  }
+      }
+}
+
+int
+main ()
+{
+  foo ();
+  __builtin_printf ("ONE%dONE\n", i[1][0][2]);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr66375.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr66375.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr66375.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* { dg-do run } */
+
+int a;
+extern void abort (void);
+int main ()
+{
+  int c = 0;
+  for (; a < 13; ++a)
+    c = (signed char)c - 11;
+  if (c != 113)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr67609.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr67609.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr67609.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+typedef union
+{
+  double v[2];
+  double s __attribute__ ((vector_size (16)));
+} data;
+
+data reg;
+
+void __attribute__ ((noinline))
+set_lower (double b)
+{
+  data stack_var;
+  double __attribute__ ((vector_size (16))) one = { 1.0, 1.0 };
+  stack_var.s = reg.s;
+  stack_var.s += one;
+  stack_var.v[0] += b;
+  reg.s = stack_var.s;
+}
+
+int
+main (int argc, char ** argv)
+{
+  reg.v[0] = 1.0;
+  reg.v[1] = 1.0;
+  /* reg should contain { 1.0, 1.0 }.  */
+  set_lower (2.0);
+  /* reg should contain { 4.0, 2.0 }.  */
+  if ((int) reg.v[0] != 4 || (int) reg.v[1] != 2)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr29119.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr29119.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr29119.c	(.../branches/gcc-4_9-branch)
@@ -2,6 +2,5 @@
 
 void ldt_add_entry(void)
 {
-   __asm__ ("" :: "m"(({unsigned __v; __v;})));
+   __asm__ ("" :: "m"(({unsigned __v; __v;})));	/* { dg-warning "memory input 0 is not directly addressable" } */
 }
-
Index: gcc/testsuite/gcc.dg/torture/pr64882.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr64882.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr64882.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* PR target/64882 */
+/* { dg-do compile } */
+
+int a, d, e;
+long long b;
+static long long *c = &b;
+
+void
+fn1 (short p)
+{
+}
+
+long long
+fn2 (long long p1, long long p2)
+{
+  return (p1 && p1 > 26854775807LL - p2) || p1 < -p2 ? p1 : p1 + p2;
+}
+
+void
+fn3 ()
+{
+  long long f;
+  int g = 3;
+  int *h = &a;
+  for (e = 0; e < 2; e++)
+    {
+      int *i = &g;
+      if (!fn2 (*c, 7 < d % (*i)--))
+	f = fn2 ((*h <= 0) | b, 5278350700LL);
+      *h = f;
+      fn1 (*h);
+    }
+}
Index: gcc/testsuite/gcc.dg/torture/pr67619.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr67619.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr67619.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target builtin_eh_return } */
+
+void
+foo ()
+{
+  unsigned long l;
+  void *p = 0; 
+
+  __builtin_unwind_init ();
+  l = 0; 
+  __builtin_eh_return (l, p);
+}
Index: gcc/testsuite/gcc.dg/torture/pr64091.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr64091.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr64091.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-g" } */
+
+extern int foo(void);
+
+int main(void)
+{
+  int i, a, b;
+
+  if (foo())
+    return 0;
+
+  for (i = 0, a = 0, b = 0; i < 3; i++, a++)
+  {
+    if (foo())
+      break;
+
+    if (b += a)
+      a = 0;
+  }
+
+  if (!a)
+    return 2;
+
+  b += a;
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr70457.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr70457.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr70457.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+
+/* This formerly ICEd when trying to expand pow as a built-in with
+   the wrong number of arguments.  */
+
+extern double pow (double, double) __attribute__ ((__nothrow__ , __leaf__));
+
+typedef struct {
+  long long data;
+  int tag;
+} Object;
+
+extern Object Make_Flonum (double);
+extern Object P_Pow (Object, Object);
+
+Object General_Function (Object x, Object y, double (*fun)()) {
+  double d, ret;
+
+  d = 1.0;
+
+  if (y.tag >> 1)
+    ret = (*fun) (d);
+  else
+    ret = (*fun) (d, 0.0);
+
+  return Make_Flonum (ret);
+}
+
+Object P_Pow (Object x, Object y) { return General_Function (x, y, pow); }
Index: gcc/testsuite/gcc.dg/torture/pr69715.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr69715.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr69715.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+
+struct __attribute__((may_alias)) S { long long low; int high; };
+struct S foo (void);
+long double
+bar (void)
+{
+  long double a;
+  *(struct S *)&a = foo ();
+  return a;
+}
Index: gcc/testsuite/gcc.dg/torture/pr66413.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr66413.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr66413.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,61 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-g" } */
+
+int a, b, c, d, i, j, q, *e, *h, *k, *r, **p = &e;
+const int *f, **n = &f;
+static int g;
+
+void
+fn1 (int p1)
+{
+  c = p1;
+}
+
+static int *
+fn2 (int *p1, const int *p2)
+{
+  if (g)
+    n = &p2;
+  *n = p2;
+  int o[245];
+  fn1 (o != p2);
+  return p1;
+}
+
+static int *
+fn3 ()
+{
+  int s[54], *t = &s[0], u = 0, v = 1;
+  h = &v;
+  q = 1;
+  for (; q; q++)
+    {
+      int *w[] = { &u };
+      for (; v;)
+	return *p;
+    }
+  *r = *t + b >= 0;
+  return *p;
+}
+
+static int
+fn4 (int *p1)
+{
+  int *l[2], **m[7];
+  for (; i < 1; i++)
+    for (; j < 1; j++)
+      m[i * 70] = &l[0];
+  k = fn3 ();
+  fn2 (0, p1);
+  if ((m[0] == 0) & a)
+    for (;;)
+      ;
+  return 0;
+}
+
+int
+main ()
+{
+  fn4 (&d);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr69644.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr69644.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr69644.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* PR target/69644 */
+/* { dg-do compile } */
+
+int
+main ()
+{
+  unsigned short x = 0x8000;
+  if (!__sync_bool_compare_and_swap (&x, 0x8000, 0) || x)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/cunroll-11.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-11.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/cunroll-11.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -Warray-bounds -fdump-tree-cunroll-details" } */
+
+typedef struct { unsigned data; } s1;
+s1 g_x[4];
+
+extern void foo (s1 *x1, s1 *x2, int a, int b)
+{
+  int i;
+  for(i = 0; i < a; i++)
+    if(i == b)
+      g_x[i] = *x1;
+    else
+      g_x[i] = *x2;
+}
+
+/* { dg-final { scan-tree-dump "Loop 1 iterates at most 3 times" "cunroll" } } */
+/* { dg-final { cleanup-tree-dump "cunroll" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/pr69355.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr69355.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr69355.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,44 @@
+/* { dg-do run } */
+/* { dg-options "-O -fno-strict-aliasing" } */
+
+struct S
+{
+  void *a;
+  long double b;
+};
+
+struct Z
+{
+  long long l;
+  short s;
+} __attribute__((packed));
+
+struct S __attribute__((noclone, noinline))
+foo (void *v, struct Z *z)
+{
+  struct S t;
+  t.a = v;
+  *(struct Z *) &t.b = *z;
+  return t;
+}
+
+struct Z gz;
+
+int
+main (int argc, char **argv)
+{
+  struct S s;
+
+  if (sizeof (long double) < sizeof (struct Z))
+    return 0;
+
+  gz.l = 0xbeef;
+  gz.s = 0xab;
+
+  s = foo ((void *) 0, &gz);
+
+  if ((((struct Z *) &s.b)->l != gz.l)
+      || (((struct Z *) &s.b)->s != gz.s))
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr68670-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr68670-1.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr68670-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/68670 */
+/* { dg-do run } */
+/* { dg-options "-O2 -ftracer" } */
+
+#include "../gcc.c-torture/execute/pr68376-1.c"
Index: gcc/testsuite/gcc.dg/pr70161.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr70161.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr70161.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-ipa-all-graph" } */
+
+void
+foo (void)
+{
+}
Index: gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fipa-sra -fdump-tree-eipa_sra-details"  } */
+
+extern void consume (int);
+extern int glob, glob1, glob2;
+extern int get (void);
+
+
+static void __attribute__ ((noinline))
+foo (int a)
+{
+  a = glob;
+  consume (a);
+  a = get ();
+  consume (a);
+  __asm__ volatile("" : : ""(a));
+  consume (a);
+
+  if (glob1)
+    a = glob1;
+  else
+    a = glob2;
+  consume (a);
+}
+
+int
+bar (int a)
+{
+  foo (a);
+  glob = a;
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "replacing an SSA name of a removed param" 4 "eipa_sra" } } */
Index: gcc/testsuite/gcc.dg/pr69238.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr69238.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr69238.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-dce -fno-forward-propagate -fno-rerun-cse-after-loop -funroll-loops" } */
+
+
+#define N 32
+
+short sa[N];
+short sb[N];
+int ia[N];
+int ib[N];
+
+int __attribute__ ((noinline, noclone))
+main1 (int n)
+{
+  int i;
+  for (i = 0; i < n; i++)
+    {
+      sa[i+7] = sb[i];
+      ia[i+3] = ib[i+1];
+    }
+  return 0;
+}
+
+int
+main (void)
+{ 
+  return main1 (N-7);
+}
Index: gcc/testsuite/gcc.dg/pr67028.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr67028.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr67028.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+short c = 0;
+
+int __attribute__ ((noinline)) f(void)
+{
+	int d = 5;
+	signed char e = (c != 1) * -2;
+	int a = (unsigned short)e > d;
+
+	return a;
+}
+
+int main(void)
+{
+	if (!f())
+		__builtin_abort();
+
+	return 0;
+}
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,786 @@
+2016-04-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-04-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/70566
+	* gcc.c-torture/execute/pr70566.c: New test.
+
+2016-04-13  Alan Modra  <amodra@gmail.com>
+
+	Backport from mainline
+	2016-03-31  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+	* g++.dg/template/ptrmem30.C (read): Rename to data_read.
+	(Holder::foo): Reflect this.
+
+	2016-03-22  Patrick Palka  <ppalka@gcc.gnu.org>
+	PR c++/70096
+	* g++.dg/template/ptrmem30.C: New test.
+
+2016-04-11  Alan Modra  <amodra@gmail.com>
+
+	* gcc.target/powerpc/pr70117.c: New.
+
+2016-04-05  Dominique d'Humieres  <dominiq@lps.ens.fr>
+	    Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	* gfortran.dg/fmt_pf.f90: New test.
+
+2016-04-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+	    Jakub Jelinek <jakub@redhat.com>
+
+	PR middle-end/70457
+	* gcc.dg/torture/pr70457.c: New.
+
+2016-03-31  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/arm/atomic_loaddi_relaxed_cond.c: New test.
+
+2016-03-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/70460
+	* gcc.c-torture/execute/pr70460.c: New test.
+
+2016-02-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69875
+	* gcc.target/arm/atomic_loaddi_acquire.x: New file.
+	* gcc.target/arm/atomic_loaddi_relaxed.x: Likewise.
+	* gcc.target/arm/atomic_loaddi_seq_cst.x: Likewise.
+	* gcc.target/arm/atomic_loaddi_1.c: New test.
+	* gcc.target/arm/atomic_loaddi_2.c: Likewise.
+	* gcc.target/arm/atomic_loaddi_3.c: Likewise.
+	* gcc.target/arm/atomic_loaddi_4.c: Likewise.
+	* gcc.target/arm/atomic_loaddi_5.c: Likewise.
+	* gcc.target/arm/atomic_loaddi_6.c: Likewise.
+	* gcc.target/arm/atomic_loaddi_7.c: Likewise.
+	* gcc.target/arm/atomic_loaddi_8.c: Likewise.
+	* gcc.target/arm/atomic_loaddi_9.c: Likewise.
+
+2016-03-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-03-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* lib/target-supports.exp: Remove v7ve entry from loop
+	creating effective target checks.
+	(check_effective_target_arm_arch_v7ve_ok): New procedure.
+	(add_options_for_arm_arch_v7ve): Likewise.
+
+2016-03-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/70327
+	* gcc.target/i386/pr70327.c: New test.
+
+2016-03-21  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2016-03-18  Tom de Vries  <tom@codesourcery.com>
+
+	* gcc.dg/pr70161-2.c: New test.
+	* gcc.dg/pr70161.c: New test.
+
+2016-03-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2014-12-19  Kai Tietz  <ktietz@redhat.com>
+		    Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/61198
+	* g++.dg/cpp0x/alias-decl-45.C: New file.
+
+2016-03-15  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-03-04  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR rtl-optimization/69941
+	* gcc.dg/torture/pr69941.c: New test.
+
+2016-03-14  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR fortran/45076
+	gfortran.dg/prof/prof.exp: New script.
+	gfortran.dg/prof/dynamic_dispatch_6.f03: New test.
+
+2016-03-10  Alan Modra  <amodra@gmail.com>
+
+	* gcc.dg/pr69195.c: New.
+	* gcc.dg/pr69238.c: New.
+
+2016-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/70059
+	* gcc.target/i386/avx512f-pr70059.c: New test.
+
+2016-03-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/gcc-gdb-test.exp (gdb-test): Make log message match command.
+	Invoke gdb with -batch.
+	* lib/gcc-simulate-thread.exp (simulate-thread): Likewise.
+
+2016-03-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/i386/pr70007.c: New test.
+
+2016-02-29  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/60126
+	* gfortran.dg/pr60126.f90: New test.
+
+2016-02-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/61156
+	* gfortran.dg/include_6.f90: Update test.
+
+2016-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from gcc-5-branch.
+	PR libgfortran/69668
+	* gfortran.dg/namelist_38.f90: Update test.
+	* gfortran.dg/namelist_84.f90: Update test.
+
+2016-02-18  Marek Polacek  <polacek@redhat.com>
+
+	2016-02-12  Marek Polacek  <polacek@redhat.com>
+	Backport from mainline
+
+	* gcc.dg/pr69522.c: Add empty dg-options.
+
+2016-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2012-02-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/vec-cg.c: New test.
+
+2016-02-17  Bernd Schmidt  <bschmidt@redhat.com>
+
+	Backport from mainline
+	2016-02-12  Bernd Schmidt  <bschmidt@redhat.com>
+
+	PR c/69522
+	* gcc.dg/pr69522.c: New test.
+
+2016-02-16  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>
+
+	* gcc.dg/lto/simd-function_0.c: New test.
+
+2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2016-02-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/67260
+	* gcc.target/sh/torture/pr67260.c: New.
+
+2016-02-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2016-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69715
+	* gcc.dg/torture/pr69715.c: New testcase.
+
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69579
+	* gcc.dg/setjmp-6.c: New testcase.
+
+	2016-02-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/69574
+	* gcc.dg/torture/pr69574.c: New testcase.
+
+2016-02-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62217
+	* gcc.dg/tree-ssa/cunroll-11.c: New testcase.
+
+	2015-06-18  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-06-03  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/66375
+	* gcc.dg/torture/pr66375.c: New testcase.
+
+	2015-06-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-06-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/66413
+	* gcc.dg/torture/pr66413.c: New testcase.
+
+	2015-07-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/66794
+	* gcc.dg/torture/pr66794.c: New testcase.
+
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/59627
+	* g++.dg/gomp/pr59627.C: New test.
+
+	2016-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69432
+	* g++.dg/opt/pr69432.C: New test.
+
+	2016-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/67653
+	* c-c++-common/pr67653.c: New test.
+	* gcc.dg/torture/pr29119.c: Add dg-warning.
+
+	2016-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/68955
+	PR rtl-optimization/64557
+	* gcc.dg/torture/pr68955.c: New test.
+
+	2016-01-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/69214
+	* gcc.c-torture/compile/pr69214.c: New test.
+
+	2016-01-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/69128
+	* gfortran.dg/gomp/pr69128.f90: New test.
+
+	2016-01-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69015
+	* gcc.dg/pr69015.c: New test.
+
+	2015-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/68376
+	PR rtl-optimization/68670
+	* gcc.c-torture/execute/pr68376-2.c (f5, f6, f7, f8): New
+	tests.
+	(main): Call them.
+	* gcc.dg/pr68670-1.c: New test.
+	* gcc.dg/pr68670-2.c: New test.
+
+	PR rtl-optimization/68376
+	* gcc.c-torture/execute/pr68376-1.c: New test.
+	* gcc.c-torture/execute/pr68376-2.c: New test.
+
+	2015-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/68680
+	* gcc.target/i386/pr68680.c: New test.
+
+	2015-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/57580
+	* c-c++-common/cpp/pr57580.c: New test.
+	* c-c++-common/gomp/pr57580.c: New test.
+
+	2015-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/66432
+	* gcc.dg/debug/pr66432.c: New test.
+
+	2015-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/67770
+	* gcc.target/i386/pr67770.c: New test.
+
+2016-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69644
+	* gcc.dg/pr69644.c: New test.
+
+2016-02-02  Alan Modra  <amodra@gmail.com>
+
+	PR target/69548
+	* gcc.target/powerpc/pr69548.c: New test.
+
+2016-01-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/69355
+	* gcc.dg/tree-ssa/pr69355.c: New test.
+
+2016-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2016-01-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/69551
+	* gcc.target/i386/pr69551.c: New test.
+
+2016-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/69459
+	* gcc.target/i386/pr69459.c: New test.
+
+2016-01-27  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.dg/and-1.c: Remove nand test for powerpc*-*-*.
+
+2016-01-27  Tom de Vries  <tom@codesourcery.com>
+
+	* gcc.dg/autopar/pr69110.c: Fix pass number.
+
+2016-01-26  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/69110
+	* gcc.dg/autopar/pr69110.c: New test.
+
+2016-01-25  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	PR tree-optimization/PR64091
+	2014-11-27  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/torture/pr64091.c: New testcase.
+
+2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2016-01-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/69403
+	* gcc.c-torture/execute/pr69403.c: New test.
+
+2016-01-21  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backported from mainline
+	2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/gpr2fprsavecfi.c: New test.
+
+2016-01-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-09-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/67439
+	* gcc.target/arm/pr67439_1.c: New test.
+
+2016-01-19  Sergei Trofimovich <siarheit@google.com>
+
+	Backport from mainline
+	PR other/60465
+	* gcc.target/ia64/pr60465-gprel64.c: New test.
+	* gcc.target/ia64/pr60465-gprel64-c37.c: New test.
+
+2016-01-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR testsuite/68820
+	* gcc.c-torture/execute/builtins/memops-asm.x: New file.
+	* gcc.c-torture/execute/builtins/strstr-asm.x: Ditto.
+	* gcc.c-torture/execute/builtins/strstr-asm.c: Remove dg-options.
+
+2016-01-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/68648
+	* gcc.dg/torture/pr68648.c: New test.
+
+2016-01-12  Jeff Law  <law@redhat.com>
+
+	PR target/63347
+	* gcc.target/m68k/pr63347.c: New test.
+
+2016-01-12  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from mainline.
+	2015-12-09  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	PR rtl-optimization/67609
+	* gcc.dg/torture/pr67609.c: New.
+
+2016-01-11  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/66616
+	* g++.dg/ipa/pr66616.C: New test.
+
+2016-01-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2015-12-15  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/68851
+	* g++.dg/ipa/pr68851.C: New test.
+
+2015-12-22  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	PR target/68872
+	* gcc.target/powerpc/pr68872.c: New test.
+
+2015-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-12-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/68701
+	* gcc.target/i386/pr68701-1.c: New test.
+	* gcc.target/i386/pr68701-2.c: Ditto.
+
+2015-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/sse4_1-roundps-1.c: Remove ASM_SUFFIX define.
+	* gcc.target/i386/sse4_1-roundps-2.c: Ditto.
+	* gcc.target/i386/sse4_1-roundps-3.c: Ditto.
+	* gcc.target/i386/sse4_1-roundsd-1.c: Ditto.
+	* gcc.target/i386/sse4_1-roundsd-2.c: Ditto.
+	* gcc.target/i386/sse4_1-roundsd-3.c: Ditto.
+	* gcc.target/i386/sse4_1-roundss-1.c: Ditto.
+	* gcc.target/i386/sse4_1-roundss-2.c: Ditto.
+	* gcc.target/i386/sse4_1-roundss-3.c: Ditto.
+
+2015-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/sse4_1-round.h (do_round): Fix inline asm statements.
+	* gcc.target/i386/sse4_1-roundsd-4.c (do_round): Ditto.
+	* gcc.target/i386/sse4_1-roundss-4.c (do_round): Ditto.
+
+2015-12-08  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>
+
+	Backport from mainline.
+	2015-03-16  Max Ostapenko  <m.ostapenko@partner.samsung.com>
+
+	PR sanitizer/64820
+	* c-c++-common/asan/pr64820.c: New test.
+
+2015-11-27  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/68218
+	* gfortran.dg/allocate_with_arrayspec_1.f90: New test.
+
+2015-11-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-11-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR rtl-optimization/67226
+	* gcc.c-torture/execute/pr67226.c: New test.
+
+2015-11-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/68196
+	* gfortran.dg/proc_ptr_47.f90: New test.
+
+	Backport from trunk.
+	PR fortran/66465
+	* gfortran.dg/pr66465.f90: New test.
+
+2015-11-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-11-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR rtl-optimization/68194
+	PR rtl-optimization/68328
+	PR rtl-optimization/68185
+	* gcc.c-torture/execute/pr68185.c: New test.
+	* gcc.c-torture/execute/pr68328.c: Likewise.
+
+2015-11-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-11-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/68363
+	* gcc.target/aarch64/pr68363_1.c: New test.
+
+2015-11-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/i386/pr67265-2.c: New test.
+
+2015-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/i386/pr67265.c: New test.
+
+2015-11-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/sparc-ret.c: Rename to...
+	* gcc.target/sparc/sparc-ret-1.c: ...this.
+	* gcc.target/sparc/sparc-ret-2.c: New test.
+
+2015-11-02  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2015-10-09  Martin Jambor  <mjambor@suse.cz>
+
+	* gcc.dg/ipa/ipa-sra-10.c: New test.
+	* gcc.dg/torture/pr67794.c: Likewise.
+
+2015-10-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/58754
+	* gfortran.dg/pr58754.f90: New test
+
+2015-11-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/67929
+	* gcc.target/arm/pr67929_1.c: Move to...
+	* gcc.c-torture/execute/pr67929_1.c: ... Here.
+	Remove arm-specific directives.  Add noclone, noinline
+	attributes.
+
+2015-10-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-10-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR middle-end/67989
+	* g++.dg/pr67989.C: New test.
+
+2015-10-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/67929
+	* gcc.target/arm/pr67929_1.c: New test.
+
+2013-10-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56852
+	* gfortran.dg/pr56852.f90 : New test
+
+2015-10-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/66385
+	* gfortran.dg/forall_17.f90:  New test.
+
+2015-10-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.dg/lto/pr55113_0.c: Skip on all x86 targets.
+
+2015-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-06-09  Shiva Chen  <shiva0217@gmail.com>
+
+	* gcc.target/arm/stl-cond.c: New test.
+
+2015-09-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/67619
+	* gcc.dg/torture/pr67619.c: New test.
+	* lib/target-supports.exp (check_effective_target_builtin_eh_return):
+	New procedure.
+
+2015-08-27  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline:
+	2015-08-27  Pat Haugen  <pthaugen@us.ibm.com>
+
+	* gcc.target/powerpc/vec-shr.c: New.
+
+2015-08-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2015-08-24  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/67211
+	* g++.dg/pr67211.C: New test.
+
+2015-08-18  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline:
+	2015-08-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/67028
+	* gcc.dg/pr67028.c: New testcase.
+
+2015-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66648
+	* gcc.target/i386/pr66648.c: New test.
+
+2015-08-07  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/66929
+	* gfortran.dg/generic_30.f90: New.
+	* gfortran.dg/generic_31.f90: New.
+
+2015-08-05  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/64921
+	* gfortran.dg/class_allocate_20.f90: New.
+
+2015-08-04  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline r225450:
+	2015-07-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/66731
+	* gcc.target/aarch64/fnmul-1.c: New.
+	* gcc.target/aarch64/fnmul-2.c: New.
+	* gcc.target/aarch64/fnmul-3.c: New.
+	* gcc.target/aarch64/fnmul-4.c: New.
+
+2015-08-03  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline:
+	2015-08-03  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* gcc.target/powerpc/htm-tabort-no-r0.c: New test.
+
+2015-08-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport form mainline r226496.
+	2015-08-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/66731
+	* gcc.target/arm/vnmul-1.c: New.
+	* gcc.target/arm/vnmul-2.c: New.
+	* gcc.target/arm/vnmul-3.c: New.
+	* gcc.target/arm/vnmul-4.c: New.
+
+2015-07-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66891
+	* gcc.target/i386/pr66891.c: New test.
+
+	2014-05-18  Wei Mi  <wmi@google.com>
+
+	PR target/58066
+	* gcc.target/i386/pr58066.c: Replace pattern matching of .cfi
+	directive with rtl insns. Add effective-target fpic and
+	tls_native.
+
+	2014-05-08  Wei Mi  <wmi@google.com>
+
+	PR target/58066
+	* gcc.target/i386/pr58066.c: New test.
+
+2015-07-25  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2015-07-25  Tom de Vries  <tom@codesourcery.com>
+
+	* gcc.dg/graphite/graphite.exp: Include uns-*.c files in
+	interchange_files and block_files variables.
+	* gcc.dg/graphite/uns-block-1.c (main): Change signed into unsigned
+	arithmetic.
+	* gcc.dg/graphite/uns-interchange-12.c: Same.
+	* gcc.dg/graphite/uns-interchange-14.c: Same.
+	* gcc.dg/graphite/uns-interchange-15.c: Same.
+	* gcc.dg/graphite/uns-interchange-9.c (foo): Same.
+	* gcc.dg/graphite/uns-interchange-mvt.c: Same.
+
+	2015-07-24  Tom de Vries  <tom@codesourcery.com>
+
+	* gcc.dg/graphite/block-1.c: Xfail scan.
+	* gcc.dg/graphite/interchange-12.c: Same.
+	* gcc.dg/graphite/interchange-14.c: Same.
+	* gcc.dg/graphite/interchange-15.c: Same.
+	* gcc.dg/graphite/interchange-9.c: Same.
+	* gcc.dg/graphite/interchange-mvt.c: Same.
+	* gcc.dg/graphite/uns-block-1.c: New test.
+	* gcc.dg/graphite/uns-interchange-12.c: New test.
+	* gcc.dg/graphite/uns-interchange-14.c: New test.
+	* gcc.dg/graphite/uns-interchange-15.c: New test.
+	* gcc.dg/graphite/uns-interchange-9.c: New test.
+	* gcc.dg/graphite/uns-interchange-mvt.c: New test.
+
+2015-07-21  Mantas Mikaitis  <mantas.mikaitis@arm.com>
+
+	* gcc.target/arm/macro_defs0.c: Add directive to skip
+	test if -marm is present.
+	* gcc.target/arm/macro_defs1.c: Likewise.
+
+2015-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66922
+	* gcc.target/i386/pr66922.c: New test.
+
+2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66866
+	* g++.dg/pr66866.C: New test.
+
+2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66703
+	* gcc.target/i386/readeflags-1.c (readeflags_test): Declare with
+	__attribute__((noinline, noclone)).  Change "x" to "volatile char"
+	type to prevent possible flag-clobbering zero-extensions.
+	* gcc.target/i386/pr66703.c: New test.
+
+2015-07-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2015-07-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66814
+	* gcc.target/i386/pr66814.c: New test.
+
+2015-07-16  Marek Polacek  <polacek@redhat.com>
+
+	2015-07-08  Marek Polacek  <polacek@redhat.com>
+	Backported from mainline
+
+	PR c++/66748
+	* g++.dg/abi/abi-tag15.C: New test.
+
+2015-07-10  Mantas Mikaitis  <Mantas.Mikaitis@arm.com>
+
+	* gcc.target/arm/macro_defs0.c: New test.
+	* gcc.target/arm/macro_defs1.c: New test.
+	* gcc.target/arm/macro_defs2.c: New test.
+
+2015-07-08  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61820
+	Backport from mainline r212915
+	2014-07-22  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/61160
+	* g++.dg/ipa/pr61160-3.C (main): Return zero.
+
+2015-07-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline r224725
+	2015-06-22  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/65914
+	* g++.dg/torture/pr65914.C:  New.
+
+2015-07-01  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline
+	2015-06-24  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/63408
+	* gcc.target/arm/pr63408.c: New test.
+
+2015-06-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/66412
+	* gcc.target/i386/pr66412.c: New test.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: gcc/testsuite/g++.dg/rtti/typeid11.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/rtti/typeid11.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/rtti/typeid11.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+// { dg-do run }
+
+#include <typeinfo>
+
+struct Base { virtual void foo() {} }; // polymorphic
+
+int main()
+{
+  Base b;
+  Base *ary[] = { &b, &b, &b};
+
+  int iter = 0;
+  typeid(*ary[iter++]);
+  if (iter != 1)	// should be 1
+    __builtin_abort();	// but 2
+}
Index: gcc/testsuite/g++.dg/opt/pr69432.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr69432.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr69432.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,62 @@
+// PR target/69432
+// { dg-do compile }
+// { dg-options "-O3" }
+// { dg-additional-options "-minline-stringops-dynamically" { target i?86-*-* x86_64-*-* } }
+
+template <typename S, typename T, typename U>
+void
+f1 (S x, T y, U z)
+{
+  for (; y; --y, ++x)
+    *x = z;
+}
+
+template <typename S, typename T, typename U>
+void f2 (S x, T y, U z)
+{
+  f1 (x, y, z);
+}
+
+struct A {};
+struct B { static char f3 (A, unsigned); };
+
+template <typename S, typename U>
+void f4 (S, U);
+
+struct C
+{
+  template <typename S, typename T, typename U>
+  static S f5 (S x, T y, U z) { f2 (x, y, z); }
+};
+
+template <typename S, typename T, typename U>
+void f6 (S x, T y, U z) { C::f5 (x, y, z); }
+
+template <typename S, typename T, typename U, typename V>
+void f7 (S x, T y, U z, V) { f6 (x, y, z); }
+
+struct E
+{
+  struct D : A { char e; D (A); };
+  A f;
+  E (int x) : g(f) { f8 (x); }
+  ~E ();
+  D g;
+  void f9 (int x) { x ? B::f3 (g, x) : char (); }
+  void f8 (int x) { f9 (x); }
+};
+
+struct F : E
+{
+  F (int x) : E(x) { f10 (x); f4 (this, 0); }
+  char h;
+  void f10 (int x) { f7 (&g.e, x, h, 0); }
+};
+
+long a;
+
+void
+test ()
+{
+  F b(a);
+}
Index: gcc/testsuite/g++.dg/pr67211.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr67211.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/pr67211.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-mcpu=power7 -mtune=power8 -O3 -w" } */
+
+/* target/67211, compiler got a 'insn does not satisfy its constraints' error.  */
+
+template <typename _InputIterator, typename _ForwardIterator>
+void find_first_of(_InputIterator, _InputIterator, _ForwardIterator p3,
+                   _ForwardIterator p4) {
+  for (; p3 != p4; ++p3)
+    ;
+}
+
+template <typename, typename, typename> struct A {
+  int _S_buffer_size;
+  int *_M_cur;
+  int *_M_first;
+  int *_M_last;
+  int **_M_node;
+  void operator++() {
+    if (_M_cur == _M_last)
+      m_fn1(_M_node + 1);
+  }
+  void m_fn1(int **p1) {
+    _M_node = p1;
+    _M_first = *p1;
+    _M_last = _M_first + _S_buffer_size;
+  }
+};
+
+template <typename _Tp, typename _Ref, typename _Ptr>
+bool operator==(A<_Tp, _Ref, _Ptr>, A<_Tp, _Ref, _Ptr>);
+template <typename _Tp, typename _Ref, typename _Ptr>
+bool operator!=(A<_Tp, _Ref, _Ptr> p1, A<_Tp, _Ref, _Ptr> p2) {
+  return p1 == p2;
+}
+
+class B {
+public:
+  A<int, int, int> m_fn2();
+};
+struct {
+  B j;
+} a;
+void Linked() {
+  A<int, int, int> b, c, d;
+  find_first_of(d, c, b, a.j.m_fn2());
+}
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-array14.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-array14.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-array14.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+// PR c++/66921
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct Holder {
+  constexpr static const int array[] = { 1, 2, 3 };
+  enum {F = array[0]};
+};
+class HI: public Holder<int> {};
Index: gcc/testsuite/g++.dg/cpp0x/alias-decl-45.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/alias-decl-45.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/alias-decl-45.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+// PR c++/61198
+// { dg-do compile { target c++11 } }
+
+template<int herp, typename derp_t>
+struct broken
+{
+	template<typename target_t>
+	using rebind = broken<herp, target_t>;
+};
+
+template<typename derp_t>
+struct broken<2, derp_t>
+{
+	template<typename target_t>
+	using rebind = broken<2, target_t>;
+};
+
+int main(int argc, char **argv)
+{		
+	broken<2, float>::rebind<double> u;
+
+	return 0;
+}
+
Index: gcc/testsuite/g++.dg/cpp0x/sfinae56.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/sfinae56.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/sfinae56.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+// PR c++/68926
+// { dg-do compile { target c++11 } }
+
+struct true_type { static constexpr bool value = true; };
+struct false_type { static constexpr bool value = false; };
+
+template<bool Cond> struct enable_if { using type = void; };
+template<> struct enable_if<false> { };
+
+template<typename T, typename U> struct is_same : false_type { };
+template<typename T> struct is_same<T, T> : true_type { };
+
+template<typename T>
+typename enable_if<is_same<int, T>::value>::type
+func();
+
+template<typename T, typename = decltype(func<T>)>
+true_type test(T);
+
+false_type test(...);
+
+int main()
+{
+   decltype(test(0))::value;   // ok
+   decltype(test(0.f))::value; // error
+}
Index: gcc/testsuite/g++.dg/torture/pr65419.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr65419.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr65419.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,70 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-std=c++14" } */
+
+enum expression_template_option { et_on };
+template <class, expression_template_option = et_on> class A;
+template <class, class, class, class = void, class = void> struct expression;
+template <class T> struct B { typedef const T &type; };
+template <class tag, class A1, class A2, class A3, class A4>
+struct B<expression<tag, A1, A2, A3, A4>> {
+  typedef expression<tag, A1, A2> type;
+};
+template <class tag, class Arg1, class Arg2>
+struct expression<tag, Arg1, Arg2> {
+  expression(Arg1 p1, const Arg2 &p2) : arg1(p1), arg2(p2) {}
+  typename B<Arg1>::type arg1;
+  typename B<Arg2>::type arg2;
+};
+template <class Backend> expression<int, int, A<Backend>> sin(A<Backend>) {
+  return expression<int, int, A<Backend>>(0, 0);
+}
+template <class tag, class A1, class A2, class A3, class A4>
+expression<int, int, expression<tag, A1, A2>>
+  asin(expression<tag, A1, A2, A3, A4> p1) {
+  return expression<int, int, expression<tag, A1, A2>>(0, p1);
+}
+template <class B, expression_template_option ET, class tag, class Arg1,
+	  class Arg2, class Arg3, class Arg4>
+expression<int, A<B>, expression<tag, Arg1, Arg2>>
+  operator+(A<B, ET>, expression<tag, Arg1, Arg2, Arg3, Arg4> p2) {
+  return expression<int, A<B>, expression<tag, Arg1, Arg2>>(0, p2);
+}
+template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2,
+	  class Arg1b, class Arg2b, class Arg3b, class Arg4b>
+expression<int, expression<tag, Arg1, Arg2>, expression<tag2, Arg1b, Arg2b>>
+  operator*(expression<tag, Arg1, Arg2, Arg3, Arg4> p1,
+	    expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b> p2) {
+  return expression<int, expression<tag, Arg1, Arg2>,
+		    expression<tag2, Arg1b, Arg2b>>(p1, p2);
+}
+template <class B> expression<int, A<B>, A<B>> operator/(A<B>, A<B>) {
+  return expression<int, A<B>, A<B>>(0, 0);
+}
+template <class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V>
+void operator/(expression<tag, Arg1, Arg2, Arg3, Arg4>, V);
+template <class, expression_template_option> class A {
+public:
+  A() {}
+  template <class V> A(V) {}
+};
+template <class T, class Policy> void jacobi_recurse(T, T, Policy) {
+  T a, b, c;
+  (a+asin(b/c) * sin(a)) / 0.1;
+}
+template <class T, class Policy> void jacobi_imp(T p1, Policy) {
+  T x;
+  jacobi_recurse(x, p1, 0);
+}
+template <class T, class U, class V, class Policy>
+void jacobi_elliptic(T, U, V, Policy) {
+  jacobi_imp(static_cast<T>(0), 0);
+}
+template <class U, class T, class Policy> void jacobi_sn(U, T, Policy) {
+  jacobi_elliptic(static_cast<T>(0), 0, 0, 0);
+}
+template <class U, class T> void jacobi_sn(U, T p2) { jacobi_sn(0, p2, 0); }
+template <class T> void test_extra(T) {
+  T d;
+  jacobi_sn(0, d);
+}
+void foo() { test_extra(A<int>()); }
Index: gcc/testsuite/g++.dg/ipa/pr61160-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr61160-3.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr61160-3.C	(.../branches/gcc-4_9-branch)
@@ -33,5 +33,6 @@
 int main ()
 {
   CExample c;
-  return (test (c) != &c);
+  test (c);
+  return 0;
 }
Index: gcc/testsuite/g++.dg/ipa/pr66616.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr66616.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr66616.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,54 @@
+// { dg-do run }
+// { dg-options "-O2 -fipa-cp-clone" }
+
+struct Distraction
+{
+  char fc[8];
+  virtual Distraction * return_self ()
+  { return this; }
+};
+
+static int go;
+
+struct A;
+
+struct A
+{
+  int fi;
+
+  A () : fi(0) {}
+  A (int pi) : fi (pi) {}
+  virtual void foo (int p) = 0;
+};
+
+struct B;
+
+struct B : public Distraction, A
+{
+  B () : Distraction(), A() { }
+  B (int pi) : Distraction (), A (pi) {}
+  virtual void foo (int p)
+  {
+    int o = fi;
+    for (int i = 0; i < p; i++)
+      o += i + i * i;
+    go = o;
+  }
+};
+
+struct B gb2 (2);
+
+extern "C" void abort (void);
+
+int
+main (void)
+{
+  for (int i = 0; i < 2; i++)
+    {
+      struct A *p = &gb2;
+      p->foo (0);
+      if (go != 2)
+	abort ();
+    }
+  return 0;
+}
Index: gcc/testsuite/g++.dg/ipa/pr68851.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr68851.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr68851.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// { dg-do compile }
+// { dg-options "-O3" }
+
+class A;
+class B {
+public:
+  operator A *() const;
+};
+class A {
+public:
+  virtual bool isFormControlElement() const {}
+};
+class C {
+  struct D {
+    B element;
+  };
+  bool checkPseudoClass(const D &, int &) const;
+};
+class F {
+  virtual bool isFormControlElement() const;
+};
+class G : A, F {
+  bool isFormControlElement() const {}
+};
+bool C::checkPseudoClass(const D &p1, int &) const {
+  A &a = *p1.element;
+  a.isFormControlElement();
+  a.isFormControlElement() || a.isFormControlElement();
+}
Index: gcc/testsuite/g++.dg/overload/defarg10.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/overload/defarg10.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/overload/defarg10.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+// PR c++/58063
+// { dg-do run }
+
+struct basic_ios
+{
+  bool operator!() const { return false; }
+};
+
+struct ostream : virtual basic_ios
+{
+};
+
+int i;
+
+ostream& operator<<(ostream& os, const char* s) {
+  ++i;
+  return os;
+}
+
+ostream cout;
+
+void f(bool x = !(cout << "hi!\n")) { }
+
+int main() {
+  f();
+  if (i != 1)
+    __builtin_abort();
+}
Index: gcc/testsuite/g++.dg/pr67989.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr67989.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/pr67989.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,75 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c++11 -O2" } */
+/* { dg-additional-options "-marm -march=armv4t" { target arm*-*-* } } */
+
+__extension__ typedef unsigned long long int uint64_t;
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  typedef enum memory_order
+  {
+    memory_order_seq_cst
+  } memory_order;
+}
+
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Tp > struct atomic
+  {
+    static constexpr int _S_min_alignment
+      = (sizeof (_Tp) & (sizeof (_Tp) - 1)) || sizeof (_Tp) > 16
+      ? 0 : sizeof (_Tp);
+    static constexpr int _S_alignment
+      = _S_min_alignment > alignof (_Tp) ? _S_min_alignment : alignof (_Tp);
+      alignas (_S_alignment) _Tp _M_i;
+    operator  _Tp () const noexcept
+    {
+      return load ();
+    }
+    _Tp load (memory_order __m = memory_order_seq_cst) const noexcept
+    {
+      _Tp tmp;
+        __atomic_load (&_M_i, &tmp, __m);
+    }
+  };
+}
+
+namespace lldb_private
+{
+  namespace imp
+  {
+  }
+  class Address;
+}
+namespace lldb
+{
+  typedef uint64_t addr_t;
+  class SBSection
+  {
+  };
+  class SBAddress
+  {
+    void SetAddress (lldb::SBSection section, lldb::addr_t offset);
+      lldb_private::Address & ref ();
+  };
+}
+namespace lldb_private
+{
+  class Address
+  {
+  public:
+    const Address & SetOffset (lldb::addr_t offset)
+    {
+      bool changed = m_offset != offset;
+    }
+    std::atomic < lldb::addr_t > m_offset;
+  };
+}
+
+using namespace lldb;
+using namespace lldb_private;
+void
+SBAddress::SetAddress (lldb::SBSection section, lldb::addr_t offset)
+{
+  Address & addr = ref ();
+  addr.SetOffset (offset);
+}
Index: gcc/testsuite/g++.dg/abi/abi-tag15.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/abi/abi-tag15.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/abi/abi-tag15.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,3 @@
+// PR c++/66748
+
+enum __attribute__((abi_tag("foo"))) E {}; // { dg-error "redeclaration of" }
Index: gcc/testsuite/g++.dg/gomp/pr59627.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/pr59627.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/pr59627.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+// PR c++/59627
+// { dg-do compile { target lto } }
+// { dg-options "-fopenmp -flto" }
+
+struct A { A () : i (0) {} int i; };
+
+void
+foo ()
+{
+  A a;
+  #pragma omp declare reduction (+: A: omp_out.i += omp_in.i)
+  #pragma omp parallel reduction (+: a)
+  ;
+}
Index: gcc/testsuite/g++.dg/init/elide3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/elide3.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/init/elide3.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+// PR c++/67557
+// { dg-do run }
+
+namespace std
+{
+  struct string
+  {
+    typedef unsigned long size_type;
+    const char* _M_p;
+    char        _M_local_buf[1];
+
+    string(const char* s) : _M_p(_M_local_buf)
+    {
+      __builtin_printf("%p constructed\n", this);
+    }
+
+    string(const string& s) : _M_p(_M_local_buf)
+    {
+      __builtin_printf("%p copied from %p\n", this, &s);
+    }
+
+    ~string()
+    {
+      __builtin_printf("%p destroyed\n", this);
+      if (_M_p != _M_local_buf)
+	__builtin_abort();
+    }
+  };
+}
+
+struct StartTag
+{
+  explicit StartTag(std::string const & tag) : tag_(tag), keepempty_(false) {}
+  std::string tag_;
+  bool keepempty_;
+};
+
+StartTag fontToStartTag() { return StartTag(""); }
+
+struct FontTag : public StartTag
+{
+  FontTag() : StartTag(fontToStartTag()) {}
+};
+
+int main()
+{
+  FontTag x;
+  __builtin_printf("%p x.tag_ in main()\n", &x.tag_);
+  return 0;
+}
Index: gcc/testsuite/g++.dg/init/elide4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/elide4.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/init/elide4.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+// PR c++/67557
+
+class A {
+public:
+  A m_fn1();
+  A(A const &);
+  int *L;
+  int ref;
+};
+struct B : A {
+  B();
+};
+B::B() : A((0, m_fn1())) {}
Index: gcc/testsuite/g++.dg/conversion/access1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/conversion/access1.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/conversion/access1.C	(.../branches/gcc-4_9-branch)
@@ -15,7 +15,7 @@
 struct C : public P
 {
   // C can access P's copy ctor, but can't convert b to const P&.
-  C(const B& b) : P(b) {}	// { dg-error "inaccessible base" }
+  C(const B& b) : P(b) {}	// { dg-error "inaccessible base" "" { xfail *-*-* } }
 };
 
 void foo()
Index: gcc/testsuite/g++.dg/pr66866.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr66866.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/pr66866.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+// { dg-require-effective-target sse2_runtime }
+// { dg-options "-O -msse2" }
+
+extern "C" void abort (void);
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef short A __attribute__((__may_alias__));
+
+__m128i __attribute__((noinline))
+shuf(const __m128i v)
+{
+  __m128i r;
+
+  reinterpret_cast<A *>(&r)[5] = reinterpret_cast<const A *>(&v)[4];
+  return r;
+}
+
+int main()
+{
+  __attribute__((aligned(16))) short mem[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };
+
+  *reinterpret_cast<__m128i *>(mem) = shuf (*reinterpret_cast<__m128i *>(mem));
+
+  if (mem[5] != 4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/inherit/access9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/inherit/access9.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/inherit/access9.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+// PR c++/66957
+
+class BaseClass {
+protected:
+  static int x;
+};
+
+struct DerivedA : BaseClass { };
+
+struct DerivedB : BaseClass {
+  DerivedB() {
+    (void) DerivedA::x;
+  }
+};
Index: gcc/testsuite/g++.dg/inherit/using8.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/inherit/using8.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/inherit/using8.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+// PR c++/65061
+
+struct B
+{
+  template<typename T>
+  struct S {};
+};
+
+struct D : B
+{
+  using B::S;
+
+  template<typename T>
+  void doIt(/*struct*/ S<T>&);
+};
Index: gcc/testsuite/g++.dg/template/pr67337.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/pr67337.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/template/pr67337.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,25 @@
+template <class> class A
+{
+  void m_fn1 (int *, int);
+};
+
+template <class> class B
+{
+public:
+  typedef int Type;
+};
+
+template <class> class C
+{
+public:
+  C (int);
+  template <template <class> class T> void m_fn2 (typename T<void>::Type);
+};
+
+template <>
+void
+A<int>::m_fn1 (int *, int)
+{
+  C<int> a (0);
+  a.m_fn2<B> (0);
+}
Index: gcc/testsuite/g++.dg/template/ptrmem30.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/ptrmem30.C	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/g++.dg/template/ptrmem30.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,45 @@
+// PR c++/70096
+// { dg-do run }
+
+int data_read;
+
+struct Holder
+{
+  void foo () { data_read = data; }
+  int data;
+};
+
+void
+poison_stack ()
+{
+  volatile char a[256];
+  __builtin_memset ((void *)a, 0xa, sizeof a);
+}
+
+template <typename F>
+void test1 ()
+{
+  Holder h;
+  h.data = 42;
+  F Holder::*fptr = &Holder::foo;
+  (h.*fptr)();
+}
+
+template <typename F>
+void test2 ()
+{
+  Holder h;
+  h.data = 42;
+  F Holder::*fptr1 = &Holder::foo;
+  F Holder::*fptr2 = fptr1;
+  (h.*fptr2)();
+}
+
+
+int main ()
+{
+  poison_stack ();
+  test1<void()>();
+  poison_stack ();
+  test2<void()>();
+}
Index: gcc/testsuite/c-c++-common/cpp/pr57580.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/cpp/pr57580.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/c-c++-common/cpp/pr57580.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR preprocessor/57580 */
+/* { dg-do compile } */
+/* { dg-options "-save-temps" } */
+
+#define MSG 	\
+  _Pragma("message(\"message0\")")	\
+  _Pragma("message(\"message1\")")
+MSG	/* { dg-message "message0" } */
+/* { dg-message "message1" "" { target *-*-* } 8 } */
Index: gcc/testsuite/c-c++-common/pr67653.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr67653.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/c-c++-common/pr67653.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+/* PR middle-end/67653 */
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  __asm__ ("" : : "m" (({ static int a; a; })));	/* { dg-warning "memory input 0 is not directly addressable" } */
+}
Index: gcc/testsuite/c-c++-common/gomp/pr57580.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr57580.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr57580.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+/* PR preprocessor/57580 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -save-temps -fdump-tree-gimple" } */
+
+#define PS \
+  _Pragma("omp parallel num_threads(2)") \
+  { \
+    _Pragma("omp single") \
+    { \
+      ret = 0; \
+    } \
+  }
+
+int
+main ()
+{
+  int ret;
+  _Pragma("omp parallel num_threads(3)")
+  {
+    _Pragma("omp single")
+    {
+      ret = 0;
+    }
+  }
+  _Pragma("omp parallel num_threads(4)") { _Pragma("omp single") { ret = 0; } }
+  { _Pragma("omp parallel num_threads(5)") { _Pragma("omp single") { ret = 0; } } }
+  PS
+  PS
+  return ret;
+}
+
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(2\\)" 2 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(3\\)" 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(4\\)" 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp parallel\[^\n\r]*num_threads\\(5\\)" 1 "gimple" } } */
+/* { dg-final { scan-tree-dump-times "#pragma omp single" 5 "gimple" } } */
Index: gcc/testsuite/c-c++-common/asan/pr64820.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/asan/pr64820.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/testsuite/c-c++-common/asan/pr64820.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target fstack_protector } */
+/* { dg-options "-fstack-protector-strong" } */
+/* { dg-set-target-env-var ASAN_OPTIONS "detect_stack_use_after_return=1" } */
+/* { dg-shouldfail "asan" } */
+
+__attribute__((noinline))
+char *Ident(char *x) {
+  return x;
+}
+
+__attribute__((noinline))
+char *Func1() {
+  char local[1 << 12];
+  return Ident(local);
+}
+
+__attribute__((noinline))
+void Func2(char *x) {
+  *x = 1;
+}
+int main(int argc, char **argv) {
+  Func2(Func1());
+  return 0;
+}
+
+/* { dg-output "AddressSanitizer: stack-use-after-return on address 0x\[0-9a-f\]+\[^\n\r]*(\n|\r\n|\r)" } */
+/* { dg-output "WRITE of size 1 at .* thread T0.*" } */
+/* { dg-output "    #0.*(Func2)?.*pr64820.(c:21)?.*" } */
+/* { dg-output "is located in stack of thread T0 at offset.*" } */
+/* { dg-output "\'local\' <== Memory access at offset 32 is inside this variable" } */
Index: gcc/cp/typeck.c
===================================================================
--- a/src/gcc/cp/typeck.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/typeck.c	(.../branches/gcc-4_9-branch)
@@ -1896,7 +1896,7 @@
 
   exp = mark_rvalue_use (exp);
 
-  exp = resolve_nondeduced_context (exp);
+  exp = resolve_nondeduced_context (exp, complain);
   if (type_unknown_p (exp))
     {
       if (complain & tf_error)
Index: gcc/cp/init.c
===================================================================
--- a/src/gcc/cp/init.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/init.c	(.../branches/gcc-4_9-branch)
@@ -3027,7 +3027,7 @@
       if (auto_node)
 	{
 	  tree d_init = (**init)[0];
-	  d_init = resolve_nondeduced_context (d_init);
+	  d_init = resolve_nondeduced_context (d_init, complain);
 	  type = do_auto_deduction (type, d_init, auto_node);
 	}
     }
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-4_9-branch)
@@ -6215,7 +6215,7 @@
       if (TREE_CODE (d_init) == TREE_LIST)
 	d_init = build_x_compound_expr_from_list (d_init, ELK_INIT,
 						  tf_warning_or_error);
-      d_init = resolve_nondeduced_context (d_init);
+      d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);
       type = TREE_TYPE (decl) = do_auto_deduction (type, d_init,
 						   auto_node);
       if (type == error_mark_node)
@@ -7138,7 +7138,8 @@
 
   /* Don't get confused by a CONSTRUCTOR for some other type.  */
   if (initial_value && TREE_CODE (initial_value) == CONSTRUCTOR
-      && !BRACE_ENCLOSED_INITIALIZER_P (initial_value))
+      && !BRACE_ENCLOSED_INITIALIZER_P (initial_value)
+      && TREE_CODE (TREE_TYPE (initial_value)) != ARRAY_TYPE)
     return 1;
 
   if (initial_value)
Index: gcc/cp/cfns.gperf
===================================================================
--- a/src/gcc/cp/cfns.gperf	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/cfns.gperf	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,5 @@
+%language=C++
+%define class-name libc_name
 %{
 /* Copyright (C) 2000-2014 Free Software Foundation, Inc.
 
@@ -16,14 +18,6 @@
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
-#ifdef __GNUC__
-__inline
-#endif
-static unsigned int hash (const char *, unsigned int);
-#ifdef __GNUC__
-__inline
-#endif
-const char * libc_name_p (const char *, unsigned int);
 %}
 %%
 # The standard C library functions, for feeding to gperf; the result is used
Index: gcc/cp/Make-lang.in
===================================================================
--- a/src/gcc/cp/Make-lang.in	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/Make-lang.in	(.../branches/gcc-4_9-branch)
@@ -111,7 +111,7 @@
 # deleting the $(srcdir)/cp/cfns.h file.
 $(srcdir)/cp/cfns.h:
 endif
-	gperf -o -C -E -k '1-6,$$' -j1 -D -N 'libc_name_p' -L ANSI-C \
+	gperf -o -C -E -k '1-6,$$' -j1 -D -N 'libc_name_p' -L C++ \
 		$(srcdir)/cp/cfns.gperf --output-file $(srcdir)/cp/cfns.h
 
 #
Index: gcc/cp/rtti.c
===================================================================
--- a/src/gcc/cp/rtti.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/rtti.c	(.../branches/gcc-4_9-branch)
@@ -245,7 +245,7 @@
   if (error_operand_p (exp))
     return error_mark_node;
 
-  exp = resolve_nondeduced_context (exp);
+  exp = resolve_nondeduced_context (exp, complain);
 
   /* peel back references, so they match.  */
   type = non_reference (TREE_TYPE (exp));
@@ -335,7 +335,7 @@
       /* So we need to look into the vtable of the type of exp.
          Make sure it isn't a null lvalue.  */
       exp = cp_build_addr_expr (exp, complain);
-      exp = stabilize_reference (exp);
+      exp = save_expr (exp);
       cond = cp_convert (boolean_type_node, exp, complain);
       exp = cp_build_indirect_ref (exp, RO_NULL, complain);
     }
Index: gcc/cp/except.c
===================================================================
--- a/src/gcc/cp/except.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/except.c	(.../branches/gcc-4_9-branch)
@@ -1030,7 +1030,8 @@
      unless the system headers are playing rename tricks, and if
      they are, we don't want to be confused by them.  */
   id = DECL_NAME (fn);
-  return !!libc_name_p (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));
+  return !!libc_name::libc_name_p (IDENTIFIER_POINTER (id),
+				   IDENTIFIER_LENGTH (id));
 }
 
 /* Returns nonzero if an exception of type FROM will be caught by a
Index: gcc/cp/tree.c
===================================================================
--- a/src/gcc/cp/tree.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/tree.c	(.../branches/gcc-4_9-branch)
@@ -2314,6 +2314,29 @@
       *walk_subtrees = 0;
       return NULL_TREE;
     }
+  if (TREE_CODE (*tp) == SAVE_EXPR)
+    {
+      t = *tp;
+      splay_tree_node n = splay_tree_lookup (target_remap,
+					     (splay_tree_key) t);
+      if (n)
+	{
+	  *tp = (tree)n->value;
+	  *walk_subtrees = 0;
+	}
+      else
+	{
+	  copy_tree_r (tp, walk_subtrees, NULL);
+	  splay_tree_insert (target_remap,
+			     (splay_tree_key)t,
+			     (splay_tree_value)*tp);
+	  /* Make sure we don't remap an already-remapped SAVE_EXPR.  */
+	  splay_tree_insert (target_remap,
+			     (splay_tree_key)*tp,
+			     (splay_tree_value)*tp);
+	}
+      return NULL_TREE;
+    }
 
   /* Make a copy of this node.  */
   t = copy_tree_r (tp, walk_subtrees, NULL);
@@ -3375,13 +3398,15 @@
 		 name, *node);
 	  goto fail;
 	}
-      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (*node))
+      else if (CLASS_TYPE_P (*node)
+	       && CLASSTYPE_TEMPLATE_INSTANTIATION (*node))
 	{
 	  warning (OPT_Wattributes, "ignoring %qE attribute applied to "
 		   "template instantiation %qT", name, *node);
 	  goto fail;
 	}
-      else if (CLASSTYPE_TEMPLATE_SPECIALIZATION (*node))
+      else if (CLASS_TYPE_P (*node)
+	       && CLASSTYPE_TEMPLATE_SPECIALIZATION (*node))
 	{
 	  warning (OPT_Wattributes, "ignoring %qE attribute applied to "
 		   "template specialization %qT", name, *node);
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,103 @@
+2016-04-13  Alan Modra  <amodra@gmail.com>
+
+	Backport from mainline
+	2016-03-22  Patrick Palka  <ppalka@gcc.gnu.org>
+	PR target/70107
+	PR c++/70096
+	* pt.c (tsubst_decl): Clear the DECL_MODE of the new decl.
+
+2016-03-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2014-12-19  Kai Tietz  <ktietz@redhat.com>
+
+	PR c++/61198
+	* pt.c (most_general_template): Don't break for template-alias.
+
+2016-03-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65061
+	* parser.c (cp_parser_template_name): Call strip_using_decl.
+
+2016-02-25  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backported from mainline
+	2016-02-19  Jakub Jelinek  <jakub@redhat.com>
+		    Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	* Make-lang.in: Invoke gperf with -L C++.
+	* cfns.gperf: Remove prototypes for hash and libc_name_p
+	inlines.
+	* cfns.h: Regenerated.
+	* except.c (nothrow_libfn_p): Adjust.
+
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/59627
+	* parser.c (cp_parser_omp_declare_reduction): Set assembler name
+	of the DECL_OMP_DECLARE_REDUCTION_P decls.
+
+2016-02-10  Jason Merrill  <jason@redhat.com>
+
+	PR c++/68926
+	* pt.c (resolve_nondeduced_context): Add complain parm.
+	(do_auto_deduction): Pass it.
+	* cvt.c (convert_to_void): Likewise.
+	* decl.c (cp_finish_decl): Likewise.
+	* init.c (build_new): Likewise.
+	* rtti.c (get_tinfo_decl_dynamic): Likewise.
+	* semantics.c (finish_decltype_type): Likewise.
+	* typeck.c (decay_conversion): Likewise.
+	* cp-tree.h: Adjust declaration.
+
+2016-01-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/68983
+	PR c++/67557
+	* call.c (unsafe_copy_elision_p): Look through COMPOUND_EXPR.
+
+2015-12-21  Jason Merrill  <jason@redhat.com>
+
+	PR c++/66921
+	* decl.c (cp_complete_array_type): Allow an initializer that
+	already has array type.
+
+2015-12-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/67576
+	PR c++/25466
+	* rtti.c (build_typeid): Use save_expr, not stabilize_reference.
+
+	PR c++/67557
+	* call.c (is_base_field_ref): New.
+	(unsafe_copy_elision_p): New.
+	(build_over_call): Use it.
+
+2015-12-04  Markus Trippelsdorf  <markus@trippelsdorf.de>
+
+	PR c++/67337
+	* mangle.c (write_template_prefix): Guard against context==NULL.
+
+2015-08-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/66957
+	* search.c (protected_accessible_p): Revert fix for 38579.
+
+	PR c++/58063
+	* tree.c (bot_manip): Remap SAVE_EXPR.
+
+2015-07-16  Marek Polacek  <polacek@redhat.com>
+
+	2015-07-08  Marek Polacek  <polacek@redhat.com>
+	Backported from mainline
+
+	PR c++/66748
+	* tree.c (handle_abi_tag_attribute): Check for CLASS_TYPE_P before
+	accessing TYPE_LANG_SPECIFIC node.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-4_9-branch)
@@ -11164,6 +11164,8 @@
 	/* The initializer must not be expanded until it is required;
 	   see [temp.inst].  */
 	DECL_INITIAL (r) = NULL_TREE;
+	if (VAR_P (r))
+	  DECL_MODE (r) = VOIDmode;
 	if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_WRTL))
 	  SET_DECL_RTL (r, NULL);
 	DECL_SIZE (r) = DECL_SIZE_UNIT (r) = 0;
@@ -16773,7 +16775,7 @@
    lvalue for the function template specialization.  */
 
 tree
-resolve_nondeduced_context (tree orig_expr)
+resolve_nondeduced_context (tree orig_expr, tsubst_flags_t complain)
 {
   tree expr, offset, baselink;
   bool addr;
@@ -16856,16 +16858,16 @@
 	    {
 	      tree base
 		= TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (offset, 0)));
-	      expr = build_offset_ref (base, expr, addr, tf_warning_or_error);
+	      expr = build_offset_ref (base, expr, addr, complain);
 	    }
 	  if (addr)
-	    expr = cp_build_addr_expr (expr, tf_warning_or_error);
+	    expr = cp_build_addr_expr (expr, complain);
 	  return expr;
 	}
-      else if (good == 0 && badargs)
+      else if (good == 0 && badargs && (complain & tf_error))
 	/* There were no good options and at least one bad one, so let the
 	   user know what the problem is.  */
-	instantiate_template (badfn, badargs, tf_warning_or_error);
+	instantiate_template (badfn, badargs, complain);
     }
   return orig_expr;
 }
@@ -18873,6 +18875,7 @@
 	break;
 
       if (CLASS_TYPE_P (TREE_TYPE (decl))
+	  && !TYPE_DECL_ALIAS_P (TYPE_NAME (TREE_TYPE (decl)))
 	  && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))
 	break;
 
@@ -21738,7 +21741,7 @@
   if (BRACE_ENCLOSED_INITIALIZER_P (init))
     type = listify_autos (type, auto_node);
 
-  init = resolve_nondeduced_context (init);
+  init = resolve_nondeduced_context (init, tf_warning_or_error);
 
   targs = make_tree_vec (1);
   if (AUTO_IS_DECLTYPE (auto_node))
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-4_9-branch)
@@ -6936,7 +6936,7 @@
 
   /* The type denoted by decltype(e) is defined as follows:  */
 
-  expr = resolve_nondeduced_context (expr);
+  expr = resolve_nondeduced_context (expr, complain);
 
   if (invalid_nonstatic_memfn_p (expr, complain))
     return error_mark_node;
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-4_9-branch)
@@ -13669,6 +13669,8 @@
 				/*ambiguous_decls=*/NULL,
 				token->location);
 
+  decl = strip_using_decl (decl);
+
   /* If DECL is a template, then the name was a template-name.  */
   if (TREE_CODE (decl) == TEMPLATE_DECL)
     ;
@@ -30918,6 +30920,7 @@
       DECL_DECLARED_INLINE_P (fndecl) = 1;
       DECL_IGNORED_P (fndecl) = 1;
       DECL_OMP_DECLARE_REDUCTION_P (fndecl) = 1;
+      SET_DECL_ASSEMBLER_NAME (fndecl, get_identifier ("<udr>"));
       DECL_ATTRIBUTES (fndecl)
 	= tree_cons (get_identifier ("gnu_inline"), NULL_TREE,
 		     DECL_ATTRIBUTES (fndecl));
Index: gcc/cp/call.c
===================================================================
--- a/src/gcc/cp/call.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/call.c	(.../branches/gcc-4_9-branch)
@@ -6734,6 +6734,42 @@
     }
 }
 
+/* Return true iff T refers to a base field.  */
+
+static bool
+is_base_field_ref (tree t)
+{
+  STRIP_NOPS (t);
+  if (TREE_CODE (t) == ADDR_EXPR)
+    t = TREE_OPERAND (t, 0);
+  if (TREE_CODE (t) == COMPONENT_REF)
+    t = TREE_OPERAND (t, 1);
+  if (TREE_CODE (t) == FIELD_DECL)
+    return DECL_FIELD_IS_BASE (t);
+  return false;
+}
+
+/* We can't elide a copy from a function returning by value to a base
+   subobject, as the callee might clobber tail padding.  Return true iff this
+   could be that case.  */
+
+static bool
+unsafe_copy_elision_p (tree target, tree exp)
+{
+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));
+  if (type == CLASSTYPE_AS_BASE (type))
+    return false;
+  if (!is_base_field_ref (target)
+      && resolves_to_fixed_type_p (target, NULL))
+    return false;
+  tree init = TARGET_EXPR_INITIAL (exp);
+  /* build_compound_expr pushes COMPOUND_EXPR inside TARGET_EXPR.  */
+  while (TREE_CODE (init) == COMPOUND_EXPR)
+    init = TREE_OPERAND (init, 1);
+  return (TREE_CODE (init) == AGGR_INIT_EXPR
+	  && !AGGR_INIT_VIA_CTOR_P (init));
+}
+
 /* Subroutine of the various build_*_call functions.  Overload resolution
    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.
    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a
@@ -7133,7 +7169,9 @@
 	  else if (trivial)
 	    return force_target_expr (DECL_CONTEXT (fn), arg, complain);
 	}
-      else if (TREE_CODE (arg) == TARGET_EXPR || trivial)
+      else if (trivial
+	       || (TREE_CODE (arg) == TARGET_EXPR
+		   && !unsafe_copy_elision_p (fa, arg)))
 	{
 	  tree to = stabilize_reference (cp_build_indirect_ref (fa, RO_NULL,
 								complain));
Index: gcc/cp/cvt.c
===================================================================
--- a/src/gcc/cp/cvt.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/cvt.c	(.../branches/gcc-4_9-branch)
@@ -1253,7 +1253,7 @@
 
     default:;
     }
-  expr = resolve_nondeduced_context (expr);
+  expr = resolve_nondeduced_context (expr, complain);
   {
     tree probe = expr;
 
Index: gcc/cp/cfns.h
===================================================================
--- a/src/gcc/cp/cfns.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/cfns.h	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
-/* ANSI-C code produced by gperf version 3.0.3 */
-/* Command-line: gperf -o -C -E -k '1-6,$' -j1 -D -N libc_name_p -L ANSI-C cfns.gperf  */
+/* C++ code produced by gperf version 3.0.4 */
+/* Command-line: gperf -o -C -E -k '1-6,$' -j1 -D -N libc_name_p -L C++ --output-file cfns.h cfns.gperf  */
 
 #if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
       && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
@@ -28,7 +28,7 @@
 #error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
 #endif
 
-#line 1 "cfns.gperf"
+#line 3 "cfns.gperf"
 
 /* Copyright (C) 2000-2014 Free Software Foundation, Inc.
 
@@ -47,26 +47,19 @@
 You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
-#ifdef __GNUC__
-__inline
-#endif
-static unsigned int hash (const char *, unsigned int);
-#ifdef __GNUC__
-__inline
-#endif
-const char * libc_name_p (const char *, unsigned int);
 /* maximum key range = 391, duplicates = 0 */
 
-#ifdef __GNUC__
-__inline
-#else
-#ifdef __cplusplus
-inline
-#endif
-#endif
-static unsigned int
-hash (register const char *str, register unsigned int len)
+class libc_name
 {
+private:
+  static inline unsigned int hash (const char *str, unsigned int len);
+public:
+  static const char *libc_name_p (const char *str, unsigned int len);
+};
+
+inline unsigned int
+libc_name::hash (register const char *str, register unsigned int len)
+{
   static const unsigned short asso_values[] =
     {
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
@@ -122,14 +115,8 @@
   return hval + asso_values[(unsigned char)str[len - 1]];
 }
 
-#ifdef __GNUC__
-__inline
-#ifdef __GNUC_STDC_INLINE__
-__attribute__ ((__gnu_inline__))
-#endif
-#endif
 const char *
-libc_name_p (register const char *str, register unsigned int len)
+libc_name::libc_name_p (register const char *str, register unsigned int len)
 {
   enum
     {
Index: gcc/cp/mangle.c
===================================================================
--- a/src/gcc/cp/mangle.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/mangle.c	(.../branches/gcc-4_9-branch)
@@ -1118,7 +1118,7 @@
      So, for the example above, `Outer<int>::Inner' is represented as a
      substitution candidate by a TREE_LIST whose purpose is `Outer<int>'
      and whose value is `Outer<T>::Inner<U>'.  */
-  if (TYPE_P (context))
+  if (context && TYPE_P (context))
     substitution = build_tree_list (context, templ);
   else
     substitution = templ;
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-4_9-branch)
@@ -5632,7 +5632,7 @@
 extern tree get_template_innermost_arguments	(const_tree);
 extern tree get_template_argument_pack_elems	(const_tree);
 extern tree get_function_template_decl		(const_tree);
-extern tree resolve_nondeduced_context		(tree);
+extern tree resolve_nondeduced_context		(tree, tsubst_flags_t);
 extern hashval_t iterative_hash_template_arg (tree arg, hashval_t val);
 
 /* in repo.c */
Index: gcc/cp/search.c
===================================================================
--- a/src/gcc/cp/search.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cp/search.c	(.../branches/gcc-4_9-branch)
@@ -727,7 +727,7 @@
     Here DERIVED is a possible P, DECL is m and BINFO_TYPE (binfo) is N.  */
 
   /* If DERIVED isn't derived from N, then it can't be a P.  */
-  if (!DERIVED_FROM_P (BINFO_TYPE (binfo), derived))
+  if (!DERIVED_FROM_P (context_for_name_lookup (decl), derived))
     return 0;
 
   access = access_in_type (derived, decl);
Index: gcc/haifa-sched.c
===================================================================
--- a/src/gcc/haifa-sched.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/haifa-sched.c	(.../branches/gcc-4_9-branch)
@@ -5801,7 +5801,15 @@
 	      if (SCHED_GROUP_P (insn) && cost > min_cost_group)
 		min_cost_group = cost;
 	      ready_remove (&ready, i);
-	      queue_insn (insn, cost, reason);
+	      /* Normally we'd want to queue INSN for COST cycles.  However,
+		 if SCHED_GROUP_P is set, then we must ensure that nothing
+		 else comes between INSN and its predecessor.  If there is
+		 some other insn ready to fire on the next cycle, then that
+		 invariant would be broken.
+
+		 So when SCHED_GROUP_P is set, just queue this insn for a
+		 single cycle.  */
+	      queue_insn (insn, SCHED_GROUP_P (insn) ? 1 : cost, reason);
 	      if (i + 1 < n)
 		break;
 	    }
Index: gcc/dojump.c
===================================================================
--- a/src/gcc/dojump.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/dojump.c	(.../branches/gcc-4_9-branch)
@@ -1193,12 +1193,12 @@
      If one side isn't, we want a noncanonicalized comparison.  See PR
      middle-end/17564.  */
   if (HAVE_canonicalize_funcptr_for_compare
-      && TREE_CODE (TREE_TYPE (treeop0)) == POINTER_TYPE
-      && TREE_CODE (TREE_TYPE (TREE_TYPE (treeop0)))
-          == FUNCTION_TYPE
-      && TREE_CODE (TREE_TYPE (treeop1)) == POINTER_TYPE
-      && TREE_CODE (TREE_TYPE (TREE_TYPE (treeop1)))
-          == FUNCTION_TYPE)
+      && POINTER_TYPE_P (TREE_TYPE (treeop0))
+      && POINTER_TYPE_P (TREE_TYPE (treeop1))
+      && (TREE_CODE (TREE_TYPE (TREE_TYPE (treeop0))) == FUNCTION_TYPE
+	  || TREE_CODE (TREE_TYPE (TREE_TYPE (treeop0))) == METHOD_TYPE)
+      && (TREE_CODE (TREE_TYPE (TREE_TYPE (treeop1))) == FUNCTION_TYPE
+	  || TREE_CODE (TREE_TYPE (TREE_TYPE (treeop1))) == METHOD_TYPE))
     {
       rtx new_op0 = gen_reg_rtx (mode);
       rtx new_op1 = gen_reg_rtx (mode);
Index: gcc/cgraphclones.c
===================================================================
--- a/src/gcc/cgraphclones.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cgraphclones.c	(.../branches/gcc-4_9-branch)
@@ -367,6 +367,7 @@
   new_thunk = cgraph_create_node (new_decl);
   set_new_clone_decl_and_node_flags (new_thunk);
   new_thunk->definition = true;
+  new_thunk->local.can_change_signature = node->local.can_change_signature;
   new_thunk->thunk = thunk->thunk;
   new_thunk->unique_name = in_lto_p;
   new_thunk->former_clone_of = thunk->decl;
Index: gcc/tree-ssa-math-opts.c
===================================================================
--- a/src/gcc/tree-ssa-math-opts.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-ssa-math-opts.c	(.../branches/gcc-4_9-branch)
@@ -746,7 +746,7 @@
       if (gimple_code (use_stmt) != GIMPLE_CALL
 	  || !gimple_call_lhs (use_stmt)
 	  || !(fndecl = gimple_call_fndecl (use_stmt))
-	  || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)
+	  || !gimple_call_builtin_p (use_stmt, BUILT_IN_NORMAL))
 	continue;
 
       switch (DECL_FUNCTION_CODE (fndecl))
@@ -1437,7 +1437,7 @@
 	  if (is_gimple_call (stmt)
 	      && gimple_call_lhs (stmt)
 	      && (fndecl = gimple_call_fndecl (stmt))
-	      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)
+	      && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
 	    {
 	      tree arg, arg0, arg1, result;
 	      HOST_WIDE_INT n;
@@ -2860,7 +2860,7 @@
 	    {
 	      tree fndecl = gimple_call_fndecl (stmt);
 	      if (fndecl
-		  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)
+		  && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
 		{
 		  switch (DECL_FUNCTION_CODE (fndecl))
 		    {
Index: gcc/tree-ssa-dom.c
===================================================================
--- a/src/gcc/tree-ssa-dom.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-ssa-dom.c	(.../branches/gcc-4_9-branch)
@@ -2261,11 +2261,16 @@
       if (loop_depth_of_name (val) > loop_depth_of_name (op))
 	return;
 
-      /* Do not propagate copies into simple IV increment statements.
-         See PR23821 for how this can disturb IV analysis.  */
-      if (TREE_CODE (val) != INTEGER_CST
-	  && simple_iv_increment_p (stmt))
-	return;
+      /* Do not propagate copies into BIVs.
+         See PR23821 and PR62217 for how this can disturb IV and
+	 number of iteration analysis.  */
+      if (TREE_CODE (val) != INTEGER_CST)
+	{
+	  gimple def = SSA_NAME_DEF_STMT (op);
+	  if (gimple_code (def) == GIMPLE_PHI
+	      && gimple_bb (def)->loop_father->header == gimple_bb (def))
+	    return;
+	}
 
       /* Dump details.  */
       if (dump_file && (dump_flags & TDF_DETAILS))
Index: gcc/config.in
===================================================================
--- a/src/gcc/config.in	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config.in	(.../branches/gcc-4_9-branch)
@@ -1223,6 +1223,12 @@
 #endif
 
 
+/* Define if isl_options_set_schedule_serialize_sccs exists. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
+#endif
+
+
 /* Define if isl_schedule_constraints_compute_schedule exists. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
Index: gcc/ifcvt.c
===================================================================
--- a/src/gcc/ifcvt.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ifcvt.c	(.../branches/gcc-4_9-branch)
@@ -2071,12 +2071,26 @@
 
   /* Work around funny ideas get_condition has wrt canonicalization.
      Note that these rtx constants are known to be CONST_INT, and
-     therefore imply integer comparisons.  */
+     therefore imply integer comparisons.
+     The one_cmpl case is more complicated, as we want to handle
+     only x < 0 ? ~x : x or x >= 0 ? x : ~x to one_cmpl_abs (x)
+     and x < 0 ? x : ~x or x >= 0 ? ~x : x to ~one_cmpl_abs (x),
+     but not other cases (x > -1 is equivalent of x >= 0).  */
   if (c == constm1_rtx && GET_CODE (cond) == GT)
     ;
   else if (c == const1_rtx && GET_CODE (cond) == LT)
-    ;
-  else if (c != CONST0_RTX (GET_MODE (b)))
+    {
+      if (one_cmpl)
+	return FALSE;
+    }
+  else if (c == CONST0_RTX (GET_MODE (b)))
+    {
+      if (one_cmpl
+	  && GET_CODE (cond) != GE
+	  && GET_CODE (cond) != LT)
+	return FALSE;
+    }
+  else
     return FALSE;
 
   /* Determine what sort of operation this is.  */
@@ -3715,8 +3729,11 @@
     return FALSE;
 
   /* If the conditional jump is more than just a conditional jump, then
-     we can not do if-conversion on this block.  */
-  if (! onlyjump_p (jump))
+     we can not do if-conversion on this block.  Give up for returnjump_p,
+     changing a conditional return followed by unconditional trap for
+     conditional trap followed by unconditional return is likely not
+     beneficial and harder to handle.  */
+  if (! onlyjump_p (jump) || returnjump_p (jump))
     return FALSE;
 
   /* We must be comparing objects whose modes imply the size.  */
Index: gcc/go/gofrontend/expressions.cc
===================================================================
--- a/src/gcc/go/gofrontend/expressions.cc	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/go/gofrontend/expressions.cc	(.../branches/gcc-4_9-branch)
@@ -9136,6 +9136,16 @@
 int
 Call_expression::do_traverse(Traverse* traverse)
 {
+  // If we are calling a function in a different package that returns
+  // an unnamed type, this may be the only chance we get to traverse
+  // that type.  We don't traverse this->type_ because it may be a
+  // Call_multiple_result_type that will just lead back here.
+  if (this->type_ != NULL && !this->type_->is_error_type())
+    {
+      Function_type *fntype = this->get_function_type();
+      if (fntype != NULL && Type::traverse(fntype, traverse) == TRAVERSE_EXIT)
+	return TRAVERSE_EXIT;
+    }
   if (Expression::traverse(&this->fn_, traverse) == TRAVERSE_EXIT)
     return TRAVERSE_EXIT;
   if (this->args_ != NULL)
Index: gcc/tree-ssa-loop-ivcanon.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ivcanon.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-ssa-loop-ivcanon.c	(.../branches/gcc-4_9-branch)
@@ -1072,7 +1072,9 @@
       tree result = gimple_phi_result (phi);
       tree arg = gimple_phi_arg_def (phi, 0);
 
-      if (gimple_phi_num_args (phi) == 1 && TREE_CODE (arg) == INTEGER_CST)
+      if (! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (result)
+	  && gimple_phi_num_args (phi) == 1
+	  && TREE_CODE (arg) == INTEGER_CST)
 	{
 	  propagate_into_all_uses (result, arg);
 	  gsi_remove (&gsi, true);
Index: gcc/ada/s-osinte-kfreebsd-gnu.ads
===================================================================
--- a/src/gcc/ada/s-osinte-kfreebsd-gnu.ads	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ada/s-osinte-kfreebsd-gnu.ads	(.../branches/gcc-4_9-branch)
@@ -7,7 +7,7 @@
 --                                  S p e c                                 --
 --                                                                          --
 --               Copyright (C) 1991-1994, Florida State University          --
---            Copyright (C) 1995-2014, Free Software Foundation, Inc.       --
+--            Copyright (C) 1995-2015, Free Software Foundation, Inc.       --
 --                                                                          --
 -- GNAT is free software;  you can  redistribute it  and/or modify it under --
 -- terms of the  GNU General Public License as published  by the Free Soft- --
@@ -30,7 +30,7 @@
 --                                                                          --
 ------------------------------------------------------------------------------
 
---  This is the GNU/kFreeBSD (GNU/LinuxThreads) version of this package
+--  This is the GNU/kFreeBSD (POSIX Threads) version of this package
 
 --  This package encapsulates all direct interfaces to OS services
 --  that are needed by children of System.
@@ -198,8 +198,24 @@
    -- Time --
    ----------
 
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
    type timespec is private;
 
+   function nanosleep (rqtp, rmtp : access timespec) return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is private;
+
+   CLOCK_REALTIME : constant clockid_t;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
    function To_Duration (TS : timespec) return Duration;
    pragma Inline (To_Duration);
 
@@ -236,6 +252,16 @@
    function getpid return pid_t;
    pragma Import (C, getpid, "getpid");
 
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
    -------------
    -- Threads --
    -------------
@@ -261,7 +287,19 @@
    type pthread_key_t       is private;
 
    PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
 
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on kfreebsd. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
    -----------
    -- Stack --
    -----------
@@ -284,10 +322,30 @@
    Alternate_Stack_Size : constant := 0;
    --  No alternate signal stack is used on this platform
 
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target
+
    function Get_Stack_Base (thread : pthread_t) return Address;
    pragma Inline (Get_Stack_Base);
-   --  This is a dummy procedure to share some GNULLI files
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
 
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
    ---------------------------------------
    -- Nonstandard Thread Initialization --
    ---------------------------------------
@@ -375,6 +433,36 @@
    -- POSIX.1c  Section 13 --
    --------------------------
 
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
    type struct_sched_param is record
       sched_priority : int;  --  scheduling priority
    end record;
@@ -386,6 +474,28 @@
       param  : access struct_sched_param) return int;
    pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
 
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
    function pthread_attr_setschedpolicy
      (attr   : access pthread_attr_t;
       policy : int) return int;
@@ -496,6 +606,9 @@
    end record;
    pragma Convention (C, timespec);
 
+   type clockid_t is new int;
+   CLOCK_REALTIME : constant clockid_t := 0;
+
    type pthread_attr_t is record
       detachstate   : int;
       schedpolicy   : int;
Index: gcc/ada/s-oscons-tmplt.c
===================================================================
--- a/src/gcc/ada/s-oscons-tmplt.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ada/s-oscons-tmplt.c	(.../branches/gcc-4_9-branch)
@@ -154,7 +154,7 @@
 # include <_types.h>
 #endif
 
-#ifdef __linux__
+#if defined (__linux__) || defined (__rtems__)
 # include <pthread.h>
 # include <signal.h>
 #endif
@@ -1441,7 +1441,8 @@
 CNS(CLOCK_RT_Ada, "")
 #endif
 
-#if defined (__APPLE__) || defined (__linux__) || defined (DUMMY)
+#if defined (__APPLE__) || defined (__linux__) || defined (__rtems__) || \
+  defined (DUMMY)
 /*
 
    --  Sizes of pthread data types
@@ -1484,7 +1485,7 @@
 CND(PTHREAD_RWLOCK_SIZE,     "pthread_rwlock_t")
 CND(PTHREAD_ONCE_SIZE,       "pthread_once_t")
 
-#endif /* __APPLE__ || __linux__ */
+#endif /* __APPLE__ || __linux__ || __rtems__*/
 
 /*
 
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,52 @@
+2015-12-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/56274
+	* s-osinte-kfreebsd-gnu.ads (pthread_rwlock_t): New subtype.
+	(pthread_rwlockattr_t): Likewise.
+
+2015-12-06  Ludovic Brenta  <ludovic@ludovic-brenta.org>
+
+	PR ada/49944
+	* s-osinte-freebsd.ads: Minor reformatting.
+	(Stack_Base_Available): Correct comments.
+	* s-osinte-kfreebsd-gnu.ads (Time_Slice_Supported, nanosleep,
+	clock_id_t, clock_gettime, Stack_Base_Available, Get_Page_Size,
+	mprotect, pthread_mutexattr_setprotocol,pthread_mutexattr_getprotocol
+	pthread_mutexattr_setprioceiling, pthread_mutexattr_getprioceiling,
+	pthread_attr_setscope, pthread_attr_getscope,
+	pthread_attr_setinheritsched, pthread_attr_getinheritsched,
+	Time_Slice_Supported): Copy from s-osinte-freebsd.ads.
+	* gcc-interface/Makefile.in (x86/kfreebsd): Use the POSIX version of
+	the System.Task_Primitives.Operations package.
+
+2015-12-06  Ludovic Brenta  <ludovic@ludovic-brenta.org>
+
+	PR ada/49940
+	* s-osinte-kfreebsd-gnu.ads (lwp_self): New imported function.
+
+2015-12-01  Jan Sommer <soja-lists@aries.uberspace.de>
+
+	PR ada/68169
+	* s-oscons-tmplt.c: Generate pthread constants for RTEMS
+	* s-osinte-rtems.ads: Declare pthread structs as opaque types in Ada
+
+2015-11-29  Matthias Klose  <doko@ubuntu.com>
+
+	PR ada/68564
+	* gcc-interface/Makefile.in: Fix powerpc/powerpc64* and
+	mipsel/mips64el bitness detection.
+	Merge the mipsel/mips64el definitions into one.
+
+2015-11-28  Matthias Klose  <doko@ubuntu.com>
+
+	PR ada/68564
+	* gcc-interface/Makefile.in: Fix sparc/sparc64 bitness detection.
+
+2015-10-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/Make-lang.in: Make sure that GNAT1_OBJS and not just
+	GNAT1_ADA_OBJS are compiled only after generated files are created.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: gcc/ada/s-osinte-rtems.ads
===================================================================
--- a/src/gcc/ada/s-osinte-rtems.ads	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ada/s-osinte-rtems.ads	(.../branches/gcc-4_9-branch)
@@ -51,6 +51,8 @@
 --  It is designed to be a bottom-level (leaf) package.
 
 with Interfaces.C;
+with System.OS_Constants;
+
 package System.OS_Interface is
    pragma Preelaborate;
 
@@ -60,6 +62,7 @@
    subtype rtems_id       is Interfaces.C.unsigned;
 
    subtype int            is Interfaces.C.int;
+   subtype char           is Interfaces.C.char;
    subtype short          is Interfaces.C.short;
    subtype long           is Interfaces.C.long;
    subtype unsigned       is Interfaces.C.unsigned;
@@ -68,7 +71,6 @@
    subtype unsigned_char  is Interfaces.C.unsigned_char;
    subtype plain_char     is Interfaces.C.plain_char;
    subtype size_t         is Interfaces.C.size_t;
-
    -----------
    -- Errno --
    -----------
@@ -76,11 +78,11 @@
    function errno return int;
    pragma Import (C, errno, "__get_errno");
 
-   EAGAIN    : constant := 11;
-   EINTR     : constant := 4;
-   EINVAL    : constant := 22;
-   ENOMEM    : constant := 12;
-   ETIMEDOUT : constant := 116;
+   EAGAIN    : constant := System.OS_Constants.EAGAIN;
+   EINTR     : constant := System.OS_Constants.EINTR;
+   EINVAL    : constant := System.OS_Constants.EINVAL;
+   ENOMEM    : constant := System.OS_Constants.ENOMEM;
+   ETIMEDOUT : constant := System.OS_Constants.ETIMEDOUT;
 
    -------------
    -- Signals --
@@ -448,6 +450,7 @@
       ss_low_priority     : int;
       ss_replenish_period : timespec;
       ss_initial_budget   : timespec;
+      sched_ss_max_repl   : int;
    end record;
    pragma Convention (C, struct_sched_param);
 
@@ -621,43 +624,34 @@
    end record;
    pragma Convention (C, timespec);
 
-   CLOCK_REALTIME :  constant clockid_t := 1;
-   CLOCK_MONOTONIC : constant clockid_t := 4;
+   CLOCK_REALTIME :  constant clockid_t := System.OS_Constants.CLOCK_REALTIME;
+   CLOCK_MONOTONIC : constant clockid_t := System.OS_Constants.CLOCK_MONOTONIC;
 
+   subtype char_array is Interfaces.C.char_array;
+
    type pthread_attr_t is record
-      is_initialized  : int;
-      stackaddr       : System.Address;
-      stacksize       : int;
-      contentionscope : int;
-      inheritsched    : int;
-      schedpolicy     : int;
-      schedparam      : struct_sched_param;
-      cputime_clocked_allowed : int;
-      detatchstate    : int;
+      Data : char_array (1 .. OS_Constants.PTHREAD_ATTR_SIZE);
    end record;
    pragma Convention (C, pthread_attr_t);
+   for pthread_attr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_condattr_t is record
-      flags           : int;
-      process_shared  : int;
+      Data : char_array (1 .. OS_Constants.PTHREAD_CONDATTR_SIZE);
    end record;
    pragma Convention (C, pthread_condattr_t);
+   for pthread_condattr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_mutexattr_t is record
-      is_initialized  : int;
-      process_shared  : int;
-      prio_ceiling    : int;
-      protocol        : int;
-      mutex_type      : int;
-      recursive       : int;
-   end record;
+      Data : char_array (1 .. OS_Constants.PTHREAD_MUTEXATTR_SIZE);
+   end  record;
    pragma Convention (C, pthread_mutexattr_t);
+   for pthread_mutexattr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_rwlockattr_t is record
-      is_initialized  : int;
-      process_shared  : int;
+      Data : char_array (1 .. OS_Constants.PTHREAD_RWLOCKATTR_SIZE);
    end record;
    pragma Convention (C, pthread_rwlockattr_t);
+   for pthread_rwlockattr_t'Alignment use Interfaces.C.double'Alignment;
 
    type pthread_t is new rtems_id;
 
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- a/src/gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -1275,9 +1275,7 @@
   s-osinte.adb<s-osinte-posix.adb \
   s-osinte.ads<s-osinte-kfreebsd-gnu.ads \
   s-osprim.adb<s-osprim-posix.adb \
-  s-taprop.adb<s-taprop-linux.adb \
-  s-tasinf.ads<s-tasinf-linux.ads \
-  s-tasinf.adb<s-tasinf-linux.adb \
+  s-taprop.adb<s-taprop-posix.adb \
   s-taspri.ads<s-taspri-posix.ads \
   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
   $(ATOMICS_TARGET_PAIRS) \
@@ -1308,9 +1306,7 @@
   s-osinte.adb<s-osinte-posix.adb \
   s-osinte.ads<s-osinte-kfreebsd-gnu.ads \
   s-osprim.adb<s-osprim-posix.adb \
-  s-taprop.adb<s-taprop-linux.adb \
-  s-tasinf.ads<s-tasinf-linux.ads \
-  s-tasinf.adb<s-tasinf-linux.adb \
+  s-taprop.adb<s-taprop-posix.adb \
   s-taspri.ads<s-taspri-posix.ads \
   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
   system.ads<system-freebsd-x86_64.ads
@@ -1797,8 +1793,8 @@
   LIBRARY_VERSION := $(LIB_VERSION)
 endif
 
-# Mips/el Linux
-ifeq ($(strip $(filter-out mipsel linux%,$(target_cpu) $(target_os))),)
+# Mips/el and Mips64/el Linux
+ifeq ($(strip $(filter-out mipsel mips64el linux%,$(target_cpu) $(target_os))),)
   LIBGNAT_TARGET_PAIRS_COMMON = \
   a-intnam.ads<a-intnam-linux.ads \
   s-inmaop.adb<s-inmaop-posix.adb \
@@ -1820,7 +1816,7 @@
   LIBGNAT_TARGET_PAIRS_64 = \
   system.ads<system-linux-mips64el.ads
 
-  ifeq ($(strip $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multi-os-directory)),../lib64)
+  ifneq (,$(or $(filter mips64el%, $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multiarch)), $(filter ../lib64, $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multi-os-directory))))
     LIBGNAT_TARGET_PAIRS = \
     $(LIBGNAT_TARGET_PAIRS_COMMON) $(LIBGNAT_TARGET_PAIRS_64)
   else
@@ -1840,49 +1836,6 @@
   LIBRARY_VERSION := $(LIB_VERSION)
 endif
 
-# Mips64/el Linux
-ifeq ($(strip $(filter-out mips64el linux%,$(target_cpu) $(target_os))),)
-  LIBGNAT_TARGET_PAIRS_COMMON = \
-  a-intnam.ads<a-intnam-linux.ads \
-  s-inmaop.adb<s-inmaop-posix.adb \
-  s-intman.adb<s-intman-posix.adb \
-  s-linux.ads<s-linux-mipsel.ads \
-  s-osinte.adb<s-osinte-posix.adb \
-  s-osinte.ads<s-osinte-linux.ads \
-  s-osprim.adb<s-osprim-posix.adb \
-  s-taprop.adb<s-taprop-linux.adb \
-  s-tasinf.ads<s-tasinf-linux.ads \
-  s-tasinf.adb<s-tasinf-linux.adb \
-  s-taspri.ads<s-taspri-posix-noaltstack.ads \
-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
-  g-sercom.adb<g-sercom-linux.adb
-
-  LIBGNAT_TARGET_PAIRS_32 = \
-  system.ads<system-linux-mipsel.ads
-
-  LIBGNAT_TARGET_PAIRS_64 = \
-  system.ads<system-linux-mips64el.ads
-
-  ifeq ($(strip $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multi-os-directory)),../lib64)
-    LIBGNAT_TARGET_PAIRS = \
-    $(LIBGNAT_TARGET_PAIRS_COMMON) $(LIBGNAT_TARGET_PAIRS_64)
-  else
-    LIBGNAT_TARGET_PAIRS = \
-    $(LIBGNAT_TARGET_PAIRS_COMMON) $(LIBGNAT_TARGET_PAIRS_32)
-  endif
-
-  TOOLS_TARGET_PAIRS =  \
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb
-
-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o
-  EH_MECHANISM=-gcc
-  THREADSLIB = -lpthread
-  GNATLIB_SHARED = gnatlib-shared-dual
-  GMEM_LIB = gmemlib
-  LIBRARY_VERSION := $(LIB_VERSION)
-endif
-
 # PowerPC and e500v2 Linux
 ifeq ($(strip $(filter-out powerpc% linux%,$(target_cpu) $(target_os))),)
   LIBGNAT_TARGET_PAIRS_COMMON = \
@@ -1917,7 +1870,7 @@
     LIBGNAT_TARGET_PAIRS_64 = \
     system.ads<system-linux-ppc64.ads
 
-    ifeq ($(strip $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multi-os-directory)),../lib64)
+    ifneq (,$(or $(filter powerpc64%, $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multiarch)), $(filter ../lib64, $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multi-os-directory))))
       LIBGNAT_TARGET_PAIRS = \
       $(LIBGNAT_TARGET_PAIRS_COMMON) $(LIBGNAT_TARGET_PAIRS_64)
     else
@@ -2048,7 +2001,7 @@
   LIBGNAT_TARGET_PAIRS_64 = \
   system.ads<system-linux-sparcv9.ads
 
-  ifeq ($(strip $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multi-os-directory)),../lib64)
+  ifneq (,$(or $(filter sparc64-linux-gnu, $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multiarch)), $(filter ../lib64, $(shell $(GCC_FOR_TARGET) $(GNATLIBCFLAGS) -print-multi-os-directory))))
     LIBGNAT_TARGET_PAIRS = \
     $(LIBGNAT_TARGET_PAIRS_COMMON) $(LIBGNAT_TARGET_PAIRS_64)
   else
Index: gcc/ada/gcc-interface/Make-lang.in
===================================================================
--- a/src/gcc/ada/gcc-interface/Make-lang.in	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ada/gcc-interface/Make-lang.in	(.../branches/gcc-4_9-branch)
@@ -1001,7 +1001,7 @@
 
 # When building from scratch we don't have dependency files, the only thing
 # we need to ensure is that the generated files are created first.
-$(GNAT1_ADA_OBJS) $(GNATBIND_OBJS): | $(ada_generated_files)
+$(GNAT1_OBJS) $(GNATBIND_OBJS): | $(ada_generated_files)
 
 # Manually include the auto-generated dependencies for the Ada host objects.
 ADA_DEPFILES = $(foreach obj,$(GNAT1_ADA_OBJS) $(GNATBIND_OBJS),\
Index: gcc/ada/s-osinte-freebsd.ads
===================================================================
--- a/src/gcc/ada/s-osinte-freebsd.ads	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ada/s-osinte-freebsd.ads	(.../branches/gcc-4_9-branch)
@@ -31,7 +31,7 @@
 --                                                                          --
 ------------------------------------------------------------------------------
 
---  This is the FreeBSD PTHREADS version of this package
+--  This is the FreeBSD (POSIX Threads) version of this package
 
 --  This package encapsulates all direct interfaces to OS services
 --  that are needed by the tasking run-time (libgnarl).
@@ -197,7 +197,7 @@
 
    type timespec is private;
 
-   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   function nanosleep (rqtp, rmtp : access timespec) return int;
    pragma Import (C, nanosleep, "nanosleep");
 
    type clockid_t is new int;
@@ -317,10 +317,7 @@
    --  No alternate signal stack is used on this platform
 
    Stack_Base_Available : constant Boolean := False;
-   --  Indicates whether the stack base is available on this target. This
-   --  allows us to share s-osinte.adb between all the FSU run time. Note that
-   --  this value can only be true if pthread_t has a complete definition that
-   --  corresponds exactly to the C header files.
+   --  Indicates whether the stack base is available on this target
 
    function Get_Stack_Base (thread : pthread_t) return Address;
    pragma Inline (Get_Stack_Base);
Index: gcc/dse.c
===================================================================
--- a/src/gcc/dse.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/dse.c	(.../branches/gcc-4_9-branch)
@@ -1545,14 +1545,9 @@
 	mem_addr = base->val_rtx;
       else
 	{
-	  group_info_t group
-	    = rtx_group_vec[group_id];
+	  group_info_t group = rtx_group_vec[group_id];
 	  mem_addr = group->canon_base_addr;
 	}
-      /* get_addr can only handle VALUE but cannot handle expr like:
-	 VALUE + OFFSET, so call get_addr to get original addr for
-	 mem_addr before plus_constant.  */
-      mem_addr = get_addr (mem_addr);
       if (offset)
 	mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);
     }
@@ -2166,14 +2161,9 @@
 	mem_addr = base->val_rtx;
       else
 	{
-	  group_info_t group
-	    = rtx_group_vec[group_id];
+	  group_info_t group = rtx_group_vec[group_id];
 	  mem_addr = group->canon_base_addr;
 	}
-      /* get_addr can only handle VALUE but cannot handle expr like:
-	 VALUE + OFFSET, so call get_addr to get original addr for
-	 mem_addr before plus_constant.  */
-      mem_addr = get_addr (mem_addr);
       if (offset)
 	mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);
     }
Index: gcc/gimple-ssa-strength-reduction.c
===================================================================
--- a/src/gcc/gimple-ssa-strength-reduction.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/gimple-ssa-strength-reduction.c	(.../branches/gcc-4_9-branch)
@@ -2251,7 +2251,8 @@
   slsr_cand_t basis = lookup_cand (c->basis);
   int nargs = gimple_phi_num_args (from_phi);
   basic_block phi_bb = gimple_bb (from_phi);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (from_phi));
+  slsr_cand_t phi_cand = *((slsr_cand_t *)
+			   pointer_map_contains (stmt_cand_map, from_phi));
   phi_args.create (nargs);
 
   /* Process each argument of the existing phi that represents
@@ -2362,7 +2363,8 @@
 {
   unsigned i;
   int cost = 0;
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *((slsr_cand_t *)
+			   pointer_map_contains (stmt_cand_map, phi));
 
   /* If we work our way back to a phi that isn't dominated by the hidden
      basis, this isn't a candidate for replacement.  Indicate this by
@@ -2573,7 +2575,8 @@
 record_phi_increments (slsr_cand_t basis, gimple phi)
 {
   unsigned i;
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *((slsr_cand_t *)
+			   pointer_map_contains (stmt_cand_map, phi));
   
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
@@ -2644,7 +2647,8 @@
   unsigned i;
   int cost = 0;
   slsr_cand_t basis = lookup_cand (c->basis);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *((slsr_cand_t *)
+			   pointer_map_contains (stmt_cand_map, phi));
 
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
@@ -2988,7 +2992,8 @@
 {
   unsigned i;
   slsr_cand_t basis = lookup_cand (c->basis);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *((slsr_cand_t *)
+			   pointer_map_contains (stmt_cand_map, phi));
 
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
@@ -3196,7 +3201,8 @@
 {
   unsigned i;
   slsr_cand_t basis = lookup_cand (c->basis);
-  slsr_cand_t phi_cand = base_cand_from_table (gimple_phi_result (phi));
+  slsr_cand_t phi_cand = *((slsr_cand_t *)
+			   pointer_map_contains (stmt_cand_map, phi));
 
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-4_9-branch)
@@ -8024,6 +8024,7 @@
   bool scalar_to_array;
   tree string_length;
   int n;
+  bool maybe_workshare = false;
 
   /* Assignment of the form lhs = rhs.  */
   gfc_start_block (&block);
@@ -8092,8 +8093,13 @@
 	}
 
       /* Allow the scalarizer to workshare array assignments.  */
-      if ((ompws_flags & OMPWS_WORKSHARE_FLAG) && loop.temp_ss == NULL)
-	ompws_flags |= OMPWS_SCALARIZER_WS;
+      if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_BODY))
+	  == OMPWS_WORKSHARE_FLAG
+	  && loop.temp_ss == NULL)
+	{
+	  maybe_workshare = true;
+	  ompws_flags |= OMPWS_SCALARIZER_WS | OMPWS_SCALARIZER_BODY;
+	}
 
       /* Start the scalarized loop body.  */
       gfc_start_scalarized_body (&loop, &body);
@@ -8208,6 +8214,9 @@
 	    gfc_add_expr_to_block (&loop.code[expr1->rank - 1], tmp);
 	}
 
+      if (maybe_workshare)
+	ompws_flags &= ~OMPWS_SCALARIZER_BODY;
+
       /* Generate the copying loops.  */
       gfc_trans_scalarizing_loops (&loop, &body);
 
Index: gcc/fortran/trans-array.c
===================================================================
--- a/src/gcc/fortran/trans-array.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/trans-array.c	(.../branches/gcc-4_9-branch)
@@ -3483,7 +3483,8 @@
   tree init;
   tree incr;
 
-  if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS))
+  if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS
+		      | OMPWS_SCALARIZER_BODY))
       == (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS)
       && n == loop->dimen - 1)
     {
@@ -4976,6 +4977,8 @@
       gcc_assert (ubound);
       gfc_conv_expr_type (&se, ubound, gfc_array_index_type);
       gfc_add_block_to_block (pblock, &se.pre);
+      if (ubound->expr_type == EXPR_FUNCTION)
+	se.expr = gfc_evaluate_now (se.expr, pblock);
 
       gfc_conv_descriptor_ubound_set (descriptor_block, descriptor,
 				      gfc_rank_cst[n], se.expr);
@@ -8925,7 +8928,11 @@
     return NULL;
 
   /* Normal procedure case.  */
-  sym = procedure_ref->symtree->n.sym;
+  if (procedure_ref->expr_type == EXPR_FUNCTION
+      && procedure_ref->value.function.esym)
+    sym = procedure_ref->value.function.esym;
+  else
+    sym = procedure_ref->symtree->n.sym;
 
   /* Typebound procedure case.  */
   for (ref = procedure_ref->ref; ref; ref = ref->next)
Index: gcc/fortran/class.c
===================================================================
--- a/src/gcc/fortran/class.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/class.c	(.../branches/gcc-4_9-branch)
@@ -840,7 +840,11 @@
 	  && c->ts.u.derived->f2k_derived->finalizers)
 	return true;
 
+      /* Stop infinite recursion through this function by inhibiting
+	 calls when the derived type and that of the component are
+	 the same.  */
       if (c->ts.type == BT_DERIVED
+	  && !gfc_compare_derived_types (derived, c->ts.u.derived)
 	  && !c->attr.pointer && !c->attr.allocatable
 	  && has_finalizer_component (c->ts.u.derived))
 	return true;
@@ -1596,6 +1600,7 @@
   final->ts.type = BT_INTEGER;
   final->ts.kind = 4;
   final->attr.artificial = 1;
+  final->attr.always_explicit = 1;
   final->attr.if_source = expr_null_wrapper ? IFSRC_IFBODY : IFSRC_DECL;
   if (ns->proc_name->attr.flavor == FL_MODULE)
     final->module = ns->proc_name->name;
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-4_9-branch)
@@ -3903,7 +3903,7 @@
 
       /* By default, every gfc_code is a single unit of work.  */
       ompws_flags |= OMPWS_CURR_SINGLEUNIT;
-      ompws_flags &= ~OMPWS_SCALARIZER_WS;
+      ompws_flags &= ~(OMPWS_SCALARIZER_WS | OMPWS_SCALARIZER_BODY);
 
       switch (code->op)
 	{
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,74 @@
+2016-02-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backported from mainline
+	PR fortran/61156
+	* scanner.c (add_path_to_list): If include path is not a directory,
+	issue a fatal error.
+
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/69128
+	* trans.h (OMPWS_SCALARIZER_BODY): Define.
+	(OMPWS_NOWAIT): Renumber.
+	* trans-stmt.c (gfc_trans_where_3): Only set OMPWS_SCALARIZER_WS
+	if OMPWS_SCALARIZER_BODY is not set already, and set also
+	OMPWS_SCALARIZER_BODY until the final loop creation.
+	* trans-expr.c (gfc_trans_assignment_1): Likewise.
+	* trans-openmp.c (gfc_trans_omp_workshare): Also clear
+	OMPWS_SCALARIZER_BODY.
+	* trans-array.c (gfc_trans_scalarized_loop_end): Don't create
+	OMP_FOR if OMPWS_SCALARIZER_BODY is set.
+
+2015-11-27  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/68218
+	* trans-array.c (gfc_array_init_size): Add gfc_evaluate_now() when
+	array spec in allocate is a function call.
+
+2015-11-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/68196
+	* class.c (has_finalizer_component): Prevent infinite recursion
+	through this function if the derived type and that of its
+	component are the same.
+	* trans-types.c (gfc_get_derived_type): Do the same for proc
+	pointers by ignoring the explicit interface for the component.
+
+	PR fortran/66465
+	* check.c (same_type_check): If either of the expressions is
+	BT_PROCEDURE, use the typespec from the symbol, rather than the
+	expression.
+
+2013-10-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56852
+	* primary.c (gfc_variable_attr): Avoid ICE on AR_UNKNOWN if any
+	of the index variables are untyped and errors are present.
+
+2015-10-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/66385
+	* frontend-passes.c (combine_array_constructor): Return early if
+	inside a FORALL loop.
+
+2015-08-07  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/66929
+	* trans-array.c (gfc_get_proc_ifc_for_expr): Use esym as procedure
+	symbol if available.
+
+2015-08-05  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/64921
+	* class.c (generate_finalization_wrapper): Set finalization
+	procedure symbol's always_explicit attribute.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: gcc/fortran/trans-stmt.c
===================================================================
--- a/src/gcc/fortran/trans-stmt.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/trans-stmt.c	(.../branches/gcc-4_9-branch)
@@ -4693,10 +4693,15 @@
   gfc_loopinfo loop;
   gfc_ss *edss = 0;
   gfc_ss *esss = 0;
+  bool maybe_workshare = false;
 
   /* Allow the scalarizer to workshare simple where loops.  */
-  if (ompws_flags & OMPWS_WORKSHARE_FLAG)
-    ompws_flags |= OMPWS_SCALARIZER_WS;
+  if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_BODY))
+      == OMPWS_WORKSHARE_FLAG)
+    {
+      maybe_workshare = true;
+      ompws_flags |= OMPWS_SCALARIZER_WS | OMPWS_SCALARIZER_BODY;
+    }
 
   cond = cblock->expr1;
   tdst = cblock->next->expr1;
@@ -4796,6 +4801,8 @@
   gfc_add_expr_to_block (&body, tmp);
   gfc_add_block_to_block (&body, &cse.post);
 
+  if (maybe_workshare)
+    ompws_flags &= ~OMPWS_SCALARIZER_BODY;
   gfc_trans_scalarizing_loops (&loop, &body);
   gfc_add_block_to_block (&block, &loop.pre);
   gfc_add_block_to_block (&block, &loop.post);
Index: gcc/fortran/trans-types.c
===================================================================
--- a/src/gcc/fortran/trans-types.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/trans-types.c	(.../branches/gcc-4_9-branch)
@@ -2342,6 +2342,7 @@
   gfc_component *c;
   gfc_dt_list *dt;
   gfc_namespace *ns;
+  tree tmp;
 
   if (derived->attr.unlimited_polymorphic)
     return ptr_type_node;
@@ -2490,8 +2491,19 @@
      node as DECL_CONTEXT of each FIELD_DECL.  */
   for (c = derived->components; c; c = c->next)
     {
-      if (c->attr.proc_pointer)
+      /* Prevent infinite recursion, when the procedure pointer type is
+	 the same as derived, by forcing the procedure pointer component to
+	 be built as if the explicit interface does not exist.  */
+      if (c->attr.proc_pointer
+	  && ((c->ts.type != BT_DERIVED && c->ts.type != BT_CLASS)
+	       || (c->ts.u.derived
+		   && !gfc_compare_derived_types (derived, c->ts.u.derived))))
 	field_type = gfc_get_ppc_type (c);
+      else if (c->attr.proc_pointer && derived->backend_decl)
+	{
+	  tmp = build_function_type_list (derived->backend_decl, NULL_TREE);
+	  field_type = build_pointer_type (tmp);
+	}
       else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
         field_type = c->ts.u.derived->backend_decl;
       else
Index: gcc/fortran/scanner.c
===================================================================
--- a/src/gcc/fortran/scanner.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/scanner.c	(.../branches/gcc-4_9-branch)
@@ -336,7 +336,7 @@
     }
   else if (!S_ISDIR (st.st_mode))
     {
-      gfc_warning_now ("\"%s\" is not a directory", path);
+      gfc_fatal_error ("\"%s\" is not a directory", path);
       return;
     }
 
Index: gcc/fortran/trans.h
===================================================================
--- a/src/gcc/fortran/trans.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/trans.h	(.../branches/gcc-4_9-branch)
@@ -982,7 +982,9 @@
 					   construct is not workshared.  */
 #define OMPWS_SCALARIZER_WS	4	/* Set if scalarizer should attempt
 					   to create parallel loops.  */
-#define OMPWS_NOWAIT		8	/* Use NOWAIT on OMP_FOR.  */
+#define OMPWS_SCALARIZER_BODY	8	/* Set if handling body of potential
+					   parallel loop.  */
+#define OMPWS_NOWAIT		16	/* Use NOWAIT on OMP_FOR.  */
 extern int ompws_flags;
 
 #endif /* GFC_TRANS_H */
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-4_9-branch)
@@ -1088,6 +1088,10 @@
   if (in_assoc_list)
     return false;
 
+  /* With FORALL, the BLOCKS created by create_var will cause an ICE.  */
+  if (forall_level > 0)
+    return false;
+
   op1 = e->value.op.op1;
   op2 = e->value.op.op2;
 
Index: gcc/fortran/check.c
===================================================================
--- a/src/gcc/fortran/check.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/check.c	(.../branches/gcc-4_9-branch)
@@ -399,7 +399,15 @@
 static bool
 same_type_check (gfc_expr *e, int n, gfc_expr *f, int m)
 {
-  if (gfc_compare_types (&e->ts, &f->ts))
+  gfc_typespec *ets = &e->ts;
+  gfc_typespec *fts = &f->ts;
+
+  if (e->ts.type == BT_PROCEDURE && e->symtree->n.sym)
+    ets = &e->symtree->n.sym->ts;
+  if (f->ts.type == BT_PROCEDURE && f->symtree->n.sym)
+    fts = &f->symtree->n.sym->ts;
+
+  if (gfc_compare_types (ets, fts))
     return true;
 
   gfc_error ("'%s' argument of '%s' intrinsic at %L must be the same type "
Index: gcc/fortran/primary.c
===================================================================
--- a/src/gcc/fortran/primary.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/fortran/primary.c	(.../branches/gcc-4_9-branch)
@@ -2133,7 +2133,7 @@
 symbol_attribute
 gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)
 {
-  int dimension, codimension, pointer, allocatable, target;
+  int dimension, codimension, pointer, allocatable, target, n;
   symbol_attribute attr;
   gfc_ref *ref;
   gfc_symbol *sym;
@@ -2190,7 +2190,25 @@
 	    break;
 
 	  case AR_UNKNOWN:
-	    gfc_internal_error ("gfc_variable_attr(): Bad array reference");
+	    /* If any of start, end or stride is not integer, there will
+	       already have been an error issued.  */
+	    for (n = 0; n < ref->u.ar.as->rank; n++)
+	      {
+		int errors;
+		gfc_get_errors (NULL, &errors);
+		if (((ref->u.ar.start[n]
+		      && ref->u.ar.start[n]->ts.type == BT_UNKNOWN)
+		     ||
+		     (ref->u.ar.end[n]
+		      && ref->u.ar.end[n]->ts.type == BT_UNKNOWN)
+		     ||
+		     (ref->u.ar.stride[n]
+		      && ref->u.ar.stride[n]->ts.type == BT_UNKNOWN))
+		    && errors > 0)
+		  break;
+	      }
+	    if (n == ref->u.ar.as->rank)
+	      gfc_internal_error ("gfc_variable_attr(): Bad array reference");
 	  }
 
 	break;
@@ -3138,7 +3156,8 @@
       break;
 
     default:
-      gfc_error ("Symbol at %C is not appropriate for an expression");
+      gfc_error ("Symbol '%s' at %C is not appropriate for an expression",
+		 sym->name);
       return MATCH_ERROR;
     }
 
Index: gcc/configure.ac
===================================================================
--- a/src/gcc/configure.ac	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/configure.ac	(.../branches/gcc-4_9-branch)
@@ -2098,7 +2098,7 @@
 [AS_HELP_STRING([[--with-plugin-ld=[ARG]]], [specify the plugin linker])],
 [if test x"$withval" != x; then
    ORIGINAL_PLUGIN_LD_FOR_TARGET="$withval"
-   PLUGIN_LD_SUFFIX=`echo $withval | sed -e "s,$target_alias-,,"`
+   PLUGIN_LD_SUFFIX="$withval"
  fi])
 AC_SUBST(ORIGINAL_PLUGIN_LD_FOR_TARGET)
 AC_DEFINE_UNQUOTED(PLUGIN_LD_SUFFIX, "$PLUGIN_LD_SUFFIX", [Specify plugin linker])
@@ -3858,13 +3858,13 @@
 
     gcc_GAS_CHECK_FEATURE([filds and fists mnemonics],
        gcc_cv_as_ix86_filds,,,
-       [filds mem; fists mem],,
+       [filds (%ebp); fists (%ebp)],,
        [AC_DEFINE(HAVE_AS_IX86_FILDS, 1,
          [Define if your assembler uses filds and fists mnemonics.])])
 
     gcc_GAS_CHECK_FEATURE([fildq and fistpq mnemonics],
        gcc_cv_as_ix86_fildq,,,
-       [fildq mem; fistpq mem],,
+       [fildq (%ebp); fistpq (%ebp)],,
        [AC_DEFINE(HAVE_AS_IX86_FILDQ, 1,
          [Define if your assembler uses fildq and fistq mnemonics.])])
 
@@ -5535,6 +5535,8 @@
 
   # Check whether isl_schedule_constraints_compute_schedule is available;
   # it's new in ISL-0.13.
+  # Check whether isl_options_set_schedule_serialize_sccs is available;
+  # it's new in ISL-0.15.
   saved_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $ISLINC"
   saved_LIBS="$LIBS"
@@ -5547,6 +5549,13 @@
               [ac_has_isl_schedule_constraints_compute_schedule=no])
   AC_MSG_RESULT($ac_has_isl_schedule_constraints_compute_schedule)
 
+  AC_MSG_CHECKING([Checking for isl_options_set_schedule_serialize_sccs])
+  AC_TRY_LINK([#include <isl/schedule.h>],
+              [isl_options_set_schedule_serialize_sccs (NULL, 0);],
+              [ac_has_isl_options_set_schedule_serialize_sccs=yes],
+              [ac_has_isl_options_set_schedule_serialize_sccs=no])
+  AC_MSG_RESULT($ac_has_isl_options_set_schedule_serialize_sccs)
+
   LIBS="$saved_LIBS"
   CFLAGS="$saved_CFLAGS"
 
@@ -5554,6 +5563,11 @@
      AC_DEFINE(HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE, 1,
                [Define if isl_schedule_constraints_compute_schedule exists.])
   fi
+
+  if test x"$ac_has_isl_options_set_schedule_serialize_sccs" = x"yes"; then
+     AC_DEFINE(HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS, 1,
+               [Define if isl_options_set_schedule_serialize_sccs exists.])
+  fi
 fi
 
 
Index: gcc/hw-doloop.c
===================================================================
--- a/src/gcc/hw-doloop.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/hw-doloop.c	(.../branches/gcc-4_9-branch)
@@ -636,7 +636,9 @@
 
   loops = discover_loops (&loop_stack, hooks);
 
-  if (do_reorder)
+  /* We can't enter cfglayout mode anymore if basic block partitioning
+     already happened.  */
+  if (do_reorder && !flag_reorder_blocks_and_partition)
     {
       reorder_loops (loops);
       free_loops (loops);
Index: gcc/gcse.c
===================================================================
--- a/src/gcc/gcse.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/gcse.c	(.../branches/gcc-4_9-branch)
@@ -3958,10 +3958,8 @@
 		{
 		  rtx src = SET_SRC (PATTERN (insn));
 		  rtx dest = SET_DEST (PATTERN (insn));
-		  rtx note = find_reg_equal_equiv_note (insn);
-		  rtx src_eq;
 
-		  /* Check for a simple LOAD...  */
+		  /* Check for a simple load.  */
 		  if (MEM_P (src) && simple_mem (src))
 		    {
 		      ptr = ldst_entry (src);
@@ -3976,12 +3974,11 @@
 		      invalidate_any_buried_refs (src);
 		    }
 
-		  if (note != 0 && REG_NOTE_KIND (note) == REG_EQUAL)
-		    src_eq = XEXP (note, 0);
-		  else
-		    src_eq = NULL_RTX;
-
-		  if (src_eq != NULL_RTX
+		  /* Check for a simple load through a REG_EQUAL note.  */
+		  rtx note = find_reg_equal_equiv_note (insn), src_eq;
+		  if (note
+		      && REG_NOTE_KIND (note) == REG_EQUAL
+		      && (src_eq = XEXP (note, 0))
 		      && !(MEM_P (src_eq) && simple_mem (src_eq)))
 		    invalidate_any_buried_refs (src_eq);
 
@@ -4004,7 +4001,17 @@
 		    }
 		}
 	      else
-		invalidate_any_buried_refs (PATTERN (insn));
+		{
+		  /* Invalidate all MEMs in the pattern and...  */
+		  invalidate_any_buried_refs (PATTERN (insn));
+
+		  /* ...in REG_EQUAL notes for PARALLELs with single SET.  */
+		  rtx note = find_reg_equal_equiv_note (insn), src_eq;
+		  if (note
+		      && REG_NOTE_KIND (note) == REG_EQUAL
+		      && (src_eq = XEXP (note, 0)))
+		    invalidate_any_buried_refs (src_eq);
+		}
 	    }
 	}
     }
Index: gcc/alias.c
===================================================================
--- a/src/gcc/alias.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/alias.c	(.../branches/gcc-4_9-branch)
@@ -1882,8 +1882,8 @@
 }
 
 /* Convert the address X into something we can use.  This is done by returning
-   it unchanged unless it is a value; in the latter case we call cselib to get
-   a more useful rtx.  */
+   it unchanged unless it is a VALUE or VALUE +/- constant; for VALUE
+   we call cselib to get a more useful rtx.  */
 
 rtx
 get_addr (rtx x)
@@ -1892,7 +1892,23 @@
   struct elt_loc_list *l;
 
   if (GET_CODE (x) != VALUE)
-    return x;
+    {
+      if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)
+	  && GET_CODE (XEXP (x, 0)) == VALUE
+	  && CONST_SCALAR_INT_P (XEXP (x, 1)))
+	{
+	  rtx op0 = get_addr (XEXP (x, 0));
+	  if (op0 != XEXP (x, 0))
+	    {
+	      if (GET_CODE (x) == PLUS
+		  && GET_CODE (XEXP (x, 1)) == CONST_INT)
+		return plus_constant (GET_MODE (x), op0, INTVAL (XEXP (x, 1)));
+	      return simplify_gen_binary (GET_CODE (x), GET_MODE (x),
+					  op0, XEXP (x, 1));
+	    }
+	}
+      return x;
+    }
   v = CSELIB_VAL_PTR (x);
   if (v)
     {
Index: gcc/tree-if-conv.c
===================================================================
--- a/src/gcc/tree-if-conv.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-if-conv.c	(.../branches/gcc-4_9-branch)
@@ -593,7 +593,7 @@
                    || TREE_CODE (ref_base_b) == REALPART_EXPR)
               ref_base_b = TREE_OPERAND (ref_base_b, 0);
 
-  	    if (!operand_equal_p (ref_base_a, ref_base_b, 0))
+  	    if (operand_equal_p (ref_base_a, ref_base_b, 0))
 	      {
 	        tree cb = bb_predicate (gimple_bb (DR_STMT (b)));
 
Index: gcc/tree-vect-loop.c
===================================================================
--- a/src/gcc/tree-vect-loop.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-vect-loop.c	(.../branches/gcc-4_9-branch)
@@ -2792,7 +2792,7 @@
   if (LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))
     {
       /*  FIXME: Make cost depend on complexity of individual check.  */
-      unsigned len = LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).length ();
+      unsigned len = LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).length ();
       (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,
 			    vect_prologue);
       dump_printf (MSG_NOTE,
Index: gcc/tree-data-ref.c
===================================================================
--- a/src/gcc/tree-data-ref.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-data-ref.c	(.../branches/gcc-4_9-branch)
@@ -1495,13 +1495,14 @@
   /* The case where the references are exactly the same.  */
   if (operand_equal_p (DR_REF (a), DR_REF (b), 0))
     {
-     if (loop_nest.exists ()
-        && !object_address_invariant_in_loop_p (loop_nest[0],
-       					        DR_BASE_OBJECT (a)))
-      {
-        DDR_ARE_DEPENDENT (res) = chrec_dont_know;
-        return res;
-      }
+      if ((loop_nest.exists ()
+	   && !object_address_invariant_in_loop_p (loop_nest[0],
+						   DR_BASE_OBJECT (a)))
+	  || DR_NUM_DIMENSIONS (a) == 0)
+	{
+	  DDR_ARE_DEPENDENT (res) = chrec_dont_know;
+	  return res;
+	}
       DDR_AFFINE_P (res) = true;
       DDR_ARE_DEPENDENT (res) = NULL_TREE;
       DDR_SUBSCRIPTS (res).create (DR_NUM_DIMENSIONS (a));
@@ -1533,9 +1534,9 @@
   /* If the base of the object is not invariant in the loop nest, we cannot
      analyze it.  TODO -- in fact, it would suffice to record that there may
      be arbitrary dependences in the loops where the base object varies.  */
-  if (loop_nest.exists ()
-      && !object_address_invariant_in_loop_p (loop_nest[0],
-     					      DR_BASE_OBJECT (a)))
+  if ((loop_nest.exists ()
+       && !object_address_invariant_in_loop_p (loop_nest[0], DR_BASE_OBJECT (a)))
+      || DR_NUM_DIMENSIONS (a) == 0)
     {
       DDR_ARE_DEPENDENT (res) = chrec_dont_know;
       return res;
Index: gcc/gimple-ssa-isolate-paths.c
===================================================================
--- a/src/gcc/gimple-ssa-isolate-paths.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/gimple-ssa-isolate-paths.c	(.../branches/gcc-4_9-branch)
@@ -404,10 +404,10 @@
   /* We scramble the CFG and loop structures a bit, clean up
      appropriately.  We really should incrementally update the
      loop structures, in theory it shouldn't be that hard.  */
+  free_dominance_info (CDI_POST_DOMINATORS);
   if (cfg_altered)
     {
       free_dominance_info (CDI_DOMINATORS);
-      free_dominance_info (CDI_POST_DOMINATORS);
       loops_state_set (LOOPS_NEED_FIXUP);
       return TODO_cleanup_cfg | TODO_update_ssa;
     }
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-4_9-branch)
@@ -5062,12 +5062,38 @@
 	    TREE_VALUE (link) = error_mark_node;
 	  tret = gimplify_expr (&TREE_VALUE (link), pre_p, post_p,
 				is_gimple_lvalue, fb_lvalue | fb_mayfail);
+	  if (tret != GS_ERROR)
+	    {
+	      /* Unlike output operands, memory inputs are not guaranteed
+		 to be lvalues by the FE, and while the expressions are
+		 marked addressable there, if it is e.g. a statement
+		 expression, temporaries in it might not end up being
+		 addressable.  They might be already used in the IL and thus
+		 it is too late to make them addressable now though.  */
+	      tree x = TREE_VALUE (link);
+	      while (handled_component_p (x))
+		x = TREE_OPERAND (x, 0);
+	      if (TREE_CODE (x) == MEM_REF
+		  && TREE_CODE (TREE_OPERAND (x, 0)) == ADDR_EXPR)
+		x = TREE_OPERAND (TREE_OPERAND (x, 0), 0);
+	      if ((TREE_CODE (x) == VAR_DECL
+		   || TREE_CODE (x) == PARM_DECL
+		   || TREE_CODE (x) == RESULT_DECL)
+		  && !TREE_ADDRESSABLE (x)
+		  && is_gimple_reg (x))
+		{
+		  warning_at (EXPR_LOC_OR_LOC (TREE_VALUE (link),
+					       input_location), 0,
+			      "memory input %d is not directly addressable",
+			      i);
+		  prepare_gimple_addressable (&TREE_VALUE (link), pre_p);
+		}
+	    }
 	  mark_addressable (TREE_VALUE (link));
 	  if (tret == GS_ERROR)
 	    {
-	      if (EXPR_HAS_LOCATION (TREE_VALUE (link)))
-	        input_location = EXPR_LOCATION (TREE_VALUE (link));
-	      error ("memory input %d is not directly addressable", i);
+	      error_at (EXPR_LOC_OR_LOC (TREE_VALUE (link), input_location),
+			"memory input %d is not directly addressable", i);
 	      ret = tret;
 	    }
 	}
Index: gcc/graphite-scop-detection.c
===================================================================
--- a/src/gcc/graphite-scop-detection.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-scop-detection.c	(.../branches/gcc-4_9-branch)
@@ -22,6 +22,7 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
Index: gcc/lra-constraints.c
===================================================================
--- a/src/gcc/lra-constraints.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/lra-constraints.c	(.../branches/gcc-4_9-branch)
@@ -3635,7 +3635,8 @@
 		 assigment pass and the scratch pseudo will be
 		 spilled.  Spilled scratch pseudos are transformed
 		 back to scratches at the LRA end.  */
-	      && lra_former_scratch_operand_p (curr_insn, i))
+	      && lra_former_scratch_operand_p (curr_insn, i)
+	      && lra_former_scratch_p (REGNO (op)))
 	    {
 	      int regno = REGNO (op);
 	      lra_change_class (regno, NO_REGS, "      Change to", true);
@@ -3644,6 +3645,8 @@
 		   spilled pseudo as there is only one such insn, the
 		   current one.  */
 		reg_renumber[regno] = -1;
+	      lra_assert (bitmap_single_bit_set_p
+			  (&lra_reg_info[REGNO (op)].insn_bitmap));
 	    }
 	  /* We can do an optional reload.  If the pseudo got a hard
 	     reg, we might improve the code through inheritance.  If
Index: gcc/calls.c
===================================================================
--- a/src/gcc/calls.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/calls.c	(.../branches/gcc-4_9-branch)
@@ -521,12 +521,9 @@
       /* We assume that alloca will always be called by name.  It
 	 makes no sense to pass it as a pointer-to-function to
 	 anything that does not understand its behavior.  */
-      if (((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6
-	    && name[0] == 'a'
-	    && ! strcmp (name, "alloca"))
-	   || (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16
-	       && name[0] == '_'
-	       && ! strcmp (name, "__builtin_alloca"))))
+      if (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6
+	  && name[0] == 'a'
+	  && ! strcmp (name, "alloca"))
 	flags |= ECF_MAY_BE_ALLOCA;
 
       /* Disregard prefix _, __, __x or __builtin_.  */
@@ -572,6 +569,17 @@
 	flags |= ECF_NORETURN;
     }
 
+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)
+    switch (DECL_FUNCTION_CODE (fndecl))
+      {
+      case BUILT_IN_ALLOCA:
+      case BUILT_IN_ALLOCA_WITH_ALIGN:
+	flags |= ECF_MAY_BE_ALLOCA;
+	break;
+      default:
+	break;
+      }
+
   return flags;
 }
 
@@ -2952,6 +2960,19 @@
 
       compute_argument_addresses (args, argblock, num_actuals);
 
+      /* Stack is properly aligned, pops can't safely be deferred during
+	 the evaluation of the arguments.  */
+      NO_DEFER_POP;
+
+      /* Precompute all register parameters.  It isn't safe to compute
+	 anything once we have started filling any specific hard regs.
+	 TLS symbols sometimes need a call to resolve.  Precompute
+	 register parameters before any stack pointer manipulation
+	 to avoid unaligned stack in the called function.  */
+      precompute_register_parameters (num_actuals, args, &reg_parm_seen);
+
+      OK_DEFER_POP;
+
       /* If we push args individually in reverse order, perform stack alignment
 	 before the first push (the last arg).  */
       if (PUSH_ARGS_REVERSED && argblock == 0
@@ -3019,10 +3040,6 @@
 	    }
 	}
 
-      /* Precompute all register parameters.  It isn't safe to compute anything
-	 once we have started filling any specific hard regs.  */
-      precompute_register_parameters (num_actuals, args, &reg_parm_seen);
-
       if (CALL_EXPR_STATIC_CHAIN (exp))
 	static_chain_value = expand_normal (CALL_EXPR_STATIC_CHAIN (exp));
       else
@@ -4662,6 +4679,13 @@
 	      if (XEXP (x, 0) != crtl->args.internal_arg_pointer)
 		i = INTVAL (XEXP (XEXP (x, 0), 1));
 
+	      /* arg.locate doesn't contain the pretend_args_size offset,
+		 it's part of argblock.  Ensure we don't count it in I.  */
+#ifdef STACK_GROWS_DOWNWARD
+		i -= crtl->args.pretend_args_size;
+#else
+		i += crtl->args.pretend_args_size;
+#endif
 	      /* expand_call should ensure this.  */
 	      gcc_assert (!arg->locate.offset.var
 			  && arg->locate.size.var == 0
Index: gcc/except.c
===================================================================
--- a/src/gcc/except.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/except.c	(.../branches/gcc-4_9-branch)
@@ -2223,7 +2223,7 @@
 		     VOIDmode, EXPAND_NORMAL);
   tmp = convert_memory_address (Pmode, tmp);
   if (!crtl->eh.ehr_stackadj)
-    crtl->eh.ehr_stackadj = copy_to_reg (tmp);
+    crtl->eh.ehr_stackadj = copy_addr_to_reg (tmp);
   else if (tmp != crtl->eh.ehr_stackadj)
     emit_move_insn (crtl->eh.ehr_stackadj, tmp);
 #endif
@@ -2232,7 +2232,7 @@
 		     VOIDmode, EXPAND_NORMAL);
   tmp = convert_memory_address (Pmode, tmp);
   if (!crtl->eh.ehr_handler)
-    crtl->eh.ehr_handler = copy_to_reg (tmp);
+    crtl->eh.ehr_handler = copy_addr_to_reg (tmp);
   else if (tmp != crtl->eh.ehr_handler)
     emit_move_insn (crtl->eh.ehr_handler, tmp);
 
Index: gcc/cfgexpand.c
===================================================================
--- a/src/gcc/cfgexpand.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cfgexpand.c	(.../branches/gcc-4_9-branch)
@@ -248,6 +248,15 @@
   return align / BITS_PER_UNIT;
 }
 
+/* Align given offset BASE with ALIGN.  Truncate up if ALIGN_UP is true,
+   down otherwise.  Return truncated BASE value.  */
+
+static inline unsigned HOST_WIDE_INT
+align_base (HOST_WIDE_INT base, unsigned HOST_WIDE_INT align, bool align_up)
+{
+  return align_up ? (base + align - 1) & -align : base & -align;
+}
+
 /* Allocate SIZE bytes at byte alignment ALIGN from the stack frame.
    Return the frame offset.  */
 
@@ -256,20 +265,17 @@
 {
   HOST_WIDE_INT offset, new_frame_offset;
 
-  new_frame_offset = frame_offset;
   if (FRAME_GROWS_DOWNWARD)
     {
-      new_frame_offset -= size + frame_phase;
-      new_frame_offset &= -align;
-      new_frame_offset += frame_phase;
+      new_frame_offset
+	= align_base (frame_offset - frame_phase - size,
+		      align, false) + frame_phase;
       offset = new_frame_offset;
     }
   else
     {
-      new_frame_offset -= frame_phase;
-      new_frame_offset += align - 1;
-      new_frame_offset &= -align;
-      new_frame_offset += frame_phase;
+      new_frame_offset
+	= align_base (frame_offset - frame_phase, align, true) + frame_phase;
       offset = new_frame_offset;
       new_frame_offset += size;
     }
@@ -983,13 +989,16 @@
 	  base = virtual_stack_vars_rtx;
 	  if ((flag_sanitize & SANITIZE_ADDRESS) && ASAN_STACK && pred)
 	    {
-	      HOST_WIDE_INT prev_offset = frame_offset;
+	      HOST_WIDE_INT prev_offset
+		= align_base (frame_offset,
+			      MAX (alignb, ASAN_RED_ZONE_SIZE),
+			      FRAME_GROWS_DOWNWARD);
 	      tree repr_decl = NULL_TREE;
-
 	      offset
 		= alloc_stack_frame_space (stack_vars[i].size
 					   + ASAN_RED_ZONE_SIZE,
 					   MAX (alignb, ASAN_RED_ZONE_SIZE));
+
 	      data->asan_vec.safe_push (prev_offset);
 	      data->asan_vec.safe_push (offset + stack_vars[i].size);
 	      /* Find best representative of the partition.
Index: gcc/graphite.c
===================================================================
--- a/src/gcc/graphite.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite.c	(.../branches/gcc-4_9-branch)
@@ -35,6 +35,7 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/options.h>
Index: gcc/tree-sra.c
===================================================================
--- a/src/gcc/tree-sra.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-sra.c	(.../branches/gcc-4_9-branch)
@@ -2295,7 +2295,7 @@
 
       if (covered_to < limit)
 	hole = true;
-      if (scalar)
+      if (scalar || !allow_replacements)
 	root->grp_total_scalarization = 0;
     }
 
@@ -4464,61 +4464,45 @@
   return NULL;
 }
 
-/* If the statement STMT defines an SSA_NAME of a parameter which is to be
-   removed because its value is not used, replace the SSA_NAME with a one
-   relating to a created VAR_DECL together all of its uses and return true.
-   ADJUSTMENTS is a pointer to an adjustments vector.  */
+/* If OLD_NAME, which is being defined by statement STMT, is an SSA_NAME of a
+   parameter which is to be removed because its value is not used, create a new
+   SSA_NAME relating to a replacement VAR_DECL, replace all uses of the
+   original with it and return it.  If there is no need to re-map, return NULL.
+   ADJUSTMENTS is a pointer to a vector of IPA-SRA adjustments.  */
 
-static bool
-replace_removed_params_ssa_names (gimple stmt,
+static tree
+replace_removed_params_ssa_names (tree old_name, gimple stmt,
 				  ipa_parm_adjustment_vec adjustments)
 {
   struct ipa_parm_adjustment *adj;
-  tree lhs, decl, repl, name;
+  tree decl, repl, new_name;
 
-  if (gimple_code (stmt) == GIMPLE_PHI)
-    lhs = gimple_phi_result (stmt);
-  else if (is_gimple_assign (stmt))
-    lhs = gimple_assign_lhs (stmt);
-  else if (is_gimple_call (stmt))
-    lhs = gimple_call_lhs (stmt);
-  else
-    gcc_unreachable ();
+  if (TREE_CODE (old_name) != SSA_NAME)
+    return NULL;
 
-  if (TREE_CODE (lhs) != SSA_NAME)
-    return false;
-
-  decl = SSA_NAME_VAR (lhs);
+  decl = SSA_NAME_VAR (old_name);
   if (decl == NULL_TREE
       || TREE_CODE (decl) != PARM_DECL)
-    return false;
+    return NULL;
 
   adj = get_adjustment_for_base (adjustments, decl);
   if (!adj)
-    return false;
+    return NULL;
 
   repl = get_replaced_param_substitute (adj);
-  name = make_ssa_name (repl, stmt);
+  new_name = make_ssa_name (repl, stmt);
 
   if (dump_file)
     {
       fprintf (dump_file, "replacing an SSA name of a removed param ");
-      print_generic_expr (dump_file, lhs, 0);
+      print_generic_expr (dump_file, old_name, 0);
       fprintf (dump_file, " with ");
-      print_generic_expr (dump_file, name, 0);
+      print_generic_expr (dump_file, new_name, 0);
       fprintf (dump_file, "\n");
     }
 
-  if (is_gimple_assign (stmt))
-    gimple_assign_set_lhs (stmt, name);
-  else if (is_gimple_call (stmt))
-    gimple_call_set_lhs (stmt, name);
-  else
-    gimple_phi_set_result (stmt, name);
-
-  replace_uses_by (lhs, name);
-  release_ssa_name (lhs);
-  return true;
+  replace_uses_by (old_name, new_name);
+  return new_name;
 }
 
 /* If the statement pointed to by STMT_PTR contains any expressions that need
@@ -4599,7 +4583,16 @@
       gimple_stmt_iterator gsi;
 
       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
-	replace_removed_params_ssa_names (gsi_stmt (gsi), adjustments);
+	{
+	  gimple phi = gsi_stmt (gsi);
+	  tree new_lhs, old_lhs = gimple_phi_result (phi);
+	  new_lhs = replace_removed_params_ssa_names (old_lhs, phi, adjustments);
+	  if (new_lhs)
+	    {
+	      gimple_phi_set_result (phi, new_lhs);
+	      release_ssa_name (old_lhs);
+	    }
+	}
 
       gsi = gsi_start_bb (bb);
       while (!gsi_end_p (gsi))
@@ -4619,7 +4612,6 @@
 
 	    case GIMPLE_ASSIGN:
 	      modified |= sra_ipa_modify_assign (&stmt, &gsi, adjustments);
-	      modified |= replace_removed_params_ssa_names (stmt, adjustments);
 	      break;
 
 	    case GIMPLE_CALL:
@@ -4634,8 +4626,6 @@
 		{
 		  t = gimple_call_lhs_ptr (stmt);
 		  modified |= ipa_modify_expr (t, false, adjustments);
-		  modified |= replace_removed_params_ssa_names (stmt,
-								adjustments);
 		}
 	      break;
 
@@ -4656,6 +4646,20 @@
 	      break;
 	    }
 
+	  def_operand_p defp;
+	  ssa_op_iter iter;
+	  FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)
+	    {
+	      tree old_def = DEF_FROM_PTR (defp);
+	      if (tree new_def = replace_removed_params_ssa_names (old_def, stmt,
+								   adjustments))
+		{
+		  SET_DEF (defp, new_def);
+		  release_ssa_name (old_def);
+		  modified = true;
+		}
+	    }
+
 	  if (modified)
 	    {
 	      update_stmt (stmt);
Index: gcc/graphite-optimize-isl.c
===================================================================
--- a/src/gcc/graphite-optimize-isl.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-optimize-isl.c	(.../branches/gcc-4_9-branch)
@@ -21,7 +21,9 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/set.h>
+#include <isl/union_set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
 #include <isl/schedule.h>
@@ -415,13 +417,13 @@
   return ScheduleMap;
 }
 
-static int
+static isl_stat
 getSingleMap (__isl_take isl_map *map, void *user)
 {
   isl_map **singleMap = (isl_map **) user;
   *singleMap = map;
 
-  return 0;
+  return isl_stat_ok;
 }
 
 static void
@@ -469,7 +471,11 @@
 
   isl_options_set_schedule_max_constant_term (scop->ctx, CONSTANT_BOUND);
   isl_options_set_schedule_maximize_band_depth (scop->ctx, 1);
+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
+  isl_options_set_schedule_serialize_sccs (scop->ctx, 1);
+#else
   isl_options_set_schedule_fuse (scop->ctx, ISL_SCHEDULE_FUSE_MIN);
+#endif
   isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_CONTINUE);
   schedule = isl_union_set_compute_schedule (domain, validity, proximity);
   isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_ABORT);
Index: gcc/ira.c
===================================================================
--- a/src/gcc/ira.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ira.c	(.../branches/gcc-4_9-branch)
@@ -2398,9 +2398,12 @@
   frame_pointer_needed
     = (! flag_omit_frame_pointer
        || (cfun->calls_alloca && EXIT_IGNORE_STACK)
-       /* We need the frame pointer to catch stack overflow exceptions
-	  if the stack pointer is moving.  */
-       || (flag_stack_check && STACK_CHECK_MOVING_SP)
+       /* We need the frame pointer to catch stack overflow exceptions if
+	  the stack pointer is moving (as for the alloca case just above).  */
+       || (STACK_CHECK_MOVING_SP
+	   && flag_stack_check
+	   && flag_exceptions
+	   && cfun->can_throw_non_call_exceptions)
        || crtl->accesses_prior_frames
        || (SUPPORTS_STACK_ALIGNMENT && crtl->stack_realign_needed)
        /* We need a frame pointer for all Cilk Plus functions that use
@@ -3434,9 +3437,6 @@
   return NULL_RTX;
 }
 
-/* Nonzero if we recorded an equivalence for a LABEL_REF.  */
-static int recorded_label_ref;
-
 /* Find registers that are equivalent to a single value throughout the
    compilation (either because they can be referenced in memory or are
    set once from a single constant).  Lower their priority for a
@@ -3446,10 +3446,8 @@
    value into the using insn.  If it succeeds, we can eliminate the
    register completely.
 
-   Initialize init_insns in ira_reg_equiv array.
-
-   Return non-zero if jump label rebuilding should be done.  */
-static int
+   Initialize init_insns in ira_reg_equiv array.  */
+static void
 update_equiv_regs (void)
 {
   rtx insn;
@@ -3458,10 +3456,6 @@
   bitmap cleared_regs;
   bool *pdx_subregs;
 
-  /* We need to keep track of whether or not we recorded a LABEL_REF so
-     that we know if the jump optimizer needs to be rerun.  */
-  recorded_label_ref = 0;
-
   /* Use pdx_subregs to show whether a reg is used in a paradoxical
      subreg.  */
   pdx_subregs = XCNEWVEC (bool, max_regno);
@@ -3507,7 +3501,8 @@
 
 	  /* If this insn contains more (or less) than a single SET,
 	     only mark all destinations as having no known equivalence.  */
-	  if (set == 0)
+	  if (set == 0
+	      || side_effects_p (SET_SRC (set)))
 	    {
 	      note_stores (PATTERN (insn), no_equiv, NULL);
 	      continue;
@@ -3659,17 +3654,6 @@
 		  = gen_rtx_INSN_LIST (VOIDmode, insn,
 				       ira_reg_equiv[regno].init_insns);
 
-	      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.
-		 We might end up substituting the LABEL_REF for uses of the
-		 pseudo here or later.  That kind of transformation may turn an
-		 indirect jump into a direct jump, in which case we must rerun the
-		 jump optimizer to ensure that the JUMP_LABEL fields are valid.  */
-	      if (GET_CODE (x) == LABEL_REF
-		  || (GET_CODE (x) == CONST
-		      && GET_CODE (XEXP (x, 0)) == PLUS
-		      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)))
-		recorded_label_ref = 1;
-
 	      reg_equiv[regno].replacement = x;
 	      reg_equiv[regno].src_p = &SET_SRC (set);
 	      reg_equiv[regno].loop_depth = loop_depth;
@@ -3786,9 +3770,9 @@
 	  if (! INSN_P (insn))
 	    continue;
 
-	  /* Don't substitute into a non-local goto, this confuses CFG.  */
-	  if (JUMP_P (insn)
-	      && find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))
+	  /* Don't substitute into jumps.  indirect_jump_optimize does
+	     this for anything we are prepared to handle.  */
+	  if (JUMP_P (insn))
 	    continue;
 
 	  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
@@ -3940,11 +3924,60 @@
   end_alias_analysis ();
   free (reg_equiv);
   free (pdx_subregs);
-  return recorded_label_ref;
 }
 
+/* A pass over indirect jumps, converting simple cases to direct jumps.
+   Combine does this optimization too, but only within a basic block.  */
+static void
+indirect_jump_optimize (void)
+{
+  basic_block bb;
+  bool rebuild_p = false;
+
+  FOR_EACH_BB_REVERSE_FN (bb, cfun)
+    {
+      rtx insn = BB_END (bb);
+      if (!JUMP_P (insn)
+	  || find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))
+	continue;
+
+      rtx x = pc_set (insn);
+      if (!x || !REG_P (SET_SRC (x)))
+	continue;
+
+      int regno = REGNO (SET_SRC (x));
+      if (DF_REG_DEF_COUNT (regno) == 1)
+	{
+	  df_ref def = DF_REG_DEF_CHAIN (regno);
+	  if (!DF_REF_IS_ARTIFICIAL (def))
+	    {
+	      rtx def_insn = DF_REF_INSN (def);
+	      rtx lab = NULL_RTX;
+	      rtx set = single_set (def_insn);
+	      if (set && GET_CODE (SET_SRC (set)) == LABEL_REF)
+		lab = SET_SRC (set);
+	      else
+		{
+		  rtx eqnote = find_reg_note (def_insn, REG_EQUAL, NULL_RTX);
+		  if (eqnote && GET_CODE (XEXP (eqnote, 0)) == LABEL_REF)
+		    lab = XEXP (eqnote, 0);
+		}
+	      if (lab && validate_replace_rtx (SET_SRC (x), lab, insn))
+		rebuild_p = true;
+	    }
+	}
+    }
+
+  if (rebuild_p)
+    {
+      timevar_push (TV_JUMP);
+      rebuild_jump_labels (get_insns ());
+      if (purge_all_dead_edges ())
+	delete_unreachable_blocks ();
+      timevar_pop (TV_JUMP);
+    }
+}
 
-
 /* Set up fields memory, constant, and invariant from init_insns in
    the structures of array ira_reg_equiv.  */
 static void
@@ -5187,7 +5220,6 @@
 {
   bool loops_p;
   int ira_max_point_before_emit;
-  int rebuild_p;
   bool saved_flag_caller_saves = flag_caller_saves;
   enum ira_region saved_flag_ira_region = flag_ira_region;
 
@@ -5260,6 +5292,10 @@
 
   df_clear_flags (DF_NO_INSN_RESCAN);
 
+  indirect_jump_optimize ();
+  if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))
+    df_analyze ();
+
   regstat_init_n_sets_and_refs ();
   regstat_compute_ri ();
 
@@ -5277,24 +5313,12 @@
   if (resize_reg_info () && flag_ira_loop_pressure)
     ira_set_pseudo_classes (true, ira_dump_file);
 
-  rebuild_p = update_equiv_regs ();
+  update_equiv_regs ();
   setup_reg_equiv ();
   setup_reg_equiv_init ();
 
-  if (optimize && rebuild_p)
-    {
-      timevar_push (TV_JUMP);
-      rebuild_jump_labels (get_insns ());
-      if (purge_all_dead_edges ())
-	delete_unreachable_blocks ();
-      timevar_pop (TV_JUMP);
-    }
-
   allocated_reg_info_size = max_reg_num ();
 
-  if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))
-    df_analyze ();
-
   /* It is not worth to do such improvement when we use a simple
      allocation because of -O0 usage or because the function is too
      big.  */
Index: gcc/graphite-dependences.c
===================================================================
--- a/src/gcc/graphite-dependences.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-dependences.c	(.../branches/gcc-4_9-branch)
@@ -22,6 +22,7 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
@@ -183,7 +184,7 @@
 /* Helper function used on each MAP of a isl_union_map.  Computes the
    maximal output dimension.  */
 
-static int
+static isl_stat
 max_number_of_out_dimensions (__isl_take isl_map *map, void *user)
 {
   int global_max = *((int *) user);
@@ -195,7 +196,7 @@
 
   isl_map_free (map);
   isl_space_free (space);
-  return 0;
+  return isl_stat_ok;
 }
 
 /* Extends the output dimension of MAP to MAX dimensions.  */
@@ -219,12 +220,12 @@
 
 /* Helper function for extend_schedule.  */
 
-static int
+static isl_stat
 extend_schedule_1 (__isl_take isl_map *map, void *user)
 {
   struct extend_schedule_str *str = (struct extend_schedule_str *) user;
   str->umap = isl_union_map_add_map (str->umap, extend_map (map, str->max));
-  return 0;
+  return isl_stat_ok;
 }
 
 /* Return a relation that has uniform output dimensions.  */
@@ -233,16 +234,16 @@
 extend_schedule (__isl_take isl_union_map *x)
 {
   int max = 0;
-  int res;
+  isl_stat res;
   struct extend_schedule_str str;
 
   res = isl_union_map_foreach_map (x, max_number_of_out_dimensions, (void *) &max);
-  gcc_assert (res == 0);
+  gcc_assert (res == isl_stat_ok);
 
   str.max = max;
   str.umap = isl_union_map_empty (isl_union_map_get_space (x));
   res = isl_union_map_foreach_map (x, extend_schedule_1, (void *) &str);
-  gcc_assert (res == 0);
+  gcc_assert (res == isl_stat_ok);
 
   isl_union_map_free (x);
   return str.umap;
Index: gcc/tree-ssa.c
===================================================================
--- a/src/gcc/tree-ssa.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-ssa.c	(.../branches/gcc-4_9-branch)
@@ -1474,7 +1474,8 @@
               tree lhs = gimple_get_lhs (stmt);
               if (lhs
 		  && TREE_CODE (lhs) != SSA_NAME
-		  && non_rewritable_lvalue_p (lhs))
+		  && ((code == GIMPLE_CALL && ! DECL_P (lhs))
+		      || non_rewritable_lvalue_p (lhs)))
 		{
 		  decl = get_base_address (lhs);
 		  if (DECL_P (decl))
Index: gcc/graphite-poly.c
===================================================================
--- a/src/gcc/graphite-poly.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-poly.c	(.../branches/gcc-4_9-branch)
@@ -22,6 +22,7 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
Index: gcc/graphite-poly.h
===================================================================
--- a/src/gcc/graphite-poly.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-poly.h	(.../branches/gcc-4_9-branch)
@@ -22,6 +22,11 @@
 #ifndef GCC_GRAPHITE_POLY_H
 #define GCC_GRAPHITE_POLY_H
 
+#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
+# define isl_stat int
+# define isl_stat_ok 0
+#endif
+
 typedef struct poly_dr *poly_dr_p;
 
 typedef struct poly_bb *poly_bb_p;
Index: gcc/tree-inline.c
===================================================================
--- a/src/gcc/tree-inline.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-inline.c	(.../branches/gcc-4_9-branch)
@@ -2655,8 +2655,6 @@
   else if (gimple_debug_source_bind_p (stmt))
     {
       gimple_debug_source_bind_set_var (stmt, t);
-      walk_tree (gimple_debug_source_bind_get_value_ptr (stmt),
-		 remap_gimple_op_r, &wi, NULL);
       /* When inlining and source bind refers to one of the optimized
 	 away parameters, change the source bind into normal debug bind
 	 referring to the corresponding DEBUG_EXPR_DECL that should have
@@ -2680,7 +2678,10 @@
 		    break;
 		  }
 	    }
-	}      
+	}
+      if (gimple_debug_source_bind_p (stmt))
+	walk_tree (gimple_debug_source_bind_get_value_ptr (stmt),
+		   remap_gimple_op_r, &wi, NULL);
     }
 
   processing_debug_stmt = 0;
@@ -2788,7 +2789,7 @@
 	base_stmt = gsi_stmt (gsi);
     }
 
-  note = gimple_build_debug_bind (tracked_var, value, base_stmt);
+  note = gimple_build_debug_bind (tracked_var, unshare_expr (value), base_stmt);
 
   if (bb)
     {
@@ -3849,7 +3850,7 @@
 	      return 0;
 	    else if (is_inexpensive_builtin (decl))
 	      return weights->target_builtin_call_cost;
-	    else if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)
+	    else if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
 	      {
 		/* We canonicalize x * x to pow (x, 2.0) with -ffast-math, so
 		   specialize the cheap expansion we do here.
Index: gcc/graphite-sese-to-poly.c
===================================================================
--- a/src/gcc/graphite-sese-to-poly.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-sese-to-poly.c	(.../branches/gcc-4_9-branch)
@@ -21,6 +21,7 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
@@ -2613,9 +2614,17 @@
   gcc_assert (is_gimple_assign (stmt));
   code = gimple_assign_rhs_code (stmt);
 
-  return flag_associative_math
-    && commutative_tree_code (code)
-    && associative_tree_code (code);
+  if (!commutative_tree_code (code)
+      || !associative_tree_code (code))
+    return false;
+
+  tree type = TREE_TYPE (gimple_assign_lhs (stmt));
+
+  if (FLOAT_TYPE_P (type))
+    return flag_associative_math;
+
+  return (INTEGRAL_TYPE_P (type)
+	  && TYPE_OVERFLOW_WRAPS (type));
 }
 
 /* Returns true when PHI contains an argument ARG.  */
Index: gcc/combine.c
===================================================================
--- a/src/gcc/combine.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/combine.c	(.../branches/gcc-4_9-branch)
@@ -11655,14 +11655,15 @@
 	      continue;
 	    }
 
-	  /* If this is (and:M1 (subreg:M2 X 0) (const_int C1)) where C1
+	  /* If this is (and:M1 (subreg:M1 X:M2 0) (const_int C1)) where C1
 	     fits in both M1 and M2 and the SUBREG is either paradoxical
 	     or represents the low part, permute the SUBREG and the AND
 	     and try again.  */
-	  if (GET_CODE (XEXP (op0, 0)) == SUBREG)
+	  if (GET_CODE (XEXP (op0, 0)) == SUBREG
+	      && CONST_INT_P (XEXP (op0, 1)))
 	    {
-	      unsigned HOST_WIDE_INT c1;
 	      tmode = GET_MODE (SUBREG_REG (XEXP (op0, 0)));
+	      unsigned HOST_WIDE_INT c1 = INTVAL (XEXP (op0, 1));
 	      /* Require an integral mode, to avoid creating something like
 		 (AND:SF ...).  */
 	      if (SCALAR_INT_MODE_P (tmode)
@@ -11672,18 +11673,22 @@
 		     have a defined value due to the AND operation.
 		     However, if we commute the AND inside the SUBREG then
 		     they no longer have defined values and the meaning of
-		     the code has been changed.  */
+		     the code has been changed.
+		     Also C1 should not change value in the smaller mode,
+		     see PR67028 (a positive C1 can become negative in the
+		     smaller mode, so that the AND does no longer mask the
+		     upper bits).  */
 		  && (0
 #ifdef WORD_REGISTER_OPERATIONS
 		      || (mode_width > GET_MODE_PRECISION (tmode)
-			  && mode_width <= BITS_PER_WORD)
+			  && mode_width <= BITS_PER_WORD
+			  && trunc_int_for_mode (c1, tmode) == (HOST_WIDE_INT) c1)
 #endif
 		      || (mode_width <= GET_MODE_PRECISION (tmode)
 			  && subreg_lowpart_p (XEXP (op0, 0))))
-		  && CONST_INT_P (XEXP (op0, 1))
 		  && mode_width <= HOST_BITS_PER_WIDE_INT
 		  && HWI_COMPUTABLE_MODE_P (tmode)
-		  && ((c1 = INTVAL (XEXP (op0, 1))) & ~mask) == 0
+		  && (c1 & ~mask) == 0
 		  && (c1 & ~GET_MODE_MASK (tmode)) == 0
 		  && c1 != mask
 		  && c1 != GET_MODE_MASK (tmode))
Index: gcc/df-problems.c
===================================================================
--- a/src/gcc/df-problems.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/df-problems.c	(.../branches/gcc-4_9-branch)
@@ -1340,22 +1340,23 @@
 
 
 /*----------------------------------------------------------------------------
-   LIVE AND MUST-INITIALIZED REGISTERS.
+   LIVE AND MAY-INITIALIZED REGISTERS.
 
    This problem first computes the IN and OUT bitvectors for the
-   must-initialized registers problems, which is a forward problem.
-   It gives the set of registers for which we MUST have an available
-   definition on any path from the entry block to the entry/exit of
-   a basic block.  Sets generate a definition, while clobbers kill
+   may-initialized registers problems, which is a forward problem.
+   It gives the set of registers for which we MAY have an available
+   definition, i.e. for which there is an available definition on
+   at least one path from the entry block to the entry/exit of a
+   basic block.  Sets generate a definition, while clobbers kill
    a definition.
 
    In and out bitvectors are built for each basic block and are indexed by
    regnum (see df.h for details).  In and out bitvectors in struct
-   df_live_bb_info actually refers to the must-initialized problem;
+   df_live_bb_info actually refers to the may-initialized problem;
 
    Then, the in and out sets for the LIVE problem itself are computed.
    These are the logical AND of the IN and OUT sets from the LR problem
-   and the must-initialized problem.
+   and the may-initialized problem.
 ----------------------------------------------------------------------------*/
 
 /* Private data used to verify the solution for this problem.  */
@@ -1566,7 +1567,7 @@
 }
 
 
-/* Transfer function for the forwards must-initialized problem.  */
+/* Transfer function for the forwards may-initialized problem.  */
 
 static bool
 df_live_transfer_function (int bb_index)
@@ -1590,7 +1591,7 @@
 }
 
 
-/* And the LR info with the must-initialized registers, to produce the LIVE info.  */
+/* And the LR info with the may-initialized registers to produce the LIVE info.  */
 
 static void
 df_live_finalize (bitmap all_blocks)
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-4_9-branch)
@@ -1542,9 +1542,6 @@
 	esac
 	with_tune_32=${with_tune_32:-generic}
 	case ${target} in
-	*-*-solaris2.9*)
-		tm_file="${tm_file} i386/sol2-9.h"
-		;;
 	*-*-solaris2.1[0-9]*)
 		tm_file="${tm_file} i386/x86-64.h i386/sol2-bi.h sol2-bi.h"
 		tm_defines="${tm_defines} TARGET_BI_ARCH=1"
Index: gcc/gimple.c
===================================================================
--- a/src/gcc/gimple.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/gimple.c	(.../branches/gcc-4_9-branch)
@@ -1854,6 +1854,11 @@
 				       && TYPE_OVERFLOW_TRAPS (t)),
 				      div));
 
+    case GIMPLE_COND:
+      t = TREE_TYPE (gimple_cond_lhs (s));
+      return operation_could_trap_p (gimple_cond_code (s),
+				     FLOAT_TYPE_P (t), false, NULL_TREE);
+
     default:
       break;
     }
Index: gcc/gimple-expr.c
===================================================================
--- a/src/gcc/gimple-expr.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/gimple-expr.c	(.../branches/gcc-4_9-branch)
@@ -374,6 +374,11 @@
   TREE_USED (copy) = 1;
   DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;
   DECL_ATTRIBUTES (copy) = DECL_ATTRIBUTES (var);
+  if (DECL_USER_ALIGN (var))
+    {
+      DECL_ALIGN (copy) = DECL_ALIGN (var);
+      DECL_USER_ALIGN (copy) = 1;
+    }
 
   return copy;
 }
Index: gcc/passes.c
===================================================================
--- a/src/gcc/passes.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/passes.c	(.../branches/gcc-4_9-branch)
@@ -2079,7 +2079,7 @@
     check_profile_consistency (pass->static_pass_number, 1, true);
 
   if (dump_file)
-    do_per_function (execute_function_dump, NULL);
+    do_per_function (execute_function_dump, pass);
   pass_fini_dump_file (pass);
 
   current_pass = NULL;
Index: gcc/ree.c
===================================================================
--- a/src/gcc/ree.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/ree.c	(.../branches/gcc-4_9-branch)
@@ -783,6 +783,12 @@
       if (state->defs_list.length () != 1)
 	return false;
 
+      /* We don't have the structure described above if there are
+	 conditional moves in between the def and the candidate,
+	 and we will not handle them correctly.  See PR68194.  */
+      if (state->copies_list.length () > 0)
+	return false;
+
       /* We require the candidate not already be modified.  It may,
 	 for example have been changed from a (sign_extend (reg))
 	 into (zero_extend (sign_extend (reg))).
@@ -793,6 +799,14 @@
       if (state->modified[INSN_UID (cand->insn)].kind != EXT_MODIFIED_NONE)
 	return false;
 
+      enum machine_mode dst_mode = GET_MODE (SET_DEST (PATTERN (cand->insn)));
+      rtx src_reg = get_extended_src_reg (SET_SRC (PATTERN (cand->insn)));
+
+      /* Ensure the number of hard registers of the copy match.  */
+      if (HARD_REGNO_NREGS (REGNO (src_reg), dst_mode)
+	  != HARD_REGNO_NREGS (REGNO (src_reg), GET_MODE (src_reg)))
+	return false;
+
       /* There's only one reaching def.  */
       rtx def_insn = state->defs_list[0];
 
@@ -842,7 +856,7 @@
       start_sequence ();
       rtx pat = PATTERN (cand->insn);
       rtx new_dst = gen_rtx_REG (GET_MODE (SET_DEST (pat)),
-                                 REGNO (XEXP (SET_SRC (pat), 0)));
+                                 REGNO (get_extended_src_reg (SET_SRC (pat))));
       rtx new_src = gen_rtx_REG (GET_MODE (SET_DEST (pat)),
                                  REGNO (SET_DEST (pat)));
       emit_move_insn (new_dst, new_src);
Index: gcc/config/s390/s390.c
===================================================================
--- a/src/gcc/config/s390/s390.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/s390/s390.c	(.../branches/gcc-4_9-branch)
@@ -8595,6 +8595,10 @@
 	    emit_move_insn (gen_rtx_REG (DImode, cfun_gpr_save_slot (i)),
 			    gen_rtx_REG (DImode, i));
 	  RTX_FRAME_RELATED_P (insn) = 1;
+	  /* This prevents dwarf2cfi from interpreting the set.  Doing
+	     so it might emit def_cfa_register infos setting an FPR as
+	     new CFA.  */
+	  add_reg_note (insn, REG_CFA_REGISTER, PATTERN (insn));
 	}
     }
 }
Index: gcc/config/sparc/driver-sparc.c
===================================================================
--- a/src/gcc/config/sparc/driver-sparc.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/driver-sparc.c	(.../branches/gcc-4_9-branch)
@@ -73,6 +73,7 @@
   { "UltraSparc T2",	"niagara2" },
   { "UltraSparc T3",	"niagara3" },
   { "UltraSparc T4",	"niagara4" },
+  { "LEON",		"leon3" },
 #endif
   { NULL,	NULL }
   };
Index: gcc/config/sparc/t-rtems
===================================================================
--- a/src/gcc/config/sparc/t-rtems	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/t-rtems	(.../branches/gcc-4_9-branch)
@@ -17,15 +17,20 @@
 # <http://www.gnu.org/licenses/>.
 #
 
-MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3/mcpu=leon3v7 muser-mode
-MULTILIB_DIRNAMES = soft v8 leon3 leon3v7 user-mode
+MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3/mcpu=leon3v7/mcpu=leon \
+		   mfix-ut699/mfix-at697f
+MULTILIB_DIRNAMES = soft v8 leon3 leon3v7 leon ut699 at697f
 MULTILIB_MATCHES = msoft-float=mno-fpu
 
-MULTILIB_EXCEPTIONS = muser-mode
-MULTILIB_EXCEPTIONS += mcpu=leon3
-MULTILIB_EXCEPTIONS += mcpu=leon3v7
-MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3
-MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3v7
-MULTILIB_EXCEPTIONS += msoft-float/muser-mode
-MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/muser-mode
-MULTILIB_EXCEPTIONS += mcpu=v8/muser-mode
+MULTILIB_EXCEPTIONS = mfix-ut699
+MULTILIB_EXCEPTIONS += msoft-float/mfix-ut699
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/mfix-ut699
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3*/mfix-ut699
+MULTILIB_EXCEPTIONS += mcpu=v8/mfix-ut699
+MULTILIB_EXCEPTIONS += mcpu=leon3*/mfix-ut699
+MULTILIB_EXCEPTIONS += mfix-at697f
+MULTILIB_EXCEPTIONS += msoft-float/mfix-at697f
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/mfix-at697f
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3*/mfix-at697f
+MULTILIB_EXCEPTIONS += mcpu=v8/mfix-at697f
+MULTILIB_EXCEPTIONS += mcpu=leon3*/mfix-at697f
Index: gcc/config/sparc/sparc.md
===================================================================
--- a/src/gcc/config/sparc/sparc.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/sparc.md	(.../branches/gcc-4_9-branch)
@@ -6398,7 +6398,6 @@
   ""
 {
   rtx valreg1 = gen_rtx_REG (DImode, 8);
-  rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
   rtx result = operands[1];
 
   /* Pass constm1 to indicate that it may expect a structure value, but
@@ -6407,8 +6406,12 @@
 
   /* Save the function value registers.  */
   emit_move_insn (adjust_address (result, DImode, 0), valreg1);
-  emit_move_insn (adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8),
-				  valreg2);
+  if (TARGET_FPU)
+    {
+      rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
+      emit_move_insn (adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8),
+		      valreg2);
+    }
 
   /* The optimizer does not know that the call sets the function value
      registers we stored in the result block.  We avoid problems by
@@ -6620,7 +6623,6 @@
   ""
 {
   rtx valreg1 = gen_rtx_REG (DImode, 24);
-  rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
   rtx result = operands[0];
 
   if (! TARGET_ARCH64)
@@ -6637,15 +6639,19 @@
       emit_insn (gen_update_return (rtnreg, value));
     }
 
-  /* Reload the function value registers.  */
+  /* Reload the function value registers.
+     Put USE insns before the return.  */
   emit_move_insn (valreg1, adjust_address (result, DImode, 0));
-  emit_move_insn (valreg2,
-		  adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8));
-
-  /* Put USE insns before the return.  */
   emit_use (valreg1);
-  emit_use (valreg2);
 
+  if (TARGET_FPU)
+    {
+      rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
+      emit_move_insn (valreg2,
+		      adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8));
+      emit_use (valreg2);
+    }
+
   /* Construct the return.  */
   expand_naked_return ();
 
Index: gcc/config/sparc/sparc.opt
===================================================================
--- a/src/gcc/config/sparc/sparc.opt	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/sparc.opt	(.../branches/gcc-4_9-branch)
@@ -114,8 +114,8 @@
 Optimize tail call instructions in assembler and linker
 
 muser-mode
-Target Report Mask(USER_MODE)
-Do not generate code that can only run in supervisor mode
+Target Report InverseMask(SV_MODE)
+Do not generate code that can only run in supervisor mode (default)
 
 mcpu=
 Target RejectNegative Joined Var(sparc_cpu_and_features) Enum(sparc_processor_type) Init(PROCESSOR_V7)
Index: gcc/config/sparc/sync.md
===================================================================
--- a/src/gcc/config/sparc/sync.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/sync.md	(.../branches/gcc-4_9-branch)
@@ -222,10 +222,10 @@
 	  UNSPECV_CAS))]
   "TARGET_LEON3"
 {
-  if (TARGET_USER_MODE)
+  if (TARGET_SV_MODE)
+    return "casa\t%1 0xb, %2, %0"; /* ASI for supervisor data space.  */
+  else
     return "casa\t%1 0xa, %2, %0"; /* ASI for user data space.  */
-  else
-    return "casa\t%1 0xb, %2, %0"; /* ASI for supervisor data space.  */
 }
   [(set_attr "type" "multi")])
 
Index: gcc/config/sparc/sp-elf.h
===================================================================
--- a/src/gcc/config/sparc/sp-elf.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/sp-elf.h	(.../branches/gcc-4_9-branch)
@@ -53,6 +53,10 @@
 #undef  ASM_GENERATE_INTERNAL_LABEL
 #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)	\
   sprintf ((LABEL), "*.L%s%ld", (PREFIX), (long)(NUM))
+
+/* We use GNU ld so undefine this so that attribute((init_priority)) works.  */
+#undef CTORS_SECTION_ASM_OP
+#undef DTORS_SECTION_ASM_OP
 
 /* ??? Inherited from sol2.h.  Probably wrong.  */
 #undef WCHAR_TYPE
Index: gcc/config/sparc/sparc.c
===================================================================
--- a/src/gcc/config/sparc/sparc.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/sparc.c	(.../branches/gcc-4_9-branch)
@@ -4980,13 +4980,18 @@
 
   /* Calculate space needed for global registers.  */
   if (TARGET_ARCH64)
-    for (i = 0; i < 8; i++)
-      if (save_global_or_fp_reg_p (i, 0))
-	n_global_fp_regs += 2;
+    {
+      for (i = 0; i < 8; i++)
+	if (save_global_or_fp_reg_p (i, 0))
+	  n_global_fp_regs += 2;
+    }
   else
-    for (i = 0; i < 8; i += 2)
-      if (save_global_or_fp_reg_p (i, 0) || save_global_or_fp_reg_p (i + 1, 0))
-	n_global_fp_regs += 2;
+    {
+      for (i = 0; i < 8; i += 2)
+	if (save_global_or_fp_reg_p (i, 0)
+	    || save_global_or_fp_reg_p (i + 1, 0))
+	  n_global_fp_regs += 2;
+    }
 
   /* In the flat window model, find out which local and in registers need to
      be saved.  We don't reserve space in the current frame for them as they
@@ -7384,9 +7389,10 @@
 	mode = word_mode;
     }
 
-  /* We should only have pointer and integer types at this point.  This must
-     match sparc_promote_function_mode.  */
+  /* We should only have pointer and integer types at this point, except with
+     -freg-struct-return.  This must match sparc_promote_function_mode.  */
   else if (TARGET_ARCH32
+	   && !(type && AGGREGATE_TYPE_P (type))
 	   && mclass == MODE_INT
 	   && GET_MODE_SIZE (mode) < UNITS_PER_WORD)
     mode = word_mode;
@@ -7427,7 +7433,7 @@
 static bool
 sparc_function_value_regno_p (const unsigned int regno)
 {
-  return (regno == 8 || regno == 32);
+  return (regno == 8 || (TARGET_FPU && regno == 32));
 }
 
 /* Do what is necessary for `va_start'.  We look at the current function
Index: gcc/config/sparc/leon.md
===================================================================
--- a/src/gcc/config/sparc/leon.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sparc/leon.md	(.../branches/gcc-4_9-branch)
@@ -24,12 +24,14 @@
 (define_cpu_unit "leon_memory" "leon")
 
 (define_insn_reservation "leon_load" 1
-  (and (eq_attr "cpu" "leon") (eq_attr "type" "load,sload"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7")
+       (and (eq_attr "fix_ut699" "false") (eq_attr "type" "load,sload")))
   "leon_memory")
 
 ;; Use a double reservation to work around the load pipeline hazard on UT699.
-(define_insn_reservation "leon3_load" 1
-  (and (eq_attr "cpu" "leon3,leon3v7") (eq_attr "type" "load,sload"))
+(define_insn_reservation "ut699_load" 1
+  (and (eq_attr "cpu" "leon,leon3,leon3v7")
+       (and (eq_attr "fix_ut699" "true") (eq_attr "type" "load,sload")))
   "leon_memory*2")
 
 (define_insn_reservation "leon_store" 2
Index: gcc/config/i386/sol2-9.h
===================================================================
--- a/src/gcc/config/i386/sol2-9.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/sol2-9.h	(.../branches/gcc-4_9-branch)
@@ -1,23 +0,0 @@
-/* Target definitions for GCC for Intel 80386 running Solaris 9
-   Copyright (C) 2014 Free Software Foundation, Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-
-/* Solaris 9 only guarantees 4-byte stack alignment as required by the i386
-   psABI, so realign it as necessary for SSE instructions.  */
-#undef STACK_REALIGN_DEFAULT
-#define STACK_REALIGN_DEFAULT 1
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-4_9-branch)
@@ -1782,7 +1782,7 @@
   [(set (match_operand:XI 0 "nonimmediate_operand")
 	(match_operand:XI 1 "general_operand"))]
   "TARGET_AVX512F"
-  "ix86_expand_move (XImode, operands); DONE;")
+  "ix86_expand_vector_move (XImode, operands); DONE;")
 
 ;; Reload patterns to support multi-word load/store
 ;; with non-offsetable address.
@@ -1822,11 +1822,11 @@
   [(set (match_operand:OI 0 "nonimmediate_operand")
 	(match_operand:OI 1 "general_operand"))]
   "TARGET_AVX"
-  "ix86_expand_move (OImode, operands); DONE;")
+  "ix86_expand_vector_move (OImode, operands); DONE;")
 
 (define_expand "movti"
   [(set (match_operand:TI 0 "nonimmediate_operand")
-	(match_operand:TI 1 "nonimmediate_operand"))]
+	(match_operand:TI 1 "general_operand"))]
   "TARGET_64BIT || TARGET_SSE"
 {
   if (TARGET_64BIT)
@@ -4901,11 +4901,11 @@
   /* The DImode arrived in a pair of integral registers (e.g. %edx:%eax).
      Assemble the 64-bit DImode value in an xmm register.  */
   emit_insn (gen_sse2_loadld (operands[3], CONST0_RTX (V4SImode),
-			      gen_rtx_SUBREG (SImode, operands[1], 0)));
+			      gen_lowpart (SImode, operands[1])));
   emit_insn (gen_sse2_loadld (operands[4], CONST0_RTX (V4SImode),
-			      gen_rtx_SUBREG (SImode, operands[1], 4)));
+			      gen_highpart (SImode, operands[1])));
   emit_insn (gen_vec_interleave_lowv4si (operands[3], operands[3],
-  	    				 operands[4]));
+					 operands[4]));
 
   operands[3] = gen_rtx_REG (DImode, REGNO (operands[3]));
 })
@@ -10518,6 +10518,7 @@
   [(set (match_dup 2) (match_dup 1))
    (set (match_dup 0) (zero_extend:DI (match_dup 2)))]
 {
+  operands[1] = shallow_copy_rtx (operands[1]);
   PUT_MODE (operands[1], QImode);
   operands[2] = gen_lowpart (QImode, operands[0]);
 })
@@ -10535,6 +10536,7 @@
    (parallel [(set (match_dup 0) (zero_extend:SI (match_dup 2)))
 	      (clobber (reg:CC FLAGS_REG))])]
 {
+  operands[1] = shallow_copy_rtx (operands[1]);
   PUT_MODE (operands[1], QImode);
   operands[2] = gen_lowpart (QImode, operands[0]);
 })
@@ -10550,6 +10552,7 @@
   [(set (match_dup 2) (match_dup 1))
    (set (match_dup 0) (zero_extend:SI (match_dup 2)))]
 {
+  operands[1] = shallow_copy_rtx (operands[1]);
   PUT_MODE (operands[1], QImode);
   operands[2] = gen_lowpart (QImode, operands[0]);
 })
@@ -10587,7 +10590,10 @@
 	    (const_int 0)))]
   ""
   [(set (match_dup 0) (match_dup 1))]
-  "PUT_MODE (operands[1], QImode);")
+{
+  operands[1] = shallow_copy_rtx (operands[1]);
+  PUT_MODE (operands[1], QImode);
+})
 
 (define_split
   [(set (strict_low_part (match_operand:QI 0 "nonimmediate_operand"))
@@ -10596,7 +10602,10 @@
 	    (const_int 0)))]
   ""
   [(set (match_dup 0) (match_dup 1))]
-  "PUT_MODE (operands[1], QImode);")
+{
+  operands[1] = shallow_copy_rtx (operands[1]);
+  PUT_MODE (operands[1], QImode);
+})
 
 (define_split
   [(set (match_operand:QI 0 "nonimmediate_operand")
@@ -10606,15 +10615,15 @@
   ""
   [(set (match_dup 0) (match_dup 1))]
 {
-  rtx new_op1 = copy_rtx (operands[1]);
-  operands[1] = new_op1;
-  PUT_MODE (new_op1, QImode);
-  PUT_CODE (new_op1, ix86_reverse_condition (GET_CODE (new_op1),
-					     GET_MODE (XEXP (new_op1, 0))));
+  operands[1] = shallow_copy_rtx (operands[1]);
+  PUT_MODE (operands[1], QImode);
+  PUT_CODE (operands[1],
+	    ix86_reverse_condition (GET_CODE (operands[1]),
+				    GET_MODE (XEXP (operands[1], 0))));
 
   /* Make sure that (a) the CCmode we have for the flags is strong
      enough for the reversed compare or (b) we have a valid FP compare.  */
-  if (! ix86_comparison_operator (new_op1, VOIDmode))
+  if (! ix86_comparison_operator (operands[1], VOIDmode))
     FAIL;
 })
 
@@ -10626,15 +10635,15 @@
   ""
   [(set (match_dup 0) (match_dup 1))]
 {
-  rtx new_op1 = copy_rtx (operands[1]);
-  operands[1] = new_op1;
-  PUT_MODE (new_op1, QImode);
-  PUT_CODE (new_op1, ix86_reverse_condition (GET_CODE (new_op1),
-					     GET_MODE (XEXP (new_op1, 0))));
+  operands[1] = shallow_copy_rtx (operands[1]);
+  PUT_MODE (operands[1], QImode);
+  PUT_CODE (operands[1],
+  	    ix86_reverse_condition (GET_CODE (operands[1]),
+				    GET_MODE (XEXP (operands[1], 0))));
 
   /* Make sure that (a) the CCmode we have for the flags is strong
      enough for the reversed compare or (b) we have a valid FP compare.  */
-  if (! ix86_comparison_operator (new_op1, VOIDmode))
+  if (! ix86_comparison_operator (operands[1], VOIDmode))
     FAIL;
 })
 
@@ -10717,7 +10726,10 @@
 	(if_then_else (match_dup 0)
 		      (label_ref (match_dup 1))
 		      (pc)))]
-  "PUT_MODE (operands[0], VOIDmode);")
+{
+  operands[0] = shallow_copy_rtx (operands[0]);
+  PUT_MODE (operands[0], VOIDmode);
+})
 
 (define_split
   [(set (pc)
@@ -10732,15 +10744,15 @@
 		      (label_ref (match_dup 1))
 		      (pc)))]
 {
-  rtx new_op0 = copy_rtx (operands[0]);
-  operands[0] = new_op0;
-  PUT_MODE (new_op0, VOIDmode);
-  PUT_CODE (new_op0, ix86_reverse_condition (GET_CODE (new_op0),
-					     GET_MODE (XEXP (new_op0, 0))));
+  operands[0] = shallow_copy_rtx (operands[0]);
+  PUT_MODE (operands[0], VOIDmode);
+  PUT_CODE (operands[0],
+  	    ix86_reverse_condition (GET_CODE (operands[0]),
+				    GET_MODE (XEXP (operands[0], 0))));
 
   /* Make sure that (a) the CCmode we have for the flags is strong
      enough for the reversed compare or (b) we have a valid FP compare.  */
-  if (! ix86_comparison_operator (new_op0, VOIDmode))
+  if (! ix86_comparison_operator (operands[0], VOIDmode))
     FAIL;
 })
 
@@ -10777,7 +10789,7 @@
 		      (pc)))]
 {
   operands[2] = simplify_gen_subreg (<MODE>mode, operands[2], QImode, 0);
-
+  operands[0] = shallow_copy_rtx (operands[0]);
   PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));
 })
 
@@ -10810,7 +10822,7 @@
 		      (pc)))]
 {
   operands[2] = simplify_gen_subreg (<MODE>mode, operands[2], SImode, 0);
-
+  operands[0] = shallow_copy_rtx (operands[0]);
   PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));
 })
 
@@ -10846,7 +10858,7 @@
 		      (pc)))]
 {
   operands[2] = simplify_gen_subreg (<MODE>mode, operands[2], SImode, 0);
-
+  operands[0] = shallow_copy_rtx (operands[0]);
   PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));
 })
 
@@ -10878,7 +10890,7 @@
 		      (pc)))]
 {
   operands[2] = simplify_gen_subreg (SImode, operands[2], QImode, 0);
-
+  operands[0] = shallow_copy_rtx (operands[0]);
   PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));
 })
 
@@ -10914,7 +10926,10 @@
 	(if_then_else (match_op_dup 0 [(reg:CCC FLAGS_REG) (const_int 0)])
 		      (label_ref (match_dup 4))
 		      (pc)))]
-  "PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));")
+{
+  operands[0] = shallow_copy_rtx (operands[0]);
+  PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));
+})
 
 ;; Define combination compare-and-branch fp compare instructions to help
 ;; combine.
@@ -11569,10 +11584,14 @@
 ;; We need to disable this for TARGET_SEH, as otherwise
 ;; shrink-wrapped prologue gets enabled too.  This might exceed
 ;; the maximum size of prologue in unwind information.
+;; Also disallow shrink-wrapping if using stack slot to pass the
+;; static chain pointer - the first instruction has to be pushl %esi
+;; and it can't be moved around, as we use alternate entry points
+;; in that case.
 
 (define_expand "simple_return"
   [(simple_return)]
-  "!TARGET_SEH"
+  "!TARGET_SEH && !ix86_static_chain_on_stack"
 {
   if (crtl->args.pops_args)
     {
@@ -12638,7 +12657,8 @@
 	(unspec:SI
 	 [(match_operand:SI 1 "register_operand" "b")
 	  (match_operand 2 "tls_symbolic_operand")
-	  (match_operand 3 "constant_call_address_operand" "z")]
+	  (match_operand 3 "constant_call_address_operand" "z")
+	  (reg:SI SP_REG)]
 	 UNSPEC_TLS_GD))
    (clobber (match_scratch:SI 4 "=d"))
    (clobber (match_scratch:SI 5 "=c"))
@@ -12663,11 +12683,14 @@
     [(set (match_operand:SI 0 "register_operand")
 	  (unspec:SI [(match_operand:SI 2 "register_operand")
 		      (match_operand 1 "tls_symbolic_operand")
-		      (match_operand 3 "constant_call_address_operand")]
+		      (match_operand 3 "constant_call_address_operand")
+		      (reg:SI SP_REG)]
 		     UNSPEC_TLS_GD))
      (clobber (match_scratch:SI 4))
      (clobber (match_scratch:SI 5))
-     (clobber (reg:CC FLAGS_REG))])])
+     (clobber (reg:CC FLAGS_REG))])]
+  ""
+  "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
 
 (define_insn "*tls_global_dynamic_64_<mode>"
   [(set (match_operand:P 0 "register_operand" "=a")
@@ -12674,7 +12697,8 @@
 	(call:P
 	 (mem:QI (match_operand 2 "constant_call_address_operand" "z"))
 	 (match_operand 3)))
-   (unspec:P [(match_operand 1 "tls_symbolic_operand")]
+   (unspec:P [(match_operand 1 "tls_symbolic_operand")
+	      (reg:P SP_REG)]
 	     UNSPEC_TLS_GD)]
   "TARGET_64BIT"
 {
@@ -12698,8 +12722,9 @@
 	 (mem:QI (plus:DI (match_operand:DI 2 "register_operand" "b")
 			  (match_operand:DI 3 "immediate_operand" "i")))
 	 (match_operand 4)))
-   (unspec:DI [(match_operand 1 "tls_symbolic_operand")]
-	     UNSPEC_TLS_GD)]
+   (unspec:DI [(match_operand 1 "tls_symbolic_operand")
+	       (reg:DI SP_REG)]
+	      UNSPEC_TLS_GD)]
   "TARGET_64BIT && ix86_cmodel == CM_LARGE_PIC && !TARGET_PECOFF
    && GET_CODE (operands[3]) == CONST
    && GET_CODE (XEXP (operands[3], 0)) == UNSPEC
@@ -12720,15 +12745,18 @@
 	  (call:P
 	   (mem:QI (match_operand 2))
 	   (const_int 0)))
-     (unspec:P [(match_operand 1 "tls_symbolic_operand")]
+     (unspec:P [(match_operand 1 "tls_symbolic_operand")
+		(reg:P SP_REG)]
 	       UNSPEC_TLS_GD)])]
-  "TARGET_64BIT")
+  "TARGET_64BIT"
+  "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
 
 (define_insn "*tls_local_dynamic_base_32_gnu"
   [(set (match_operand:SI 0 "register_operand" "=a")
 	(unspec:SI
 	 [(match_operand:SI 1 "register_operand" "b")
-	  (match_operand 2 "constant_call_address_operand" "z")]
+	  (match_operand 2 "constant_call_address_operand" "z")
+	  (reg:SI SP_REG)]
 	 UNSPEC_TLS_LD_BASE))
    (clobber (match_scratch:SI 3 "=d"))
    (clobber (match_scratch:SI 4 "=c"))
@@ -12754,11 +12782,14 @@
      [(set (match_operand:SI 0 "register_operand")
 	   (unspec:SI
 	    [(match_operand:SI 1 "register_operand")
-	     (match_operand 2 "constant_call_address_operand")]
+	     (match_operand 2 "constant_call_address_operand")
+	     (reg:SI SP_REG)]
 	    UNSPEC_TLS_LD_BASE))
       (clobber (match_scratch:SI 3))
       (clobber (match_scratch:SI 4))
-      (clobber (reg:CC FLAGS_REG))])])
+      (clobber (reg:CC FLAGS_REG))])]
+  ""
+  "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
 
 (define_insn "*tls_local_dynamic_base_64_<mode>"
   [(set (match_operand:P 0 "register_operand" "=a")
@@ -12765,7 +12796,7 @@
 	(call:P
 	 (mem:QI (match_operand 1 "constant_call_address_operand" "z"))
 	 (match_operand 2)))
-   (unspec:P [(const_int 0)] UNSPEC_TLS_LD_BASE)]
+   (unspec:P [(reg:P SP_REG)] UNSPEC_TLS_LD_BASE)]
   "TARGET_64BIT"
 {
   output_asm_insn
@@ -12783,7 +12814,7 @@
 	 (mem:QI (plus:DI (match_operand:DI 1 "register_operand" "b")
 			  (match_operand:DI 2 "immediate_operand" "i")))
 	 (match_operand 3)))
-   (unspec:DI [(const_int 0)] UNSPEC_TLS_LD_BASE)]
+   (unspec:DI [(reg:DI SP_REG)] UNSPEC_TLS_LD_BASE)]
   "TARGET_64BIT && ix86_cmodel == CM_LARGE_PIC && !TARGET_PECOFF
    && GET_CODE (operands[2]) == CONST
    && GET_CODE (XEXP (operands[2], 0)) == UNSPEC
@@ -12804,8 +12835,9 @@
 	   (call:P
 	    (mem:QI (match_operand 1))
 	    (const_int 0)))
-      (unspec:P [(const_int 0)] UNSPEC_TLS_LD_BASE)])]
-  "TARGET_64BIT")
+      (unspec:P [(reg:P SP_REG)] UNSPEC_TLS_LD_BASE)])]
+  "TARGET_64BIT"
+  "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
 
 ;; Local dynamic of a single variable is a lose.  Show combine how
 ;; to convert that back to global dynamic.
@@ -12814,7 +12846,8 @@
   [(set (match_operand:SI 0 "register_operand" "=a")
 	(plus:SI
 	 (unspec:SI [(match_operand:SI 1 "register_operand" "b")
-		     (match_operand 2 "constant_call_address_operand" "z")]
+		     (match_operand 2 "constant_call_address_operand" "z")
+		     (reg:SI SP_REG)]
 		    UNSPEC_TLS_LD_BASE)
 	 (const:SI (unspec:SI
 		    [(match_operand 3 "tls_symbolic_operand")]
@@ -12827,7 +12860,8 @@
   ""
   [(parallel
      [(set (match_dup 0)
-	   (unspec:SI [(match_dup 1) (match_dup 3) (match_dup 2)]
+	   (unspec:SI [(match_dup 1) (match_dup 3) (match_dup 2)
+		       (reg:SI SP_REG)]
 		      UNSPEC_TLS_GD))
       (clobber (match_dup 4))
       (clobber (match_dup 5))
@@ -16721,6 +16755,7 @@
   operands[1] = gen_lowpart (SImode, operands[1]);
   if (GET_CODE (operands[3]) != ASHIFT)
     operands[2] = gen_lowpart (SImode, operands[2]);
+  operands[3] = shallow_copy_rtx (operands[3]);
   PUT_MODE (operands[3], SImode);
 })
 
@@ -16890,8 +16925,8 @@
 ;; lifetime information then.
 
 (define_peephole2
-  [(set (match_operand:SWI124 0 "nonimmediate_operand")
-	(not:SWI124 (match_operand:SWI124 1 "nonimmediate_operand")))]
+  [(set (match_operand:SWI124 0 "nonimmediate_gr_operand")
+	(not:SWI124 (match_operand:SWI124 1 "nonimmediate_gr_operand")))]
   "optimize_insn_for_speed_p ()
    && ((TARGET_NOT_UNPAIRABLE
 	&& (!MEM_P (operands[0])
@@ -17035,8 +17070,10 @@
                      [(match_dup 0)
                       (match_operand 2 "memory_operand")]))]
   "REGNO (operands[0]) != REGNO (operands[1])
-   && ((MMX_REG_P (operands[0]) && MMX_REG_P (operands[1])) 
-       || (SSE_REG_P (operands[0]) && SSE_REG_P (operands[1])))"
+   && ((MMX_REGNO_P (REGNO (operands[0]))
+        && MMX_REGNO_P (REGNO (operands[1]))) 
+       || (SSE_REGNO_P (REGNO (operands[0]))
+           && SSE_REGNO_P (REGNO (operands[1]))))"
   [(set (match_dup 0) (match_dup 2))
    (set (match_dup 0)
         (match_op_dup 3 [(match_dup 0) (match_dup 1)]))])
@@ -17184,7 +17221,7 @@
 	(match_operand 1 "const0_operand"))]
   "GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD
    && (! TARGET_USE_MOV0 || optimize_insn_for_size_p ())
-   && GENERAL_REG_P (operands[0])
+   && GENERAL_REGNO_P (REGNO (operands[0]))
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 0) (const_int 0))
 	      (clobber (reg:CC FLAGS_REG))])]
@@ -17205,6 +17242,7 @@
   [(set (match_operand:SWI248 0 "register_operand")
 	(const_int -1))]
   "(optimize_insn_for_size_p () || TARGET_MOVE_M1_VIA_OR)
+   && GENERAL_REGNO_P (REGNO (operands[0]))
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 0) (const_int -1))
 	      (clobber (reg:CC FLAGS_REG))])]
@@ -17572,11 +17610,13 @@
 
   operands[1] = gen_rtx_PLUS (word_mode, base,
 			      gen_rtx_MULT (word_mode, index, GEN_INT (scale)));
-  operands[5] = base;
   if (mode != word_mode)
     operands[1] = gen_rtx_SUBREG (mode, operands[1], 0);
+
+  operands[5] = base;
   if (op1mode != word_mode)
-    operands[5] = gen_rtx_SUBREG (op1mode, operands[5], 0);
+    operands[5] = gen_lowpart (op1mode, operands[5]);
+
   operands[0] = dest;
 })
 
Index: gcc/config/i386/sol2.h
===================================================================
--- a/src/gcc/config/i386/sol2.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/sol2.h	(.../branches/gcc-4_9-branch)
@@ -25,6 +25,11 @@
 #define TARGET_SUBTARGET_DEFAULT \
 	(MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_VECT8_RETURNS)
 
+/* 32-bit Solaris/x86 only guarantees 4-byte stack alignment as required by
+   the i386 psABI, so realign it as necessary for SSE instructions.  */
+#undef STACK_REALIGN_DEFAULT
+#define STACK_REALIGN_DEFAULT (TARGET_64BIT ? 0 : 1)
+
 /* Old versions of the Solaris assembler can not handle the difference of
    labels in different sections, so force DW_EH_PE_datarel.  */
 #undef ASM_PREFERRED_EH_DATA_FORMAT
Index: gcc/config/i386/constraints.md
===================================================================
--- a/src/gcc/config/i386/constraints.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/constraints.md	(.../branches/gcc-4_9-branch)
@@ -18,7 +18,7 @@
 ;; <http://www.gnu.org/licenses/>.
 
 ;;; Unused letters:
-;;;     B     H
+;;;           H
 ;;;           h j
 
 ;; Integer register constraints.
@@ -156,6 +156,10 @@
   (and (not (match_test "TARGET_X32"))
        (match_operand 0 "memory_operand")))
 
+(define_constraint "BC"
+  "@internal SSE constant operand."
+  (match_test "standard_sse_constant_p (op)"))
+
 ;; Integer constant constraints.
 (define_constraint "I"
   "Integer constant in the range 0 @dots{} 31, for 32-bit shifts."
@@ -206,8 +210,8 @@
 
 ;; This can theoretically be any mode's CONST0_RTX.
 (define_constraint "C"
-  "Standard SSE floating point constant."
-  (match_test "standard_sse_constant_p (op)"))
+  "SSE constant zero operand."
+  (match_test "standard_sse_constant_p (op) == 1"))
 
 ;; Constant-or-symbol-reference constraints.
 
Index: gcc/config/i386/predicates.md
===================================================================
--- a/src/gcc/config/i386/predicates.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/predicates.md	(.../branches/gcc-4_9-branch)
@@ -37,6 +37,12 @@
   (and (match_code "reg")
        (match_test "GENERAL_REG_P (op)")))
 
+;; True if the operand is a nonimmediate operand with GENERAL class register.
+(define_predicate "nonimmediate_gr_operand"
+  (if_then_else (match_code "reg")
+    (match_test "GENERAL_REGNO_P (REGNO (op))")
+    (match_operand 0 "nonimmediate_operand")))
+
 ;; Return true if OP is a register operand other than an i387 fp register.
 (define_predicate "register_and_not_fp_reg_operand"
   (and (match_code "reg")
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-4_9-branch)
@@ -546,7 +546,8 @@
 
 ;; Pointer size override for scalar modes (Intel asm dialect)
 (define_mode_attr iptr
-  [(V32QI "b") (V16HI "w") (V8SI "k") (V4DI "q")
+  [(V16SI "k") (V8DI "q")
+   (V32QI "b") (V16HI "w") (V8SI "k") (V4DI "q")
    (V16QI "b") (V8HI "w") (V4SI "k") (V2DI "q")
    (V8SF "k") (V4DF "q")
    (V4SF "k") (V2DF "q")
@@ -655,7 +656,7 @@
 
 (define_insn "*mov<mode>_internal"
   [(set (match_operand:VMOVE 0 "nonimmediate_operand"               "=v,v ,m")
-	(match_operand:VMOVE 1 "nonimmediate_or_sse_const_operand"  "C ,vm,v"))]
+	(match_operand:VMOVE 1 "nonimmediate_or_sse_const_operand"  "BC,vm,v"))]
   "TARGET_SSE
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
@@ -872,9 +873,9 @@
       /* The DImode arrived in a pair of integral registers (e.g. %edx:%eax).
 	 Assemble the 64-bit DImode value in an xmm register.  */
       emit_insn (gen_sse2_loadld (operands[0], CONST0_RTX (V4SImode),
-				  gen_rtx_SUBREG (SImode, operands[1], 0)));
+				  gen_lowpart (SImode, operands[1])));
       emit_insn (gen_sse2_loadld (operands[2], CONST0_RTX (V4SImode),
-				  gen_rtx_SUBREG (SImode, operands[1], 4)));
+				  gen_highpart (SImode, operands[1])));
       emit_insn (gen_vec_interleave_lowv4si (operands[0], operands[0],
 					     operands[2]));
    }
@@ -9725,13 +9726,13 @@
 {
   int mask = INTVAL (operands[3]);
   if (mask == 0)
-    emit_insn (gen_vec_set_lo_<mode>_mask
-      (operands[0], operands[1], operands[2],
-       operands[4], operands[5]));
+    emit_insn (gen_vec_set_lo_<mode>_mask (operands[0], operands[1],
+					   operands[2], operands[4],
+					   operands[5]));
   else
-    emit_insn (gen_vec_set_hi_<mode>_mask
-      (operands[0], operands[1], operands[2],
-       operands[4], operands[5]));
+    emit_insn (gen_vec_set_hi_<mode>_mask (operands[0], operands[1],
+					   operands[2], operands[4],
+					   operands[5]));
   DONE;
 })
 
@@ -9742,7 +9743,7 @@
 	  (vec_select:<ssehalfvecmode>
 	    (match_operand:V8FI 1 "register_operand" "v")
 	    (parallel [(const_int 4) (const_int 5)
-              (const_int 6) (const_int 7)]))))]
+		       (const_int 6) (const_int 7)]))))]
   "TARGET_AVX512F"
   "vinsert<shuffletype>64x4\t{$0x0, %2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2, $0x0}"
   [(set_attr "type" "sselog")
@@ -9753,11 +9754,11 @@
 (define_insn "vec_set_hi_<mode><mask_name>"
   [(set (match_operand:V8FI 0 "register_operand" "=v")
 	(vec_concat:V8FI
-	  (match_operand:<ssehalfvecmode> 2 "nonimmediate_operand" "vm")
 	  (vec_select:<ssehalfvecmode>
 	    (match_operand:V8FI 1 "register_operand" "v")
 	    (parallel [(const_int 0) (const_int 1)
-              (const_int 2) (const_int 3)]))))]
+		       (const_int 2) (const_int 3)]))
+	  (match_operand:<ssehalfvecmode> 2 "nonimmediate_operand" "vm")))]
   "TARGET_AVX512F"
   "vinsert<shuffletype>64x4\t{$0x1, %2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2, $0x1}"
   [(set_attr "type" "sselog")
Index: gcc/config/i386/freebsd.h
===================================================================
--- a/src/gcc/config/i386/freebsd.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/freebsd.h	(.../branches/gcc-4_9-branch)
@@ -59,29 +59,16 @@
 #define SUBTARGET_EXTRA_SPECS \
   { "fbsd_dynamic_linker", FBSD_DYNAMIC_LINKER }
     
-/* Provide a STARTFILE_SPEC appropriate for FreeBSD.  Here we add
-   the magical crtbegin.o file (see crtstuff.c) which provides part 
-	of the support for getting C++ file-scope static object constructed 
-	before entering `main'.  */
-   
-#undef	STARTFILE_SPEC
-#define STARTFILE_SPEC \
-  "%{!shared: \
-     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \
-		       %{!p:%{profile:gcrt1.o%s} \
-			 %{!profile:crt1.o%s}}}} \
-   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+/* Use the STARTFILE_SPEC from config/freebsd-spec.h.  */
 
-/* Provide a ENDFILE_SPEC appropriate for FreeBSD.  Here we tack on
-   the magical crtend.o file (see crtstuff.c) which provides part of 
-	the support for getting C++ file-scope static object constructed 
-	before entering `main', followed by a normal "finalizer" file, 
-	`crtn.o'.  */
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC FBSD_STARTFILE_SPEC
 
-#undef	ENDFILE_SPEC
-#define ENDFILE_SPEC \
-  "%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s"
+/* Use the ENDFILE_SPEC from config/freebsd-spec.h.  */
 
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC FBSD_ENDFILE_SPEC
+
 /* Provide a LINK_SPEC appropriate for FreeBSD.  Here we provide support
    for the special GCC options -static and -shared, which allow us to
    link things in one of these three modes by applying the appropriate
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-4_9-branch)
@@ -528,17 +528,17 @@
   {4, 6, 6},				/* cost of storing fp registers
 					   in SFmode, DFmode and XFmode */
 
-  1,					/* cost of moving MMX register */
-  {1, 1},				/* cost of loading MMX registers
+  2,					/* cost of moving MMX register */
+  {2, 2},				/* cost of loading MMX registers
 					   in SImode and DImode */
-  {1, 1},				/* cost of storing MMX registers
+  {2, 2},				/* cost of storing MMX registers
 					   in SImode and DImode */
-  1,					/* cost of moving SSE register */
-  {1, 1, 1},				/* cost of loading SSE registers
+  2,					/* cost of moving SSE register */
+  {2, 2, 8},				/* cost of loading SSE registers
 					   in SImode, DImode and TImode */
-  {1, 1, 1},				/* cost of storing SSE registers
+  {2, 2, 8},				/* cost of storing SSE registers
 					   in SImode, DImode and TImode */
-  1,					/* MMX or SSE register to integer */
+  3,					/* MMX or SSE register to integer */
   64,					/* size of l1 cache.  */
   128,					/* size of l2 cache.  */
   32,					/* size of prefetch block */
@@ -4029,6 +4029,17 @@
       opts->x_target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
     }
 
+  /* Stack realignment without -maccumulate-outgoing-args requires %ebp,
+     so enable -maccumulate-outgoing-args when %ebp is fixed.  */
+  if (fixed_regs[BP_REG]
+      && !(opts->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))
+    {
+      if (opts_set->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS)
+	warning (0, "fixed ebp register requires %saccumulate-outgoing-args%s",
+		 prefix, suffix);
+      opts->x_target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;
+    }
+
   /* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */
   {
     char *p;
@@ -9519,21 +9530,31 @@
   frame->nregs = ix86_nsaved_regs ();
   frame->nsseregs = ix86_nsaved_sseregs ();
 
-  stack_alignment_needed = crtl->stack_alignment_needed / BITS_PER_UNIT;
-  preferred_alignment = crtl->preferred_stack_boundary / BITS_PER_UNIT;
-
   /* 64-bit MS ABI seem to require stack alignment to be always 16 except for
      function prologues and leaf.  */
-  if ((TARGET_64BIT_MS_ABI && preferred_alignment < 16)
+  if ((TARGET_64BIT_MS_ABI && crtl->preferred_stack_boundary < 128)
       && (!crtl->is_leaf || cfun->calls_alloca != 0
           || ix86_current_function_calls_tls_descriptor))
     {
-      preferred_alignment = 16;
-      stack_alignment_needed = 16;
       crtl->preferred_stack_boundary = 128;
       crtl->stack_alignment_needed = 128;
     }
+  /* preferred_stack_boundary is never updated for call
+     expanded from tls descriptor. Update it here. We don't update it in
+     expand stage because according to the comments before
+     ix86_current_function_calls_tls_descriptor, tls calls may be optimized
+     away.  */
+  else if (ix86_current_function_calls_tls_descriptor
+	   && crtl->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)
+    {
+      crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;
+      if (crtl->stack_alignment_needed < PREFERRED_STACK_BOUNDARY)
+	crtl->stack_alignment_needed = PREFERRED_STACK_BOUNDARY;
+    }
 
+  stack_alignment_needed = crtl->stack_alignment_needed / BITS_PER_UNIT;
+  preferred_alignment = crtl->preferred_stack_boundary / BITS_PER_UNIT;
+
   gcc_assert (!size || stack_alignment_needed);
   gcc_assert (preferred_alignment >= STACK_BOUNDARY / BITS_PER_UNIT);
   gcc_assert (preferred_alignment <= stack_alignment_needed);
@@ -10431,8 +10452,6 @@
       release_scratch_register_on_entry (&sr);
     }
 
-  gcc_assert (cfun->machine->fs.cfa_reg != stack_pointer_rtx);
-
   /* Even if the stack pointer isn't the CFA register, we need to correctly
      describe the adjustments made to it, in particular differentiate the
      frame-related ones from the frame-unrelated ones.  */
@@ -10656,7 +10675,11 @@
       && !crtl->accesses_prior_frames
       && !cfun->calls_alloca
       && !crtl->calls_eh_return
-      && !(flag_stack_check && STACK_CHECK_MOVING_SP)
+      /* See ira_setup_eliminable_regset for the rationale.  */
+      && !(STACK_CHECK_MOVING_SP
+	   && flag_stack_check
+	   && flag_exceptions
+	   && cfun->can_throw_non_call_exceptions)
       && !ix86_frame_pointer_required ()
       && get_frame_size () == 0
       && ix86_nsaved_sseregs () == 0
@@ -23582,7 +23605,7 @@
        if (DYNAMIC_CHECK)
 	 Round COUNT down to multiple of SIZE
        << optional caller supplied zero size guard is here >>
-       << optional caller suppplied dynamic check is here >>
+       << optional caller supplied dynamic check is here >>
        << caller supplied main copy loop is here >>
      }
    done_label:
@@ -23756,8 +23779,8 @@
       else
 	*min_size = 0;
 
-      /* Our loops always round down the bock size, but for dispatch to library
-	 we need precise value.  */
+      /* Our loops always round down the block size, but for dispatch to
+         library we need precise value.  */
       if (dynamic_check)
 	*count = expand_simple_binop (GET_MODE (*count), AND, *count,
 				      GEN_INT (-size), *count, 1, OPTAB_DIRECT);
@@ -24335,6 +24358,13 @@
   size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;
   epilogue_size_needed = size_needed;
 
+  /* If we are going to call any library calls conditionally, make sure any
+     pending stack adjustment happen before the first conditional branch,
+     otherwise they will be emitted before the library call only and won't
+     happen from the other branches.  */
+  if (dynamic_check != -1)
+    do_pending_stack_adjust ();
+
   desired_align = decide_alignment (align, alg, expected_size, move_mode);
   if (!TARGET_ALIGN_STRINGOPS || noalign)
     align = desired_align;
@@ -24409,7 +24439,8 @@
       dst = change_address (dst, BLKmode, destreg);
       set_mem_align (dst, desired_align * BITS_PER_UNIT);
       epilogue_size_needed = 0;
-      if (need_zero_guard && !min_size)
+      if (need_zero_guard
+	  && min_size < (unsigned HOST_WIDE_INT) size_needed)
 	{
 	  /* It is possible that we copied enough so the main loop will not
 	     execute.  */
@@ -24541,7 +24572,7 @@
 	  max_size -= align_bytes;
 	}
       if (need_zero_guard
-	  && !min_size
+	  && min_size < (unsigned HOST_WIDE_INT) size_needed
 	  && (count < (unsigned HOST_WIDE_INT) size_needed
 	      || (align_bytes == 0
 		  && count < ((unsigned HOST_WIDE_INT) size_needed
@@ -40631,6 +40662,7 @@
 	{
 	  /* For SSE1, we have to reuse the V4SF code.  */
 	  rtx t = gen_reg_rtx (V4SFmode);
+	  emit_move_insn (t, gen_lowpart (V4SFmode, target));
 	  ix86_expand_vector_set (false, t, gen_lowpart (SFmode, val), elt);
 	  emit_move_insn (target, gen_lowpart (mode, t));
 	}
@@ -45320,6 +45352,14 @@
   unsigned int size = INTVAL (operands[1]);
   unsigned int pos = INTVAL (operands[2]);
 
+  if (GET_CODE (src) == SUBREG)
+    {
+      /* Reject non-lowpart subregs.  */
+      if (SUBREG_BYTE (src) != 0)
+       return false;
+      src = SUBREG_REG (src);
+    }
+
   if (GET_CODE (dst) == SUBREG)
     {
       pos += SUBREG_BYTE (dst) * BITS_PER_UNIT;
@@ -45326,9 +45366,6 @@
       dst = SUBREG_REG (dst);
     }
 
-  if (GET_CODE (src) == SUBREG)
-    src = SUBREG_REG (src);
-
   switch (GET_MODE (dst))
     {
     case V16QImode:
@@ -45376,6 +45413,10 @@
 	    return false;
 	  }
 
+	/* Reject insertions to misaligned positions.  */
+	if (pos & (size-1))
+	  return false;
+
 	rtx d = dst;
 	if (GET_MODE (dst) != dstmode)
 	  d = gen_reg_rtx (dstmode);
Index: gcc/config/sh/sh.c
===================================================================
--- a/src/gcc/config/sh/sh.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sh/sh.c	(.../branches/gcc-4_9-branch)
@@ -1746,12 +1746,13 @@
 		  || tls_kind == TLS_MODEL_LOCAL_DYNAMIC
 		  || tls_kind == TLS_MODEL_INITIAL_EXEC))
 	    {
+	      static int got_labelno;
 	      /* Don't schedule insns for getting GOT address when
 		 the first scheduling is enabled, to avoid spill
 		 failures for R0.  */
 	      if (flag_schedule_insns)
 		emit_insn (gen_blockage ());
-	      emit_insn (gen_GOTaddr2picreg ());
+	      emit_insn (gen_GOTaddr2picreg (GEN_INT (++got_labelno)));
 	      emit_use (gen_rtx_REG (SImode, PIC_REG));
 	      if (flag_schedule_insns)
 		emit_insn (gen_blockage ());
@@ -7768,7 +7769,7 @@
     }
 
   if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))
-    emit_insn (gen_GOTaddr2picreg ());
+    emit_insn (gen_GOTaddr2picreg (const0_rtx));
 
   if (SHMEDIA_REGS_STACK_ADJUST ())
     {
Index: gcc/config/sh/sh.md
===================================================================
--- a/src/gcc/config/sh/sh.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/sh/sh.md	(.../branches/gcc-4_9-branch)
@@ -7448,6 +7448,24 @@
   ""
 {
   prepare_move_operands (operands, DImode);
+  if (TARGET_SH1)
+    {
+      /* When the dest operand is (R0, R1) register pair, split it to
+	 two movsi of which dest is R1 and R0 so as to lower R0-register
+	 pressure on the first movsi.  Apply only for simple source not
+	 to make complex rtl here.  */
+      if (REG_P (operands[0])
+	  && REGNO (operands[0]) == R0_REG
+	  && REG_P (operands[1])
+	  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)
+	{
+	  emit_insn (gen_movsi (gen_rtx_REG (SImode, R1_REG),
+			        gen_rtx_SUBREG (SImode, operands[1], 4)));
+	  emit_insn (gen_movsi (gen_rtx_REG (SImode, R0_REG),
+			        gen_rtx_SUBREG (SImode, operands[1], 0)));
+	  DONE;
+	}
+    }
 })
 
 (define_insn "movdf_media"
@@ -9587,12 +9605,16 @@
 		      (const_string "single") (const_string "double")))
    (set_attr "type" "jump_ind")])
 
+;; sibcall_value_pcrel used to have a =&k clobber for the scratch register
+;; that it needs for the branch address.  This causes troubles when there
+;; is a big overlap of argument and return value registers.  Hence, use a
+;; fixed call clobbered register for the address.  See also PR 67260.
 (define_insn_and_split "sibcall_value_pcrel"
   [(set (match_operand 0 "" "=rf")
 	(call (mem:SI (match_operand:SI 1 "symbol_ref_operand" ""))
 	      (match_operand 2 "" "")))
    (use (reg:PSI FPSCR_REG))
-   (clobber (match_scratch:SI 3 "=k"))
+   (clobber (reg:SI R1_REG))
    (return)]
   "TARGET_SH2"
   "#"
@@ -9602,6 +9624,8 @@
   rtx lab = PATTERN (gen_call_site ());
   rtx call_insn;
 
+  operands[3] =  gen_rtx_REG (SImode, R1_REG);
+
   emit_insn (gen_sym_label2reg (operands[3], operands[1], lab));
   call_insn = emit_call_insn (gen_sibcall_valuei_pcrel (operands[0],
 							operands[3],
@@ -9999,12 +10023,18 @@
   [(set_attr "in_delay_slot" "no")
    (set_attr "type" "arith")])
 
+;; Loads of the GOTPC relocation values must not be optimized away
+;; by e.g. any kind of CSE and must stay as they are.  Although there
+;; are other various ways to ensure this, we use an artificial counter
+;; operand to generate unique symbols.
 (define_expand "GOTaddr2picreg"
   [(set (reg:SI R0_REG)
-	(unspec:SI [(const:SI (unspec:SI [(match_dup 1)] UNSPEC_PIC))]
-		   UNSPEC_MOVA))
-   (set (match_dup 0) (const:SI (unspec:SI [(match_dup 1)] UNSPEC_PIC)))
-   (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI R0_REG)))]
+	(unspec:SI [(const:SI (unspec:SI [(match_dup 2)
+					  (match_operand:SI 0 "" "")]
+					 UNSPEC_PIC))] UNSPEC_MOVA))
+   (set (match_dup 1)
+	(const:SI (unspec:SI [(match_dup 2) (match_dup 0)] UNSPEC_PIC)))
+   (set (match_dup 1) (plus:SI (match_dup 1) (reg:SI R0_REG)))]
   ""
 {
   if (TARGET_VXWORKS_RTP)
@@ -10015,8 +10045,8 @@
       DONE;
     }
 
-  operands[0] = gen_rtx_REG (Pmode, PIC_REG);
-  operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);
+  operands[1] = gen_rtx_REG (Pmode, PIC_REG);
+  operands[2] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);
 
   if (TARGET_SHMEDIA)
     {
@@ -10025,23 +10055,23 @@
       rtx lab = PATTERN (gen_call_site ());
       rtx insn, equiv;
 
-      equiv = operands[1];
-      operands[1] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[1], lab),
+      equiv = operands[2];
+      operands[2] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[2], lab),
 				    UNSPEC_PCREL_SYMOFF);
-      operands[1] = gen_rtx_CONST (Pmode, operands[1]);
+      operands[2] = gen_rtx_CONST (Pmode, operands[2]);
 
       if (Pmode == SImode)
 	{
-	  emit_insn (gen_movsi_const (pic, operands[1]));
+	  emit_insn (gen_movsi_const (pic, operands[2]));
 	  emit_insn (gen_ptrel_si (tr, pic, copy_rtx (lab)));
 	}
       else
 	{
-	  emit_insn (gen_movdi_const (pic, operands[1]));
+	  emit_insn (gen_movdi_const (pic, operands[2]));
 	  emit_insn (gen_ptrel_di (tr, pic, copy_rtx (lab)));
 	}
 
-      insn = emit_move_insn (operands[0], tr);
+      insn = emit_move_insn (operands[1], tr);
 
       set_unique_reg_note (insn, REG_EQUAL, equiv);
 
@@ -10095,7 +10125,7 @@
   [(match_operand 0 "" "")]
   "flag_pic"
 {
-  emit_insn (gen_GOTaddr2picreg ());
+  emit_insn (gen_GOTaddr2picreg (const0_rtx));
   DONE;
 })
 
@@ -10152,11 +10182,6 @@
 		 "__stack_chk_guard") == 0)
     stack_chk_guard_p = true;
 
-  /* Use R0 to avoid long R0 liveness which stack-protector tends to
-     produce.  */
-  if (stack_chk_guard_p && ! reload_in_progress && ! reload_completed)
-    operands[2] = gen_rtx_REG (Pmode, R0_REG);
-
   if (TARGET_SHMEDIA)
     {
       rtx reg = operands[2];
@@ -10700,12 +10725,16 @@
 ;; ??? reload might clobber r0 if we use it explicitly in the RTL before
 ;; reload; using a R0_REGS pseudo reg is likely to give poor code.
 ;; So we keep the use of r0 hidden in a R0_REGS clobber until after reload.
+;;
+;; The use on the T_REG in the casesi_worker* patterns links the bounds
+;; checking insns and the table memory access.  See also PR 69713.
 (define_insn "casesi_worker_0"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	(unspec:SI [(match_operand:SI 1 "register_operand" "0,r")
 		 (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
    (clobber (match_scratch:SI 3 "=X,1"))
-   (clobber (match_scratch:SI 4 "=&z,z"))]
+   (clobber (match_scratch:SI 4 "=&z,z"))
+   (use (reg:SI T_REG))]
   "TARGET_SH1"
   "#")
 
@@ -10714,7 +10743,8 @@
 	(unspec:SI [(match_operand:SI 1 "register_operand" "")
 		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
    (clobber (match_scratch:SI 3 ""))
-   (clobber (match_scratch:SI 4 ""))]
+   (clobber (match_scratch:SI 4))
+   (use (reg:SI T_REG))]
   "TARGET_SH1 && ! TARGET_SH2 && reload_completed"
   [(set (reg:SI R0_REG) (unspec:SI [(label_ref (match_dup 2))] UNSPEC_MOVA))
    (parallel [(set (match_dup 0)
@@ -10732,7 +10762,8 @@
 	(unspec:SI [(match_operand:SI 1 "register_operand" "")
 		    (label_ref (match_operand 2 "" ""))] UNSPEC_CASESI))
    (clobber (match_scratch:SI 3 ""))
-   (clobber (match_scratch:SI 4 ""))]
+   (clobber (match_scratch:SI 4))
+   (use (reg:SI T_REG))]
   "TARGET_SH2 && reload_completed"
   [(set (reg:SI R0_REG) (unspec:SI [(label_ref (match_dup 2))] UNSPEC_MOVA))
    (parallel [(set (match_dup 0)
@@ -10744,6 +10775,8 @@
     LABEL_NUSES (operands[2])++;
 })
 
+;; This may be replaced with casesi_worker_2 in sh_reorg for PIC.
+;; The insn length is set to 8 for that case.
 (define_insn "casesi_worker_1"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	(unspec:SI [(reg:SI R0_REG)
@@ -10775,7 +10808,9 @@
       gcc_unreachable ();
     }
 }
-  [(set_attr "length" "4")])
+  [(set_attr_alternative "length"
+     [(if_then_else (match_test "flag_pic") (const_int 8) (const_int 4))
+      (if_then_else (match_test "flag_pic") (const_int 8) (const_int 4))])])
 
 (define_insn "casesi_worker_2"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
Index: gcc/config/avr/avr-dimode.md
===================================================================
--- a/src/gcc/config/avr/avr-dimode.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/avr/avr-dimode.md	(.../branches/gcc-4_9-branch)
@@ -461,7 +461,8 @@
               (match_operand:SI 2 "general_operand" "")
               ;; Just to mention the iterator 
               (clobber (any_extend:SI (match_dup 1)))])]
-  "avr_have_dimode"
+  "avr_have_dimode
+   && AVR_HAVE_MUL"
   {
     avr_fix_inputs (operands, 1 << 2, regmask (SImode, 22));
     emit_move_insn (gen_rtx_REG (SImode, 22), operands[1]);
@@ -480,7 +481,8 @@
                  (any_extend:DI (reg:SI 22))))
    (clobber (reg:HI REG_X))
    (clobber (reg:HI REG_Z))]
-  "avr_have_dimode"
+  "avr_have_dimode
+   && AVR_HAVE_MUL"
   "%~call __<extend_u>mulsidi3"
   [(set_attr "adjust_len" "call")
    (set_attr "cc" "clobber")])
Index: gcc/config/ia64/predicates.md
===================================================================
--- a/src/gcc/config/ia64/predicates.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/ia64/predicates.md	(.../branches/gcc-4_9-branch)
@@ -92,6 +92,32 @@
     }
 })
 
+;; True if OP refers to a local symbol [+any offset].
+;; To be encoded as:
+;;   movl % = @gprel(symbol+offset)
+;;   add  % = %, gp
+(define_predicate "local_symbolic_operand64"
+  (match_code "symbol_ref,const")
+{
+  switch (GET_CODE (op))
+    {
+    case CONST:
+      op = XEXP (op, 0);
+      if (GET_CODE (op) != PLUS
+	  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF
+	  || GET_CODE (XEXP (op, 1)) != CONST_INT)
+	return false;
+      op = XEXP (op, 0);
+      /* FALLTHRU */
+
+    case SYMBOL_REF:
+	return SYMBOL_REF_LOCAL_P (op);
+
+    default:
+      gcc_unreachable ();
+    }
+})
+
 ;; True if OP refers to a symbol in the small address area.
 (define_predicate "small_addr_symbolic_operand" 
   (match_code "symbol_ref,const")
Index: gcc/config/ia64/ia64.c
===================================================================
--- a/src/gcc/config/ia64/ia64.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/ia64/ia64.c	(.../branches/gcc-4_9-branch)
@@ -1100,6 +1100,15 @@
     emit_insn (gen_load_fptr (dest, src));
   else if (sdata_symbolic_operand (src, VOIDmode))
     emit_insn (gen_load_gprel (dest, src));
+  else if (local_symbolic_operand64 (src, VOIDmode))
+    {
+      /* We want to use @gprel rather than @ltoff relocations for local
+	 symbols:
+	  - @gprel does not require dynamic linker
+	  - and does not use .sdata section
+	 https://gcc.gnu.org/bugzilla/60465 */
+      emit_insn (gen_load_gprel64 (dest, src));
+    }
   else
     {
       HOST_WIDE_INT addend = 0;
Index: gcc/config/aarch64/aarch64.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/aarch64/aarch64.md	(.../branches/gcc-4_9-branch)
@@ -3357,6 +3357,16 @@
         (mult:GPF
 		 (neg:GPF (match_operand:GPF 1 "register_operand" "w"))
 		 (match_operand:GPF 2 "register_operand" "w")))]
+  "TARGET_FLOAT && !flag_rounding_math"
+  "fnmul\\t%<s>0, %<s>1, %<s>2"
+  [(set_attr "type" "fmul<s>")]
+)
+
+(define_insn "*fnmul<mode>3"
+  [(set (match_operand:GPF 0 "register_operand" "=w")
+        (neg:GPF (mult:GPF
+		 (match_operand:GPF 1 "register_operand" "w")
+		 (match_operand:GPF 2 "register_operand" "w"))))]
   "TARGET_FLOAT"
   "fnmul\\t%<s>0, %<s>1, %<s>2"
   [(set_attr "type" "fmul<s>")]
@@ -3444,7 +3454,8 @@
 
 (define_insn "aarch64_movdi_<mode>low"
   [(set (match_operand:DI 0 "register_operand" "=r")
-        (truncate:DI (match_operand:TX 1 "register_operand" "w")))]
+	(zero_extract:DI (match_operand:TX 1 "register_operand" "w")
+			 (const_int 64) (const_int 0)))]
   "reload_completed || reload_in_progress"
   "fmov\\t%x0, %d1"
   [(set_attr "type" "f_mrc")
@@ -3453,9 +3464,8 @@
 
 (define_insn "aarch64_movdi_<mode>high"
   [(set (match_operand:DI 0 "register_operand" "=r")
-        (truncate:DI
-	  (lshiftrt:TX (match_operand:TX 1 "register_operand" "w")
-		       (const_int 64))))]
+	(zero_extract:DI (match_operand:TX 1 "register_operand" "w")
+			 (const_int 64) (const_int 64)))]
   "reload_completed || reload_in_progress"
   "fmov\\t%x0, %1.d[1]"
   [(set_attr "type" "f_mrc")
Index: gcc/config/aarch64/aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/aarch64/aarch64.c	(.../branches/gcc-4_9-branch)
@@ -6564,7 +6564,7 @@
   if (!aarch64_fix_a53_err835769)
     return false;
 
-  if (recog_memoized (insn) < 0)
+  if (!INSN_P (insn) || recog_memoized (insn) < 0)
     return false;
 
   attr_type = get_attr_type (insn);
@@ -8405,6 +8405,18 @@
 				  enum machine_mode to,
 				  enum reg_class rclass)
 {
+  /* We cannot allow word_mode subregs of full vector modes.
+     Otherwise the middle-end will assume it's ok to store to
+     (subreg:DI (reg:TI 100) 0) in order to modify only the low 64 bits
+     of the 128-bit register.  However, after reload the subreg will
+     be dropped leaving a plain DImode store.  See PR67609 for a more
+     detailed dicussion.  In some other cases we can be permissive and
+     return false.  */
+  if (reg_classes_intersect_p (FP_REGS, rclass)
+      && GET_MODE_SIZE (to) == UNITS_PER_WORD
+      && GET_MODE_SIZE (from) > UNITS_PER_WORD)
+    return true;
+
   /* Full-reg subregs are allowed on general regs or any class if they are
      the same size.  */
   if (GET_MODE_SIZE (from) == GET_MODE_SIZE (to)
Index: gcc/config/aarch64/aarch64-elf-raw.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-elf-raw.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/aarch64/aarch64-elf-raw.h	(.../branches/gcc-4_9-branch)
@@ -42,7 +42,12 @@
 #endif
 
 #ifndef LINK_SPEC
-#define LINK_SPEC "%{mbig-endian:-EB} %{mlittle-endian:-EL} -X \
+#define LINK_SPEC "%{h*}			\
+   %{static:-Bstatic}				\
+   %{shared:-shared}				\
+   %{symbolic:-Bsymbolic}			\
+   %{!static:%{rdynamic:-export-dynamic}}	\
+   %{mbig-endian:-EB} %{mlittle-endian:-EL} -X	\
   -maarch64elf%{mabi=ilp32*:32}%{mbig-endian:b}" \
   CA53_ERR_835769_SPEC \
   CA53_ERR_843419_SPEC
Index: gcc/config/aarch64/aarch64-linux.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-linux.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/aarch64/aarch64-linux.h	(.../branches/gcc-4_9-branch)
@@ -29,8 +29,9 @@
    %{static:-Bstatic}				\
    %{shared:-shared}				\
    %{symbolic:-Bsymbolic}			\
-   %{rdynamic:-export-dynamic}			\
-   -dynamic-linker " GNU_USER_DYNAMIC_LINKER "	\
+   %{!static:					\
+     %{rdynamic:-export-dynamic}		\
+     %{!shared:-dynamic-linker " GNU_USER_DYNAMIC_LINKER "}} \
    -X						\
    %{mbig-endian:-EB} %{mlittle-endian:-EL}     \
    -maarch64linux%{mbig-endian:b}"
Index: gcc/config/rs6000/t-freebsd64
===================================================================
--- a/src/gcc/config/rs6000/t-freebsd64	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/t-freebsd64	(.../branches/gcc-4_9-branch)
@@ -21,11 +21,9 @@
 # On FreeBSD the 32-bit libraries are found under /usr/lib32.
 # Set MULTILIB_OSDIRNAMES according to this.
 
-MULTILIB_OPTIONS        = m32 msoft-float
-MULTILIB_DIRNAMES       = 32 nof
+MULTILIB_OPTIONS        = m32
+MULTILIB_DIRNAMES       = 32
 MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
 MULTILIB_EXCEPTIONS     =
-MULTILIB_EXCLUSIONS     = !m32/msoft-float 
 MULTILIB_OSDIRNAMES	= ../lib32
-#MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
 
Index: gcc/config/rs6000/vector.md
===================================================================
--- a/src/gcc/config/rs6000/vector.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/vector.md	(.../branches/gcc-4_9-branch)
@@ -988,6 +988,7 @@
   rtx bitshift = operands[2];
   rtx shift;
   rtx insn;
+  rtx zero_reg;
   HOST_WIDE_INT bitshift_val;
   HOST_WIDE_INT byteshift_val;
 
@@ -997,16 +998,18 @@
   if (bitshift_val & 0x7)
     FAIL;
   byteshift_val = bitshift_val >> 3;
+  zero_reg = gen_reg_rtx (<MODE>mode);
+  emit_move_insn (zero_reg, CONST0_RTX (<MODE>mode));
   if (TARGET_VSX && (byteshift_val & 0x3) == 0)
     {
       shift = gen_rtx_CONST_INT (QImode, byteshift_val >> 2);
-      insn = gen_vsx_xxsldwi_<mode> (operands[0], operands[1], operands[1],
+      insn = gen_vsx_xxsldwi_<mode> (operands[0], operands[1], zero_reg,
 				     shift);
     }
   else
     {
       shift = gen_rtx_CONST_INT (QImode, byteshift_val);
-      insn = gen_altivec_vsldoi_<mode> (operands[0], operands[1], operands[1],
+      insn = gen_altivec_vsldoi_<mode> (operands[0], operands[1], zero_reg,
 					shift);
     }
 
@@ -1029,6 +1032,7 @@
   rtx bitshift = operands[2];
   rtx shift;
   rtx insn;
+  rtx zero_reg;
   HOST_WIDE_INT bitshift_val;
   HOST_WIDE_INT byteshift_val;
 
@@ -1038,16 +1042,18 @@
   if (bitshift_val & 0x7)
     FAIL;
   byteshift_val = 16 - (bitshift_val >> 3);
+  zero_reg = gen_reg_rtx (<MODE>mode);
+  emit_move_insn (zero_reg, CONST0_RTX (<MODE>mode));
   if (TARGET_VSX && (byteshift_val & 0x3) == 0)
     {
       shift = gen_rtx_CONST_INT (QImode, byteshift_val >> 2);
-      insn = gen_vsx_xxsldwi_<mode> (operands[0], operands[1], operands[1],
+      insn = gen_vsx_xxsldwi_<mode> (operands[0], zero_reg, operands[1],
 				     shift);
     }
   else
     {
       shift = gen_rtx_CONST_INT (QImode, byteshift_val);
-      insn = gen_altivec_vsldoi_<mode> (operands[0], operands[1], operands[1],
+      insn = gen_altivec_vsldoi_<mode> (operands[0], zero_reg, operands[1],
 					shift);
     }
 
Index: gcc/config/rs6000/predicates.md
===================================================================
--- a/src/gcc/config/rs6000/predicates.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/predicates.md	(.../branches/gcc-4_9-branch)
@@ -41,7 +41,7 @@
   if (!REG_P (op))
     return 0;
 
-  if (REGNO (op) > LAST_VIRTUAL_REGISTER)
+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)
     return 1;
 
   return ALTIVEC_REGNO_P (REGNO (op));
@@ -57,7 +57,7 @@
   if (!REG_P (op))
     return 0;
 
-  if (REGNO (op) > LAST_VIRTUAL_REGISTER)
+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)
     return 1;
 
   return VSX_REGNO_P (REGNO (op));
@@ -74,7 +74,7 @@
   if (!REG_P (op))
     return 0;
 
-  if (REGNO (op) > LAST_VIRTUAL_REGISTER)
+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)
     return 1;
 
   return VFLOAT_REGNO_P (REGNO (op));
@@ -91,7 +91,7 @@
   if (!REG_P (op))
     return 0;
 
-  if (REGNO (op) > LAST_VIRTUAL_REGISTER)
+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)
     return 1;
 
   return VINT_REGNO_P (REGNO (op));
@@ -108,7 +108,7 @@
   if (!REG_P (op))
     return 0;
 
-  if (REGNO (op) > LAST_VIRTUAL_REGISTER)
+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)
     return 1;
 
   return VLOGICAL_REGNO_P (REGNO (op));
@@ -270,8 +270,13 @@
 
 ;; Return 1 if op is a general purpose register that is an even register
 ;; which suitable for a load/store quad operation
+;; Subregs are not allowed here because when they are combine can
+;; create (subreg:PTI (reg:TI pseudo)) which will cause reload to
+;; think the innermost reg needs reloading, in TImode instead of
+;; PTImode.  So reload will choose a reg in TImode which has no
+;; requirement that the reg be even.
 (define_predicate "quad_int_reg_operand"
-  (match_operand 0 "register_operand")
+  (match_code "reg")
 {
   HOST_WIDE_INT r;
 
@@ -278,12 +283,6 @@
   if (!TARGET_QUAD_MEMORY && !TARGET_QUAD_MEMORY_ATOMIC)
     return 0;
 
-  if (GET_CODE (op) == SUBREG)
-    op = SUBREG_REG (op);
-
-  if (!REG_P (op))
-    return 0;
-
   r = REGNO (op);
   if (r >= FIRST_PSEUDO_REGISTER)
     return 1;
@@ -1063,12 +1062,12 @@
 (define_predicate "current_file_function_operand"
   (and (match_code "symbol_ref")
        (match_test "(DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))
-		    && ((SYMBOL_REF_LOCAL_P (op)
-			 && ((DEFAULT_ABI != ABI_AIX
-			      && DEFAULT_ABI != ABI_ELFv2)
-			     || !SYMBOL_REF_EXTERNAL_P (op)))
-		        || (op == XEXP (DECL_RTL (current_function_decl),
-						  0)))")))
+		    && (SYMBOL_REF_LOCAL_P (op)
+			|| op == XEXP (DECL_RTL (current_function_decl), 0))
+		    && !((DEFAULT_ABI == ABI_AIX
+			  || DEFAULT_ABI == ABI_ELFv2)
+			 && (SYMBOL_REF_EXTERNAL_P (op)
+			     || SYMBOL_REF_WEAK (op)))")))
 
 ;; Return 1 if this operand is a valid input for a move insn.
 (define_predicate "input_operand"
Index: gcc/config/rs6000/htm.md
===================================================================
--- a/src/gcc/config/rs6000/htm.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/htm.md	(.../branches/gcc-4_9-branch)
@@ -27,6 +27,14 @@
   ])
 
 ;;
+;; UNSPEC usage
+;;
+
+(define_c_enum "unspec"
+  [UNSPEC_HTM_FENCE
+  ])
+
+;;
 ;; UNSPEC_VOLATILE usage
 ;;
 
@@ -45,96 +53,223 @@
    UNSPECV_HTM_MTSPR
   ])
 
+(define_expand "tabort"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand:SI 0 "base_reg_operand" "b")]
+			       UNSPECV_HTM_TABORT))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
 
-(define_insn "tabort"
+(define_insn "*tabort"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
-			    UNSPECV_HTM_TABORT))]
+	(unspec_volatile:CC [(match_operand:SI 0 "base_reg_operand" "b")]
+			    UNSPECV_HTM_TABORT))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tabort<wd>c"
+(define_expand "tabort<wd>c"
+  [(parallel
+     [(set (match_operand:CC 3 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
+				(match_operand:GPR 1 "gpc_reg_operand" "r")
+				(match_operand:GPR 2 "gpc_reg_operand" "r")]
+			       UNSPECV_HTM_TABORTXC))
+      (set (match_dup 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[4]) = 1;
+})
+
+(define_insn "*tabort<wd>c"
   [(set (match_operand:CC 3 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
 			     (match_operand:GPR 1 "gpc_reg_operand" "r")
 			     (match_operand:GPR 2 "gpc_reg_operand" "r")]
-			    UNSPECV_HTM_TABORTXC))]
+			    UNSPECV_HTM_TABORTXC))
+   (set (match_operand:BLK 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort<wd>c. %0,%1,%2"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tabort<wd>ci"
+(define_expand "tabort<wd>ci"
+  [(parallel
+     [(set (match_operand:CC 3 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
+				(match_operand:GPR 1 "gpc_reg_operand" "r")
+				(match_operand 2 "s5bit_cint_operand" "n")]
+			       UNSPECV_HTM_TABORTXCI))
+      (set (match_dup 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[4]) = 1;
+})
+
+(define_insn "*tabort<wd>ci"
   [(set (match_operand:CC 3 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
 			     (match_operand:GPR 1 "gpc_reg_operand" "r")
 			     (match_operand 2 "s5bit_cint_operand" "n")]
-			    UNSPECV_HTM_TABORTXCI))]
+			    UNSPECV_HTM_TABORTXCI))
+   (set (match_operand:BLK 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort<wd>ci. %0,%1,%2"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tbegin"
+(define_expand "tbegin"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
+			       UNSPECV_HTM_TBEGIN))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*tbegin"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
-			    UNSPECV_HTM_TBEGIN))]
+			    UNSPECV_HTM_TBEGIN))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tbegin. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tcheck"
+(define_expand "tcheck"
+  [(parallel
+     [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	   (unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TCHECK))
+      (set (match_dup 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[1]) = 1;
+})
+
+(define_insn "*tcheck"
   [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec_volatile:CC [(const_int 0)]
-			    UNSPECV_HTM_TCHECK))]
+	(unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TCHECK))
+   (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tcheck %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tend"
+(define_expand "tend"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
+			       UNSPECV_HTM_TEND))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*tend"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
-			    UNSPECV_HTM_TEND))]
+			    UNSPECV_HTM_TEND))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tend. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "trechkpt"
+(define_expand "trechkpt"
+  [(parallel
+     [(set (match_operand:CC 0 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TRECHKPT))
+      (set (match_dup 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[1]) = 1;
+})
+
+(define_insn "*trechkpt"
   [(set (match_operand:CC 0 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(const_int 0)]
-			    UNSPECV_HTM_TRECHKPT))]
+	(unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TRECHKPT))
+   (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "trechkpt."
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "treclaim"
+(define_expand "treclaim"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
+			       UNSPECV_HTM_TRECLAIM))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*treclaim"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
-			    UNSPECV_HTM_TRECLAIM))]
+			    UNSPECV_HTM_TRECLAIM))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "treclaim. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tsr"
+(define_expand "tsr"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
+			       UNSPECV_HTM_TSR))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*tsr"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
-			    UNSPECV_HTM_TSR))]
+			    UNSPECV_HTM_TSR))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tsr. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "ttest"
+(define_expand "ttest"
+  [(parallel
+     [(set (match_operand:CC 0 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TTEST))
+      (set (match_dup 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[1]) = 1;
+})
+
+(define_insn "*ttest"
   [(set (match_operand:CC 0 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(const_int 0)]
-			    UNSPECV_HTM_TTEST))]
+	(unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TTEST))
+   (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabortwci. 0,1,0"
   [(set_attr "type" "htm")
Index: gcc/config/rs6000/freebsd64.h
===================================================================
--- a/src/gcc/config/rs6000/freebsd64.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/freebsd64.h	(.../branches/gcc-4_9-branch)
@@ -65,6 +65,13 @@
 #define INVALID_64BIT "-m%s not supported in this configuration"
 #define INVALID_32BIT INVALID_64BIT
 
+/* Use LINUX64 instead of FREEBSD64 for compat with e.g. sysv4le.h */
+#ifdef LINUX64_DEFAULT_ABI_ELFv2
+#define ELFv2_ABI_CHECK (rs6000_elf_abi != 1)
+#else
+#define ELFv2_ABI_CHECK (rs6000_elf_abi == 2)
+#endif
+
 #undef  SUBSUBTARGET_OVERRIDE_OPTIONS
 #define SUBSUBTARGET_OVERRIDE_OPTIONS				\
   do								\
@@ -84,6 +91,12 @@
 	      rs6000_isa_flags &= ~OPTION_MASK_RELOCATABLE;	\
 	      error (INVALID_64BIT, "relocatable");		\
 	    }							\
+	  if (ELFv2_ABI_CHECK)					\
+	    {							\
+	      rs6000_current_abi = ABI_ELFv2;			\
+	      if (dot_symbols)					\
+		error ("-mcall-aixdesc incompatible with -mabi=elfv2"); \
+	    }							\
 	  if (rs6000_isa_flags & OPTION_MASK_EABI)		\
 	    {							\
 	      rs6000_isa_flags &= ~OPTION_MASK_EABI;		\
@@ -130,7 +143,7 @@
 #define	LINK_OS_FREEBSD_SPEC "%{m32:%(link_os_freebsd_spec32)}%{!m32:%(link_os_freebsd_spec64)}"
 
 #define ASM_SPEC32 "-a32 \
-%{mrelocatable} %{mrelocatable-lib} %{fpic:-K PIC} %{fPIC:-K PIC} \
+%{mrelocatable} %{mrelocatable-lib} %{fpic|fpie|fPIC|fPIE:-K PIC} \
 %{memb} %{!memb: %{msdata=eabi: -memb}} \
 %{!mlittle: %{!mlittle-endian: %{!mbig: %{!mbig-endian: \
     %{mcall-freebsd: -mbig} \
@@ -154,10 +167,7 @@
   { "link_os_freebsd_spec32",	LINK_OS_FREEBSD_SPEC32 },     		\
   { "link_os_freebsd_spec64",	LINK_OS_FREEBSD_SPEC64 },
 
-#define FREEBSD_DYNAMIC_LINKER32 "/libexec/ld-elf32.so.1"
-#define FREEBSD_DYNAMIC_LINKER64 "/libexec/ld-elf.so.1"
-
-#define LINK_OS_FREEBSD_SPEC_DEF32 "\
+#define LINK_OS_FREEBSD_SPEC_DEF "\
   %{p:%nconsider using `-pg' instead of `-p' with gprof(1)} \
   %{v:-V} \
   %{assert*} %{R*} %{rpath*} %{defsym*} \
@@ -165,25 +175,13 @@
   %{!shared: \
     %{!static: \
       %{rdynamic: -export-dynamic} \
-      %{!dynamic-linker:-dynamic-linker " FREEBSD_DYNAMIC_LINKER32 "}} \
+      %{!dynamic-linker:-dynamic-linker " FBSD_DYNAMIC_LINKER "}} \
     %{static:-Bstatic}} \
   %{symbolic:-Bsymbolic}"
 
-#define LINK_OS_FREEBSD_SPEC_DEF64 "\
-  %{p:%nconsider using `-pg' instead of `-p' with gprof(1)} \
-  %{v:-V} \
-  %{assert*} %{R*} %{rpath*} %{defsym*} \
-  %{shared:-Bshareable %{h*} %{soname*}} \
-  %{!shared: \
-    %{!static: \
-      %{rdynamic: -export-dynamic} \
-      %{!dynamic-linker:-dynamic-linker " FREEBSD_DYNAMIC_LINKER64 "}} \
-    %{static:-Bstatic}} \
-  %{symbolic:-Bsymbolic}"
-
-#define LINK_OS_FREEBSD_SPEC32 "-melf32ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF32
+#define LINK_OS_FREEBSD_SPEC32 "-melf32ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF
   
-#define LINK_OS_FREEBSD_SPEC64 "-melf64ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF64
+#define LINK_OS_FREEBSD_SPEC64 "-melf64ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF
 
 #undef	MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS { "m64" }
@@ -304,7 +302,7 @@
 
 /* rs6000.h gets this wrong for FreeBSD.  We use the GCC defaults instead.  */
 #undef WCHAR_TYPE
-#define	WCHAR_TYPE      (TARGET_64BIT ? "int" : "long int")
+
 #undef  WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
Index: gcc/config/rs6000/rs6000-cpus.def
===================================================================
--- a/src/gcc/config/rs6000/rs6000-cpus.def	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/rs6000-cpus.def	(.../branches/gcc-4_9-branch)
@@ -52,6 +52,7 @@
 				 | OPTION_MASK_P8_VECTOR		\
 				 | OPTION_MASK_CRYPTO			\
 				 | OPTION_MASK_DIRECT_MOVE		\
+				 | OPTION_MASK_EFFICIENT_UNALIGNED_VSX	\
 				 | OPTION_MASK_HTM			\
 				 | OPTION_MASK_QUAD_MEMORY		\
   				 | OPTION_MASK_QUAD_MEMORY_ATOMIC)
@@ -76,6 +77,7 @@
 				 | OPTION_MASK_DFP			\
 				 | OPTION_MASK_DIRECT_MOVE		\
 				 | OPTION_MASK_DLMZB			\
+				 | OPTION_MASK_EFFICIENT_UNALIGNED_VSX	\
 				 | OPTION_MASK_FPRND			\
 				 | OPTION_MASK_HTM			\
 				 | OPTION_MASK_ISEL			\
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-4_9-branch)
@@ -353,7 +353,11 @@
   if ((flags & OPTION_MASK_VSX) != 0)
     rs6000_define_or_undefine_macro (define_p, "__VSX__");
   if ((flags & OPTION_MASK_HTM) != 0)
-    rs6000_define_or_undefine_macro (define_p, "__HTM__");
+    {
+      rs6000_define_or_undefine_macro (define_p, "__HTM__");
+      /* Tell the user that our HTM insn patterns act as memory barriers.  */
+      rs6000_define_or_undefine_macro (define_p, "__TM_FENCE__");
+    }
   if ((flags & OPTION_MASK_P8_VECTOR) != 0)
     rs6000_define_or_undefine_macro (define_p, "__POWER8_VECTOR__");
   if ((flags & OPTION_MASK_QUAD_MEMORY) != 0)
Index: gcc/config/rs6000/rs6000.opt
===================================================================
--- a/src/gcc/config/rs6000/rs6000.opt	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/rs6000.opt	(.../branches/gcc-4_9-branch)
@@ -212,7 +212,7 @@
 ; Allow/disallow the movmisalign in DF/DI vectors
 
 mefficient-unaligned-vector
-Target Undocumented Report Var(TARGET_EFFICIENT_UNALIGNED_VSX) Init(-1) Save
+Target Undocumented Report Mask(EFFICIENT_UNALIGNED_VSX) Var(rs6000_isa_flags)
 ; Consider unaligned VSX accesses to be efficient/inefficient
 
 mallow-df-permute
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_9-branch)
@@ -3506,6 +3506,45 @@
       && optimize >= 3)
     rs6000_isa_flags |= OPTION_MASK_P8_FUSION_SIGN;
 
+  /* Set -mallow-movmisalign to explicitly on if we have full ISA 2.07
+     support. If we only have ISA 2.06 support, and the user did not specify
+     the switch, leave it set to -1 so the movmisalign patterns are enabled,
+     but we don't enable the full vectorization support  */
+  if (TARGET_ALLOW_MOVMISALIGN == -1 && TARGET_P8_VECTOR && TARGET_DIRECT_MOVE)
+    TARGET_ALLOW_MOVMISALIGN = 1;
+
+  else if (TARGET_ALLOW_MOVMISALIGN && !TARGET_VSX)
+    {
+      if (TARGET_ALLOW_MOVMISALIGN > 0)
+	error ("-mallow-movmisalign requires -mvsx");
+
+      TARGET_ALLOW_MOVMISALIGN = 0;
+    }
+
+  /* Determine when unaligned vector accesses are permitted, and when
+     they are preferred over masked Altivec loads.  Note that if
+     TARGET_ALLOW_MOVMISALIGN has been disabled by the user, then
+     TARGET_EFFICIENT_UNALIGNED_VSX must be as well.  The converse is
+     not true.  */
+  if (TARGET_EFFICIENT_UNALIGNED_VSX)
+    {
+      if (!TARGET_VSX)
+	{
+	  if (rs6000_isa_flags_explicit & OPTION_MASK_EFFICIENT_UNALIGNED_VSX)
+	    error ("-mefficient-unaligned-vsx requires -mvsx");
+
+	  rs6000_isa_flags &= ~OPTION_MASK_EFFICIENT_UNALIGNED_VSX;
+	}
+
+      else if (!TARGET_ALLOW_MOVMISALIGN)
+	{
+	  if (rs6000_isa_flags_explicit & OPTION_MASK_EFFICIENT_UNALIGNED_VSX)
+	    error ("-mefficient-unaligned-vsx requires -mallow-movmisalign");
+
+	  rs6000_isa_flags &= ~OPTION_MASK_EFFICIENT_UNALIGNED_VSX;
+	}
+    }
+
   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)
     rs6000_print_isa_options (stderr, 0, "after defaults", rs6000_isa_flags);
 
@@ -4065,22 +4104,6 @@
 	}
     }
 
-  /* Determine when unaligned vector accesses are permitted, and when
-     they are preferred over masked Altivec loads.  Note that if
-     TARGET_ALLOW_MOVMISALIGN has been disabled by the user, then
-     TARGET_EFFICIENT_UNALIGNED_VSX must be as well.  The converse is
-     not true.  */
-  if (TARGET_EFFICIENT_UNALIGNED_VSX == -1) {
-    if (TARGET_VSX && rs6000_cpu == PROCESSOR_POWER8
-	&& TARGET_ALLOW_MOVMISALIGN != 0)
-      TARGET_EFFICIENT_UNALIGNED_VSX = 1;
-    else
-      TARGET_EFFICIENT_UNALIGNED_VSX = 0;
-  }
-
-  if (TARGET_ALLOW_MOVMISALIGN == -1 && rs6000_cpu == PROCESSOR_POWER8)
-    TARGET_ALLOW_MOVMISALIGN = 1;
-
   /* Set the builtin mask of the various options used that could affect which
      builtins were used.  In the past we used target_flags, but we've run out
      of bits, and some options like SPE and PAIRED are no longer in
@@ -17212,8 +17235,21 @@
 
   if (GET_CODE (addr) == PRE_MODIFY)
     {
+      gcc_assert (REG_P (XEXP (addr, 0))
+		  && GET_CODE (XEXP (addr, 1)) == PLUS
+		  && XEXP (XEXP (addr, 1), 0) == XEXP (addr, 0));
       scratch_or_premodify = XEXP (addr, 0);
-      gcc_assert (REG_P (scratch_or_premodify));
+      if (!HARD_REGISTER_P (scratch_or_premodify))
+	/* If we have a pseudo here then reload will have arranged
+	   to have it replaced, but only in the original insn.
+	   Use the replacement here too.  */
+	scratch_or_premodify = find_replacement (&XEXP (addr, 0));
+
+      /* RTL emitted by rs6000_secondary_reload_gpr uses RTL
+	 expressions from the original insn, without unsharing them.
+	 Any RTL that points into the original insn will of course
+	 have register replacements applied.  That is why we don't
+	 need to look for replacements under the PLUS.  */
       addr = XEXP (addr, 1);
     }
   gcc_assert (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM);
@@ -20227,6 +20263,9 @@
   else if (reg_overlap_mentioned_p (retval, oldval))
     oldval = copy_to_reg (oldval);
 
+  if (mode != TImode && !reg_or_short_operand (oldval, mode))
+    oldval = copy_to_mode_reg (mode, oldval);
+
   mem = rs6000_pre_atomic_barrier (mem, mod_s);
 
   label1 = NULL_RTX;
@@ -20241,10 +20280,8 @@
 
   x = retval;
   if (mask)
-    {
-      x = expand_simple_binop (SImode, AND, retval, mask,
-			       NULL_RTX, 1, OPTAB_LIB_WIDEN);
-    }
+    x = expand_simple_binop (SImode, AND, retval, mask,
+			     NULL_RTX, 1, OPTAB_LIB_WIDEN);
 
   cond = gen_reg_rtx (CCmode);
   /* If we have TImode, synthesize a comparison.  */
@@ -21843,6 +21880,7 @@
       || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)
 	  && decl
 	  && !DECL_EXTERNAL (decl)
+	  && !DECL_WEAK (decl)
 	  && (*targetm.binds_local_p) (decl))
       || (DEFAULT_ABI == ABI_V4
 	  && (!TARGET_SECURE_PLT
@@ -31578,6 +31616,8 @@
   { "crypto",			OPTION_MASK_CRYPTO,		false, true  },
   { "direct-move",		OPTION_MASK_DIRECT_MOVE,	false, true  },
   { "dlmzb",			OPTION_MASK_DLMZB,		false, true  },
+  { "efficient-unaligned-vsx",	OPTION_MASK_EFFICIENT_UNALIGNED_VSX,
+								false, true  },
   { "fprnd",			OPTION_MASK_FPRND,		false, true  },
   { "hard-dfp",			OPTION_MASK_DFP,		false, true  },
   { "htm",			OPTION_MASK_HTM,		false, true  },
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-4_9-branch)
@@ -1353,7 +1353,7 @@
 ;; Used by direct move to move a SFmode value from GPR to VSX register
 (define_insn "vsx_xscvspdpn_directmove"
   [(set (match_operand:SF 0 "vsx_register_operand" "=wa")
-	(unspec:SF [(match_operand:DI 1 "vsx_register_operand" "wa")]
+	(unspec:SF [(match_operand:SF 1 "vsx_register_operand" "wa")]
 		   UNSPEC_VSX_CVSPDPN))]
   "TARGET_XSCVSPDPN"
   "xscvspdpn %x0,%x1"
Index: gcc/config/rs6000/rs6000.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/rs6000.h	(.../branches/gcc-4_9-branch)
@@ -121,6 +121,7 @@
 %{mcpu=power8: %(asm_cpu_power8)} \
 %{mcpu=a2: -ma2} \
 %{mcpu=powerpc: -mppc} \
+%{mcpu=powerpc64le: %(asm_cpu_power8)} \
 %{mcpu=rs64a: -mppc64} \
 %{mcpu=401: -mppc} \
 %{mcpu=403: -m403} \
Index: gcc/config/rs6000/altivec.md
===================================================================
--- a/src/gcc/config/rs6000/altivec.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/altivec.md	(.../branches/gcc-4_9-branch)
@@ -2436,7 +2436,7 @@
 	  (match_operand:VM2 1 "memory_operand" "Z"))
      (unspec [(const_int 0)] UNSPEC_SET_VSCR)])]
   "TARGET_ALTIVEC"
-  "lvx %0,%y1"
+  "lvxl %0,%y1"
   [(set_attr "type" "vecload")])
 
 (define_expand "altivec_lvx_<mode>"
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_9-branch)
@@ -9976,38 +9976,28 @@
 ;; value, since it is allocated in reload and not all of the flow information
 ;; is setup for it.  We have two patterns to do the two moves between gprs and
 ;; fprs.  There isn't a dependancy between the two, but we could potentially
-;; schedule other instructions between the two instructions.  TFmode is
-;; currently limited to traditional FPR registers.  If/when this is changed, we
-;; will need to revist %L to make sure it works with VSX registers, or add an
-;; %x version of %L.
+;; schedule other instructions between the two instructions.
 
 (define_insn "p8_fmrgow_<mode>"
   [(set (match_operand:FMOVE64X 0 "register_operand" "=d")
-	(unspec:FMOVE64X [(match_operand:TF 1 "register_operand" "d")]
+	(unspec:FMOVE64X [
+		(match_operand:DF 1 "register_operand" "d")
+		(match_operand:DF 2 "register_operand" "d")]
 			 UNSPEC_P8V_FMRGOW))]
   "!TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "fmrgow %0,%1,%L1"
+  "fmrgow %0,%1,%2"
   [(set_attr "type" "vecperm")])
 
-(define_insn "p8_mtvsrwz_1"
-  [(set (match_operand:TF 0 "register_operand" "=d")
-	(unspec:TF [(match_operand:SI 1 "register_operand" "r")]
+(define_insn "p8_mtvsrwz"
+  [(set (match_operand:DF 0 "register_operand" "=d")
+	(unspec:DF [(match_operand:SI 1 "register_operand" "r")]
 		   UNSPEC_P8V_MTVSRWZ))]
   "!TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
   "mtvsrwz %x0,%1"
   [(set_attr "type" "mftgpr")])
 
-(define_insn "p8_mtvsrwz_2"
-  [(set (match_operand:TF 0 "register_operand" "+d")
-	(unspec:TF [(match_dup 0)
-		    (match_operand:SI 1 "register_operand" "r")]
-		   UNSPEC_P8V_MTVSRWZ))]
-  "!TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "mtvsrwz %L0,%1"
-  [(set_attr "type" "mftgpr")])
-
 (define_insn_and_split "reload_fpr_from_gpr<mode>"
-  [(set (match_operand:FMOVE64X 0 "register_operand" "=ws")
+  [(set (match_operand:FMOVE64X 0 "register_operand" "=d")
 	(unspec:FMOVE64X [(match_operand:FMOVE64X 1 "register_operand" "r")]
 			 UNSPEC_P8V_RELOAD_FROM_GPR))
    (clobber (match_operand:TF 2 "register_operand" "=d"))]
@@ -10018,13 +10008,14 @@
 {
   rtx dest = operands[0];
   rtx src = operands[1];
-  rtx tmp = operands[2];
+  rtx tmp_hi = simplify_gen_subreg (DFmode, operands[2], TFmode, 0);
+  rtx tmp_lo = simplify_gen_subreg (DFmode, operands[2], TFmode, 8);
   rtx gpr_hi_reg = gen_highpart (SImode, src);
   rtx gpr_lo_reg = gen_lowpart (SImode, src);
 
-  emit_insn (gen_p8_mtvsrwz_1 (tmp, gpr_hi_reg));
-  emit_insn (gen_p8_mtvsrwz_2 (tmp, gpr_lo_reg));
-  emit_insn (gen_p8_fmrgow_<mode> (dest, tmp));
+  emit_insn (gen_p8_mtvsrwz (tmp_hi, gpr_hi_reg));
+  emit_insn (gen_p8_mtvsrwz (tmp_lo, gpr_lo_reg));
+  emit_insn (gen_p8_fmrgow_<mode> (dest, tmp_hi, tmp_lo));
   DONE;
 }
   [(set_attr "length" "12")
@@ -10031,29 +10022,22 @@
    (set_attr "type" "three")])
 
 ;; Move 128 bit values from GPRs to VSX registers in 64-bit mode
-(define_insn "p8_mtvsrd_1"
-  [(set (match_operand:TF 0 "register_operand" "=ws")
-	(unspec:TF [(match_operand:DI 1 "register_operand" "r")]
+(define_insn "p8_mtvsrd_df"
+  [(set (match_operand:DF 0 "register_operand" "=wa")
+	(unspec:DF [(match_operand:DI 1 "register_operand" "r")]
 		   UNSPEC_P8V_MTVSRD))]
   "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "mtvsrd %0,%1"
+  "mtvsrd %x0,%1"
   [(set_attr "type" "mftgpr")])
 
-(define_insn "p8_mtvsrd_2"
-  [(set (match_operand:TF 0 "register_operand" "+ws")
-	(unspec:TF [(match_dup 0)
-		    (match_operand:DI 1 "register_operand" "r")]
-		   UNSPEC_P8V_MTVSRD))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "mtvsrd %L0,%1"
-  [(set_attr "type" "mftgpr")])
-
 (define_insn "p8_xxpermdi_<mode>"
   [(set (match_operand:FMOVE128_GPR 0 "register_operand" "=wa")
-	(unspec:FMOVE128_GPR [(match_operand:TF 1 "register_operand" "ws")]
-			     UNSPEC_P8V_XXPERMDI))]
+	(unspec:FMOVE128_GPR [
+		(match_operand:DF 1 "register_operand" "wa")
+		(match_operand:DF 2 "register_operand" "wa")]
+		UNSPEC_P8V_XXPERMDI))]
   "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "xxpermdi %x0,%1,%L1,0"
+  "xxpermdi %x0,%x1,%x2,0"
   [(set_attr "type" "vecperm")])
 
 (define_insn_and_split "reload_vsx_from_gpr<mode>"
@@ -10061,7 +10045,7 @@
 	(unspec:FMOVE128_GPR
 	 [(match_operand:FMOVE128_GPR 1 "register_operand" "r")]
 	 UNSPEC_P8V_RELOAD_FROM_GPR))
-   (clobber (match_operand:TF 2 "register_operand" "=ws"))]
+   (clobber (match_operand:TF 2 "register_operand" "=wa"))]
   "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
   "#"
   "&& reload_completed"
@@ -10069,13 +10053,18 @@
 {
   rtx dest = operands[0];
   rtx src = operands[1];
-  rtx tmp = operands[2];
+  /* You might think that we could use op0 as one temp and a DF clobber
+     as op2, but you'd be wrong.  Secondary reload move patterns don't
+     check for overlap of the clobber and the destination.  */
+  rtx tmp_hi = simplify_gen_subreg (DFmode, operands[2], TFmode, 0);
+  rtx tmp_lo = simplify_gen_subreg (DFmode, operands[2], TFmode, 8);
   rtx gpr_hi_reg = gen_highpart (DImode, src);
   rtx gpr_lo_reg = gen_lowpart (DImode, src);
 
-  emit_insn (gen_p8_mtvsrd_1 (tmp, gpr_hi_reg));
-  emit_insn (gen_p8_mtvsrd_2 (tmp, gpr_lo_reg));
-  emit_insn (gen_p8_xxpermdi_<mode> (dest, tmp));
+  emit_insn (gen_p8_mtvsrd_df (tmp_hi, gpr_hi_reg));
+  emit_insn (gen_p8_mtvsrd_df (tmp_lo, gpr_lo_reg));
+  emit_insn (gen_p8_xxpermdi_<mode> (dest, tmp_hi, tmp_lo));
+  DONE;
 }
   [(set_attr "length" "12")
    (set_attr "type" "three")])
@@ -10092,6 +10081,13 @@
 ;; Move SFmode to a VSX from a GPR register.  Because scalar floating point
 ;; type is stored internally as double precision in the VSX registers, we have
 ;; to convert it from the vector format.
+(define_insn "p8_mtvsrd_sf"
+  [(set (match_operand:SF 0 "register_operand" "=wa")
+	(unspec:SF [(match_operand:DI 1 "register_operand" "r")]
+		   UNSPEC_P8V_MTVSRD))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "mtvsrd %x0,%1"
+  [(set_attr "type" "mftgpr")])
 
 (define_insn_and_split "reload_vsx_from_gprsf"
   [(set (match_operand:SF 0 "register_operand" "=wa")
@@ -10106,16 +10102,12 @@
   rtx op0 = operands[0];
   rtx op1 = operands[1];
   rtx op2 = operands[2];
-  /* Also use the destination register to hold the unconverted DImode value.
-     This is conceptually a separate value from OP0, so we use gen_rtx_REG
-     rather than simplify_gen_subreg.  */
-  rtx op0_di = gen_rtx_REG (DImode, REGNO (op0));
   rtx op1_di = simplify_gen_subreg (DImode, op1, SFmode, 0);
 
   /* Move SF value to upper 32-bits for xscvspdpn.  */
   emit_insn (gen_ashldi3 (op2, op1_di, GEN_INT (32)));
-  emit_move_insn (op0_di, op2);
-  emit_insn (gen_vsx_xscvspdpn_directmove (op0, op0_di));
+  emit_insn (gen_p8_mtvsrd_sf (op0, op2));
+  emit_insn (gen_vsx_xscvspdpn_directmove (op0, op0));
   DONE;
 }
   [(set_attr "length" "8")
Index: gcc/config/darwin.c
===================================================================
--- a/src/gcc/config/darwin.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/darwin.c	(.../branches/gcc-4_9-branch)
@@ -1232,6 +1232,11 @@
 void
 darwin_mark_decl_preserved (const char *name)
 {
+  /* Actually we shouldn't mark any local symbol this way, but for now
+     this only happens with ObjC meta-data.  */
+  if (darwin_label_is_anonymous_local_objc_name (name))
+    return;
+
   fprintf (asm_out_file, "\t.no_dead_strip ");
   assemble_name (asm_out_file, name);
   fputc ('\n', asm_out_file);
Index: gcc/config/arm/thumb2.md
===================================================================
--- a/src/gcc/config/arm/thumb2.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/thumb2.md	(.../branches/gcc-4_9-branch)
@@ -642,15 +642,27 @@
    (set_attr "type" "multiple")]
 )
 
-(define_insn "*thumb2_ior_scc_strict_it"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,l")
+(define_insn_and_split "*thumb2_ior_scc_strict_it"
+  [(set (match_operand:SI 0 "s_register_operand" "=&r")
 	(ior:SI (match_operator:SI 2 "arm_comparison_operator"
 		 [(match_operand 3 "cc_register" "") (const_int 0)])
-		(match_operand:SI 1 "s_register_operand" "0,?l")))]
+		(match_operand:SI 1 "s_register_operand" "r")))]
   "TARGET_THUMB2 && arm_restrict_it"
-  "@
-   it\\t%d2\;mov%d2\\t%0, #1\;it\\t%d2\;orr%d2\\t%0, %1
-   mov\\t%0, #1\;orr\\t%0, %1\;it\\t%D2\;mov%D2\\t%0, %1"
+  "#" ; orr\\t%0, %1, #1\;it\\t%D2\;mov%D2\\t%0, %1
+  "&& reload_completed"
+  [(set (match_dup 0) (ior:SI (match_dup 1) (const_int 1)))
+   (cond_exec (match_dup 4)
+     (set (match_dup 0) (match_dup 1)))]
+  {
+    machine_mode mode = GET_MODE (operands[3]);
+    rtx_code rc = GET_CODE (operands[2]);
+
+    if (mode == CCFPmode || mode == CCFPEmode)
+      rc = reverse_condition_maybe_unordered (rc);
+    else
+      rc = reverse_condition (rc);
+    operands[4] = gen_rtx_fmt_ee (rc, VOIDmode, operands[3], const0_rtx);
+  }
   [(set_attr "conds" "use")
    (set_attr "length" "8")
    (set_attr "type" "multiple")]
@@ -1409,7 +1421,8 @@
 		      (match_operand 5 "" "")
 		      (match_operand 6 "" "")))]
   "TARGET_THUMB2
-   && (INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 32)"
+   && (INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 32)
+   && peep2_reg_dead_p (2, operands[0])"
   [(parallel [(set (match_dup 0)
 		   (compare:CC_NOOV (ashift:SI (match_dup 1) (match_dup 2))
 				    (const_int 0)))
@@ -1437,7 +1450,8 @@
 		      (match_operand 5 "" "")
 		      (match_operand 6 "" "")))]
   "TARGET_THUMB2
-   && (INTVAL (operands[2]) > 0 && INTVAL (operands[2]) < 32)"
+   && (INTVAL (operands[2]) > 0 && INTVAL (operands[2]) < 32)
+   && peep2_reg_dead_p (2, operands[0])"
   [(parallel [(set (match_dup 0)
 		   (compare:CC_NOOV (ashift:SI (match_dup 1) (match_dup 2))
 				    (const_int 0)))
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-4_9-branch)
@@ -9821,7 +9821,7 @@
 
 	  *cost = COSTS_N_INSNS (1);
 
-	  if (GET_CODE (op0) == NEG)
+	  if (GET_CODE (op0) == NEG && !flag_rounding_math)
 	    op0 = XEXP (op0, 0);
 
 	  if (speed_p)
@@ -9897,6 +9897,13 @@
       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
 	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
+	  if (GET_CODE (XEXP (x, 0)) == MULT)
+	    {
+	      /* FNMUL.  */
+	      *cost = rtx_cost (XEXP (x, 0), NEG, 0, speed_p);
+	      return true;
+	    }
+
 	  *cost = COSTS_N_INSNS (1);
 	  if (speed_p)
 	    *cost += extra_cost->fp[mode != SFmode].neg;
@@ -22617,13 +22624,20 @@
     }
 
   /* We allow almost any value to be stored in the general registers.
-     Restrict doubleword quantities to even register pairs so that we can
-     use ldrd.  Do not allow very large Neon structure opaque modes in
-     general registers; they would use too many.  */
+     Restrict doubleword quantities to even register pairs in ARM state
+     so that we can use ldrd.  Do not allow very large Neon structure
+     opaque modes in general registers; they would use too many.  */
   if (regno <= LAST_ARM_REGNUM)
-    return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0)
-      && ARM_NUM_REGS (mode) <= 4;
+    {
+      if (ARM_NUM_REGS (mode) > 4)
+	  return FALSE;
 
+      if (TARGET_THUMB2)
+	return TRUE;
+
+      return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0);
+    }
+
   if (regno == FRAME_POINTER_REGNUM
       || regno == ARG_POINTER_REGNUM)
     /* We only allow integers in the fake hard registers.  */
@@ -29812,7 +29826,8 @@
     return 0;
   
   REAL_VALUE_FROM_CONST_DOUBLE (r0, operand);
-  if (exact_real_inverse (DFmode, &r0))
+  if (exact_real_inverse (DFmode, &r0)
+      && !REAL_VALUE_NEGATIVE (r0))
     {
       if (exact_real_truncate (DFmode, &r0))
 	{
@@ -29825,25 +29840,36 @@
   return 0;
 }
 
+/* If X is a CONST_DOUBLE with a value that is a power of 2 whose
+   log2 is in [1, 32], return that log2.  Otherwise return -1.
+   This is used in the patterns for vcvt.s32.f32 floating-point to
+   fixed-point conversions.  */
+
 int
-vfp3_const_double_for_bits (rtx operand)
+vfp3_const_double_for_bits (rtx x)
 {
-  REAL_VALUE_TYPE r0;
+  if (!CONST_DOUBLE_P (x))
+    return -1;
 
-  if (!CONST_DOUBLE_P (operand))
-    return 0;
+  REAL_VALUE_TYPE r;
 
-  REAL_VALUE_FROM_CONST_DOUBLE (r0, operand);
-  if (exact_real_truncate (DFmode, &r0))
-    {
-      HOST_WIDE_INT value = real_to_integer (&r0);
-      value = value & 0xffffffff;
-      if ((value != 0) && ( (value & (value - 1)) == 0))
-	return int_log2 (value);
-    }
+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+  if (REAL_VALUE_NEGATIVE (r)
+      || REAL_VALUE_ISNAN (r)
+      || REAL_VALUE_ISINF (r)
+      || !real_isinteger (&r, SFmode))
+    return -1;
 
-  return 0;
+  HOST_WIDE_INT hwint = exact_log2 (real_to_integer (&r));
+
+  /* The exact_log2 above will have returned -1 if this is
+     not an exact log2.  */
+  if (!IN_RANGE (hwint, 1, 32))
+    return -1;
+
+  return hwint;
 }
+
 
 /* Emit a memory barrier around an atomic sequence according to MODEL.  */
 
@@ -31080,7 +31106,39 @@
   #undef BRANCH
 }
 
+/* Returns true if the pattern is a valid symbolic address, which is either a
+   symbol_ref or (symbol_ref + addend).
 
+   According to the ARM ELF ABI, the initial addend of REL-type relocations
+   processing MOVW and MOVT instructions is formed by interpreting the 16-bit
+   literal field of the instruction as a 16-bit signed value in the range
+   -32768 <= A < 32768.  */
+
+bool
+arm_valid_symbolic_address_p (rtx addr)
+{
+  rtx xop0, xop1 = NULL_RTX;
+  rtx tmp = addr;
+
+  if (GET_CODE (tmp) == SYMBOL_REF || GET_CODE (tmp) == LABEL_REF)
+    return true;
+
+  /* (const (plus: symbol_ref const_int))  */
+  if (GET_CODE (addr) == CONST)
+    tmp = XEXP (addr, 0);
+
+  if (GET_CODE (tmp) == PLUS)
+    {
+      xop0 = XEXP (tmp, 0);
+      xop1 = XEXP (tmp, 1);
+
+      if (GET_CODE (xop0) == SYMBOL_REF && CONST_INT_P (xop1))
+	  return IN_RANGE (INTVAL (xop1), -0x8000, 0x7fff);
+    }
+
+  return false;
+}
+
 /* Returns true if a valid comparison operation and makes
    the operands in a form that is valid.  */
 bool
Index: gcc/config/arm/arm.h
===================================================================
--- a/src/gcc/config/arm/arm.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/arm.h	(.../branches/gcc-4_9-branch)
@@ -363,6 +363,11 @@
 /* Nonzero if this chip supports ldrex and strex */
 #define TARGET_HAVE_LDREX	((arm_arch6 && TARGET_ARM) || arm_arch7)
 
+/* Nonzero if this chip supports LPAE.  Such systems also support the
+   hardware divide instructions.  */
+#define TARGET_HAVE_LPAE						\
+  (arm_arch7 && arm_arch_arm_hwdiv && arm_arch_thumb_hwdiv)
+
 /* Nonzero if this chip supports ldrex{bh} and strex{bh}.  */
 #define TARGET_HAVE_LDREXBH	((arm_arch6k && TARGET_ARM) || arm_arch7)
 
@@ -2349,17 +2354,17 @@
    point types.  Where bit 1 indicates 16-bit support, bit 2 indicates
    32-bit support, bit 3 indicates 64-bit support.  */
 #define TARGET_ARM_FP			\
-  (TARGET_VFP_SINGLE ? 4		\
-  		     : (TARGET_VFP_DOUBLE ? (TARGET_FP16 ? 14 : 12) : 0))
+  (!TARGET_SOFT_FLOAT ? (TARGET_VFP_SINGLE ? 4		\
+			: (TARGET_VFP_DOUBLE ? (TARGET_FP16 ? 14 : 12) : 0)) \
+		      : 0)
 
 
 /* Set as a bit mask indicating the available widths of floating point
    types for hardware NEON floating point.  This is the same as
    TARGET_ARM_FP without the 64-bit bit set.  */
-#ifdef TARGET_NEON
-#define TARGET_NEON_FP		\
-  (TARGET_ARM_FP & (0xff ^ 0x08))
-#endif
+#define TARGET_NEON_FP				 \
+  (TARGET_NEON ? (TARGET_ARM_FP & (0xff ^ 0x08)) \
+	       : 0)
 
 /* The maximum number of parallel loads or stores we support in an ldm/stm
    instruction.  */
Index: gcc/config/arm/unspecs.md
===================================================================
--- a/src/gcc/config/arm/unspecs.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/unspecs.md	(.../branches/gcc-4_9-branch)
@@ -138,6 +138,7 @@
   VUNSPEC_ATOMIC_XCHG	; Represent an atomic exchange.
   VUNSPEC_ATOMIC_OP	; Represent an atomic operation.
   VUNSPEC_LL		; Represent a load-register-exclusive.
+  VUNSPEC_LDRD_ATOMIC	; Represent an LDRD used as an atomic DImode load.
   VUNSPEC_SC		; Represent a store-register-exclusive.
   VUNSPEC_LAX		; Represent a load-register-acquire-exclusive.
   VUNSPEC_SLX		; Represent a store-register-release-exclusive.
Index: gcc/config/arm/arm-protos.h
===================================================================
--- a/src/gcc/config/arm/arm-protos.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/arm-protos.h	(.../branches/gcc-4_9-branch)
@@ -282,6 +282,7 @@
 
 extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,
 					   rtx);
+extern bool arm_valid_symbolic_address_p (rtx);
 extern bool arm_validize_comparison (rtx *, rtx *, rtx *);
 #endif /* RTX_CODE */
 
Index: gcc/config/arm/vfp.md
===================================================================
--- a/src/gcc/config/arm/vfp.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/vfp.md	(.../branches/gcc-4_9-branch)
@@ -765,6 +765,17 @@
   [(set (match_operand:SF		   0 "s_register_operand" "=t")
 	(mult:SF (neg:SF (match_operand:SF 1 "s_register_operand" "t"))
 		 (match_operand:SF	   2 "s_register_operand" "t")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && !flag_rounding_math"
+  "fnmuls%?\\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")
+   (set_attr "type" "fmuls")]
+)
+
+(define_insn "*negmulsf3_vfp"
+  [(set (match_operand:SF		   0 "s_register_operand" "=t")
+	(neg:SF (mult:SF (match_operand:SF 1 "s_register_operand" "t")
+		 (match_operand:SF	   2 "s_register_operand" "t"))))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
   "fnmuls%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
@@ -776,6 +787,18 @@
   [(set (match_operand:DF		   0 "s_register_operand" "=w")
 	(mult:DF (neg:DF (match_operand:DF 1 "s_register_operand" "w"))
 		 (match_operand:DF	   2 "s_register_operand" "w")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+  && !flag_rounding_math"
+  "fnmuld%?\\t%P0, %P1, %P2"
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")
+   (set_attr "type" "fmuld")]
+)
+
+(define_insn "*negmuldf3_vfp"
+  [(set (match_operand:DF		   0 "s_register_operand" "=w")
+	(neg:DF (mult:DF (match_operand:DF 1 "s_register_operand" "w")
+		 (match_operand:DF	   2 "s_register_operand" "w"))))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fnmuld%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
Index: gcc/config/arm/constraints.md
===================================================================
--- a/src/gcc/config/arm/constraints.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/constraints.md	(.../branches/gcc-4_9-branch)
@@ -67,9 +67,10 @@
 (define_constraint "j"
  "A constant suitable for a MOVW instruction. (ARM/Thumb-2)"
  (and (match_test "TARGET_32BIT && arm_arch_thumb2")
-      (ior (match_code "high")
+      (ior (and (match_code "high")
+		(match_test "arm_valid_symbolic_address_p (XEXP (op, 0))"))
 	   (and (match_code "const_int")
-                (match_test "(ival & 0xffff0000) == 0")))))
+		(match_test "(ival & 0xffff0000) == 0")))))
 
 (define_constraint "Pj"
  "@internal A 12-bit constant suitable for an ADDW or SUBW instruction. (Thumb-2)"
@@ -338,7 +339,8 @@
  "@internal
   In ARM/ Thumb2 a const_double which can be used with a vcvt.s32.f32 with bits operation"
   (and (match_code "const_double")
-       (match_test "TARGET_32BIT && TARGET_VFP && vfp3_const_double_for_bits (op)")))
+       (match_test "TARGET_32BIT && TARGET_VFP
+		    && vfp3_const_double_for_bits (op) > 0")))
 
 (define_register_constraint "Ts" "(arm_restrict_it) ? LO_REGS : GENERAL_REGS"
  "For arm_restrict_it the core registers @code{r0}-@code{r7}.  GENERAL_REGS otherwise.")
Index: gcc/config/arm/predicates.md
===================================================================
--- a/src/gcc/config/arm/predicates.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/predicates.md	(.../branches/gcc-4_9-branch)
@@ -659,7 +659,7 @@
 (define_predicate "const_double_vcvt_power_of_two"
   (and (match_code "const_double")
        (match_test "TARGET_32BIT && TARGET_VFP
-                   && vfp3_const_double_for_bits (op)")))
+		    && vfp3_const_double_for_bits (op) > 0")))
 
 (define_predicate "neon_struct_operand"
   (and (match_code "mem")
Index: gcc/config/arm/sync.md
===================================================================
--- a/src/gcc/config/arm/sync.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/sync.md	(.../branches/gcc-4_9-branch)
@@ -77,11 +77,12 @@
     if (model == MEMMODEL_RELAXED
         || model == MEMMODEL_CONSUME
         || model == MEMMODEL_RELEASE)
-      return \"ldr<sync_sfx>\\t%0, %1\";
+      return \"ldr%(<sync_sfx>%)\\t%0, %1\";
     else
-      return \"lda<sync_sfx>\\t%0, %1\";
+      return \"lda<sync_sfx>%?\\t%0, %1\";
   }
-)
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")])
 
 (define_insn "atomic_store<mode>"
   [(set (match_operand:QHSI 0 "memory_operand" "=Q")
@@ -95,38 +96,69 @@
     if (model == MEMMODEL_RELAXED
         || model == MEMMODEL_CONSUME
         || model == MEMMODEL_ACQUIRE)
-      return \"str<sync_sfx>\t%1, %0\";
+      return \"str%(<sync_sfx>%)\t%1, %0\";
     else
-      return \"stl<sync_sfx>\t%1, %0\";
+      return \"stl<sync_sfx>%?\t%1, %0\";
   }
-)
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")])
 
-;; Note that ldrd and vldr are *not* guaranteed to be single-copy atomic,
-;; even for a 64-bit aligned address.  Instead we use a ldrexd unparied
-;; with a store.
+;; An LDRD instruction usable by the atomic_loaddi expander on LPAE targets
+
+(define_insn "arm_atomic_loaddi2_ldrd"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+       (unspec_volatile:DI
+	[(match_operand:DI 1 "arm_sync_memory_operand" "Q")]
+	  VUNSPEC_LDRD_ATOMIC))]
+  "ARM_DOUBLEWORD_ALIGN && TARGET_HAVE_LPAE"
+  "ldr%(d%)\t%0, %H0, %C1"
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")])
+
+;; There are three ways to expand this depending on the architecture
+;; features available.  As for the barriers, a load needs a barrier
+;; after it on all non-relaxed memory models except when the load
+;; has acquire semantics (for ARMv8-A).
+
 (define_expand "atomic_loaddi"
   [(match_operand:DI 0 "s_register_operand")		;; val out
    (match_operand:DI 1 "mem_noofs_operand")		;; memory
    (match_operand:SI 2 "const_int_operand")]		;; model
-  "TARGET_HAVE_LDREXD && ARM_DOUBLEWORD_ALIGN"
+  "(TARGET_HAVE_LDREXD || TARGET_HAVE_LPAE || TARGET_HAVE_LDACQ)
+   && ARM_DOUBLEWORD_ALIGN"
 {
   enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
-  if (model == MEMMODEL_SEQ_CST)
-    expand_mem_thread_fence (model);
-  DONE;
+
+  /* For ARMv8-A we can use an LDAEXD to atomically load two 32-bit registers
+     when acquire or stronger semantics are needed.  When the relaxed model is
+     used this can be relaxed to a normal LDRD.  */
+  if (TARGET_HAVE_LDACQ)
+    {
+      if (model == MEMMODEL_RELAXED)
+       emit_insn (gen_arm_atomic_loaddi2_ldrd (operands[0], operands[1]));
+      else
+       emit_insn (gen_arm_load_acquire_exclusivedi (operands[0], operands[1]));
+
+      DONE;
+    }
+
+  /* On LPAE targets LDRD and STRD accesses to 64-bit aligned
+     locations are 64-bit single-copy atomic.  We still need barriers in the
+     appropriate places to implement the ordering constraints.  */
+  if (TARGET_HAVE_LPAE)
+    emit_insn (gen_arm_atomic_loaddi2_ldrd (operands[0], operands[1]));
+  else
+    emit_insn (gen_arm_load_exclusivedi (operands[0], operands[1]));
+
+
+  /* All non-relaxed models need a barrier after the load when load-acquire
+     instructions are not available.  */
+  if (model != MEMMODEL_RELAXED)
+     expand_mem_thread_fence (model);
+
+   DONE;
 })
 
-(define_insn "atomic_loaddi_1"
-  [(set (match_operand:DI 0 "s_register_operand" "=r")
-	(unspec:DI [(match_operand:DI 1 "mem_noofs_operand" "Ua")]
-		   UNSPEC_LL))]
-  "TARGET_HAVE_LDREXD && ARM_DOUBLEWORD_ALIGN"
-  "ldrexd%?\t%0, %H0, %C1"
-  [(set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "no")])
-
 (define_expand "atomic_compare_and_swap<mode>"
   [(match_operand:SI 0 "s_register_operand" "")		;; bool out
    (match_operand:QHSD 1 "s_register_operand" "")	;; val out
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-4_9-branch)
@@ -3331,8 +3331,22 @@
   "#"   ; "orr%?\\t%0, %1, %2\;bic%?\\t%0, %0, %3"
   "&& reload_completed"
   [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 2)))
-   (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 0)))]
-  ""
+   (set (match_dup 0) (and:SI (match_dup 4) (match_dup 5)))]
+  {
+     /* If operands[3] is a constant make sure to fold the NOT into it
+	to avoid creating a NOT of a CONST_INT.  */
+    rtx not_rtx = simplify_gen_unary (NOT, SImode, operands[3], SImode);
+    if (CONST_INT_P (not_rtx))
+      {
+	operands[4] = operands[0];
+	operands[5] = not_rtx;
+      }
+    else
+      {
+	operands[5] = operands[0];
+	operands[4] = not_rtx;
+      }
+  }
   [(set_attr "length" "8")
    (set_attr "ce_count" "2")
    (set_attr "predicable" "yes")
@@ -6196,7 +6210,7 @@
   [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
 	(lo_sum:SI (match_operand:SI 1 "nonimmediate_operand" "0")
 		   (match_operand:SI 2 "general_operand"      "i")))]
-  "arm_arch_thumb2"
+  "arm_arch_thumb2 && arm_valid_symbolic_address_p (operands[2])"
   "movt%?\t%0, #:upper16:%c2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
@@ -7190,7 +7204,7 @@
 (define_insn "*arm32_movhf"
   [(set (match_operand:HF 0 "nonimmediate_operand" "=r,m,r,r")
 	(match_operand:HF 1 "general_operand"	   " m,r,r,F"))]
-  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_FP16) && !arm_restrict_it
+  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_FP16)
    && (	  s_register_operand (operands[0], HFmode)
        || s_register_operand (operands[1], HFmode))"
   "*
@@ -7228,7 +7242,8 @@
   [(set_attr "conds" "unconditional")
    (set_attr "type" "load1,store1,mov_reg,multiple")
    (set_attr "length" "4,4,4,8")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")]
 )
 
 (define_insn "*thumb1_movhf"
Index: gcc/config/pa/predicates.md
===================================================================
--- a/src/gcc/config/pa/predicates.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/pa/predicates.md	(.../branches/gcc-4_9-branch)
@@ -301,6 +301,9 @@
 
   if (reg_plus_base_memory_operand (op, mode))
     {
+      if (reload_in_progress)
+	return true;
+
       /* Extract CONST_INT operand.  */
       if (GET_CODE (op) == SUBREG)
 	op = SUBREG_REG (op);
@@ -335,6 +338,9 @@
 
   if (reg_plus_base_memory_operand (op, mode))
     {
+      if (reload_in_progress)
+	return true;
+
       /* Extract CONST_INT operand.  */
       if (GET_CODE (op) == SUBREG)
 	op = SUBREG_REG (op);
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-4_9-branch)
@@ -699,67 +699,6 @@
 (include "predicates.md")
 (include "constraints.md")
 
-;; Atomic instructions
-
-;; All memory loads and stores access storage atomically except
-;; for one exception.  The STORE BYTES, STORE DOUBLE BYTES, and
-;; doubleword loads and stores are not guaranteed to be atomic
-;; when referencing the I/O address space.
-
-;; Implement atomic DImode load using 64-bit floating point load and copy.
-
-(define_expand "atomic_loaddi"
-  [(match_operand:DI 0 "register_operand")              ;; val out
-   (match_operand:DI 1 "memory_operand")                ;; memory
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-{
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  operands[2] = gen_reg_rtx (DImode);
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1], operands[2]));
-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_loaddi_1"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (mem:DI (match_operand:SI 1 "register_operand" "r")))
-   (clobber (match_operand:DI 2 "register_operand" "=&f"))]
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-  "{fldds|fldd} 0(%1),%2\;{fstds|fstd} %2,-16(%%sp)\;{ldws|ldw} -16(%%sp),%0\;{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move")
-   (set_attr "length" "16")])
-
-;; Implement atomic DImode store using copy and 64-bit floating point store.
-
-(define_expand "atomic_storedi"
-  [(match_operand:DI 0 "memory_operand")                ;; memory
-   (match_operand:DI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-{
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
-  operands[2] = gen_reg_rtx (DImode);
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1], operands[2]));
-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_storedi_1"
-  [(set (mem:DI (match_operand:SI 0 "register_operand" "r"))
-        (match_operand:DI 1 "register_operand" "r"))
-   (clobber (match_operand:DI 2 "register_operand" "=&f"))]
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-  "{stws|stw} %1,-16(%%sp)\;{stws|stw} %R1,-12(%%sp)\;{fldds|fldd} -16(%%sp),%2\;{fstds|fstd} %2,0(%0)"
-  [(set_attr "type" "move")
-   (set_attr "length" "16")])
-
 ;; Compare instructions.
 ;; This controls RTL generation and register allocation.
 
@@ -6933,8 +6872,8 @@
 
 ;;; Hope this is only within a function...
 (define_insn "indirect_jump"
-  [(set (pc) (match_operand 0 "register_operand" "r"))]
-  "GET_MODE (operands[0]) == word_mode"
+  [(set (pc) (match_operand 0 "pmode_register_operand" "r"))]
+  ""
   "bv%* %%r0(%0)"
   [(set_attr "type" "branch")
    (set_attr "length" "4")])
@@ -7529,7 +7468,6 @@
 (define_insn "call_reg_64bit"
   [(call (mem:SI (match_operand:DI 0 "register_operand" "r"))
 	 (match_operand 1 "" "i"))
-   (clobber (reg:DI 1))
    (clobber (reg:DI 2))
    (clobber (match_operand 2))
    (use (reg:DI 27))
@@ -7550,7 +7488,6 @@
 (define_split
   [(parallel [(call (mem:SI (match_operand 0 "register_operand" ""))
 		    (match_operand 1 "" ""))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (clobber (match_operand 2))
 	      (use (reg:DI 27))
@@ -7561,7 +7498,6 @@
   [(set (match_dup 2) (reg:DI 27))
    (parallel [(call (mem:SI (match_dup 0))
 		    (match_dup 1))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (use (reg:DI 27))
 	      (use (reg:DI 29))
@@ -7571,7 +7507,6 @@
 (define_split
   [(parallel [(call (mem:SI (match_operand 0 "register_operand" ""))
 		    (match_operand 1 "" ""))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (clobber (match_operand 2))
 	      (use (reg:DI 27))
@@ -7581,7 +7516,6 @@
   [(set (match_dup 2) (reg:DI 27))
    (parallel [(call (mem:SI (match_dup 0))
 		    (match_dup 1))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (use (reg:DI 27))
 	      (use (reg:DI 29))
@@ -7592,7 +7526,6 @@
 (define_insn "*call_reg_64bit_post_reload"
   [(call (mem:SI (match_operand:DI 0 "register_operand" "r"))
 	 (match_operand 1 "" "i"))
-   (clobber (reg:DI 1))
    (clobber (reg:DI 2))
    (use (reg:DI 27))
    (use (reg:DI 29))
@@ -9855,3 +9788,72 @@
   "addil LR'%1-$tls_leoff$,%2\;ldo RR'%1-$tls_leoff$(%%r1),%0"
   [(set_attr "type" "multi")
    (set_attr "length" "8")])
+
+;; Atomic instructions
+
+;; All memory loads and stores access storage atomically except
+;; for one exception.  The STORE BYTES, STORE DOUBLE BYTES, and
+;; doubleword loads and stores are not guaranteed to be atomic
+;; when referencing the I/O address space.
+
+;; Implement atomic DImode load using 64-bit floating point load and copy.
+
+(define_expand "atomic_loaddi"
+  [(match_operand:DI 0 "register_operand")              ;; val out
+   (match_operand:DI 1 "memory_operand")                ;; memory
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+
+  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
+  operands[2] = gen_reg_rtx (DImode);
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1], operands[2]));
+  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_loaddi_1"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (mem:DI (match_operand:SI 1 "register_operand" "r")))
+   (clobber (match_operand:DI 2 "register_operand" "=&f"))]
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
+  "{fldds|fldd} 0(%1),%2\;{fstds|fstd} %2,-16(%%sp)\;{ldws|ldw} -16(%%sp),%0\;{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move")
+   (set_attr "length" "16")])
+
+;; Implement atomic DImode store using copy and 64-bit floating point store.
+
+(define_expand "atomic_storedi"
+  [(match_operand:DI 0 "memory_operand")                ;; memory
+   (match_operand:DI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+
+  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
+  operands[2] = gen_reg_rtx (DImode);
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1], operands[2]));
+  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_storedi_1"
+  [(set (mem:DI (match_operand:SI 0 "register_operand" "r"))
+        (match_operand:DI 1 "register_operand" "r"))
+   (clobber (match_operand:DI 2 "register_operand" "=&f"))]
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
+  "{stws|stw} %1,-16(%%sp)\;{stws|stw} %R1,-12(%%sp)\;{fldds|fldd} -16(%%sp),%2\;{fstds|fstd} %2,0(%0)"
+  [(set_attr "type" "move")
+   (set_attr "length" "16")])
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-4_9-branch)
@@ -1663,78 +1663,114 @@
 
   /* Handle secondary reloads for loads/stores of FP registers from
      REG+D addresses where D does not fit in 5 or 14 bits, including
-     (subreg (mem (addr))) cases.  */
+     (subreg (mem (addr))) cases, and reloads for other unsupported
+     memory operands.  */
   if (scratch_reg
-      && fp_reg_operand (operand0, mode)
+      && FP_REG_P (operand0)
       && (MEM_P (operand1)
 	  || (GET_CODE (operand1) == SUBREG
-	      && MEM_P (XEXP (operand1, 0))))
-      && !floating_point_store_memory_operand (operand1, mode))
+	      && MEM_P (XEXP (operand1, 0)))))
     {
-      if (GET_CODE (operand1) == SUBREG)
-	operand1 = XEXP (operand1, 0);
+      rtx op1 = operand1;
 
-      /* SCRATCH_REG will hold an address and maybe the actual data.  We want
-	 it in WORD_MODE regardless of what mode it was originally given
-	 to us.  */
-      scratch_reg = force_mode (word_mode, scratch_reg);
+      if (GET_CODE (op1) == SUBREG)
+	op1 = XEXP (op1, 0);
 
-      /* D might not fit in 14 bits either; for such cases load D into
-	 scratch reg.  */
-      if (reg_plus_base_memory_operand (operand1, mode)
-	  && !(TARGET_PA_20
-	       && !TARGET_ELF32
-	       && INT_14_BITS (XEXP (XEXP (operand1, 0), 1))))
+      if (reg_plus_base_memory_operand (op1, GET_MODE (op1)))
 	{
-	  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));
-	  emit_move_insn (scratch_reg,
-			  gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),
-					  Pmode,
-					  XEXP (XEXP (operand1, 0), 0),
-					  scratch_reg));
+	  if (!(TARGET_PA_20
+		&& !TARGET_ELF32
+		&& INT_14_BITS (XEXP (XEXP (op1, 0), 1)))
+	      && !INT_5_BITS (XEXP (XEXP (op1, 0), 1)))
+	    {
+	      /* SCRATCH_REG will hold an address and maybe the actual data.
+		 We want it in WORD_MODE regardless of what mode it was
+		 originally given to us.  */
+	      scratch_reg = force_mode (word_mode, scratch_reg);
+
+	      /* D might not fit in 14 bits either; for such cases load D
+		 into scratch reg.  */
+	      if (!INT_14_BITS (XEXP (XEXP (op1, 0), 1)))
+		{
+		  emit_move_insn (scratch_reg, XEXP (XEXP (op1, 0), 1));
+		  emit_move_insn (scratch_reg,
+				  gen_rtx_fmt_ee (GET_CODE (XEXP (op1, 0)),
+						  Pmode,
+						  XEXP (XEXP (op1, 0), 0),
+						  scratch_reg));
+		}
+	      else
+		emit_move_insn (scratch_reg, XEXP (op1, 0));
+	      emit_insn (gen_rtx_SET (VOIDmode, operand0,
+				  replace_equiv_address (op1, scratch_reg)));
+	      return 1;
+	    }
 	}
-      else
-	emit_move_insn (scratch_reg, XEXP (operand1, 0));
-      emit_insn (gen_rtx_SET (VOIDmode, operand0,
-			      replace_equiv_address (operand1, scratch_reg)));
-      return 1;
+      else if ((!INT14_OK_STRICT && symbolic_memory_operand (op1, VOIDmode))
+	       || IS_LO_SUM_DLT_ADDR_P (XEXP (op1, 0))
+	       || IS_INDEX_ADDR_P (XEXP (op1, 0)))
+	{
+	  /* Load memory address into SCRATCH_REG.  */
+	  scratch_reg = force_mode (word_mode, scratch_reg);
+	  emit_move_insn (scratch_reg, XEXP (op1, 0));
+	  emit_insn (gen_rtx_SET (VOIDmode, operand0,
+				  replace_equiv_address (op1, scratch_reg)));
+	  return 1;
+	}
     }
   else if (scratch_reg
-	   && fp_reg_operand (operand1, mode)
+	   && FP_REG_P (operand1)
 	   && (MEM_P (operand0)
 	       || (GET_CODE (operand0) == SUBREG
-		   && MEM_P (XEXP (operand0, 0))))
-	   && !floating_point_store_memory_operand (operand0, mode))
+		   && MEM_P (XEXP (operand0, 0)))))
     {
-      if (GET_CODE (operand0) == SUBREG)
-	operand0 = XEXP (operand0, 0);
+      rtx op0 = operand0;
 
-      /* SCRATCH_REG will hold an address and maybe the actual data.  We want
-	 it in WORD_MODE regardless of what mode it was originally given
-	 to us.  */
-      scratch_reg = force_mode (word_mode, scratch_reg);
+      if (GET_CODE (op0) == SUBREG)
+	op0 = XEXP (op0, 0);
 
-      /* D might not fit in 14 bits either; for such cases load D into
-	 scratch reg.  */
-      if (reg_plus_base_memory_operand (operand0, mode)
-	  && !(TARGET_PA_20
-	       && !TARGET_ELF32
-	       && INT_14_BITS (XEXP (XEXP (operand0, 0), 1))))
+      if (reg_plus_base_memory_operand (op0, GET_MODE (op0)))
 	{
-	  emit_move_insn (scratch_reg, XEXP (XEXP (operand0, 0), 1));
-	  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand0,
-								        0)),
-						       Pmode,
-						       XEXP (XEXP (operand0, 0),
-								   0),
-						       scratch_reg));
+	  if (!(TARGET_PA_20
+		&& !TARGET_ELF32
+		&& INT_14_BITS (XEXP (XEXP (op0, 0), 1)))
+	      && !INT_5_BITS (XEXP (XEXP (op0, 0), 1)))
+	    {
+	      /* SCRATCH_REG will hold an address and maybe the actual data.
+		 We want it in WORD_MODE regardless of what mode it was
+		 originally given to us.  */
+	      scratch_reg = force_mode (word_mode, scratch_reg);
+
+	      /* D might not fit in 14 bits either; for such cases load D
+		 into scratch reg.  */
+	      if (!INT_14_BITS (XEXP (XEXP (op0, 0), 1)))
+		{
+		  emit_move_insn (scratch_reg, XEXP (XEXP (op0, 0), 1));
+		  emit_move_insn (scratch_reg,
+				  gen_rtx_fmt_ee (GET_CODE (XEXP (op0, 0)),
+						  Pmode,
+						  XEXP (XEXP (op0, 0), 0),
+						  scratch_reg));
+		}
+	      else
+		emit_move_insn (scratch_reg, XEXP (op0, 0));
+	      emit_insn (gen_rtx_SET (VOIDmode,
+				      replace_equiv_address (op0, scratch_reg),
+				      operand1));
+	      return 1;
+	    }
 	}
-      else
-	emit_move_insn (scratch_reg, XEXP (operand0, 0));
-      emit_insn (gen_rtx_SET (VOIDmode,
-			      replace_equiv_address (operand0, scratch_reg),
-			      operand1));
-      return 1;
+      else if ((!INT14_OK_STRICT && symbolic_memory_operand (op0, VOIDmode))
+	       || IS_LO_SUM_DLT_ADDR_P (XEXP (op0, 0))
+	       || IS_INDEX_ADDR_P (XEXP (op0, 0)))
+	{
+	  /* Load memory address into SCRATCH_REG.  */
+	  emit_move_insn (scratch_reg, XEXP (op0, 0));
+	  emit_insn (gen_rtx_SET (VOIDmode,
+				  replace_equiv_address (op0, scratch_reg),
+				  operand1));
+	  return 1;
+	}
     }
   /* Handle secondary reloads for loads of FP registers from constant
      expressions by forcing the constant into memory.  For the most part,
@@ -1743,7 +1779,7 @@
      Use scratch_reg to hold the address of the memory location.  */
   else if (scratch_reg
 	   && CONSTANT_P (operand1)
-	   && fp_reg_operand (operand0, mode))
+	   && FP_REG_P (operand0))
     {
       rtx const_mem, xoperands[2];
 
@@ -1788,12 +1824,11 @@
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 
 	  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));
-	  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1,
-								        0)),
-						       Pmode,
-						       XEXP (XEXP (operand1, 0),
-						       0),
-						       scratch_reg));
+	  emit_move_insn (scratch_reg,
+			  gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),
+					  Pmode,
+					  XEXP (XEXP (operand1, 0), 0),
+					  scratch_reg));
 
 	  /* Now we are going to load the scratch register from memory,
 	     we want to load it in the same width as the original MEM,
@@ -1819,8 +1854,9 @@
       emit_move_insn (operand0, scratch_reg);
       return 1;
     }
+
   /* Handle the most common case: storing into a register.  */
-  else if (register_operand (operand0, mode))
+  if (register_operand (operand0, mode))
     {
       /* Legitimize TLS symbol references.  This happens for references
 	 that aren't a legitimate constant.  */
@@ -2435,6 +2471,7 @@
   enum { REGOP, OFFSOP, MEMOP, CNSTOP, RNDOP } optype0, optype1;
   rtx latehalf[2];
   rtx addreg0 = 0, addreg1 = 0;
+  int highonly = 0;
 
   /* First classify both operands.  */
 
@@ -2645,7 +2682,14 @@
   else if (optype1 == OFFSOP)
     latehalf[1] = adjust_address_nv (operands[1], SImode, 4);
   else if (optype1 == CNSTOP)
-    split_double (operands[1], &operands[1], &latehalf[1]);
+    {
+      if (GET_CODE (operands[1]) == HIGH)
+	{
+	  operands[1] = XEXP (operands[1], 0);
+	  highonly = 1;
+	}
+      split_double (operands[1], &operands[1], &latehalf[1]);
+    }
   else
     latehalf[1] = operands[1];
 
@@ -2699,8 +2743,11 @@
   if (addreg1)
     output_asm_insn ("ldo 4(%0),%0", &addreg1);
 
-  /* Do that word.  */
-  output_asm_insn (pa_singlemove_string (latehalf), latehalf);
+  /* Do high-numbered word.  */
+  if (highonly)
+    output_asm_insn ("ldil L'%1,%0", latehalf);
+  else
+    output_asm_insn (pa_singlemove_string (latehalf), latehalf);
 
   /* Undo the adds we just did.  */
   if (addreg0)
@@ -8539,14 +8586,6 @@
   if (TARGET_PORTABLE_RUNTIME)
     return false;
 
-  /* Sibcalls are ok for TARGET_ELF32 as along as the linker is used in
-     single subspace mode and the call is not indirect.  As far as I know,
-     there is no operating system support for the multiple subspace mode.
-     It might be possible to support indirect calls if we didn't use
-     $$dyncall (see the indirect sequence generated in pa_output_call).  */
-  if (TARGET_ELF32)
-    return (decl != NULL_TREE);
-
   /* Sibcalls are not ok because the arg pointer register is not a fixed
      register.  This prevents the sibcall optimization from occurring.  In
      addition, there are problems with stub placement using GNU ld.  This
Index: gcc/config/pa/constraints.md
===================================================================
--- a/src/gcc/config/pa/constraints.md	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/pa/constraints.md	(.../branches/gcc-4_9-branch)
@@ -106,7 +106,7 @@
   (and (match_code "mem")
        (match_test "IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))")))
 
-(define_memory_constraint "Q"
+(define_constraint "Q"
   "A memory operand that can be used as the destination operand of an
    integer store, or the source operand of an integer load.  That is
    any memory operand that isn't a symbolic, indexed or lo_sum memory
@@ -122,7 +122,7 @@
   (and (match_code "mem")
        (match_test "IS_INDEX_ADDR_P (XEXP (op, 0))")))
 
-(define_memory_constraint "T"
+(define_constraint "T"
   "A memory operand for floating-point loads and stores."
   (match_test "floating_point_store_memory_operand (op, mode)"))
 
Index: gcc/config/freebsd-spec.h
===================================================================
--- a/src/gcc/config/freebsd-spec.h	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/config/freebsd-spec.h	(.../branches/gcc-4_9-branch)
@@ -66,8 +66,9 @@
   "%{!shared: \
      %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \
 		       %{!p:%{profile:gcrt1.o%s} \
-			 %{!profile:crt1.o%s}}}} \
-   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+			 %{!profile: \
+                            %{pie: Scrt1.o%s;:crt1.o%s}}}}} \
+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
 
 /* Provide a ENDFILE_SPEC appropriate for FreeBSD.  Here we tack on
    the magical crtend.o file (see crtstuff.c) which provides part of 
@@ -76,7 +77,7 @@
 	`crtn.o'.  */
 
 #define FBSD_ENDFILE_SPEC \
-  "%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s"
+  "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
 
 /* Provide a LIB_SPEC appropriate for FreeBSD as configured and as
    required by the user-land thread model.  Before __FreeBSD_version
Index: gcc/cfgrtl.c
===================================================================
--- a/src/gcc/cfgrtl.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/cfgrtl.c	(.../branches/gcc-4_9-branch)
@@ -4239,14 +4239,14 @@
   rtx x;
   basic_block bb;
 
-  /* Once bb reordering is complete, cfg layout mode should not be re-entered.
-     Entering cfg layout mode will perform optimizations on the cfg that
-     could affect the bb layout negatively or even require fixups. An
-     example of the latter is if edge forwarding performed when optimizing
-     the cfg layout required moving a block from the hot to the cold section
-     under -freorder-blocks-and-partition. This would create an illegal
-     partitioning unless some manual fixup was performed.  */
-  gcc_assert (!crtl->bb_reorder_complete);
+  /* Once bb partitioning is complete, cfg layout mode should not be
+     re-entered.  Entering cfg layout mode may require fixups.  As an
+     example, if edge forwarding performed when optimizing the cfg
+     layout required moving a block from the hot to the cold
+     section. This would create an illegal partitioning unless some
+     manual fixup was performed.  */
+  gcc_assert (!(crtl->bb_reorder_complete
+		&& flag_reorder_blocks_and_partition));
 
   initialize_original_copy_tables ();
 
Index: gcc/tree-ssa-threadedge.c
===================================================================
--- a/src/gcc/tree-ssa-threadedge.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/tree-ssa-threadedge.c	(.../branches/gcc-4_9-branch)
@@ -282,15 +282,40 @@
 }
 
 /* A new value has been assigned to LHS.  If necessary, invalidate any
-   equivalences that are no longer valid.  */
+   equivalences that are no longer valid.   This includes invaliding
+   LHS and any objects that are currently equivalent to LHS.
+
+   Finding the objects that are currently marked as equivalent to LHS
+   is a bit tricky.  We could walk the ssa names and see if any have
+   SSA_NAME_VALUE that is the same as LHS.  That's expensive.
+
+   However, it's far more efficient to look at the unwinding stack as
+   that will have all context sensitive equivalences which are the only
+   ones that we really have to worry about here.   */
 static void
 invalidate_equivalences (tree lhs, vec<tree> *stack)
 {
 
-  for (unsigned int i = 1; i < num_ssa_names; i++)
-    if (ssa_name (i) && SSA_NAME_VALUE (ssa_name (i)) == lhs)
-      record_temporary_equivalence (ssa_name (i), NULL_TREE, stack);
+  /* The stack is an unwinding stack.  If the current element is NULL
+     then it's a "stop unwinding" marker.  Else the current marker is
+     the SSA_NAME with an equivalence and the prior entry in the stack
+     is what the current element is equivalent to.  */
+  for (int i = stack->length() - 1; i >= 0; i--)
+    {
+      /* Ignore the stop unwinding markers.  */
+      if ((*stack)[i] == NULL)
+	continue;
 
+      /* We want to check the current value of stack[i] to see if
+	 it matches LHS.  If so, then invalidate.  */
+      if (SSA_NAME_VALUE ((*stack)[i]) == lhs)
+	record_temporary_equivalence ((*stack)[i], NULL_TREE, stack);
+
+      /* Remember, we're dealing with two elements in this case.  */
+      i--;
+    }
+
+  /* And invalidate any known value for LHS itself.  */
   if (SSA_NAME_VALUE (lhs))
     record_temporary_equivalence (lhs, NULL_TREE, stack);
 }
Index: gcc/graphite-interchange.c
===================================================================
--- a/src/gcc/graphite-interchange.c	(.../tags/gcc_4_9_3_release)
+++ b/src/gcc/graphite-interchange.c	(.../branches/gcc-4_9-branch)
@@ -24,6 +24,7 @@
 #include "config.h"
 
 #ifdef HAVE_cloog
+#include <isl/constraint.h>
 #include <isl/aff.h>
 #include <isl/set.h>
 #include <isl/map.h>
Index: libgo/runtime/mgc0.c
===================================================================
--- a/src/libgo/runtime/mgc0.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgo/runtime/mgc0.c	(.../branches/gcc-4_9-branch)
@@ -2110,7 +2110,7 @@
 		runtime_notesleep(&work.alldone);
 
 	cachestats();
-	mstats.next_gc = mstats.heap_alloc+mstats.heap_alloc*gcpercent/100;
+	mstats.next_gc = mstats.heap_alloc+(mstats.heap_alloc-runtime_stacks_sys)*gcpercent/100;
 
 	t4 = runtime_nanotime();
 	mstats.last_gc = t4;
Index: libgo/go/syscall/libcall_linux.go
===================================================================
--- a/src/libgo/go/syscall/libcall_linux.go	(.../tags/gcc_4_9_3_release)
+++ b/src/libgo/go/syscall/libcall_linux.go	(.../branches/gcc-4_9-branch)
@@ -223,7 +223,6 @@
 	} else {
 		p = (*byte)(unsafe.Pointer(&_zero))
 	}
-	Entersyscall()
 	s := SYS_GETDENTS64
 	if s == 0 {
 		s = SYS_GETDENTS
@@ -233,7 +232,6 @@
 	if n < 0 {
 		err = errno
 	}
-	Exitsyscall()
 	return
 }
 
Index: libgfortran/configure
===================================================================
--- a/src/libgfortran/configure	(.../tags/gcc_4_9_3_release)
+++ b/src/libgfortran/configure	(.../branches/gcc-4_9-branch)
@@ -16485,6 +16485,15 @@
 $as_echo "#define HAVE_STRTOLD 1" >>confdefs.h
 
    fi
+
+  # ARM, AArch64 and SH also provide ftruncate.
+  case "${host}" in
+     arm* | aarch64* | sh*)
+
+$as_echo "#define HAVE_FTRUNCATE 1" >>confdefs.h
+
+       ;;
+  esac
 else
 
 
Index: libgfortran/configure.ac
===================================================================
--- a/src/libgfortran/configure.ac	(.../tags/gcc_4_9_3_release)
+++ b/src/libgfortran/configure.ac	(.../branches/gcc-4_9-branch)
@@ -280,6 +280,13 @@
    if test x"long_double_math_on_this_cpu" = x"yes"; then
      AC_DEFINE(HAVE_STRTOLD, 1, [Define if you have strtold.])
    fi
+
+  # ARM, AArch64 and SH also provide ftruncate.
+  case "${host}" in
+     arm* | aarch64* | sh*)
+       AC_DEFINE(HAVE_FTRUNCATE, 1, [Define if you have ftruncate.])
+       ;;
+  esac
 else
    AC_CHECK_FUNCS_ONCE(getrusage times mkstemp strtof strtold snprintf \
    ftruncate chsize chdir getlogin gethostname kill link symlink sleep ttyname \
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,36 @@
+2016-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+	    Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR libgfortran/70235
+	* io/write_float.def: Fix PF format for negative values of the scale
+	factor.
+
+2016-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from gcc-5-branch.
+	PR libgfortran/69668
+	* io/list_read.c (read_character): Remove code related to DELIM_NONE.
+
+2015-08-28  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	Backport from gcc-5-branch.
+	2015-08-28  James Greenhalgh  <james.greenhalgh@arm.com>
+
+	* configure.ac: Define HAVE_FTRUNCATE for ARM/AArch64/SH newlib
+	builds.
+	* configure: Regenerate.
+
+2015-08-18  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR libfortran/66936
+	* io/unix.c (__MINGW32__): Undefine HAVE_UMASK.
+
+2015-07-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR libgfortran/66650
+	* libgfortran.h (GFC_DTYPE_SIZE_MASK): Rewrite to avoid
+	"left shift of negative value" warning.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libgfortran/libgfortran.h
===================================================================
--- a/src/libgfortran/libgfortran.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libgfortran/libgfortran.h	(.../branches/gcc-4_9-branch)
@@ -415,8 +415,7 @@
 
 /* Macros to get both the size and the type with a single masking operation  */
 
-#define GFC_DTYPE_SIZE_MASK \
-  ((~((index_type) 0) >> GFC_DTYPE_SIZE_SHIFT) << GFC_DTYPE_SIZE_SHIFT)
+#define GFC_DTYPE_SIZE_MASK (-((index_type) 1 << GFC_DTYPE_SIZE_SHIFT))
 #define GFC_DTYPE_TYPE_SIZE_MASK (GFC_DTYPE_SIZE_MASK | GFC_DTYPE_TYPE_MASK)
 
 #define GFC_DTYPE_TYPE_SIZE(desc) ((desc)->dtype & GFC_DTYPE_TYPE_SIZE_MASK)
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-4_9-branch)
@@ -1006,21 +1006,6 @@
     default:
       if (dtp->u.p.namelist_mode)
 	{
-	  if (dtp->u.p.current_unit->delim_status == DELIM_NONE)
-	    {
-	      /* No delimiters so finish reading the string now.  */
-	      int i;
-	      push_char (dtp, c);
-	      for (i = dtp->u.p.ionml->string_length; i > 1; i--)
-		{
-		  if ((c = next_char (dtp)) == EOF)
-		    goto done_eof;
-		  push_char (dtp, c);
-		}
-	      dtp->u.p.saved_type = BT_CHARACTER;
-	      free_line (dtp);
-	      return;
-	    }
 	  unget_char (dtp, c);
 	  return;
 	}
Index: libgfortran/io/unix.c
===================================================================
--- a/src/libgfortran/io/unix.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libgfortran/io/unix.c	(.../branches/gcc-4_9-branch)
@@ -101,6 +101,12 @@
 }
 
 #endif /* HAVE_WORKING_STAT */
+
+
+/* On mingw, we don't use umask in tempfile_open(), because it
+   doesn't support the user/group/other-based permissions.  */
+#undef HAVE_UMASK
+
 #endif /* __MINGW32__ */
 
 
Index: libgfortran/io/write_float.def
===================================================================
--- a/src/libgfortran/io/write_float.def	(.../tags/gcc_4_9_3_release)
+++ b/src/libgfortran/io/write_float.def	(.../branches/gcc-4_9-branch)
@@ -184,9 +184,6 @@
 	      memmove (digits + nbefore, digits + nbefore + 1, p);
 	      digits[nbefore + p] = '.';
 	      nbefore += p;
-	      nafter = d - p;
-	      if (nafter < 0)
-		nafter = 0;
 	      nafter = d;
 	      nzero = 0;
 	    }
@@ -204,12 +201,27 @@
 		{
 		  nzero = -(nbefore + p);
 		  memmove (digits + 1, digits, nbefore);
-		  digits++;
-		  nafter = d + nbefore;
+		  nafter = d - nzero;
+		  if (nafter == 0 && d > 0)
+		    {
+		      /* This is needed to get the correct rounding. */
+		      memmove (digits + 1, digits, ndigits - 1);
+		      digits[1] = '0';
+		      nafter = 1;
+		      nzero = d - 1;
+		    }
+		  else if (nafter < 0)
+		    {
+		      /* Reset digits to 0 in order to get correct rounding
+			 towards infinity. */
+		      for (i = 0; i < ndigits; i++)
+			digits[i] = '0';
+		      digits[ndigits - 1] = '1';
+		      nafter = d;
+		      nzero = 0;
+		    }
 		  nbefore = 0;
 		}
-	      if (nzero > d)
-		nzero = d;
 	    }
 	}
       else
Index: Makefile.def
===================================================================
--- a/src/Makefile.def	(.../tags/gcc_4_9_3_release)
+++ b/src/Makefile.def	(.../branches/gcc-4_9-branch)
@@ -499,6 +499,7 @@
 // on libgcc and newlib/libgloss.
 lang_env_dependencies = { module=libjava; cxx=true; };
 lang_env_dependencies = { module=libitm; cxx=true; };
+lang_env_dependencies = { module=libffi; cxx=true; };
 lang_env_dependencies = { module=libcilkrts; cxx=true; };
 lang_env_dependencies = { module=newlib; no_c=true; };
 lang_env_dependencies = { module=libgloss; no_c=true; };
Index: libcpp/files.c
===================================================================
--- a/src/libcpp/files.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libcpp/files.c	(.../branches/gcc-4_9-branch)
@@ -516,7 +516,10 @@
     return entry->u.file;
 
   file = make_cpp_file (pfile, start_dir, fname);
-  file->implicit_preinclude = implicit_preinclude;
+  file->implicit_preinclude
+    = (implicit_preinclude
+       || (pfile->buffer
+	   && pfile->buffer->file->implicit_preinclude));
 
   /* Try each path in the include chain.  */
   for (; !fake ;)
@@ -709,7 +712,7 @@
 
   if (count < 0)
     {
-      cpp_errno (pfile, CPP_DL_ERROR, file->path);
+      cpp_errno_filename (pfile, CPP_DL_ERROR, file->path);
       free (buf);
       return false;
     }
@@ -1035,7 +1038,8 @@
       /* If the preprocessor output (other than dependency information) is
          being used, we must also flag an error.  */
       if (CPP_OPTION (pfile, deps.need_preprocessor_output))
-	cpp_errno (pfile, CPP_DL_FATAL, file->path);
+	cpp_errno_filename (pfile, CPP_DL_FATAL,
+			    file->path ? file->path : file->name);
     }
   else
     {
@@ -1049,9 +1053,11 @@
       if (CPP_OPTION (pfile, deps.style) == DEPS_NONE
           || print_dep
           || CPP_OPTION (pfile, deps.need_preprocessor_output))
-	cpp_errno (pfile, CPP_DL_FATAL, file->path);
+	cpp_errno_filename (pfile, CPP_DL_FATAL,
+			    file->path ? file->path : file->name);
       else
-	cpp_errno (pfile, CPP_DL_WARNING, file->path);
+	cpp_errno_filename (pfile, CPP_DL_WARNING,
+			    file->path ? file->path : file->name);
     }
 }
 
Index: libcpp/include/cpplib.h
===================================================================
--- a/src/libcpp/include/cpplib.h	(.../tags/gcc_4_9_3_release)
+++ b/src/libcpp/include/cpplib.h	(.../branches/gcc-4_9-branch)
@@ -949,6 +949,9 @@
 /* Output a diagnostic with "MSGID: " preceding the
    error string of errno.  No location is printed.  */
 extern bool cpp_errno (cpp_reader *, int, const char *msgid);
+/* Similarly, but with "FILENAME: " instead of "MSGID: ", where
+   the filename is not localized.  */
+extern bool cpp_errno_filename (cpp_reader *, int, const char *filename);
 
 /* Same as cpp_error, except additionally specifies a position as a
    (translation unit) physical line and physical column.  If the line is
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,27 @@
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2016-01-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/68176
+	* files.c (_cpp_find_file): Set file->implicit_preinclude even if
+	included from file->implicit_preinclude header.
+
+2016-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/60736
+	* include/cpplib.h (cpp_errno_filename): New prototype.
+	* errors.c (cpp_errno): Don't handle msgid "" specially, use
+	_(msgid) instead of msgid as argument to cpp_error.
+	(cpp_errno_filename): New function.
+	* files.c (read_file_guts): Use cpp_errno_filename instead of
+	cpp_errno.
+	(open_file_failed): Likewise.  Use file->name if file->path is NULL
+	in diagnostics.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: libcpp/errors.c
===================================================================
--- a/src/libcpp/errors.c	(.../tags/gcc_4_9_3_release)
+++ b/src/libcpp/errors.c	(.../branches/gcc-4_9-branch)
@@ -230,8 +230,18 @@
 bool
 cpp_errno (cpp_reader *pfile, int level, const char *msgid)
 {
-  if (msgid[0] == '\0')
-    msgid = _("stdout");
+  return cpp_error (pfile, level, "%s: %s", _(msgid), xstrerror (errno));
+}
 
-  return cpp_error (pfile, level, "%s: %s", msgid, xstrerror (errno));
+/* Print a warning or error, depending on the value of LEVEL.  Include
+   information from errno.  Unlike cpp_errno, the argument is a filename
+   that is not localized, but "" is replaced with localized "stdout".  */
+
+bool
+cpp_errno_filename (cpp_reader *pfile, int level, const char *filename)
+{
+  if (filename[0] == '\0')
+    filename = _("stdout");
+
+  return cpp_error (pfile, level, "%s: %s", filename, xstrerror (errno));
 }
Index: fixincludes/ChangeLog
===================================================================
--- a/src/fixincludes/ChangeLog	(.../tags/gcc_4_9_3_release)
+++ b/src/fixincludes/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,10 @@
+2016-02-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/68741
+	* inclhack.def (hpux_vsscanf): New fix.
+	* fixincl.x: Regenerated.
+	* tests/base/stdio.h [HPUX_VSSCANF_CHECK]: New test.
+
 2015-06-26  Release Manager
 
 	* GCC 4.9.3 released.
Index: fixincludes/tests/base/stdio.h
===================================================================
--- a/src/fixincludes/tests/base/stdio.h	(.../tags/gcc_4_9_3_release)
+++ b/src/fixincludes/tests/base/stdio.h	(.../branches/gcc-4_9-branch)
@@ -49,6 +49,11 @@
 #endif  /* HPUX11_VSNPRINTF_CHECK */
 
 
+#if defined( HPUX_VSSCANF_CHECK )
+extern int vsscanf(const char *, const char *, __gnuc_va_list);
+#endif  /* HPUX_VSSCANF_CHECK */
+
+
 #if defined( IRIX_STDIO_DUMMY_VA_LIST_CHECK )
 extern int printf( const char *, __gnuc_va_list );
 #endif  /* IRIX_STDIO_DUMMY_VA_LIST_CHECK */
Index: fixincludes/fixincl.x
===================================================================
--- a/src/fixincludes/fixincl.x	(.../tags/gcc_4_9_3_release)
+++ b/src/fixincludes/fixincl.x	(.../branches/gcc-4_9-branch)
@@ -1,12 +1,12 @@
 /*  -*- buffer-read-only: t -*- vi: set ro:
- *
+ * 
  * DO NOT EDIT THIS FILE   (fixincl.x)
- *
- * It has been AutoGen-ed  December  8, 2013 at 12:24:14 PM by AutoGen 5.18.2
+ * 
+ * It has been AutoGen-ed  Monday February  1, 2016 at 03:26:15 PM EST
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Sun Dec  8 12:24:14 PST 2013
+/* DO NOT SVN-MERGE THIS FILE, EITHER Mon  1 Feb 2016 15:26:15 EST
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 229 fixup descriptions.
+ * This file contains 230 fixup descriptions.
  *
  * See README for more information.
  *
@@ -4119,6 +4119,43 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Hpux_Vsscanf fix
+ */
+tSCC zHpux_VsscanfName[] =
+     "hpux_vsscanf";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zHpux_VsscanfList[] =
+  "stdio.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzHpux_VsscanfMachs[] = {
+        "*-*-hpux*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zHpux_VsscanfSelect0[] =
+       "(extern int vsscanf\\()char";
+
+#define    HPUX_VSSCANF_TEST_CT  1
+static tTestDesc aHpux_VsscanfTests[] = {
+  { TT_EGREP,    zHpux_VsscanfSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Hpux_Vsscanf
+ */
+static const char* apzHpux_VsscanfPatch[] = {
+    "format",
+    "%1const char",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Hpux8_Bogus_Inlines fix
  */
 tSCC zHpux8_Bogus_InlinesName[] =
@@ -9403,9 +9440,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          268
+#define REGEX_COUNT          269
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            229
+#define FIX_COUNT            230
 
 /*
  *  Enumerate the fixes
@@ -9506,6 +9543,7 @@
     HPUX11_SIZE_T_FIXIDX,
     HPUX11_SNPRINTF_FIXIDX,
     HPUX11_VSNPRINTF_FIXIDX,
+    HPUX_VSSCANF_FIXIDX,
     HPUX8_BOGUS_INLINES_FIXIDX,
     HPUX_C99_INTPTR_FIXIDX,
     HPUX_C99_INTTYPES_FIXIDX,
@@ -10118,6 +10156,11 @@
      HPUX11_VSNPRINTF_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aHpux11_VsnprintfTests,   apzHpux11_VsnprintfPatch, 0 },
 
+  {  zHpux_VsscanfName,    zHpux_VsscanfList,
+     apzHpux_VsscanfMachs,
+     HPUX_VSSCANF_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aHpux_VsscanfTests,   apzHpux_VsscanfPatch, 0 },
+
   {  zHpux8_Bogus_InlinesName,    zHpux8_Bogus_InlinesList,
      apzHpux8_Bogus_InlinesMachs,
      HPUX8_BOGUS_INLINES_TEST_CT, FD_MACH_ONLY,
Index: fixincludes/inclhack.def
===================================================================
--- a/src/fixincludes/inclhack.def	(.../tags/gcc_4_9_3_release)
+++ b/src/fixincludes/inclhack.def	(.../branches/gcc-4_9-branch)
@@ -2186,6 +2186,20 @@
 };
 
 /*
+ *  Fix missing const in hpux vsscanf declaration
+ */
+fix = {
+    hackname = hpux_vsscanf;
+    mach    = "*-*-hpux*";
+    files   = stdio.h;
+    select  = '(extern int vsscanf\()char';
+    c_fix   = format;
+    c_fix_arg = "%1const char";
+
+    test_text = 'extern int vsscanf(char *, const char *, __va_list);';
+};
+
+/*
  *  get rid of bogus inline definitions in HP-UX 8.0
  */
 fix = {
Index: .
===================================================================
--- a/src/.	(.../tags/gcc_4_9_3_release)
+++ b/src/.	(.../branches/gcc-4_9-branch)

Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
## -0,0 +0,1 ##
   Merged /branches/gcc-5-branch:r230092
