# DP: updates from the 4.7 branch upto 20140112 (r206563).

last_updated()
{
	cat > ${dir}LAST_UPDATED <<EOF
Sun Jan 12 10:47:48 CET 2014
Sun Jan 12 09:47:48 UTC 2014 (revision 206563)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/branches/gcc-4_7-branch@205768 svn://gcc.gnu.org/svn/gcc/branches/gcc-4_7-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(revision
+++ b/src/libgcc/ChangeLog	(revision
@@ -1,3 +1,8 @@
+2014-01-03  Joseph Myers  <joseph@codesourcery.com>
+
+	* config/rs6000/ibm-ldouble.c (__gcc_qdiv): Scale up arguments in
+	case of small numerator and finite nonzero result.
+
 2013-11-10  Kai Tietz  <ktietz@redhat.com>
 
 	Back-merged from trunk
Index: libgcc/config/rs6000/ibm-ldouble.c
===================================================================
--- a/src/libgcc/config/rs6000/ibm-ldouble.c	(revision
+++ b/src/libgcc/config/rs6000/ibm-ldouble.c	(revision
@@ -189,7 +189,16 @@
       || nonfinite (t))
     return t;
 
-  /* Finite nonzero result requires corrections to the highest order term.  */
+  /* Finite nonzero result requires corrections to the highest order
+     term.  These corrections require the low part of c * t to be
+     exactly represented in double.  */
+  if (fabs (a) <= 0x1p-969)
+    {
+      a *= 0x1p106;
+      b *= 0x1p106;
+      c *= 0x1p106;
+      d *= 0x1p106;
+    }
 
   s = c * t;                    /* (s,sigma) = c*t exactly.  */
   w = -(-b + d * t);	/* Written to get fnmsub for speed, but not
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(revision
+++ b/src/gcc/DATESTAMP	(revision
@@ -1 +1 @@
-20131207
+20140112
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(revision
+++ b/src/gcc/ChangeLog	(revision
@@ -1,3 +1,39 @@
+2014-01-10  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR rtl-optimization/54300
+	* regcprop.c (copyprop_hardreg_forward_1): Ensure any unused
+	outputs in a single-set are killed from the value chains.
+
+2014-01-10  Huacai Chen  <chenhc@lemote.com>
+
+	* config/mips/driver-native.c (host_detect_local_cpu): Handle new
+	kernel strings for Loongson-2E/2F/3A.
+
+2014-01-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2014-01-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (ix86_data_alignment): Calculate max_align
+	from prefetch_block tune setting.
+	(nocona_cost): Correct size of prefetch block to 64.
+
+2013-12-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (output file options): Add missing markers.
+
+2013-12-11  Kai Tietz  <ktietz@redhat.com>
+
+	PR target/56807
+	* config/i386/i386.c (ix86_expand_prologue): plus_constant
+	takes no mode-argument.
+
+2013-12-10  Kai Tietz  <ktietz@redhat.com>
+
+	PR target/56807
+	* config/i386/i386.c (ix86_expand_prologue): Address saved
+	registers stack-relative, not via frame-pointer.
+
 2013-12-03  Marek Polacek  <polacek@redhat.com>
 
 	Backport from mainline
Index: gcc/testsuite/gcc.target/arm/pr54300.C
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr54300.C	(revision
+++ b/src/gcc/testsuite/gcc.target/arm/pr54300.C	(revision
@@ -0,0 +1,61 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+#include <stdlib.h>
+
+struct __attribute__ ((aligned(8))) _v16u8_ {
+  uint8x16_t val;
+  _v16u8_( const int16x8_t &src) { val = vreinterpretq_u8_s16(src); }
+  operator int16x8_t () const { return vreinterpretq_s16_u8(val); }
+};
+typedef struct _v16u8_ v16u8;
+
+struct __attribute__ ((aligned(4))) _v8u8_ {
+  uint8x8_t val;
+  _v8u8_( const uint8x8_t &src) { val = src; }
+  operator int16x4_t () const { return vreinterpret_s16_u8(val); }
+};
+typedef struct _v8u8_ v8u8;
+
+typedef v16u8                v8i16;
+typedef int32x4_t            v4i32;
+typedef const short         cv1i16;
+typedef const unsigned char cv1u8;
+typedef const v8i16         cv8i16;
+
+static inline __attribute__((always_inline)) v8u8 zero_64(){ return vdup_n_u8( 0 ); }
+
+static inline __attribute__((always_inline)) v8i16 loadlo_8i16( cv8i16* p ){
+  return vcombine_s16( vld1_s16( (cv1i16 *)p ), zero_64() );
+}
+static inline __attribute__((always_inline)) v8i16 _loadlo_8i16( cv8i16* p, int offset ){
+  return loadlo_8i16( (cv8i16*)(&((cv1u8*)p)[offset]) );
+}
+
+void __attribute__((noinline))
+test(unsigned short *_Inp, int32_t *_Out,
+     unsigned int s1v, unsigned int dv0,
+     unsigned int smask_v)
+{
+  int32x4_t c = vdupq_n_s32(0);
+
+  for(unsigned int sv=0 ; sv!=dv0 ; sv=(sv+s1v)&smask_v )
+    {
+      int32x4_t s;
+      s = vmovl_s16( vget_low_s16( _loadlo_8i16( (cv8i16*) _Inp, sv ) ) );
+      c = vaddq_s32( c, s );
+    }
+  vst1q_s32( _Out, c );
+}
+
+main()
+{
+  unsigned short a[4] = {1, 2, 3, 4};
+  int32_t b[4] = {0, 0, 0, 0};
+  test(a, b, 1, 1, ~0);
+  if (b[0] != 1 || b[1] != 2 || b[2] != 3 || b[3] != 4)
+    abort();
+}
Index: gcc/testsuite/gcc.target/powerpc/rs6000-ldouble-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/rs6000-ldouble-3.c	(revision
+++ b/src/gcc/testsuite/gcc.target/powerpc/rs6000-ldouble-3.c	(revision
@@ -0,0 +1,21 @@
+/* Test accuracy of long double division (glibc bug 15396).  */
+/* { dg-do run { target powerpc*-*-linux* powerpc*-*-darwin* powerpc*-*-aix* rs6000-*-* } } */
+/* { dg-options "-mlong-double-128" } */
+
+extern void exit (int);
+extern void abort (void);
+
+volatile long double a = 0x1p-1024L;
+volatile long double b = 0x3p-53L;
+volatile long double r;
+volatile long double expected = 0x1.55555555555555555555555555p-973L;
+
+int
+main (void)
+{
+  r = a / b;
+  /* Allow error up to 2ulp.  */
+  if (__builtin_fabsl (r - expected) > 0x1p-1073L)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmovapd-256-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmovapd-256-2.c	(revision
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmovapd-256-2.c	(revision
@@ -15,7 +15,7 @@
 avx_test (void)
 {
   union256d u;
-  double e [4] __attribute__ ((aligned (8))) = {0.0};
+  double e [4] __attribute__ ((aligned (32))) = {0.0};
 
   u.x = _mm256_set_pd (39578.467285, 7856.342941, 85632.783567, 47563.234215);
 
Index: gcc/testsuite/gcc.target/i386/sse2-movapd-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse2-movapd-1.c	(revision
+++ b/src/gcc/testsuite/gcc.target/i386/sse2-movapd-1.c	(revision
@@ -25,7 +25,7 @@
 TEST (void)
 {
   union128d u;
-  double e[2] __attribute__ ((aligned (8))) = {2134.3343,1234.635654};
+  double e[2] __attribute__ ((aligned (16))) = {2134.3343,1234.635654};
 
   u.x = test (e);   
 
Index: gcc/testsuite/gcc.target/i386/sse2-movapd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse2-movapd-2.c	(revision
+++ b/src/gcc/testsuite/gcc.target/i386/sse2-movapd-2.c	(revision
@@ -25,7 +25,7 @@
 TEST (void)
 {
   union128d u;
-  double e[2] __attribute__ ((aligned (8))) = {0.0};
+  double e[2] __attribute__ ((aligned (16))) = {0.0};
 
   u.x = _mm_set_pd (2134.3343,1234.635654);
 
Index: gcc/testsuite/gcc.target/i386/avx-vmovapd-256-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmovapd-256-1.c	(revision
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmovapd-256-1.c	(revision
@@ -15,7 +15,7 @@
 avx_test (void)
 {
   union256d u;
-  double e [4] __attribute__ ((aligned (8)))  = {41124.234,2344.2354,8653.65635,856.43576};
+  double e [4] __attribute__ ((aligned (32)))  = {41124.234,2344.2354,8653.65635,856.43576};
 
   u.x = test (e);
 
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(revision
+++ b/src/gcc/testsuite/ChangeLog	(revision
@@ -1,3 +1,23 @@
+2014-01-10  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR rtl-optimization/54300
+	* gcc.target/arm/pr54300.C: New test.
+
+2014-01-03  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.target/powerpc/rs6000-ldouble-3.c: New test.
+
+2013-12-12  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2013-12-12  Ryan Mansfield  <rmansfield@qnx.com>
+
+	PR testsuite/59442
+	* gcc.target/i386/sse2-movapd-1.c: Fix alignment attributes.
+	* gcc.target/i386/sse2-movapd-2.c: Likewise.
+	* gcc.target/i386/avx-vmovapd-256-1.c: Likewise.
+	* gcc.target/i386/avx-vmovapd-256-2.c: Likewise.
+
 2013-12-04  Marek Polacek  <polacek@redhat.com>
 
 	PR c/59351
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(revision
+++ b/src/gcc/ada/ChangeLog	(revision
@@ -1,3 +1,7 @@
+2013-12-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/Make-lang.in (ada/doctools/xgnatugn): Use gnatmake.
+
 2013-10-19  Eric Botcazou  <ebotcazou@adacore.com>
 
 	* gcc-interface/utils.c (gnat_set_type_context): New function.
Index: gcc/ada/gcc-interface/Make-lang.in
===================================================================
--- a/src/gcc/ada/gcc-interface/Make-lang.in	(revision
+++ b/src/gcc/ada/gcc-interface/Make-lang.in	(revision
@@ -660,7 +660,7 @@
 ada/doctools/xgnatugn$(build_exeext): ada/xgnatugn.adb
 	-$(MKDIR) ada/doctools
 	$(CP) $^ ada/doctools
-	cd ada/doctools && $(GNATMAKE) -q xgnatugn
+	cd ada/doctools && gnatmake -q xgnatugn
 
 # Note that doc/gnat_ugn.texi and doc/projects.texi do not depend on
 # xgnatugn being built so we can distribute a pregenerated doc/gnat_ugn.info
Index: gcc/fortran/dump-parse-tree.c
===================================================================
--- a/src/gcc/fortran/dump-parse-tree.c	(revision
+++ b/src/gcc/fortran/dump-parse-tree.c	(revision
@@ -104,7 +104,8 @@
       break;
 
     case BT_CHARACTER:
-      show_expr (ts->u.cl->length);
+      if (ts->u.cl)
+	show_expr (ts->u.cl->length);
       fprintf(dumpfile, " %d", ts->kind);
       break;
 
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(revision
+++ b/src/gcc/fortran/ChangeLog	(revision
@@ -1,3 +1,14 @@
+2014-01-11  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	2013-12-29  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/59612
+	PR fortran/57042
+	* dump-parse-tree.c (show_typespec): Check for charlen.
+	* invoke.texi: Fix documentation of -fdump-fortran-optimized and
+	-fdump-parse-tree.
+
 2013-11-17  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/58771
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(revision
+++ b/src/gcc/config/i386/i386.c	(revision
@@ -1623,7 +1623,7 @@
   8,					/* MMX or SSE register to integer */
   8,					/* size of l1 cache.  */
   1024,					/* size of l2 cache.  */
-  128,					/* size of prefetch block */
+  64,					/* size of prefetch block */
   8,					/* number of parallel prefetches */
   1,					/* Branch cost */
   COSTS_N_INSNS (6),			/* cost of FADD and FSUB insns.  */
@@ -10431,14 +10431,15 @@
 
       if (r10_live && eax_live)
         {
-	  t = choose_baseaddr (m->fs.sp_offset - allocate);
+	  t = plus_constant (stack_pointer_rtx, allocate);
 	  emit_move_insn (r10, gen_frame_mem (Pmode, t));
-	  t = choose_baseaddr (m->fs.sp_offset - allocate - UNITS_PER_WORD);
+	  t = plus_constant (stack_pointer_rtx,
+			     allocate - UNITS_PER_WORD);
 	  emit_move_insn (eax, gen_frame_mem (Pmode, t));
 	}
       else if (eax_live || r10_live)
 	{
-	  t = choose_baseaddr (m->fs.sp_offset - allocate);
+	  t = plus_constant (stack_pointer_rtx, allocate);
 	  emit_move_insn ((eax_live ? eax : r10), gen_frame_mem (Pmode, t));
 	}
     }
@@ -24265,8 +24266,17 @@
 int
 ix86_data_alignment (tree type, int align)
 {
-  int max_align = optimize_size ? BITS_PER_WORD : MIN (256, MAX_OFILE_ALIGNMENT);
+  /* A data structure, equal or greater than the size of a cache line
+     (64 bytes in the Pentium 4 and other recent Intel processors, including
+     processors based on Intel Core microarchitecture) should be aligned
+     so that its base address is a multiple of a cache line size.  */
 
+  int max_align
+    = MIN ((unsigned) ix86_cost->prefetch_block * 8, MAX_OFILE_ALIGNMENT);
+
+  if (max_align < BITS_PER_WORD)
+    max_align = BITS_PER_WORD;
+
   if (AGGREGATE_TYPE_P (type)
       && TYPE_SIZE (type)
       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
Index: gcc/config/mips/driver-native.c
===================================================================
--- a/src/gcc/config/mips/driver-native.c	(revision
+++ b/src/gcc/config/mips/driver-native.c	(revision
@@ -116,11 +116,17 @@
     if (strncmp (buf, "cpu model", sizeof ("cpu model") - 1) == 0)
       {
 	if (strstr (buf, "Godson2 V0.2") != NULL
-	    || strstr (buf, "Loongson-2 V0.2") != NULL)
+	    || strstr (buf, "Loongson-2 V0.2") != NULL
+	    || strstr (buf, "Loongson-2E") != NULL)
 	  cpu = "loongson2e";
 	else if (strstr (buf, "Godson2 V0.3") != NULL
-		 || strstr (buf, "Loongson-2 V0.3") != NULL)
+		 || strstr (buf, "Loongson-2 V0.3") != NULL
+		 || strstr (buf, "Loongson-2F") != NULL)
 	  cpu = "loongson2f";
+	else if (strstr (buf, "Godson3 V0.5") != NULL
+		 || strstr (buf, "Loongson-3 V0.5") != NULL
+		 || strstr (buf, "Loongson-3A") != NULL)
+	  cpu = "loongson3a";
 	else if (strstr (buf, "SiByte SB1") != NULL)
 	  cpu = "sb1";
 	else if (strstr (buf, "R5000") != NULL)
Index: gcc/regcprop.c
===================================================================
--- a/src/gcc/regcprop.c	(revision
+++ b/src/gcc/regcprop.c	(revision
@@ -741,6 +741,7 @@
       int n_ops, i, alt, predicated;
       bool is_asm, any_replacements;
       rtx set;
+      rtx link;
       bool replaced[MAX_RECOG_OPERANDS];
       bool changed = false;
 
@@ -808,6 +809,23 @@
 	if (recog_op_alt[i][alt].earlyclobber)
 	  kill_value (recog_data.operand[i], vd);
 
+      /* If we have dead sets in the insn, then we need to note these as we
+	 would clobbers.  */
+      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+	{
+	  if (REG_NOTE_KIND (link) == REG_UNUSED)
+	    {
+	      kill_value (XEXP (link, 0), vd);
+	      /* Furthermore, if the insn looked like a single-set,
+		 but the dead store kills the source value of that
+		 set, then we can no-longer use the plain move
+		 special case below.  */
+	      if (set
+		  && reg_overlap_mentioned_p (XEXP (link, 0), SET_SRC (set)))
+		set = NULL;
+	    }
+	}
+
       /* Special-case plain move instructions, since we may well
 	 be able to do the move from a different register class.  */
       if (set && REG_P (SET_SRC (set)))
