# DP: updates from the 4.5 branch upto 20120122 (r183389).

last_updated()
{
	cat > ${dir}LAST_UPDATED <<EOF
Sun Jan 22 11:57:00 CET 2012
Sun Jan 22 10:57:00 UTC 2012 (revision 183389)
EOF
}

svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_4_5_3_release svn://gcc.gnu.org/svn/gcc/branches/gcc-4_5-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: configure
===================================================================
--- a/src/configure	(.../tags/gcc_4_5_3_release)
+++ b/src/configure	(.../branches/gcc-4_5-branch)
@@ -2912,9 +2912,8 @@
 
 # these libraries are built for the target environment, and are built after
 # the host libraries and the host tools (which may be a cross compiler)
-#
+# Note that libiberty is not a target library.
 target_libraries="target-libgcc \
-		target-libiberty \
 		target-libgloss \
 		target-newlib \
 		target-libgomp \
@@ -3269,14 +3268,14 @@
     ;;
   *-*-kaos*)
     # Remove unsupported stuff on all kaOS configurations.
-    skipdirs="target-libiberty ${libgcj} target-libstdc++-v3 target-librx"
+    skipdirs="${libgcj} target-libstdc++-v3 target-librx"
     skipdirs="$skipdirs target-libobjc target-examples target-groff target-gperf"
     skipdirs="$skipdirs zlib fastjar target-libjava target-boehm-gc target-zlib"
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
   *-*-netbsd*)
     # Skip some stuff on all NetBSD configurations.
-    noconfigdirs="$noconfigdirs target-newlib target-libiberty target-libgloss"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
 
     # Skip some stuff that's unsupported on some NetBSD configurations.
     case "${target}" in
@@ -3288,20 +3287,20 @@
     esac
     ;;
   *-*-netware*)
-    noconfigdirs="$noconfigdirs target-newlib target-libiberty target-libgloss ${libgcj} target-libmudflap"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj} target-libmudflap"
     ;;
   *-*-rtems*)
     noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
     ;;
     # The tpf target doesn't support gdb yet.
   *-*-tpf*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty ${libgcj} target-libmudflap gdb tcl tk libgui itcl"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj} target-libmudflap gdb tcl tk libgui itcl"
     ;;
   *-*-uclinux*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libstdc++-v3 ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
@@ -3329,7 +3328,7 @@
   sh*-*-pe|mips*-*-pe|*arm-wince-pe)
     noconfigdirs="$noconfigdirs ${libgcj}"
     noconfigdirs="$noconfigdirs target-examples"
-    noconfigdirs="$noconfigdirs target-libiberty texinfo send-pr"
+    noconfigdirs="$noconfigdirs texinfo send-pr"
     noconfigdirs="$noconfigdirs tcl tk itcl libgui sim"
     noconfigdirs="$noconfigdirs expect dejagnu"
     # the C++ libraries don't build on top of CE's C libraries
@@ -3363,7 +3362,7 @@
     libgloss_dir=arm
     ;;
   arm*-*-symbianelf*)
-    noconfigdirs="$noconfigdirs ${libgcj} target-libiberty"
+    noconfigdirs="$noconfigdirs ${libgcj}"
     libgloss_dir=arm
     ;;
   arm-*-pe*)
@@ -3382,7 +3381,7 @@
     noconfigdirs="$noconfigdirs ld target-libgloss ${libgcj}"
     ;;
   avr-*-*)
-    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj} target-libssp"
+    noconfigdirs="$noconfigdirs target-libstdc++-v3 ${libgcj} target-libssp"
     ;;
   bfin-*-*)
     unsupported_languages="$unsupported_languages java"
@@ -3561,7 +3560,7 @@
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
-    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-libstdc++-v3 ${libgcj}"
     libgloss_dir=m68hc11
     ;;
   m68k-*-elf*)
@@ -3632,7 +3631,6 @@
     noconfigdirs="$noconfigdirs gprof ${libgcj}"
     ;;
   mips*-sde-elf*)
-    skipdirs="$skipdirs target-libiberty"
     noconfigdirs="$noconfigdirs ${libgcj}"
     if test x$with_newlib = xyes; then
       noconfigdirs="$noconfigdirs gprof"
@@ -3728,7 +3726,7 @@
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
   ip2k-*-*)
-    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-libstdc++-v3 ${libgcj}"
     ;;
   *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
@@ -3917,6 +3915,9 @@
     tentative_cc="/usr/cygnus/progressive/bin/gcc"
     host_makefile_frag="config/mh-lynxrs6k"
     ;;
+  i[3456789]86-*-darwin* | x86_64-*-darwin*)
+    host_makefile_frag="config/mh-x86-darwin"
+    ;;
   powerpc-*-darwin*)
     host_makefile_frag="config/mh-ppc-darwin"
     ;;
@@ -5243,7 +5244,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_cc_gcc_supports_ada" >&5
 $as_echo "$acx_cv_cc_gcc_supports_ada" >&6; }
 
-if test x$GNATBIND != xno && test x$GNATMAKE != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
+if test "x$GNATBIND" != xno && test "x$GNATMAKE" != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
   have_gnat=yes
 else
   have_gnat=no
@@ -6992,27 +6993,6 @@
   fi
 done
 
-# Sometimes the tools are distributed with libiberty but with no other
-# libraries.  In that case, we don't want to build target-libiberty.
-# Don't let libgcc imply libiberty either.
-if test -n "${target_configdirs}" ; then
-  libgcc=
-  others=
-  for i in `echo ${target_configdirs} | sed -e s/target-//g` ; do
-    if test "$i" = "libgcc"; then
-      libgcc=target-libgcc
-    elif test "$i" != "libiberty" ; then
-      if test -r $srcdir/$i/configure ; then
-	others=yes;
-	break;
-      fi
-    fi
-  done
-  if test -z "${others}" ; then
-    target_configdirs=$libgcc
-  fi
-fi
-
 # Quietly strip out all directories which aren't configurable in this tree.
 # This relies on all configurable subdirectories being autoconfiscated, which
 # is now the case.
Index: Makefile.in
===================================================================
--- a/src/Makefile.in	(.../tags/gcc_4_5_3_release)
+++ b/src/Makefile.in	(.../branches/gcc-4_5-branch)
@@ -930,7 +930,6 @@
     maybe-configure-target-libtermcap \
     maybe-configure-target-winsup \
     maybe-configure-target-libgloss \
-    maybe-configure-target-libiberty \
     maybe-configure-target-gperf \
     maybe-configure-target-examples \
     maybe-configure-target-libffi \
@@ -1112,7 +1111,6 @@
 all-target: maybe-all-target-libtermcap
 all-target: maybe-all-target-winsup
 all-target: maybe-all-target-libgloss
-all-target: maybe-all-target-libiberty
 all-target: maybe-all-target-gperf
 all-target: maybe-all-target-examples
 all-target: maybe-all-target-libffi
@@ -1233,7 +1231,6 @@
 info-target: maybe-info-target-libtermcap
 info-target: maybe-info-target-winsup
 info-target: maybe-info-target-libgloss
-info-target: maybe-info-target-libiberty
 info-target: maybe-info-target-gperf
 info-target: maybe-info-target-examples
 info-target: maybe-info-target-libffi
@@ -1347,7 +1344,6 @@
 dvi-target: maybe-dvi-target-libtermcap
 dvi-target: maybe-dvi-target-winsup
 dvi-target: maybe-dvi-target-libgloss
-dvi-target: maybe-dvi-target-libiberty
 dvi-target: maybe-dvi-target-gperf
 dvi-target: maybe-dvi-target-examples
 dvi-target: maybe-dvi-target-libffi
@@ -1461,7 +1457,6 @@
 pdf-target: maybe-pdf-target-libtermcap
 pdf-target: maybe-pdf-target-winsup
 pdf-target: maybe-pdf-target-libgloss
-pdf-target: maybe-pdf-target-libiberty
 pdf-target: maybe-pdf-target-gperf
 pdf-target: maybe-pdf-target-examples
 pdf-target: maybe-pdf-target-libffi
@@ -1575,7 +1570,6 @@
 html-target: maybe-html-target-libtermcap
 html-target: maybe-html-target-winsup
 html-target: maybe-html-target-libgloss
-html-target: maybe-html-target-libiberty
 html-target: maybe-html-target-gperf
 html-target: maybe-html-target-examples
 html-target: maybe-html-target-libffi
@@ -1689,7 +1683,6 @@
 TAGS-target: maybe-TAGS-target-libtermcap
 TAGS-target: maybe-TAGS-target-winsup
 TAGS-target: maybe-TAGS-target-libgloss
-TAGS-target: maybe-TAGS-target-libiberty
 TAGS-target: maybe-TAGS-target-gperf
 TAGS-target: maybe-TAGS-target-examples
 TAGS-target: maybe-TAGS-target-libffi
@@ -1803,7 +1796,6 @@
 install-info-target: maybe-install-info-target-libtermcap
 install-info-target: maybe-install-info-target-winsup
 install-info-target: maybe-install-info-target-libgloss
-install-info-target: maybe-install-info-target-libiberty
 install-info-target: maybe-install-info-target-gperf
 install-info-target: maybe-install-info-target-examples
 install-info-target: maybe-install-info-target-libffi
@@ -1917,7 +1909,6 @@
 install-pdf-target: maybe-install-pdf-target-libtermcap
 install-pdf-target: maybe-install-pdf-target-winsup
 install-pdf-target: maybe-install-pdf-target-libgloss
-install-pdf-target: maybe-install-pdf-target-libiberty
 install-pdf-target: maybe-install-pdf-target-gperf
 install-pdf-target: maybe-install-pdf-target-examples
 install-pdf-target: maybe-install-pdf-target-libffi
@@ -2031,7 +2022,6 @@
 install-html-target: maybe-install-html-target-libtermcap
 install-html-target: maybe-install-html-target-winsup
 install-html-target: maybe-install-html-target-libgloss
-install-html-target: maybe-install-html-target-libiberty
 install-html-target: maybe-install-html-target-gperf
 install-html-target: maybe-install-html-target-examples
 install-html-target: maybe-install-html-target-libffi
@@ -2145,7 +2135,6 @@
 installcheck-target: maybe-installcheck-target-libtermcap
 installcheck-target: maybe-installcheck-target-winsup
 installcheck-target: maybe-installcheck-target-libgloss
-installcheck-target: maybe-installcheck-target-libiberty
 installcheck-target: maybe-installcheck-target-gperf
 installcheck-target: maybe-installcheck-target-examples
 installcheck-target: maybe-installcheck-target-libffi
@@ -2259,7 +2248,6 @@
 mostlyclean-target: maybe-mostlyclean-target-libtermcap
 mostlyclean-target: maybe-mostlyclean-target-winsup
 mostlyclean-target: maybe-mostlyclean-target-libgloss
-mostlyclean-target: maybe-mostlyclean-target-libiberty
 mostlyclean-target: maybe-mostlyclean-target-gperf
 mostlyclean-target: maybe-mostlyclean-target-examples
 mostlyclean-target: maybe-mostlyclean-target-libffi
@@ -2373,7 +2361,6 @@
 clean-target: maybe-clean-target-libtermcap
 clean-target: maybe-clean-target-winsup
 clean-target: maybe-clean-target-libgloss
-clean-target: maybe-clean-target-libiberty
 clean-target: maybe-clean-target-gperf
 clean-target: maybe-clean-target-examples
 clean-target: maybe-clean-target-libffi
@@ -2487,7 +2474,6 @@
 distclean-target: maybe-distclean-target-libtermcap
 distclean-target: maybe-distclean-target-winsup
 distclean-target: maybe-distclean-target-libgloss
-distclean-target: maybe-distclean-target-libiberty
 distclean-target: maybe-distclean-target-gperf
 distclean-target: maybe-distclean-target-examples
 distclean-target: maybe-distclean-target-libffi
@@ -2601,7 +2587,6 @@
 maintainer-clean-target: maybe-maintainer-clean-target-libtermcap
 maintainer-clean-target: maybe-maintainer-clean-target-winsup
 maintainer-clean-target: maybe-maintainer-clean-target-libgloss
-maintainer-clean-target: maybe-maintainer-clean-target-libiberty
 maintainer-clean-target: maybe-maintainer-clean-target-gperf
 maintainer-clean-target: maybe-maintainer-clean-target-examples
 maintainer-clean-target: maybe-maintainer-clean-target-libffi
@@ -2770,7 +2755,6 @@
     maybe-check-target-libtermcap \
     maybe-check-target-winsup \
     maybe-check-target-libgloss \
-    maybe-check-target-libiberty \
     maybe-check-target-gperf \
     maybe-check-target-examples \
     maybe-check-target-libffi \
@@ -2991,7 +2975,6 @@
     maybe-install-target-libtermcap \
     maybe-install-target-winsup \
     maybe-install-target-libgloss \
-    maybe-install-target-libiberty \
     maybe-install-target-gperf \
     maybe-install-target-examples \
     maybe-install-target-libffi \
@@ -50216,448 +50199,6 @@
 
 
 
-.PHONY: configure-target-libiberty maybe-configure-target-libiberty
-maybe-configure-target-libiberty:
-@if gcc-bootstrap
-configure-target-libiberty: stage_current
-@endif gcc-bootstrap
-@if target-libiberty
-maybe-configure-target-libiberty: configure-target-libiberty
-configure-target-libiberty: 
-	@: $(MAKE); $(unstage)
-	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	echo "Checking multilib configuration for libiberty..."; \
-	$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libiberty ; \
-	$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libiberty/multilib.tmp 2> /dev/null ; \
-	if test -r $(TARGET_SUBDIR)/libiberty/multilib.out; then \
-	  if cmp -s $(TARGET_SUBDIR)/libiberty/multilib.tmp $(TARGET_SUBDIR)/libiberty/multilib.out; then \
-	    rm -f $(TARGET_SUBDIR)/libiberty/multilib.tmp; \
-	  else \
-	    rm -f $(TARGET_SUBDIR)/libiberty/Makefile; \
-	    mv $(TARGET_SUBDIR)/libiberty/multilib.tmp $(TARGET_SUBDIR)/libiberty/multilib.out; \
-	  fi; \
-	else \
-	  mv $(TARGET_SUBDIR)/libiberty/multilib.tmp $(TARGET_SUBDIR)/libiberty/multilib.out; \
-	fi; \
-	test ! -f $(TARGET_SUBDIR)/libiberty/Makefile || exit 0; \
-	$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libiberty ; \
-	$(NORMAL_TARGET_EXPORTS)  \
-	echo Configuring in $(TARGET_SUBDIR)/libiberty; \
-	cd "$(TARGET_SUBDIR)/libiberty" || exit 1; \
-	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
-	  *) topdir=`echo $(TARGET_SUBDIR)/libiberty/ | \
-		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
-	esac; \
-	srcdiroption="--srcdir=$${topdir}/libiberty"; \
-	libsrcdir="$$s/libiberty"; \
-	rm -f no-such-file || : ; \
-	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
-	  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \
-	  --target=${target_alias} $${srcdiroption}  \
-	  || exit 1
-@endif target-libiberty
-
-
-
-
-
-.PHONY: all-target-libiberty maybe-all-target-libiberty
-maybe-all-target-libiberty:
-@if gcc-bootstrap
-all-target-libiberty: stage_current
-@endif gcc-bootstrap
-@if target-libiberty
-TARGET-target-libiberty=all
-maybe-all-target-libiberty: all-target-libiberty
-all-target-libiberty: configure-target-libiberty
-	@: $(MAKE); $(unstage)
-	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS)  \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)  \
-		$(TARGET-target-libiberty))
-@endif target-libiberty
-
-
-
-
-
-.PHONY: check-target-libiberty maybe-check-target-libiberty
-maybe-check-target-libiberty:
-@if target-libiberty
-maybe-check-target-libiberty: check-target-libiberty
-
-check-target-libiberty:
-	@: $(MAKE); $(unstage)
-	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)
-
-@endif target-libiberty
-
-.PHONY: install-target-libiberty maybe-install-target-libiberty
-maybe-install-target-libiberty:
-@if target-libiberty
-maybe-install-target-libiberty: install-target-libiberty
-
-install-target-libiberty: installdirs
-	@: $(MAKE); $(unstage)
-	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)
-
-@endif target-libiberty
-
-# Other targets (info, dvi, pdf, etc.)
-
-.PHONY: maybe-info-target-libiberty info-target-libiberty
-maybe-info-target-libiberty:
-@if target-libiberty
-maybe-info-target-libiberty: info-target-libiberty
-
-info-target-libiberty: \
-    configure-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing info in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           info) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-dvi-target-libiberty dvi-target-libiberty
-maybe-dvi-target-libiberty:
-@if target-libiberty
-maybe-dvi-target-libiberty: dvi-target-libiberty
-
-dvi-target-libiberty: \
-    configure-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing dvi in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           dvi) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-pdf-target-libiberty pdf-target-libiberty
-maybe-pdf-target-libiberty:
-@if target-libiberty
-maybe-pdf-target-libiberty: pdf-target-libiberty
-
-pdf-target-libiberty: \
-    configure-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing pdf in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           pdf) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-html-target-libiberty html-target-libiberty
-maybe-html-target-libiberty:
-@if target-libiberty
-maybe-html-target-libiberty: html-target-libiberty
-
-html-target-libiberty: \
-    configure-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing html in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           html) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-TAGS-target-libiberty TAGS-target-libiberty
-maybe-TAGS-target-libiberty:
-@if target-libiberty
-maybe-TAGS-target-libiberty: TAGS-target-libiberty
-
-TAGS-target-libiberty: \
-    configure-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing TAGS in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           TAGS) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-install-info-target-libiberty install-info-target-libiberty
-maybe-install-info-target-libiberty:
-@if target-libiberty
-maybe-install-info-target-libiberty: install-info-target-libiberty
-
-install-info-target-libiberty: \
-    configure-target-libiberty \
-    info-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing install-info in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           install-info) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-install-pdf-target-libiberty install-pdf-target-libiberty
-maybe-install-pdf-target-libiberty:
-@if target-libiberty
-maybe-install-pdf-target-libiberty: install-pdf-target-libiberty
-
-install-pdf-target-libiberty: \
-    configure-target-libiberty \
-    pdf-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing install-pdf in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           install-pdf) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-install-html-target-libiberty install-html-target-libiberty
-maybe-install-html-target-libiberty:
-@if target-libiberty
-maybe-install-html-target-libiberty: install-html-target-libiberty
-
-install-html-target-libiberty: \
-    configure-target-libiberty \
-    html-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing install-html in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           install-html) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-installcheck-target-libiberty installcheck-target-libiberty
-maybe-installcheck-target-libiberty:
-@if target-libiberty
-maybe-installcheck-target-libiberty: installcheck-target-libiberty
-
-installcheck-target-libiberty: \
-    configure-target-libiberty 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing installcheck in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           installcheck) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-mostlyclean-target-libiberty mostlyclean-target-libiberty
-maybe-mostlyclean-target-libiberty:
-@if target-libiberty
-maybe-mostlyclean-target-libiberty: mostlyclean-target-libiberty
-
-mostlyclean-target-libiberty: 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing mostlyclean in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           mostlyclean) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-clean-target-libiberty clean-target-libiberty
-maybe-clean-target-libiberty:
-@if target-libiberty
-maybe-clean-target-libiberty: clean-target-libiberty
-
-clean-target-libiberty: 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing clean in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           clean) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-distclean-target-libiberty distclean-target-libiberty
-maybe-distclean-target-libiberty:
-@if target-libiberty
-maybe-distclean-target-libiberty: distclean-target-libiberty
-
-distclean-target-libiberty: 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing distclean in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           distclean) \
-	  || exit 1
-
-@endif target-libiberty
-
-.PHONY: maybe-maintainer-clean-target-libiberty maintainer-clean-target-libiberty
-maybe-maintainer-clean-target-libiberty:
-@if target-libiberty
-maybe-maintainer-clean-target-libiberty: maintainer-clean-target-libiberty
-
-maintainer-clean-target-libiberty: 
-	@: $(MAKE); $(unstage)
-	@[ -f $(TARGET_SUBDIR)/libiberty/Makefile ] || exit 0 ; \
-	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
-	$(NORMAL_TARGET_EXPORTS) \
-	echo "Doing maintainer-clean in $(TARGET_SUBDIR)/libiberty" ; \
-	for flag in $(EXTRA_TARGET_FLAGS); do \
-	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
-	done; \
-	(cd $(TARGET_SUBDIR)/libiberty && \
-	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
-	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
-	          "RANLIB=$${RANLIB}" \
-	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
-	           maintainer-clean) \
-	  || exit 1
-
-@endif target-libiberty
-
-
-
-
-
 .PHONY: configure-target-gperf maybe-configure-target-gperf
 maybe-configure-target-gperf:
 @if gcc-bootstrap
@@ -57654,7 +57195,6 @@
 configure-target-libtermcap: stage_last
 configure-target-winsup: stage_last
 configure-target-libgloss: stage_last
-configure-target-libiberty: stage_last
 configure-target-gperf: stage_last
 configure-target-examples: stage_last
 configure-target-libffi: stage_last
@@ -57683,7 +57223,6 @@
 configure-target-libtermcap: maybe-all-gcc
 configure-target-winsup: maybe-all-gcc
 configure-target-libgloss: maybe-all-gcc
-configure-target-libiberty: maybe-all-gcc
 configure-target-gperf: maybe-all-gcc
 configure-target-examples: maybe-all-gcc
 configure-target-libffi: maybe-all-gcc
@@ -58395,7 +57934,6 @@
 configure-target-boehm-gc: maybe-all-target-libstdc++-v3
 configure-target-fastjar: maybe-configure-target-zlib
 all-target-fastjar: maybe-all-target-zlib
-all-target-fastjar: maybe-all-target-libiberty
 configure-target-libjava: maybe-configure-target-zlib
 configure-target-libjava: maybe-configure-target-boehm-gc
 configure-target-libjava: maybe-configure-target-qthreads
@@ -58406,9 +57944,7 @@
 all-target-libjava: maybe-all-target-qthreads
 all-target-libjava: maybe-all-target-libffi
 configure-target-libobjc: maybe-configure-target-boehm-gc
-all-target-libobjc: maybe-all-target-libiberty
 all-target-libobjc: maybe-all-target-boehm-gc
-all-target-libstdc++-v3: maybe-all-target-libiberty
 configure-target-libstdc++-v3: maybe-configure-target-libgomp
 
 configure-stage1-target-libstdc++-v3: maybe-configure-stage1-target-libgomp
@@ -58426,10 +57962,7 @@
 all-stageprofile-target-libstdc++-v3: maybe-configure-stageprofile-target-libgomp
 all-stagefeedback-target-libstdc++-v3: maybe-configure-stagefeedback-target-libgomp
 all-target-libgloss: maybe-all-target-newlib
-all-target-winsup: maybe-all-target-libiberty
 all-target-winsup: maybe-all-target-libtermcap
-configure-target-libiberty: maybe-all-binutils
-configure-target-libiberty: maybe-all-ld
 configure-target-newlib: maybe-all-binutils
 configure-target-newlib: maybe-all-ld
 
@@ -58464,7 +57997,6 @@
 configure-target-libtermcap: maybe-all-target-libgcc
 configure-target-winsup: maybe-all-target-libgcc
 configure-target-libgloss: maybe-all-target-libgcc
-configure-target-libiberty: maybe-all-target-libgcc
 configure-target-gperf: maybe-all-target-libgcc
 configure-target-examples: maybe-all-target-libgcc
 configure-target-libffi: maybe-all-target-libgcc
@@ -58495,7 +58027,6 @@
 configure-target-winsup: maybe-all-target-newlib maybe-all-target-libgloss
 
 
-
 configure-target-gperf: maybe-all-target-newlib maybe-all-target-libgloss
 configure-target-gperf: maybe-all-target-libstdc++-v3
 
Index: libgcc/config/i386/64/sfp-machine.h
===================================================================
--- a/src/libgcc/config/i386/64/sfp-machine.h	(.../tags/gcc_4_5_3_release)
+++ b/src/libgcc/config/i386/64/sfp-machine.h	(.../branches/gcc-4_5-branch)
@@ -79,17 +79,25 @@
   unsigned short int __unused5;
 };
 
+#ifdef __AVX__
+ #define ASM_INVALID "vdivss %0, %0, %0"
+ #define ASM_DIVZERO "vdivss %1, %0, %0"
+#else
+ #define ASM_INVALID "divss %0, %0"
+ #define ASM_DIVZERO "divss %1, %0"
+#endif
+
 #define FP_HANDLE_EXCEPTIONS						\
   do {									\
     if (_fex & FP_EX_INVALID)						\
       {									\
 	float f = 0.0;							\
-	__asm__ __volatile__ ("divss %0, %0 " : : "x" (f));		\
+	__asm__ __volatile__ (ASM_INVALID : : "x" (f));			\
       }									\
     if (_fex & FP_EX_DIVZERO)						\
       {									\
 	float f = 1.0, g = 0.0;						\
-	__asm__ __volatile__ ("divss %1, %0" : : "x" (f), "x" (g));	\
+	__asm__ __volatile__ (ASM_DIVZERO : : "x" (f), "x" (g));	\
       }									\
     if (_fex & FP_EX_OVERFLOW)						\
       {									\
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,9 @@
+2011-08-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/64/sfp-machine.h (ASM_INVALID): New define.
+	(ASM_DIVZERO): Ditto.
+	(FP_HANLDE_EXCEPTIONS): Use ASM_INVALID and ASM_DIVZERO.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
@@ -21,7 +27,7 @@
 2010-09-12  Gerald Pfeifer  <gerald@pfeifer.com>
 	    Andrew Pinski  <pinskia@gmail.com>
 
-	PR target/40959	
+	PR target/40959
 	* config.host (ia64*-*-freebsd*): Set extra_parts.  Set tmake_file.
 
 2010-07-31  Release Manager
Index: libgomp/fortran.c
===================================================================
--- a/src/libgomp/fortran.c	(.../tags/gcc_4_5_3_release)
+++ b/src/libgomp/fortran.c	(.../branches/gcc-4_5-branch)
@@ -1,4 +1,4 @@
-/* Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
+/* Copyright (C) 2005, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.
    Contributed by Jakub Jelinek <jakub@redhat.com>.
 
    This file is part of the GNU OpenMP Library (libgomp).
@@ -27,6 +27,7 @@
 #include "libgomp.h"
 #include "libgomp_f.h"
 #include <stdlib.h>
+#include <limits.h>
 
 #ifdef HAVE_ATTRIBUTE_ALIAS
 /* Use internal aliases if possible.  */
@@ -244,6 +245,8 @@
 omp_lock_symver (omp_test_nest_lock_)
 #endif
 
+#define TO_INT(x) ((x) > INT_MIN ? (x) < INT_MAX ? (x) : INT_MAX : INT_MIN)
+
 void
 omp_set_dynamic_ (const int32_t *set)
 {
@@ -253,7 +256,7 @@
 void
 omp_set_dynamic_8_ (const int64_t *set)
 {
-  omp_set_dynamic (*set);
+  omp_set_dynamic (!!*set);
 }
 
 void
@@ -265,7 +268,7 @@
 void
 omp_set_nested_8_ (const int64_t *set)
 {
-  omp_set_nested (*set);
+  omp_set_nested (!!*set);
 }
 
 void
@@ -277,7 +280,7 @@
 void
 omp_set_num_threads_8_ (const int64_t *set)
 {
-  omp_set_num_threads (*set);
+  omp_set_num_threads (TO_INT (*set));
 }
 
 int32_t
@@ -343,7 +346,7 @@
 void
 omp_set_schedule_8_ (const int32_t *kind, const int64_t *modifier)
 {
-  omp_set_schedule (*kind, *modifier);
+  omp_set_schedule (*kind, TO_INT (*modifier));
 }
 
 void
@@ -381,7 +384,7 @@
 void
 omp_set_max_active_levels_8_ (const int64_t *levels)
 {
-  omp_set_max_active_levels (*levels);
+  omp_set_max_active_levels (TO_INT (*levels));
 }
 
 int32_t
@@ -405,7 +408,7 @@
 int32_t
 omp_get_ancestor_thread_num_8_ (const int64_t *level)
 {
-  return omp_get_ancestor_thread_num (*level);
+  return omp_get_ancestor_thread_num (TO_INT (*level));
 }
 
 int32_t
@@ -417,7 +420,7 @@
 int32_t
 omp_get_team_size_8_ (const int64_t *level)
 {
-  return omp_get_team_size (*level);
+  return omp_get_team_size (TO_INT (*level));
 }
 
 int32_t
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,15 @@
+2011-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/48894
+	* fortran.c: Include limits.h.
+	(TO_INT): Define.
+	(omp_set_dynamic_8_, omp_set_num_threads_8_): Use !!*set instead of
+	*set.
+	(omp_set_num_threads_8_, omp_set_schedule_8_,
+	omp_set_max_active_levels_8_, omp_get_ancestor_thread_num_8_,
+	omp_get_team_size_8_): Use TO_INT macro.
+	* testsuite/libgomp.fortran/pr48894.f90: New test.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: libgomp/testsuite/libgomp.fortran/pr48894.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/pr48894.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/pr48894.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,23 @@
+! PR fortran/48894
+! { dg-do run }
+! { dg-options "-fdefault-integer-8" }
+
+  use omp_lib
+  integer, parameter :: zero = 0
+  integer :: err
+  logical :: l
+  err = 0
+  !$omp parallel
+    !$omp parallel private (l)
+      l = omp_get_ancestor_thread_num (-HUGE (zero)) .ne. -1
+      l = l .or. (omp_get_ancestor_thread_num (HUGE (zero)) .ne. -1)
+      l = l .or. (omp_get_team_size (-HUGE (zero)) .ne. -1)
+      l = l .or. (omp_get_team_size (HUGE (zero)) .ne. -1)
+      if (l) then
+        !$omp atomic
+          err = err + 1
+      endif
+    !$omp end parallel
+  !$omp end parallel
+  if (err .ne. 0) call abort
+end
Index: gcc/tree-vrp.c
===================================================================
--- a/src/gcc/tree-vrp.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-vrp.c	(.../branches/gcc-4_5-branch)
@@ -1,5 +1,5 @@
 /* Support routines for Value Range Propagation (VRP).
-   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010
+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
    Contributed by Diego Novillo <dnovillo@redhat.com>.
 
@@ -1445,7 +1445,7 @@
 
   limit = avoid_overflow_infinity (limit);
 
-  type = TREE_TYPE (limit);
+  type = TREE_TYPE (var);
   gcc_assert (limit != var);
 
   /* For pointer arithmetic, we only keep track of pointer equality
@@ -1619,8 +1619,8 @@
 	  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */
 	  if (cond_code == LT_EXPR)
 	    {
-	      tree one = build_int_cst (type, 1);
-	      max = fold_build2 (MINUS_EXPR, type, max, one);
+	      tree one = build_int_cst (TREE_TYPE (max), 1);
+	      max = fold_build2 (MINUS_EXPR, TREE_TYPE (max), max, one);
 	      if (EXPR_P (max))
 		TREE_NO_WARNING (max) = 1;
 	    }
@@ -1654,8 +1654,8 @@
 	  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */
 	  if (cond_code == GT_EXPR)
 	    {
-	      tree one = build_int_cst (type, 1);
-	      min = fold_build2 (PLUS_EXPR, type, min, one);
+	      tree one = build_int_cst (TREE_TYPE (min), 1);
+	      min = fold_build2 (PLUS_EXPR, TREE_TYPE (min), min, one);
 	      if (EXPR_P (min))
 		TREE_NO_WARNING (min) = 1;
 	    }
@@ -2257,18 +2257,28 @@
 	 op0 + op1 == 0, so we cannot claim that the sum is in ~[0,0].
 	 Note that we are guaranteed to have vr0.type == vr1.type at
 	 this point.  */
-      if (code == PLUS_EXPR && vr0.type == VR_ANTI_RANGE)
+      if (vr0.type == VR_ANTI_RANGE)
 	{
-	  set_value_range_to_varying (vr);
-	  return;
+	  if (code == PLUS_EXPR)
+	    {
+	      set_value_range_to_varying (vr);
+	      return;
+	    }
+	  /* For MIN_EXPR and MAX_EXPR with two VR_ANTI_RANGEs,
+	     the resulting VR_ANTI_RANGE is the same - intersection
+	     of the two ranges.  */
+	  min = vrp_int_const_binop (MAX_EXPR, vr0.min, vr1.min);
+	  max = vrp_int_const_binop (MIN_EXPR, vr0.max, vr1.max);
 	}
+      else
+	{
+	  /* For operations that make the resulting range directly
+	     proportional to the original ranges, apply the operation to
+	     the same end of each range.  */
+	  min = vrp_int_const_binop (code, vr0.min, vr1.min);
+	  max = vrp_int_const_binop (code, vr0.max, vr1.max);
+	}
 
-      /* For operations that make the resulting range directly
-	 proportional to the original ranges, apply the operation to
-	 the same end of each range.  */
-      min = vrp_int_const_binop (code, vr0.min, vr1.min);
-      max = vrp_int_const_binop (code, vr0.max, vr1.max);
-
       /* If both additions overflowed the range kind is still correct.
 	 This happens regularly with subtracting something in unsigned
 	 arithmetic.
@@ -4505,28 +4515,35 @@
   return need_assert;
 }
 
-/* Compare two case labels sorting first by the destination label uid
+struct case_info
+{
+  tree expr;
+  basic_block bb;
+};
+
+/* Compare two case labels sorting first by the destination bb index
    and then by the case value.  */
 
 static int
 compare_case_labels (const void *p1, const void *p2)
 {
-  const_tree const case1 = *(const_tree const*)p1;
-  const_tree const case2 = *(const_tree const*)p2;
-  unsigned int uid1 = DECL_UID (CASE_LABEL (case1));
-  unsigned int uid2 = DECL_UID (CASE_LABEL (case2));
+  const struct case_info *ci1 = (const struct case_info *) p1;
+  const struct case_info *ci2 = (const struct case_info *) p2;
+  int idx1 = ci1->bb->index;
+  int idx2 = ci2->bb->index;
 
-  if (uid1 < uid2)
+  if (idx1 < idx2)
     return -1;
-  else if (uid1 == uid2)
+  else if (idx1 == idx2)
     {
       /* Make sure the default label is first in a group.  */
-      if (!CASE_LOW (case1))
+      if (!CASE_LOW (ci1->expr))
 	return -1;
-      else if (!CASE_LOW (case2))
+      else if (!CASE_LOW (ci2->expr))
 	return 1;
       else
-        return tree_int_cst_compare (CASE_LOW (case1), CASE_LOW (case2));
+	return tree_int_cst_compare (CASE_LOW (ci1->expr),
+				     CASE_LOW (ci2->expr));
     }
   else
     return 1;
@@ -4547,8 +4564,8 @@
   gimple_stmt_iterator bsi;
   tree op;
   edge e;
-  tree vec2;
-  size_t n = gimple_switch_num_labels(last);
+  struct case_info *ci;
+  size_t n = gimple_switch_num_labels (last);
 #if GCC_VERSION >= 4000
   unsigned int idx;
 #else
@@ -4563,36 +4580,38 @@
     return false;
 
   /* Build a vector of case labels sorted by destination label.  */
-  vec2 = make_tree_vec (n);
+  ci = XNEWVEC (struct case_info, n);
   for (idx = 0; idx < n; ++idx)
-    TREE_VEC_ELT (vec2, idx) = gimple_switch_label (last, idx);
-  qsort (&TREE_VEC_ELT (vec2, 0), n, sizeof (tree), compare_case_labels);
+    {
+      ci[idx].expr = gimple_switch_label (last, idx);
+      ci[idx].bb = label_to_block (CASE_LABEL (ci[idx].expr));
+    }
+  qsort (ci, n, sizeof (struct case_info), compare_case_labels);
 
   for (idx = 0; idx < n; ++idx)
     {
       tree min, max;
-      tree cl = TREE_VEC_ELT (vec2, idx);
+      tree cl = ci[idx].expr;
+      basic_block cbb = ci[idx].bb;
 
       min = CASE_LOW (cl);
       max = CASE_HIGH (cl);
 
       /* If there are multiple case labels with the same destination
 	 we need to combine them to a single value range for the edge.  */
-      if (idx + 1 < n
-	  && CASE_LABEL (cl) == CASE_LABEL (TREE_VEC_ELT (vec2, idx + 1)))
+      if (idx + 1 < n && cbb == ci[idx + 1].bb)
 	{
 	  /* Skip labels until the last of the group.  */
 	  do {
 	    ++idx;
-	  } while (idx < n
-		   && CASE_LABEL (cl) == CASE_LABEL (TREE_VEC_ELT (vec2, idx)));
+	  } while (idx < n && cbb == ci[idx].bb);
 	  --idx;
 
 	  /* Pick up the maximum of the case label range.  */
-	  if (CASE_HIGH (TREE_VEC_ELT (vec2, idx)))
-	    max = CASE_HIGH (TREE_VEC_ELT (vec2, idx));
+	  if (CASE_HIGH (ci[idx].expr))
+	    max = CASE_HIGH (ci[idx].expr);
 	  else
-	    max = CASE_LOW (TREE_VEC_ELT (vec2, idx));
+	    max = CASE_LOW (ci[idx].expr);
 	}
 
       /* Nothing to do if the range includes the default label until we
@@ -4601,7 +4620,7 @@
 	continue;
 
       /* Find the edge to register the assert expr on.  */
-      e = find_edge (bb, label_to_block (CASE_LABEL (cl)));
+      e = find_edge (bb, cbb);
 
       /* Register the necessary assertions for the operand in the
 	 SWITCH_EXPR.  */
@@ -4619,6 +4638,7 @@
 	}
     }
 
+  XDELETEVEC (ci);
   return need_assert;
 }
 
Index: gcc/fwprop.c
===================================================================
--- a/src/gcc/fwprop.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fwprop.c	(.../branches/gcc-4_5-branch)
@@ -228,8 +228,11 @@
 
   process_uses (df_get_artificial_uses (bb_index), DF_REF_AT_TOP);
   process_defs (df_get_artificial_defs (bb_index), DF_REF_AT_TOP);
-  df_simulate_initialize_forwards (bb, local_lr);
 
+  /* We don't call df_simulate_initialize_forwards, as it may overestimate
+     the live registers if there are unused artificial defs.  We prefer
+     liveness to be underestimated.  */
+
   FOR_BB_INSNS (bb, insn)
     if (INSN_P (insn))
       {
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-4_5-branch)
@@ -1 +1 @@
-20110428
+20120122
Index: gcc/tree-tailcall.c
===================================================================
--- a/src/gcc/tree-tailcall.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-tailcall.c	(.../branches/gcc-4_5-branch)
@@ -1007,6 +1007,14 @@
 					     integer_one_node);
     }
 
+  if (a_acc || m_acc)
+    {
+      /* When the tail call elimination using accumulators is performed,
+	 statements adding the accumulated value are inserted at all exits.
+	 This turns all other tail calls to non-tail ones.  */
+      opt_tailcalls = false;
+    }
+
   for (; tailcalls; tailcalls = next)
     {
       next = tailcalls->next;
Index: gcc/reload.c
===================================================================
--- a/src/gcc/reload.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/reload.c	(.../branches/gcc-4_5-branch)
@@ -6795,6 +6795,15 @@
 	  || num > PARAM_VALUE (PARAM_MAX_RELOAD_SEARCH_INSNS))
 	return 0;
 
+      /* Don't reuse register contents from before a setjmp-type
+	 function call; on the second return (from the longjmp) it
+	 might have been clobbered by a later reuse.  It doesn't
+	 seem worthwhile to actually go and see if it is actually
+	 reused even if that information would be readily available;
+	 just don't reuse it across the setjmp call.  */
+      if (CALL_P (p) && find_reg_note (p, REG_SETJMP, NULL_RTX))
+	return 0;
+
       if (NONJUMP_INSN_P (p)
 	  /* If we don't want spill regs ...  */
 	  && (! (reload_reg_p != 0
Index: gcc/final.c
===================================================================
--- a/src/gcc/final.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/final.c	(.../branches/gcc-4_5-branch)
@@ -2241,6 +2241,11 @@
 	    location_t loc;
 	    expanded_location expanded;
 
+	    /* Make sure we flush any queued register saves in case this
+	       clobbers affected registers.  */
+	    if (dwarf2out_do_frame ())
+	      dwarf2out_frame_debug (insn, false);
+
 	    /* There's no telling what that did to the condition codes.  */
 	    CC_STATUS_INIT;
 
Index: gcc/builtins.c
===================================================================
--- a/src/gcc/builtins.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/builtins.c	(.../branches/gcc-4_5-branch)
@@ -3896,9 +3896,9 @@
 }
 
 /* Expand expression EXP, which is a call to the memcmp built-in function.
-   Return NULL_RTX if we failed and the
-   caller should emit a normal call, otherwise try to get the result in
-   TARGET, if convenient (and in mode MODE, if that's convenient).  */
+   Return NULL_RTX if we failed and the caller should emit a normal call,
+   otherwise try to get the result in TARGET, if convenient (and in mode
+   MODE, if that's convenient).  */
 
 static rtx
 expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,
@@ -3910,7 +3910,10 @@
  			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
     return NULL_RTX;
 
-#if defined HAVE_cmpmemsi || defined HAVE_cmpstrnsi
+  /* Note: The cmpstrnsi pattern, if it exists, is not suitable for
+     implementing memcmp because it will stop if it encounters two
+     zero bytes.  */
+#if defined HAVE_cmpmemsi
   {
     rtx arg1_rtx, arg2_rtx, arg3_rtx;
     rtx result;
@@ -3925,16 +3928,9 @@
       = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;
     enum machine_mode insn_mode;
 
-#ifdef HAVE_cmpmemsi
     if (HAVE_cmpmemsi)
       insn_mode = insn_data[(int) CODE_FOR_cmpmemsi].operand[0].mode;
     else
-#endif
-#ifdef HAVE_cmpstrnsi
-    if (HAVE_cmpstrnsi)
-      insn_mode = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;
-    else
-#endif
       return NULL_RTX;
 
     /* If we don't have POINTER_TYPE, call the function.  */
@@ -3959,18 +3955,10 @@
 	set_mem_size (arg2_rtx, arg3_rtx);
       }
 
-#ifdef HAVE_cmpmemsi
     if (HAVE_cmpmemsi)
       insn = gen_cmpmemsi (result, arg1_rtx, arg2_rtx, arg3_rtx,
 			   GEN_INT (MIN (arg1_align, arg2_align)));
     else
-#endif
-#ifdef HAVE_cmpstrnsi
-    if (HAVE_cmpstrnsi)
-      insn = gen_cmpstrnsi (result, arg1_rtx, arg2_rtx, arg3_rtx,
-			    GEN_INT (MIN (arg1_align, arg2_align)));
-    else
-#endif
       gcc_unreachable ();
 
     if (insn)
@@ -3996,7 +3984,7 @@
     else
       return convert_to_mode (mode, result, 0);
   }
-#endif
+#endif /* HAVE_cmpmemsi.  */
 
   return NULL_RTX;
 }
Index: gcc/fold-const.c
===================================================================
--- a/src/gcc/fold-const.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fold-const.c	(.../branches/gcc-4_5-branch)
@@ -2784,8 +2784,6 @@
 
     case VOID_TYPE:
       tem = fold_ignored_result (arg);
-      if (TREE_CODE (tem) == MODIFY_EXPR)
-	goto fold_convert_exit;
       return fold_build1_loc (loc, NOP_EXPR, type, tem);
 
     default:
Index: gcc/reorg.c
===================================================================
--- a/src/gcc/reorg.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/reorg.c	(.../branches/gcc-4_5-branch)
@@ -3557,9 +3557,11 @@
 	    }
 	}
 
+      /* See if we have a simple (conditional) jump that is useless.  */
       if (! INSN_ANNULLED_BRANCH_P (delay_insn)
+	  && ! condjump_in_parallel_p (delay_insn)
 	  && prev_active_insn (target_label) == insn
-	  && ! condjump_in_parallel_p (delay_insn)
+	  && ! BARRIER_P (prev_nonnote_insn (target_label))
 #ifdef HAVE_cc0
 	  /* If the last insn in the delay slot sets CC0 for some insn,
 	     various code assumes that it is in a delay slot.  We could
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- a/src/gcc/tree-ssa-sccvn.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-ssa-sccvn.c	(.../branches/gcc-4_5-branch)
@@ -1805,12 +1805,26 @@
 static inline bool
 set_ssa_val_to (tree from, tree to)
 {
-  tree currval;
+  tree currval = SSA_VAL (from);
 
-  if (from != to
-      && TREE_CODE (to) == SSA_NAME
-      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (to))
-    to = from;
+  if (from != to)
+    {
+      if (currval == from)
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "Not changing value number of ");
+	      print_generic_expr (dump_file, from, 0);
+	      fprintf (dump_file, " from VARYING to ");
+	      print_generic_expr (dump_file, to, 0);
+	      fprintf (dump_file, "\n");
+	    }
+	  return false;
+	}
+      else if (TREE_CODE (to) == SSA_NAME
+	       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (to))
+	to = from;
+    }
 
   /* The only thing we allow as value numbers are VN_TOP, ssa_names
      and invariants.  So assert that here.  */
@@ -1827,8 +1841,6 @@
       print_generic_expr (dump_file, to, 0);
     }
 
-  currval = SSA_VAL (from);
-
   if (currval != to  && !operand_equal_p (currval, to, OEP_PURE_SAME))
     {
       VN_INFO (from)->valnum = to;
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,851 @@
+2012-01-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* cfgrtl.c (rtl_dump_bb): Do not dump insns for {ENTRY|EXIT}_BLOCK.
+
+2012-01-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/51821
+	* recog.c (peep2_find_free_register): Determine clobbered registers
+	from insn pattern.
+
+2012-01-12  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	Backport from mainline:
+	2012-01-11  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	* config/arm/arm.md (mov_notscc): Use MVN for false condition.
+
+2012-01-10  Joseph Myers  <joseph@codesourcery.com>
+
+	Revert:
+
+	2008-09-18  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR rtl-opt/37451
+	* loop-doloop.c (doloop_modify): New argument zero_extend_p and
+	zero extend count after the correction to it is done.
+	(doloop_optimize): Update call to doloop_modify, don't zero extend
+	count before call.
+
+	2008-11-03  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR rtl-opt/37782
+	* loop-doloop.c (doloop_modify): Add from_mode argument that says what
+	mode count is in.
+	(doloop_optimize): Update call to doloop_modify.
+
+2012-01-09  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	* config/mips/mips.md (loadgp_newabi_<mode>): Add missing
+	earlyclobber.
+
+2012-01-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/51759
+	Backport from mainline
+	2010-09-15  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/45644
+	* tree-sra.c (create_access): Check for bit-fields directly.
+
+2012-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sol2-unwind.h (sparc64_is_sighandler): Check that the
+	purported sigacthandler address isn't null before dereferencing it.
+	(sparc_is_sighandler): Likewise.
+
+2012-01-06  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR middle-end/48660
+	* expr.h (copy_blkmode_to_reg): Declare.
+	* expr.c (copy_blkmode_to_reg): New function.
+	(expand_assignment): Don't expand register RESULT_DECLs before
+	the lhs.  Use copy_blkmode_to_reg to copy BLKmode values into a
+	RESULT_DECL register.
+	(expand_expr_real_1): Handle BLKmode decls when looking for promotion.
+
+2012-01-04  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2012-01-04  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49651
+	* tree-ssa-structalias.c (type_can_have_subvars): New function.
+	(var_can_have_subvars): Use it.
+	(get_constraint_for_1): Only consider subfields if there
+	can be any.
+
+	2011-07-14  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49651
+	* tree-ssa-structalias.c (get_constraint_for_1): Properly
+	handle dereferences with subvariables.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-10-12  Paul Koning  <pkoning@gcc.gnu.org>
+
+	PR tree-optimization/50189
+	* tree-vrp.c (extract_range_from_assert): Use the type of
+	the variable, not the limit.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-10-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/49279
+	* tree-ssa-structalias.c (find_func_aliases): Don't handle
+	CAST_RESTRICT.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-08-23  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/50162
+	* tree-vect-stmts.c (vectorizable_call): Fix argument lookup.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-05-12  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/48172
+	* tree-vect-loop-manip.c (vect_vfa_segment_size): Do not exclude
+	the number of iterations from the segment size calculation.
+	(vect_create_cond_for_alias_checks): Adjust.
+
+	2011-05-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/48172
+	* tree-vect-loop-manip.c (vect_vfa_segment_size): Avoid
+	multiplying by number of iterations for equal step.
+	(vect_create_cond_for_alias_checks): Likewise.
+
+2011-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2011-12-21  Richard Guenther  <rguenther@suse.de>
+
+	PR lto/41159
+	* tree-outof-ssa.c (insert_value_copy_on_edge): Use the
+	mode of the pseudo as destination mode.  Only assert that
+	is equal to the promoted mode of the decl if it is a REG.
+
+2011-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/linux-unwind.h: Update copyright years.
+	(MD_FROB_UPDATE_CONTEXT): New define.
+	(alpha_frob_update_context): New function.
+
+2011-12-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.md (UNSPEC_FRAME_BLOCKAGE): New constant.
+	(frame_blockage): New expander.
+	(frame_blockage<P:mode>): New instruction.
+	* config/sparc/sparc.c (sparc_expand_prologue): When the sequence of
+	instructions establishing the frame isn't atomic, emit frame blockage.
+
+2011-12-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* lto-streamer-out.c (write_symbol): Use proper 64-bit host type.
+	* lto-streamer-in.c (lto_read_body): Use 'int' for offsets.
+	(lto_input_toplevel_asms): Likewise.
+	* lto-section-in.c (lto_create_simple_input_block): Likewise.
+	* lto-opts.c (lto_read_file_options): Likewise.
+	* ipa-prop.c (ipa_prop_read_section): Likewise.
+
+	* df.h (DF_NOTE): Fix typo in comment.
+
+2011-12-13  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* regmove.c (fixup_match_2): Only access call_used_regs with hard
+	regs.
+
+2011-12-09  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+
+	2011-12-05  Kazu Hirata  <kazu@codesourcery.com>
+
+	PR target/51408
+	* config/arm/arm.md (*minmax_arithsi): Always require the else
+	clause in the MINUS case.
+
+2011-12-04  Jrmie Detrey  <Jeremie.Detrey@loria.fr>
+
+	PR target/51393
+	* config/i386/avxintrin.h (_mm256_insert_epi64): Declare second
+	parameter as long long.
+
+2011-11-25  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	Backport from mainline:
+
+	2011-03-29  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR debug/48190
+	* dwarf2out.c (dw_loc_list_node): Add resolved_addr and replaced.
+	(cached_dw_loc_list_def): New structure.
+	(cached_dw_loc_list): New typedef.
+	(cached_dw_loc_list_table): New variable.
+	(cached_dw_loc_list_table_hash): New function.
+	(cached_dw_loc_list_table_eq): Likewise.
+	(add_location_or_const_value_attribute): Take a bool cache_p.
+	Cache the list when the parameter is true.
+	(gen_formal_parameter_die): Update caller.
+	(gen_variable_die): Likewise.
+	(dwarf2out_finish): Likewise.
+	(dwarf2out_abstract_function): Nullify cached_dw_loc_list_table
+	while generating debug info for the decl.
+	(dwarf2out_function_decl): Clear cached_dw_loc_list_table.
+	(dwarf2out_init): Initialize cached_dw_loc_list_table.
+	(resolve_addr): Cache the result of resolving a chain of
+	location lists.
+
+	From: 2010-10-12  Jakub Jelinek  <jakub@redhat.com>
+	* dwarf2out.c (dw_loc_list_node): Add emitted field.
+	(output_loc_list): Return immediately if emitted is set, set it.
+
+2011-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/51187
+	* reorg.c (relax_delay_slots): Do not consider a jump useless if there
+	is a barrier between the jump and its target label.
+
+2011-11-07  Alan Modra  <amodra@gmail.com>
+
+	PR target/30282
+	* config/rs6000/rs6000.c (rs6000_emit_stack_reset): Always emit
+	blockage for ABI_V4.
+
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/50979
+	* config/sparc/sparc.h (ASM_CPU_SPEC): Pass -Av8 if -mcpu=v8.
+
+2011-10-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50875
+	* config/i386/sse.md (*avx_unpcklpd256): Remove extra insn
+	constraints.  Change alternative 1 to "x,m,1".
+
+2011-10-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/50691
+	* config/pa/pa.c (emit_move_sequence): Legitimize TLS symbol
+	references.
+	* config/pa/pa.h (LEGITIMATE_CONSTANT_P): Return false for
+	TLS_MODEL_GLOBAL_DYNAMIC and TLS_MODEL_LOCAL_DYNAMIC symbol references.
+
+2011-10-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50788
+	* config/i386/sse.md (avx_maskload<ssemodesuffix><avxmodesuffix>):
+	Remove (match_dup 0).
+
+2011-10-18  Uros Bizjak  <ubizjak@gmail.com>
+	    Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/50737
+	* config/alpha/linux-unwind.h (alpha_fallback_frame_state): Set
+	fs->signal_frame to 1.
+
+2011-10-12  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/50565
+	* convert.c (convert_to_integer): Do not narrow operands of
+	pointer subtraction.
+
+2011-10-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/49965
+	* config/sparc/sparc.md (mov<I:mode>cc): Do not save comparison code.
+	(mov<F:mode>cc): Likewise.
+
+2011-09-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50464
+	* config/i386/sse.md (xop_pcmov_<mode>): Change operand 1 predicate
+	to register_operand and operand 2 predicate to nonimmediate_operand.
+	(xop_pcmov_<mode>256): Ditto.
+	* config/i386/i386.c (ix86_expand_sse_movcc): When generating
+	xop_pcmov, force op_true to register.  Also, force op_false to
+	register if it doesn't satisfy nonimmediate_operand predicate.
+
+2011-09-18  Eric Botcazou  <ebotcazou@adacore.com>
+	    Iain Sandoe  <developer@sandoe-acoustics.co.uk>
+
+	PR target/50091
+	* config/rs6000/rs6000.md (probe_stack): Use explicit operand.
+
+2011-09-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2011-09-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/49911
+	* tree-sra.c (analyze_access_subtree): Change type of to-be-replaced
+	enumerations to the corresponding plain integer type.
+
+2011-08-26  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR target/50090
+	* config/arm/bpabi.h (RENAME_LIBRARY_SET): Delete.
+	(RENAME_LIBRARY): Use a C-level alias instead of an assembly one.
+
+2011-08-12  Nick Clifton  <nickc@redhat.com>
+
+	* builtins.c (expand_builtin_memcmp): Do not use cmpstrnsi pattern.
+	* doc/md.texi (cmpstrn): Note that the comparison stops if both
+	fetched bytes are zero.
+	(cmpstr): Likewise.
+	(cmpmem): Note that the comparison does not stop if both of the
+	fetched bytes are zero.
+
+2011-08-11  Kazuhiro Inaoka  <kazuhiro.inaoka.ud@renesas.com>
+
+	* config/rx/rx.md (movsicc): Allow register to register transfers.
+	(*movsicc): Likewise.
+	(*stcc): Restrict this pattern to EQ and NE compares.
+	(*stcc_reg): New pattern.  Works for any comparison but only for
+	register transfers.
+
+2011-08-10  DJ Delorie  <dj@redhat.com>
+
+	* expr.c (expand_expr_addr_expr_1): Detect a user request for
+	a local frame in a naked function, and produce a suitable
+	error for that specific case.
+
+2011-08-06  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50001
+	* config/alpha/alpha.c (alpha_instantiate_decls): New function.
+	(TARGET_INSTANTIATE_DECLS): New define.
+
+2011-08-01  Sebastien Bourdeauducq  <sebastien@milkymist.org>
+
+	* config/lm32/t-lm32: Add missing multilibs.
+
+2011-07-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/49920
+	* config/i386/i386.md (strset): Do not expand strset_singleop
+	when %eax or $edi are fixed.
+	(*strsetdi_rex_1): Disable when %eax or %edi are fixed.
+	(*strsetsi_1): Ditto.
+	(*strsetsi_rex_1): Ditto.
+	(*strsethi_1): Ditto.
+	(*strsethi_rex_1): Ditto.
+	(*strsetqi_1): Ditto.
+	(*strsetqi_rex_1): Ditto.
+	(*rep_stosdi_rex64): Disable when %eax, %ecx or %edi are fixed.
+	(*rep_stossi): Ditto.
+	(*rep_stossi_rex64): Ditto.
+	(*rep_stosqi): Ditto.
+	(*rep_stosqi_rex64): Ditto.
+	(*strlenqi_1): Ditto.
+	(*strlenqi_rex_1): Ditto.
+	(cmpstrnsi): Also fail when %ecx is fixed.
+	(*cmpstrnqi_nz_1): Disable when %ecx, %esi or %edi are fixed.
+	(*cmpstrnqi_nz_rex_1): Ditto.
+	(*cmpstrnqi_1): Ditto.
+	(*cmpstrnqi_rex_1): Ditto.
+	(*strmovdi_rex_1): Disable when %esi or %edi are fixed.
+	(*strmovsi_1): Ditto.
+	(*strmovsi_rex_1): Ditto.
+	(*strmovhi_1): Ditto.
+	(*strmovhi_rex_1): Ditto.
+	(*strmovqi_1): Ditto.
+	(*strmovqi_rex_1): Ditto.
+	(*rep_movdi_rex64): Disable when %ecx, %esi or %edi are fixed.
+	(*rep_movsi): Ditto.
+	(*rep_movsi_rex64): Ditto.
+	(*rep_movqi): Ditto.
+	(*rep_movqi_rex64): Ditto.
+
+2011-07-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/47364
+	* config/i386/i386.md (strlensi): Enable for !TARGET_64BIT only.
+	(strlendi): Enable for TARGET_64BIT only.
+
+2011-07-29  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.c (rx_expand_builtin): Fix typo checking the setpsw
+	builtin.
+
+2011-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-07-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/49621
+	* config/rs6000/rs6000.c (rs6000_emit_vector_cond_expr): Use
+	CONST0_RTX (dest_mode) instead of const0_rtx as second operand
+	of NE.
+	* config/rs6000/vector.md (vector_select_<mode>,
+	vector_select_<mode>_uns): Change second operand of NE to
+	CONST0_RTX (<MODE>mode) instead of const0_rtx.
+	* config/rs6000/altivec.md (*altivec_vsel<mode>,
+	*altivec_vsel<mode>_uns): Expect second operand of NE to be
+	zero_constant of the corresponding vector mode.
+	* config/rs6000/vsx.md (*vsx_xxsel<mode>, *vsx_xxsel<mode>_uns):
+	Likewise.
+
+	2011-07-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/49644
+	* c-typeck.c (build_binary_op): For MULT_EXPR and TRUNC_DIV_EXPR with
+	one non-complex and one complex argument, call c_save_expr on both
+	operands.
+
+	PR middle-end/49640
+	* gimplify.c (gimplify_compound_lval): For last 2 ARRAY_*REF
+	operands and last COMPONENT_REF operand call gimplify_expr on it
+	if non-NULL.
+
+	2011-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/49619
+	* combine.c (combine_simplify_rtx): In PLUS -> IOR simplification
+	pass VOIDmode as op0_mode to recursive call.
+
+	2011-05-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/49165
+	* c-common.c (c_common_truthvalue_conversion) <case COND_EXPR>: For
+	C++ don't call c_common_truthvalue_conversion on void type arms.
+
+	2011-05-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/49165
+	* gimplify.c (shortcut_cond_r): Don't special case
+	COND_EXPRs if they have void type on one of their arms.
+
+	PR tree-optimization/49161
+	* tree-vrp.c (struct case_info): New type.
+	(compare_case_labels): Sort case_info structs instead of
+	trees, and not primarily by CASE_LABEL uids but by
+	label_for_block indexes.
+	(find_switch_asserts): Put case labels into struct case_info
+	array instead of TREE_VEC, adjust sorting, compare label_for_block
+	values instead of CASE_LABELs.
+
+	2011-05-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/49120
+	* c-decl.c (start_decl): Convert expr to void_type_node.
+
+	PR middle-end/48973
+	* expr.c (expand_expr_real_2) <case LT_EXPR>: If do_store_flag
+	failed and the comparison has a single bit signed type, use
+	constm1_rtx instead of const1_rtx for true value.
+	(do_store_flag): If ops->type is single bit signed type, disable
+	signel bit test optimization and pass -1 instead of 1 as last
+	parameter to emit_store_flag_force.
+
+	2011-05-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/49039
+	* tree-vrp.c (extract_range_from_binary_expr): For
+	MIN_EXPR <~[a, b], ~[c, d]> and MAX_EXPR <~[a, b], ~[c, d]>
+	return ~[MAX_EXPR <a, c>, MIN_EXPR <b, d>].
+
+2011-07-17  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/49746
+	Revert:
+	2010-12-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/pa.md: Add ",*" condition to 64-bit add/subtract boolean
+	patterns.
+
+2011-07-15  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/49723
+	* config/pa/pa.md (casesi): Use gen_int_mode instead of GEN_INT.
+
+2011-07-12  Andrey Belevantsev  <abel@ispras.ru>
+
+	Backport from mainline
+	2011-05-25  Andrey Belevantsev  <abel@ispras.ru>
+
+	PR rtl-optimization/49014
+	* config/i386/athlon.md (athlon_ssecomi): Change type to ssecomi.
+
+2011-07-07  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/49660
+	* config/sparc/sol2.h [TARGET_64BIT_DEFAULT] (TARGET_DEFAULT): Add
+	MASK_V8PLUS, remove commented out flag and reorder.
+
+	Backport from mainline
+	2011-06-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/sparc/sol2-64.h (TARGET_DEFAULT): Remove.
+	(TARGET_64BIT_DEFAULT): Define.
+	* config.gcc (sparc*-*-solaris2*): Move sparc/sol2-64.h to front
+	of tm_file.
+	* config/sparc/sol2.h [TARGET_64BIT_DEFAULT] (TARGET_DEFAULT): Define.
+
+2011-07-04  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-05-02  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/48822
+	* tree-ssa-sccvn.c (set_ssa_val_to): Never go up the lattice.
+
+2011-07-04  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-05-23  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49115
+	* tree-ssa-dce.c (mark_aliased_reaching_defs_necessary_1): Likewise.
+
+2011-07-04  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49615
+	* tree-cfgcleanup.c (split_bbs_on_noreturn_calls): Fix
+	basic-block index check.
+
+2011-06-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/49572
+	* tree-ssa-dom.c (initialize_hash_element) <GIMPLE_SINGLE_RHS>: Use the
+	type of the RHS instead of that of the LHS for the expression type.
+
+2011-06-30  Jack Howarth  <howarth@bromo.med.uc.edu>
+
+	Backport from mainline
+	2011-02-07  Mike Stump  <mikestump@comcast.net>
+
+	PR target/42333
+	Add __ieee_divdc3 entry point.
+	* config/i386/darwin.h (DECLARE_LIBRARY_RENAMES): Retain ___divdc3
+	entry point.
+	(SUBTARGET_INIT_BUILTINS): Call darwin_rename_builtins.
+	* config/i386/i386.c (TARGET_INIT_LIBFUNCS): Likewise.
+	* config/darwin.c (darwin_rename_builtins): Add.
+	* config/darwin-protos.h (darwin_rename_builtins): Add.
+
+2011-06-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-dom.c (initialize_hash_element): Fix oversight.
+
+2011-06-17  Hans-Peter Nilsson  <hp@axis.com>
+
+	Backport from mainline
+	2011-06-17  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR rtl-optimization/48542
+	* reload.c (find_equiv_reg): Stop looking when finding a
+	setjmp-type call.
+	* reload1.c (reload_as_needed): Invalidate all reload
+	registers when crossing a setjmp-type call.
+
+2011-06-16  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2011-06-09  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/49307
+	* config/sh/sh.md (UNSPEC_CHKADD): New.
+	(chk_guard_add): New define_insn_and_split.
+	(symGOT_load): Use chk_guard_add instead of blockage.
+
+2011-06-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (vec_dupv4sf): Correct mode of forced register.
+	(*vec_dupv2df): Rename from vec_dupv2df.
+	(vec_dupv2df): New expander.
+
+2011-06-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.md (return_internal): Adjust 'length' attribute.
+
+2011-06-08  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2011-06-01  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/49238
+	* config/sh/sh.c (expand_cbranchdi4): Use a scratch register if
+	needed when original operands are used for msw_skip comparison.
+
+2011-06-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.c (output_return): Fix thinko in the output of an
+	EH return when delayed branches are disabled.
+
+2011-06-05  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2011-05-30  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/49186
+	* config/sh/sh.c (expand_cbranchdi4): Set msw_skip when the high
+	part of the second operand is 0.
+
+2011-06-04  Ira Rosen  <ira.rosen@linaro.org>
+
+	PR tree-optimization/49038
+	* tree-vect-loop-manip.c (vect_generate_tmps_on_preheader):
+	Ensure at least one epilogue iteration if required by data
+	accesses with gaps.
+	* tree-vectorizer.h (struct _loop_vec_info): Add new field
+	to mark loops that require peeling for gaps.
+	* tree-vect-loop.c (new_loop_vec_info): Initialize new field.
+	(vect_estimate_min_profitable_iters): Take peeling for gaps into
+	account.
+	(vect_transform_loop): Generate epilogue if required by data
+	access with gaps.
+	* tree-vect-data-refs.c (vect_analyze_group_access): Mark the
+	loop as requiring an epilogue if there are gaps in the end of
+	the strided group.
+
+2011-05-29  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	PR target/43700
+	* config/mips/mips.c (mips_cfun_call_saved_reg_p): Handle global
+	registers.
+
+2011-05-29  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	PR target/43995
+	* config/mips/mips.c (mips_pic_call_symbol_from_set): Add a
+	recurse_p argument.  Only follow register copies if it is set,
+	and prevent mips_find_pic_call_symbol from recursing.
+	(mips_find_pic_call_symbol): Add a recurse_p argument.
+	Pass it to mips_pic_call_symbol_from_set.
+	(mips_annotate_pic_calls): Update accordingly.
+
+2011-05-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc-protos.h (sparc_optimization_options): Declare.
+	* config/sparc/sparc.h (OPTIMIZATION_OPTIONS): Define.
+	* config/sparc/sparc.c (sparc_optimization_options): New function.
+	Set flag_ira_share_save_slots to 0.
+
+	Backport from mainline
+	2011-01-21  Jeff Law  <law@redhat.com>
+
+	PR rtl-optimization/41619
+	* caller-save.c (setup_save_areas): Break out code to determine
+	which hard regs are live across calls by examining the reload chains
+	so that it is always used.
+	Eliminate code which checked REG_N_CALLS_CROSSED.
+
+2011-05-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/49133
+	* config/i386/sse.md (sse2_loadhpd): Remove shufpd alternative.
+
+2011-05-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.md (setjmp): Handle PIC mode and use the hard
+	frame pointer.
+
+2011-05-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.c (eligible_for_return_delay): Do not return
+	false if there are call-saved registers here...
+	(sparc_can_use_return_insn_p): ...but here instead.
+	(save_or_restore_regs): Fix thinko.
+	(sparc_expand_prologue): Use current_function_is_leaf.
+	(sparc_frame_pointer_required): Likewise.
+
+2011-05-20  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.h (HAVE_PRE_DECREMENT): Fix typo in macro name.
+
+2011-05-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (*movxf_internal): Disable CONST_DOUBLE
+	optimization for CM_MEDIUM and CM_LARGE code models.  Fix usage
+	of standard_80387_constant_p.
+	(*movxf_internal_nointeger): Ditto.
+	(*movdf_internal): Remove dead code-size optimization.
+	(*movdf_internal_rex64): Fix usage of standard_80387_constant_p.
+	(*movdf_internal_nointeger): Ditto.
+	(*movsf_internal): Ditto.
+	(floating point move splitters): Ditto.
+	* config/i386/constraints.md (G): Ditto.
+	* config/i386/i386.c (ix86_preferred_reload_class): Ditto.
+
+2011-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2011-05-10  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/48857, 48495
+	* config/rs6000/rs6000.h (VSX_SCALAR_MODE): Delete.
+	(VSX_MODE): Ditto.
+	(VSX_MOVE_MODE): Ditto.
+	(ALTIVEC_OR_VSX_VECTOR_MODE): New macro, combine all Altivec and
+	VSX vector types.  Add V2DImode.
+	(HARD_REGNO_CALLER_SAVE_MODE): Use it instead of
+	ALTIVEC_VECTOR_MODE and VSX_VECTOR_MODE calls.
+	(MODES_TIEABLE_P): Ditto.
+
+	* config/rs6000/rs6000.c (rs6000_emit_move): Use
+	ALTIVEC_OR_VSX_MODE instead of ALTIVEC_VECTOR_MODE and
+	VSX_VECTOR_MODE.
+	(init_cumulative_args): Ditto.
+	(rs6000_function_arg_boundary): Ditto.
+	(rs6000_function_arg_advance_1): Ditto.
+	(rs6000_function_arg): Ditto.
+	(rs6000_function_ok_for_sibcall): Ditto.
+	(emit_frame_save): Ditto.
+	(rs6000_function_value): Ditto.
+	(rs6000_libcall_value): Ditto.
+
+2011-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2011-05-07  Zdenek Dvorak  <ook@ucw.cz>
+
+	PR tree-optimization/48837
+	* tree-tailcall.c (tree_optimize_tail_calls_1): Do not mark tailcalls
+	when accumulator transformation is performed.
+
+2011-05-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* var-tracking.c (find_mem_expr_in_1pdv): Fix thinko.
+	(dataflow_set_preserve_mem_locs): Likewise.
+
+2011-05-07  Alan Modra  <amodra@gmail.com>
+
+	PR target/48900
+	* config/rs6000/rs6000.c (rs6000_legitimize_tls_address): Use
+	const0_rtx as the arg to the dummy __tls_get_addr libcall.
+
+2011-05-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/40975
+	* tree-inline.c (copy_tree_r): Handle STATEMENT_LIST.
+
+2011-05-05  Julian Brown  <julian@codesourcery.com>
+
+	* config/arm/neon.md (vec_set<mode>_internal): Fix misplaced
+	parenthesis in D-register case.
+
+2011-05-05  Ira Rosen  <ira.rosen@linaro.org>
+
+	Backport from mainline:
+	2011-04-18  Ulrich Weigand  <ulrich.weigand@linaro.org>
+		    Ira Rosen  <ira.rosen@linaro.org>
+
+	PR target/48252
+	* config/arm/arm.c (neon_emit_pair_result_insn): Swap arguments
+	to match neon_vzip/vuzp/vtrn_internal.
+	* config/arm/neon.md (neon_vtrn<mode>_internal): Make both
+	outputs explicitly dependent on both inputs.
+	(neon_vzip<mode>_internal, neon_vuzp<mode>_internal): Likewise.
+
+2011-05-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2011-04-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/48708
+	* config/i386/i386.c (ix86_expand_vector_set) <V2DImode>: Generate
+	vec_extract and vec_concat for non-SSE4_1 targets.
+
+2011-05-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (*movdi_internal_rex64) <TYPE_SSEMOV>:
+	Use %v prefix in insn mnemonic to handle TARGET_AVX.
+	(*movdi_internal): Use "maybe_vex" instead of "vex" in "prefix"
+	attribute calculation.
+	(*movdf_internal): Output AVX mnemonics.  Add "prefix" attribute.
+	* config/i386/sse.md (*sse2_storeq_rex64): Do not emit %v prefix
+	for mov{q} mnemonic.
+	(*vec_extractv2di_1_rex64_avx): Ditto.
+	(*vec_concatv2di_rex64_sse4_1): Use %vmovd for reg<->xmm moves.
+	(*vec_concatv2di_rex64_sse): Use movd for reg<->xmm moves.
+	* config/i386/mmx.md (*mov<mode>_internal_rex64): Ditto.
+
+2011-05-03  Uros Bizjak  <ubizjak@gmail.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/48774
+	* config/i386/i386.c (ix86_match_ccmode): For CC{A,C,O,S}mode
+	only succeed if req_mode is the same as set_mode.
+
+2011-05-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/48809
+	* tree-switch-conversion.c (build_arrays): Compute tidx in unsigned
+	type.
+	(gen_inbound_check): Don't compute index_expr - range_min in utype
+	again, instead reuse SSA_NAME initialized in build_arrays.
+	Remove two useless gsi_for_stmt calls.
+
+	2011-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/48597
+	* final.c (final_scan_insn): Call dwarf2out_frame_debug even for
+	inline asm.
+
+	2011-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/48742
+	* c-typeck.c (build_binary_op): Don't wrap arguments if
+	int_operands is true.
+
+	2011-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/48685
+	* fold-const.c (fold_convert_loc): Add NOP_EXPR when casting
+	to VOID_TYPE even around MODIFY_EXPR.
+
+2011-05-02  Ulrich Weigand  <ulrich.weigand@linaro.org>
+
+	PR middle-end/43085
+	Backport from mainline:
+
+	2010-04-29  Bernd Schmidt  <bernds@codesourcery.com>
+
+	From Dominique d'Humieres  <dominiq@lps.ens.fr>
+	PR bootstrap/43858
+	* ifcvt.c (dead_or_predicable): Use df_simulate_find_defs to compute
+	test_set.
+
+	2010-04-26  Bernd Schmidt  <bernds@codesourcery.com>
+
+	* df-problems.c (df_simulate_initialize_forwards): Set, don't clear,
+	bits for artificial defs at the top of the block.
+	* fwprop.c (single_def_use_enter_block): Don't call it.
+
+	2010-04-22  Bernd Schmidt  <bernds@codesourcery.com>
+
+	* ifcvt.c (dead_or_predicable): Use df_simulate_find_defs and
+	df_simulate_find_noclobber_defs as appropriate.  Keep track of an
+	extra set merge_set_noclobber, and use it to relax the final test
+	slightly.
+	* df.h (df_simulate_find_noclobber_defs): Declare.
+	* df-problems.c (df_simulate_find_defs): Don't ignore partial or
+	conditional defs.
+	(df_simulate_find_noclobber_defs): New function.
+
+2011-04-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/48288
+	* config/pa/predicates.md (ior_operand): Delete predicate.
+	(cint_ior_operand, reg_or_cint_ior_operand): New predicates.
+	* config/pa/pa.md (iordi3): Use reg_or_cint_ior_operand predicate in
+	expander.  Use cint_ior_operand in unnamed insn.
+	(iorsi3): Likewise.
+	* config/pa/pa-protos.h (ior_operand): Delete declarations.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
@@ -80,7 +933,7 @@
 	to flow_loop_nested_p when moving the loop upward.
 
 	2011-03-15  Richard Guenther  <rguenther@suse.de>
- 
+
 	PR middle-end/48031
 	* fold-const.c (fold_indirect_ref_1): Do not create new variable-sized
 	or variable-indexed array accesses when in gimple form.
@@ -433,7 +1286,7 @@
 	PR target/48171
 	* config/i386/i386.opt: Add Save to -mavx and -mfma.
 
-2011-03-16  Pat Haugen <pthaugen@us.ibm.com>
+2011-03-16  Pat Haugen  <pthaugen@us.ibm.com>
 
 	PR target/47862
 	* caller-save.c (insert_restore, insert_save): Use non-validate
@@ -506,10 +1359,10 @@
 	* cgraph.c (cgraph_function_body_availability): Use decl_replaceable_p.
 	* tree-inline.c (inlinable_function_p): Likewise.
 
-2011-03-07  Pat Haugen <pthaugen@us.ibm.com>
+2011-03-07  Pat Haugen  <pthaugen@us.ibm.com>
 
 	Backport from mainline
-	2011-03-07  Pat Haugen <pthaugen@us.ibm.com>
+	2011-03-07  Pat Haugen  <pthaugen@us.ibm.com>
 
 	PR target/47862
 	* config/rs6000/rs6000.h (HARD_REGNO_CALLER_SAVE_MODE): Define.
@@ -525,7 +1378,7 @@
 	(ssse3_pmaddubsw128): Ditto.
 	(ssse3_pmaddubsw): Ditto.
 
-2011-03-03  Denis Chertykov <chertykov@gmail.com>
+2011-03-03  Denis Chertykov  <chertykov@gmail.com>
 
 	Backport from mainline
 	2011-02-22  Georg-Johann Lay  <avr@gjlay.de>
@@ -605,7 +1458,7 @@
 	origin of assertions.
 	Update copyright years.
 
-2011-02-25  Andriy Gapon <avg@freebsd.org>
+2011-02-25  Andriy Gapon  <avg@freebsd.org>
 
 	PR target/45808
 	* config/freebsd-spec.h (FBSD_LIB_SPEC): Handle the shared case.
@@ -1304,7 +2157,7 @@
 
 	Backport from mainline
 	2010-12-06  Jakub Jelinek  <jakub@redhat.com>
- 
+
 	PR target/43897
 	* config/ia64/ia64.c (rtx_needs_barrier): Handle asm CLOBBER
 	as a store into that register.
@@ -1798,7 +2651,7 @@
 	debug isnsn.  Skip them when searching for cc0 setter.
 	(set_live_p): Skip debug insns when searching for cc0 user.
 
-2010-10-09  Ralf Corspius <ralf.corsepius@rtems.org>
+2010-10-09  Ralf Corspius  <ralf.corsepius@rtems.org>
 
 	* config.gcc (bfin*-rtems*): Add newlib-stdint.h.
 	* config.gcc (lm32*-rtems*): Add newlib-stdint.h.
@@ -1822,7 +2675,7 @@
 2010-10-06  Jack Howarth  <howarth@bromo.med.uc.edu>
 
 	Backport from mainline
-	2010-04-26  Jack Howarth <howarth@bromo.med.uc.edu>
+	2010-04-26  Jack Howarth  <howarth@bromo.med.uc.edu>
 
 	PR 43715
 	* configure.ac: Pass -g for export_sym_check on darwin.
@@ -2079,11 +2932,11 @@
 	insns instead.  Rewrite the movement code to support moving through
 	several basic blocks.
 
-2010-09-10  Jack Howarth <howarth@bromo.med.uc.edu>
+2010-09-10  Jack Howarth  <howarth@bromo.med.uc.edu>
 
 	Backport from mainline
 	2010-09-07  H.J. Lu  <hjl.tools@gmail.com>
-		    Jack Howarth <howarth@bromo.med.uc.edu>
+		    Jack Howarth  <howarth@bromo.med.uc.edu>
 
 	PR target/36502
 	PR target/42313
@@ -2483,7 +3336,7 @@
 	Backport from mainline.
 	2010-07-22  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
 
- 	PR target/43698
+	PR target/43698
 	* config/arm/arm.md: Split arm_rev into *arm_rev and *thumb1_rev.
 	Set *arm_rev to be predicable.
 
@@ -4135,7 +4988,7 @@
 	* tree-tailcall.c (find_tail_calls): Verify the tail call
 	properly.
 
-2010-04-19 Ira Rosen  <irar@il.ibm.com>
+2010-04-19  Ira Rosen  <irar@il.ibm.com>
 
 	PR tree-optimization/43771
 	* tree-vect-slp.c (vect_supported_load_permutation_p): Check that
Index: gcc/tree-vect-loop-manip.c
===================================================================
--- a/src/gcc/tree-vect-loop-manip.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-vect-loop-manip.c	(.../branches/gcc-4_5-branch)
@@ -1516,7 +1516,7 @@
   edge pe;
   basic_block new_bb;
   gimple_seq stmts;
-  tree ni_name;
+  tree ni_name, ni_minus_gap_name;
   tree var;
   tree ratio_name;
   tree ratio_mult_vf_name;
@@ -1533,9 +1533,39 @@
   ni_name = vect_build_loop_niters (loop_vinfo, cond_expr_stmt_list);
   log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));
 
+  /* If epilogue loop is required because of data accesses with gaps, we
+     subtract one iteration from the total number of iterations here for
+     correct calculation of RATIO.  */
+  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))
+    {
+      ni_minus_gap_name = fold_build2 (MINUS_EXPR, TREE_TYPE (ni_name),
+				       ni_name,
+			               build_one_cst (TREE_TYPE (ni_name)));
+      if (!is_gimple_val (ni_minus_gap_name))
+	{
+	  var = create_tmp_var (TREE_TYPE (ni), "ni_gap");
+          add_referenced_var (var);
+
+          stmts = NULL;
+          ni_minus_gap_name = force_gimple_operand (ni_minus_gap_name, &stmts,
+						    true, var);
+          if (cond_expr_stmt_list)
+            gimple_seq_add_seq (&cond_expr_stmt_list, stmts);
+          else
+            {
+              pe = loop_preheader_edge (loop);
+              new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);
+              gcc_assert (!new_bb);
+            }
+        }
+    }
+  else
+    ni_minus_gap_name = ni_name;
+
   /* Create: ratio = ni >> log2(vf) */
 
-  ratio_name = fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_name), ni_name, log_vf);
+  ratio_name = fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_minus_gap_name),
+			    ni_minus_gap_name, log_vf);
   if (!is_gimple_val (ratio_name))
     {
       var = create_tmp_var (TREE_TYPE (ni), "bnd");
@@ -2312,26 +2342,26 @@
 
    Input:
      DR: The data reference.
-     VECT_FACTOR: vectorization factor.
+     LENGTH_FACTOR: segment length to consider.
 
    Return an expression whose value is the size of segment which will be
    accessed by DR.  */
 
 static tree
-vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)
+vect_vfa_segment_size (struct data_reference *dr, tree length_factor)
 {
-  tree segment_length = fold_build2 (MULT_EXPR, integer_type_node,
-			             DR_STEP (dr), vect_factor);
-
+  tree segment_length;
+  segment_length = size_binop (MULT_EXPR,
+			       fold_convert (sizetype, DR_STEP (dr)),
+			       fold_convert (sizetype, length_factor));
   if (vect_supportable_dr_alignment (dr) == dr_explicit_realign_optimized)
     {
       tree vector_size = TYPE_SIZE_UNIT
 			  (STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr))));
 
-      segment_length = fold_build2 (PLUS_EXPR, integer_type_node,
-				    segment_length, vector_size);
+      segment_length = size_binop (PLUS_EXPR, segment_length, vector_size);
     }
-  return fold_convert (sizetype, segment_length);
+  return segment_length;
 }
 
 
@@ -2365,12 +2395,12 @@
   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);
   VEC (ddr_p, heap) * may_alias_ddrs =
     LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);
-  tree vect_factor =
-    build_int_cst (integer_type_node, LOOP_VINFO_VECT_FACTOR (loop_vinfo));
+  int vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);
+  tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);
 
   ddr_p ddr;
   unsigned int i;
-  tree part_cond_expr;
+  tree part_cond_expr, length_factor;
 
   /* Create expression
      ((store_ptr_0 + store_segment_length_0) < load_ptr_0)
@@ -2417,8 +2447,12 @@
         vect_create_addr_base_for_vector_ref (stmt_b, cond_expr_stmt_list,
 					      NULL_TREE, loop);
 
-      segment_length_a = vect_vfa_segment_size (dr_a, vect_factor);
-      segment_length_b = vect_vfa_segment_size (dr_b, vect_factor);
+      if (!operand_equal_p (DR_STEP (dr_a), DR_STEP (dr_b), 0))
+	length_factor = scalar_loop_iters;
+      else
+	length_factor = size_int (vect_factor);
+      segment_length_a = vect_vfa_segment_size (dr_a, length_factor);
+      segment_length_b = vect_vfa_segment_size (dr_b, length_factor);
 
       if (vect_print_dump_info (REPORT_DR_DETAILS))
 	{
Index: gcc/testsuite/gcc.c-torture/execute/960321-1.x
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/960321-1.x	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/960321-1.x	(.../branches/gcc-4_5-branch)
@@ -1,15 +0,0 @@
-# This test fails to link on 64-bit Solaris 2/x86 due to a Sun as bug.
-if { [istarget "i?86-*-solaris2*"]
-     && ! [check_effective_target_ilp32]
-     && ! [check_effective_target_gas] } { 
-    set torture_eval_before_compile {
-        global compiler_conditional_xfail_data
-        set compiler_conditional_xfail_data {
-            "64-bit Sun as bug" \
-                { "i?86-*-solaris2*" } \
-                { "-O[1-3s]" } \
-                { "" }
-       }
-    }
-}
-return 0
Index: gcc/testsuite/gcc.c-torture/execute/doloop-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/doloop-1.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/doloop-1.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,18 @@
+#include <limits.h>
+
+extern void exit (int);
+extern void abort (void);
+
+volatile unsigned int i;
+
+int
+main (void)
+{
+  unsigned char z = 0;
+
+  do ++i;
+  while (--z > 0);
+  if (i != UCHAR_MAX + 1U)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.c-torture/execute/20120111-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20120111-1.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20120111-1.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,18 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+uint32_t f0a (uint64_t arg2) __attribute__((noinline));
+
+uint32_t
+f0a (uint64_t arg)
+{
+  return ~(arg > -3);
+}
+
+int main() {
+  uint32_t r1;
+  r1 = f0a (12094370573988097329ULL);
+  if (r1 != ~0U)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr49186.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr49186.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr49186.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,15 @@
+/* PR target/49186 */
+extern void abort (void);
+
+int
+main ()
+{
+  int x;
+  unsigned long long uv = 0x1000000001ULL;
+
+  x = (uv < 0x80) ? 1 : ((uv < 0x800) ? 2 : 3);
+  if (x != 3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr48973-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr48973-1.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr48973-1.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,20 @@
+/* PR middle-end/48973 */
+
+extern void abort (void);
+struct S { int f : 1; } s;
+int v = -1;
+
+void
+foo (unsigned int x)
+{
+  if (x != -1U)
+    abort ();
+}
+
+int
+main ()
+{
+  s.f = (v & 1) > 0;
+  foo (s.f);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr49644.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr49644.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr49644.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,16 @@
+/* PR c/49644 */
+
+extern void abort (void);
+
+int
+main ()
+{
+  _Complex double a[12], *c = a, s = 3.0 + 1.0i;
+  double b[12] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, *d = b;
+  int i;
+  for (i = 0; i < 6; i++)
+    *c++ = *d++ * s;
+  if (c != a + 6 || d != b + 6)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr49279.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr49279.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr49279.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,35 @@
+/* PR tree-optimization/49279 */
+extern void abort (void);
+
+struct S { int a; int *__restrict p; };
+
+__attribute__((noinline, noclone))
+struct S *bar (struct S *p)
+{
+  struct S *r;
+  asm volatile ("" : "=r" (r) : "0" (p) : "memory");
+  return r;
+}
+
+__attribute__((noinline, noclone))
+int
+foo (int *p, int *q)
+{
+  struct S s, *t;
+  s.a = 1;
+  s.p = p;
+  t = bar (&s);
+  t->p = q;
+  s.p[0] = 0;
+  t->p[0] = 1;
+  return s.p[0];
+}
+
+int
+main ()
+{
+  int a, b;
+  if (foo (&a, &b) != 1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr49161.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr49161.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr49161.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,46 @@
+/* PR tree-optimization/49161 */
+
+extern void abort (void);
+
+int c;
+
+__attribute__((noinline, noclone)) void
+bar (int x)
+{
+  if (x != c++)
+    abort ();
+}
+
+__attribute__((noinline, noclone)) void
+foo (int x)
+{
+  switch (x)
+    {
+    case 3: goto l1;
+    case 4: goto l2;
+    case 6: goto l3;
+    default: return;
+    }
+l1:
+  goto l4;
+l2:
+  goto l4;
+l3:
+  bar (-1);
+l4:
+  bar (0);
+  if (x != 4)
+    bar (1);
+  if (x != 3)
+    bar (-1);
+  bar (2);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (c != 3)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/doloop-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/doloop-2.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/doloop-2.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,18 @@
+#include <limits.h>
+
+extern void exit (int);
+extern void abort (void);
+
+volatile unsigned int i;
+
+int
+main (void)
+{
+  unsigned short z = 0;
+
+  do ++i;
+  while (--z > 0);
+  if (i != USHRT_MAX + 1U)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr48973-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr48973-2.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr48973-2.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,14 @@
+/* PR middle-end/48973 */
+
+extern void abort (void);
+struct S { int f : 1; } s;
+int v = -1;
+
+int
+main ()
+{
+  s.f = v < 0;
+  if ((unsigned int) s.f != -1U)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr48809.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr48809.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr48809.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,60 @@
+/* PR tree-optimization/48809 */
+
+extern void abort (void);
+
+int
+foo (signed char x)
+{
+  int y = 0;
+  switch (x)
+    {
+    case 0: y = 1; break;
+    case 1: y = 7; break;
+    case 2: y = 2; break;
+    case 3: y = 19; break;
+    case 4: y = 5; break;
+    case 5: y = 17; break;
+    case 6: y = 31; break;
+    case 7: y = 8; break;
+    case 8: y = 28; break;
+    case 9: y = 16; break;
+    case 10: y = 31; break;
+    case 11: y = 12; break;
+    case 12: y = 15; break;
+    case 13: y = 111; break;
+    case 14: y = 17; break;
+    case 15: y = 10; break;
+    case 16: y = 31; break;
+    case 17: y = 7; break;
+    case 18: y = 2; break;
+    case 19: y = 19; break;
+    case 20: y = 5; break;
+    case 21: y = 107; break;
+    case 22: y = 31; break;
+    case 23: y = 8; break;
+    case 24: y = 28; break;
+    case 25: y = 106; break;
+    case 26: y = 31; break;
+    case 27: y = 102; break;
+    case 28: y = 105; break;
+    case 29: y = 111; break;
+    case 30: y = 17; break;
+    case 31: y = 10; break;
+    case 32: y = 31; break;
+    case 98: y = 18; break;
+    case -62: y = 19; break;
+    }
+  return y;
+}
+
+int
+main ()
+{
+  if (foo (98) != 18 || foo (97) != 0 || foo (99) != 0)
+    abort ();
+  if (foo (-62) != 19 || foo (-63) != 0 || foo (-61) != 0)
+    abort ();
+  if (foo (28) != 105 || foo (27) != 102 || foo (29) != 111)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr49039.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr49039.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr49039.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,26 @@
+/* PR tree-optimization/49039 */
+extern void abort (void);
+int cnt;
+
+__attribute__((noinline, noclone)) void
+foo (unsigned int x, unsigned int y)
+{
+  unsigned int minv, maxv;
+  if (x == 1 || y == -2U)
+    return;
+  minv = x < y ? x : y;
+  maxv = x > y ? x : y;
+  if (minv == 1)
+    ++cnt;
+  if (maxv == -2U)
+    ++cnt;
+}
+
+int
+main ()
+{
+  foo (-2U, 1);
+  if (cnt != 2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr50565-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr50565-1.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr50565-1.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,4 @@
+struct s { char p[2]; };
+static struct s v;
+const int o0 = (int) ((void *) &v.p[0] - (void *) &v) + 0U;
+const int o1 = (int) ((void *) &v.p[0] - (void *) &v) + 1U;
Index: gcc/testsuite/gcc.c-torture/compile/pr38752.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr38752.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr38752.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,25 @@
+typedef struct
+{
+  int             baddr;
+} mstruct_t;
+
+static struct
+{
+  unsigned int    mapnum;
+  mstruct_t       unused;
+} mtab;
+
+static mstruct_t *mactab = &mtab.unused;
+
+int
+main(void)
+{
+  int i;
+  int addr;
+
+  for (i=1; i <= mtab.mapnum; i++)
+    if (addr < mactab[i].baddr)
+      break;
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr48742.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr48742.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr48742.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,15 @@
+/* PR c/48742 */
+
+void baz (int);
+
+int
+foo (void)
+{
+  return 1 / 0 > 0;
+}
+
+void
+bar (void)
+{
+  baz (1 <= 2 % (3 >> 1 > 5 / 6 == 3));
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr49238.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr49238.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr49238.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,18 @@
+/* PR target/49238 */
+extern int bar (void);
+
+void
+foo (unsigned long long a, int b)
+{
+  int i;
+
+  if (b)
+    for (a = -12; a >= 10; a = bar ())
+      break;
+  else
+    return;
+
+  for (i = 0; i < 10; i += 10)
+    if ((i == bar ()) | (bar () >= a))
+      bar ();
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr50565-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr50565-2.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr50565-2.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,4 @@
+struct s { char p[2]; };
+static struct s v;
+const int o0 = (int) ((void *) &v.p[0] - (void *) &v) + 0;
+const int o1 = (int) ((void *) &v.p[0] - (void *) &v) + 1;
Index: gcc/testsuite/gcc.target/arm/neon-vset_lanes8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/neon-vset_lanes8.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/neon-vset_lanes8.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,21 @@
+/* Test the `vset_lane_s8' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+#include <string.h>
+
+int8x8_t x = { 1, 2, 3, 4, 5, 6, 7, 8 };
+int8x8_t y = { 1, 2, 3, 16, 5, 6, 7, 8 };
+
+int main (void)
+{
+  x = vset_lane_s8 (16, x, 3);
+  if (memcmp (&x, &y, sizeof (x)) != 0)
+    abort();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/pr48252.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr48252.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr48252.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main(void)
+{
+    uint8x8_t v1 = {1, 1, 1, 1, 1, 1, 1, 1};
+    uint8x8_t v2 = {2, 2, 2, 2, 2, 2, 2, 2};
+    uint8x8x2_t vd1, vd2;
+    union {uint8x8_t v; uint8_t buf[8];} d1, d2, d3, d4;
+    int i;
+
+    vd1 = vzip_u8(v1, vdup_n_u8(0));
+    vd2 = vzip_u8(v2, vdup_n_u8(0));
+
+    vst1_u8(d1.buf, vd1.val[0]);
+    vst1_u8(d2.buf, vd1.val[1]);
+    vst1_u8(d3.buf, vd2.val[0]);
+    vst1_u8(d4.buf, vd2.val[1]);
+
+    for (i = 0; i < 8; i++)
+      if ((i % 2 == 0 && d4.buf[i] != 2)
+          || (i % 2 == 1 && d4.buf[i] != 0))
+         abort ();
+
+    return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/altivec-34.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/altivec-34.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/altivec-34.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,24 @@
+/* PR target/49621 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -maltivec" } */
+
+#include <altivec.h>
+
+int
+foo (void)
+{
+  vector unsigned a, b, c;
+  unsigned k = 1;
+
+  a = (vector unsigned) { 0, 0, 0, 1 };
+  b = c = (vector unsigned) { 0, 0, 0, 0 };
+
+  a = vec_add (a, vec_splats (k));
+  b = vec_add (b, a);
+  c = vec_sel (c, a, b);
+
+  if (vec_any_eq (b, c))
+    return 1;
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr48857.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr48857.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr48857.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,25 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O2 -mcpu=power7 -mabi=altivec" } */
+/* { dg-final { scan-assembler-times "lxvd2x" 1 } } */
+/* { dg-final { scan-assembler-times "stxvd2x" 1 } } */
+/* { dg-final { scan-assembler-not "ld" } } */
+/* { dg-final { scan-assembler-not "lwz" } } */
+/* { dg-final { scan-assembler-not "stw" } } */
+/* { dg-final { scan-assembler-not "addi" } } */
+
+typedef vector long long v2di_type;
+
+v2di_type
+return_v2di (v2di_type *ptr)
+{
+  return *ptr;		/* should generate lxvd2x 34,0,3.  */
+}
+
+void
+pass_v2di (v2di_type arg, v2di_type *ptr)
+{
+  *ptr = arg;		/* should generate stxvd2x 34,0,{3,5}.  */
+}
+
Index: gcc/testsuite/gcc.target/i386/avx-check.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-check.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-check.h	(.../branches/gcc-4_5-branch)
@@ -1,6 +1,7 @@
 #include <stdlib.h>
 #include "cpuid.h"
 #include "m256-check.h"
+#include "avx-os-support.h"
 
 static void avx_test (void);
 
@@ -20,7 +21,8 @@
     return 0;
 
   /* Run AVX test only if host has AVX support.  */
-  if ((ecx & (bit_AVX | bit_OSXSAVE)) == (bit_AVX | bit_OSXSAVE))
+  if (((ecx & (bit_AVX | bit_OSXSAVE)) == (bit_AVX | bit_OSXSAVE))
+      && avx_os_support ())
     {
       do_test ();
 #ifdef DEBUG
Index: gcc/testsuite/gcc.target/i386/pr48708.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr48708.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr48708.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse2" } */
+
+#include <emmintrin.h>
+
+typedef long long T __attribute__((may_alias));
+struct S { __m128i d; };
+
+__m128i
+foo (long long *x, struct S *y, __m128i *z)
+{
+  struct S s = *y;
+  ((T *) &s.d)[0] = *x;
+  return _mm_cmpeq_epi16 (s.d, *z);
+}
Index: gcc/testsuite/gcc.target/i386/pr49920.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr49920.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr49920.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-require-effective-target ilp32 } */
+
+typedef __SIZE_TYPE__ size_t;
+extern void *malloc (size_t);
+
+register unsigned int MR_mr0 asm ("esi");
+register unsigned int MR_mr1 asm ("edi");
+
+void ml_backend__ml_closure_gen_module11 (void)
+{
+  unsigned int MR_tempr1, MR_tempr2, MR_tempr3;
+
+  MR_tempr1 = (unsigned int)((char *) malloc (sizeof (unsigned int)) + 4);
+  MR_tempr3 = ((unsigned int *) MR_mr0)[0];
+
+  ((unsigned int *) (MR_tempr1 - 4))[0] = MR_tempr3;
+
+  MR_tempr2 = (unsigned int)((char *) malloc (2 * sizeof (unsigned int)));
+
+  ((unsigned int *) MR_tempr2)[1] = MR_tempr1;
+}
Index: gcc/testsuite/gcc.target/i386/pr51393.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr51393.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr51393.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O -mavx" } */
+
+#include "avx-check.h"
+#include <immintrin.h>
+
+static void
+__attribute__((noinline))
+avx_test (void)
+{
+  long long in = 0x800000000ll;
+  long long out;
+
+  __m256i zero = _mm256_setzero_si256();
+  __m256i tmp  = _mm256_insert_epi64 (zero, in, 0);
+  out = _mm256_extract_epi64(tmp, 0);
+
+  if (in != out)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/aes-avx-check.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/aes-avx-check.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/aes-avx-check.h	(.../branches/gcc-4_5-branch)
@@ -3,6 +3,7 @@
 #endif
 #include <stdlib.h>
 #include "cpuid.h"
+#include "avx-os-support.h"
 
 static void aes_avx_test (void);
 
@@ -22,7 +23,9 @@
     return 0;
 
   /* Run AES + AVX test only if host has AES + AVX support.  */
-  if ((ecx & (bit_AVX | bit_AES)) == (bit_AVX | bit_AES))
+  if (((ecx & (bit_AVX | bit_OSXSAVE | bit_AES))
+       == (bit_AVX | bit_OSXSAVE | bit_AES))
+      && avx_os_support ())
     {
       do_test ();
 #ifdef DEBUG
Index: gcc/testsuite/gcc.target/i386/pr50788.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr50788.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr50788.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mavx -fpeel-loops -fstack-protector-all" } */
+
+typedef long long __m256i __attribute__ ((__vector_size__ (32)));
+typedef double __m256d __attribute__ ((__vector_size__ (32)));
+
+__m256d foo (__m256d *__P, __m256i __M)
+{
+  return __builtin_ia32_maskloadpd256 ( __P, __M);
+}
Index: gcc/testsuite/gcc.target/i386/avx-os-support.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-os-support.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-os-support.h	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,10 @@
+/* Check if the OS supports executing AVX instructions.  */
+
+static int
+avx_os_support (void)
+{
+  unsigned int eax, edx;
+
+  __asm__ ("xgetbv" : "=a" (eax), "=d" (edx) : "c" (0));
+  return (eax & 6) == 6;
+}
Index: gcc/testsuite/gcc.target/i386/sse2-init-v2di-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse2-init-v2di-2.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse2-init-v2di-2.c	(.../branches/gcc-4_5-branch)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target lp64 } */
-/* { dg-options "-O2 -msse4 -march=core2" } */
+/* { dg-options "-O2 -msse4 -march=core2 -dp" } */
 
 #include <emmintrin.h>
 
@@ -10,4 +10,4 @@
   return _mm_cvtsi64_si128 (b); 
 }
 
-/* { dg-final { scan-assembler "movq" } } */
+/* { dg-final { scan-assembler-times "\\*vec_concatv2di_rex64_sse4_1/3" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pclmul-avx-check.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pclmul-avx-check.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pclmul-avx-check.h	(.../branches/gcc-4_5-branch)
@@ -3,6 +3,7 @@
 #endif
 #include <stdlib.h>
 #include "cpuid.h"
+#include "avx-os-support.h"
 
 static void pclmul_avx_test (void);
 
@@ -22,7 +23,9 @@
     return 0;
 
   /* Run PCLMUL + AVX test only if host has PCLMUL + AVX support.  */
-  if ((ecx & (bit_AVX | bit_PCLMUL)) == (bit_AVX | bit_PCLMUL))
+  if (((ecx & (bit_AVX | bit_OSXSAVE | bit_PCLMUL))
+       == (bit_AVX | bit_OSXSAVE | bit_PCLMUL))
+      && avx_os_support ())
     {
       do_test ();
 #ifdef DEBUG
Index: gcc/testsuite/gcc.target/mips/reg-var-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/reg-var-1.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/mips/reg-var-1.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+register int g asm ("$18");
+
+void __attribute__((noinline))
+test (void)
+{
+  g = g + 1;
+}
+
+int
+main (void)
+{
+  g = 2;
+  test ();
+  return g != 3;
+}
Index: gcc/testsuite/gcc.target/sparc/cas64.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sparc/cas64.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.target/sparc/cas64.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,15 @@
+/* PR target/49660 */
+
+/* { dg-do compile { target sparc*-*-solaris2.* } } */
+
+#include <stdint.h>
+
+extern int64_t *val, old, new;
+
+int
+cas64 (void)
+{
+  return __sync_bool_compare_and_swap (val, old, new);
+}
+
+/* { dg-final { scan-assembler-not "compare_and_swap_8" } } */
Index: gcc/testsuite/gnat.dg/renaming5.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/renaming5.adb	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gnat.dg/renaming5.adb	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,30 @@
+-- PR ada/46192
+-- Testcase by Rolf Ebert <rolf.ebert.gcc@gmx.de>
+
+-- { dg-do compile }
+-- { dg-options "-O2 -fdump-tree-optimized" }
+
+with System; use System;
+
+package body Renaming5 is
+
+   type Bits_In_Byte is array (0 .. 7) of Boolean;
+   pragma Pack (Bits_In_Byte);
+
+   A : Bits_In_Byte;
+   for A'Address use System'To_Address(16#c0#);
+   pragma Volatile (A);
+
+   B : Bits_In_Byte renames A;
+
+   procedure Proc is
+   begin
+      while B (0) = False loop
+         null;
+      end loop;
+   end;
+
+end Renaming5;
+
+-- { dg-final { scan-tree-dump-times "goto" 2 "optimized" } }
+-- { dg-final { cleanup-tree-dump "optimized" } }
Index: gcc/testsuite/gnat.dg/renaming5.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/renaming5.ads	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gnat.dg/renaming5.ads	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,5 @@
+package Renaming5 is
+
+   procedure Proc;
+
+end Renaming5;
Index: gcc/testsuite/gnat.dg/opt17.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt17.adb	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gnat.dg/opt17.adb	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,13 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt17 is
+
+  function Func return S is
+    V : String (1 .. 6);
+  begin
+    V (1 .. 3) := "ABC";
+    return V (1 .. 5);
+  end;
+
+end Opt17;
Index: gcc/testsuite/gnat.dg/opt17.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt17.ads	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gnat.dg/opt17.ads	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,7 @@
+package Opt17 is
+
+  subtype S is String (1 .. 5);
+
+  function Func return S;
+
+end Opt17;
Index: gcc/testsuite/gcc.dg/gomp/pr49640.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr49640.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr49640.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,29 @@
+/* PR middle-end/49640 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -std=gnu99 -fopenmp" } */
+
+void
+foo (int N, int M, int K, int P, int Q, int R, int i, int j, int k,
+     unsigned char x[P][Q][R], int y[N][M][K])
+{
+  int ii, jj, kk;
+
+#pragma omp parallel for private(ii,jj,kk)
+  for (ii = 0; ii < P; ++ii)
+    for (jj = 0; jj < Q; ++jj)
+      for (kk = 0; kk < R; ++kk)
+	y[i + ii][j + jj][k + kk] = x[ii][jj][kk];
+}
+
+void
+bar (int N, int M, int K, int P, int Q, int R, int i, int j, int k,
+     unsigned char x[P][Q][R], float y[N][M][K], float factor, float zero)
+{
+  int ii, jj, kk;
+
+#pragma omp parallel for private(ii,jj,kk)
+  for (ii = 0; ii < P; ++ii)
+    for (jj = 0; jj < Q; ++jj)
+      for (kk = 0; kk < R; ++kk)
+	y[i + ii][j + jj][k + kk] = factor * x[ii][jj][kk] + zero;
+}
Index: gcc/testsuite/gcc.dg/pr49619.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr49619.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr49619.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,13 @@
+/* PR rtl-optimization/49619 */
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-fre" } */
+
+extern int a, b;
+
+void
+foo (int x)
+{
+  a = 2;
+  b = 0;
+  b = (a && ((a = 1, 0 >= b) || (short) (x + (b & x))));
+}
Index: gcc/testsuite/gcc.dg/pr49307.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr49307.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr49307.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,21 @@
+/* PR target/49307 */
+/* { dg-do compile } */
+/* { dg-options "-O -fpic -fstack-protector" } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target fstack_protector } */
+
+extern void bar (char **pp, void *vp);
+extern void free (void *p);
+
+int
+foo (void)
+{
+  char *p;
+  char fext[128];
+
+  p = fext;
+  bar (&p, (void *)0);
+  if (p)
+    free (p);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr51821.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr51821.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr51821.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+/* { dg-options "-std=c99 -O2" } */
+/* { dg-options "-std=c99 -O2 -msse" { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-require-effective-target sse_runtime { target { i?86-*-* x86_64-*-* } } } */
+
+extern void abort (void);
+
+unsigned int  __attribute__((noinline))
+test (int shift_size)
+{
+  unsigned long long res = ~0;
+
+  return res << shift_size;
+}
+
+int
+main ()
+{
+  int dst = 32;
+
+  if (test (dst) != 0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr48774.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr48774.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr48774.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,38 @@
+/* PR target/48774 */
+/* { dg-do run } */
+/* { dg-options "-O2 -funroll-loops" } */
+
+extern void abort (void);
+unsigned long int s[24]
+  = { 12, ~1, 12, ~2, 12, ~4, 12, ~8, 12, ~16, 12, ~32,
+      12, ~64, 12, ~128, 12, ~256, 12, ~512, 12, ~1024, 12, ~2048 };
+struct { int n; unsigned long *e[12]; } g
+  = { 12, { &s[0], &s[2], &s[4], &s[6], &s[8], &s[10], &s[12], &s[14],
+	    &s[16], &s[18], &s[20], &s[22] } };
+int c[12];
+
+__attribute__((noinline, noclone)) void
+foo (void)
+{
+  int i, j;
+  for (i = 0; i < g.n; i++)
+    for (j = 0; j < g.n; j++)
+      {
+	if (i == j && j < g.e[0][0] && (g.e[i][1] & (1UL << j)))
+	  abort ();
+	if (j < g.e[0][0] && (g.e[i][1] & (1UL << j)))
+	  c[i]++;
+      }
+}
+
+int
+main ()
+{
+  int i;
+  asm volatile ("" : "+m" (s), "+m" (g), "+m" (c));
+  foo ();
+  for (i = 0; i < 12; i++)
+    if (c[i] != 11)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr51408.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr51408.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr51408.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,22 @@
+/* This testcase used to fail because of a bug in 
+   arm.md:*minmax_arithsi.  */
+
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+extern void abort (void);
+
+int __attribute__((noinline))
+foo (int a, int b)
+{
+  int max = (b > 0) ? b : 0;
+  return max - a;
+}
+
+int
+main (void)
+{
+  if (foo (3, -1) != -3)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr48837.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr48837.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr48837.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,30 @@
+/* PR tree-optimization/48837 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+void abort (void);
+
+__attribute__((noinline))
+int baz(void)
+{
+  return 1;
+}
+
+inline const int *bar(const int *a, const int *b)
+{
+ return *a ? a : b;
+}
+
+int foo(int a, int b)
+{
+   return a || b ? baz() : foo(*bar(&a, &b), 1) + foo(1, 0);
+}
+
+int main(void)
+{
+ if (foo(0, 0) != 2)
+   abort();
+
+ return 0;
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr48822.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr48822.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr48822.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+
+void foo (int *, int *);
+int bar ()
+{
+  int a = 0;
+  int b = 0;
+  if (b != 0)
+    {
+      int ax = a;
+      int bx = b;
+      while (bx != 0)
+	{
+	  int tem = ax % bx;
+	  ax = bx;
+	  bx = tem;
+	}
+    }
+  foo (&a, &b);
+}
Index: gcc/testsuite/gcc.dg/torture/pr48542.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr48542.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr48542.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,57 @@
+/* { dg-do run } */
+/* The return-address was clobbered.  */
+#include <stdlib.h>
+#include <setjmp.h>
+
+jmp_buf env;
+extern void sub(void);
+extern void sub3(void);
+int called;
+__attribute__ ((__noinline__))
+int sjtest()
+{
+  int i;
+  if (setjmp(env))
+    return 99;
+
+  for (i = 0; i < 10; i++)
+    sub();
+
+  longjmp(env, 1);
+}
+
+__attribute__ ((__noinline__))
+void sub(void)
+{
+  called++;
+}
+
+int called3;
+__attribute__ ((__noinline__))
+int sjtest3()
+{
+  int i;
+  if (setjmp(env))
+    return 42;
+
+  for (i = 0; i < 10; i++)
+    sub3();
+  return 0;
+}
+
+__attribute__ ((__noinline__))
+void sub3(void)
+{
+  called3++;
+  if (called3 == 10)
+    longjmp (env, 1);
+}
+
+int main(void)
+{
+  if (sjtest() != 99 || called != 10)
+    abort();
+  if (sjtest3() != 42 || called3 != 10)
+    abort();
+  exit (0);
+}
Index: gcc/testsuite/gcc.dg/torture/pr49651.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr49651.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr49651.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+struct X {
+    int *p;
+    int *q;
+};
+
+void __attribute__((noinline, noclone))
+foo (struct X x) { *x.q = 0; }
+
+volatile int what;
+struct X y;
+
+int main()
+{
+  int i, j;
+  struct X x, *p;
+  x.p = &i;
+  x.q = &j;
+  if (what)
+    p = &y;
+  else
+    p = &x;
+  j = 1;
+  foo (*p);
+  if (j != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr49039.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr49039.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr49039.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,31 @@
+/* PR tree-optimization/49039 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-vrp1" } */
+
+extern void bar (void);
+
+void
+foo (unsigned int x, unsigned int y)
+{
+  unsigned int minv, maxv;
+  if (x >= 3 && x <= 6)
+    return;
+  if (y >= 5 && y <= 8)
+    return;
+  minv = x < y ? x : y;
+  maxv = x > y ? x : y;
+  if (minv == 5)
+    bar ();
+  if (minv == 6)
+    bar ();
+  if (maxv == 5)
+    bar ();
+  if (maxv == 6)
+    bar ();
+}
+
+/* { dg-final { scan-tree-dump "Folding predicate minv_\[0-9\]* == 5 to 0" "vrp1" } } */
+/* { dg-final { scan-tree-dump "Folding predicate minv_\[0-9\]* == 6 to 0" "vrp1" } } */
+/* { dg-final { scan-tree-dump "Folding predicate maxv_\[0-9\]* == 5 to 0" "vrp1" } } */
+/* { dg-final { scan-tree-dump "Folding predicate maxv_\[0-9\]* == 6 to 0" "vrp1" } } */
+/* { dg-final { cleanup-tree-dump "vrp1" } } */
Index: gcc/testsuite/gcc.dg/ipa/pr45644.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr45644.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr45644.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,35 @@
+/* Verify that we do not IPA-SRA bitfields.  */
+/* { dg-do run } */
+/* { dg-options "-O2"  } */
+
+extern void abort (void);
+
+struct S
+{
+  int j : 8;
+  int i : 24;
+  int l;
+};
+
+static int __attribute__((noinline)) foo (struct S *s)
+{
+  int z = s->i;
+  if (z != 777)
+    abort ();
+  return 0;
+}
+
+int __attribute__((noinline)) bar (struct S *s)
+{
+  return foo (s);
+}
+
+int main (int argc, char *argv[])
+{
+  struct S s;
+  s.j = 5;
+  s.i = 777;
+  s.l = -1;
+
+  return bar (&s);
+}
Index: gcc/testsuite/gcc.dg/pr49120.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr49120.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr49120.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,11 @@
+/* PR c/49120 */
+/* { dg-do compile } */
+/* { dg-options "-Wall" } */
+
+int
+main ()
+{
+  int a = 1;
+  int c = ({ char b[a + 1]; b[0] = 0; b[0]; });
+  return c;
+}
Index: gcc/testsuite/gcc.dg/delay-slot-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/delay-slot-2.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/delay-slot-2.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,116 @@
+/* PR rtl-optimization/51187 */
+/* Reported by Jurij Smakov <jurij@wooyd.org> */
+
+/* { dg-do compile } */
+/* { dg-options "-g -O2" } */
+
+extern int printf (__const char *__restrict __format, ...);
+extern void print_c_condition (const char *);
+
+enum decision_type
+{
+  DT_num_insns,
+  DT_mode, DT_code, DT_veclen,
+  DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide, DT_elt_zero_wide_safe,
+  DT_const_int,
+  DT_veclen_ge, DT_dup, DT_pred, DT_c_test,
+  DT_accept_op, DT_accept_insn
+};
+
+struct decision_test
+{
+  struct decision_test *next;
+  enum decision_type type;
+
+  union
+  {
+    int num_insns;
+
+    struct
+    {
+      const char *name;
+    } pred;
+
+    const char *c_test;
+    int veclen;
+    int dup;
+    long intval;
+    int opno;
+
+    struct {
+      int code_number;
+      int lineno;
+      int num_clobbers_to_add;
+    } insn;
+  } u;
+};
+
+enum routine_type {
+  RECOG, SPLIT, PEEPHOLE2
+};
+
+void
+write_cond (struct decision_test *p, int depth,
+     enum routine_type subroutine_type)
+{
+  switch (p->type)
+    {
+    case DT_num_insns:
+      printf ("peep2_current_count >= %d", p->u.num_insns);
+      break;
+
+    case DT_code:
+      printf ("GET_CODE (x%d) == ", depth);
+      break;
+
+    case DT_veclen:
+      printf ("XVECLEN (x%d, 0) == %d", depth, p->u.veclen);
+      break;
+
+    case DT_elt_zero_int:
+      printf ("XINT (x%d, 0) == %d", depth, (int) p->u.intval);
+      break;
+
+    case DT_elt_one_int:
+      printf ("XINT (x%d, 1) == %d", depth, (int) p->u.intval);
+      break;
+
+    case DT_elt_zero_wide:
+    case DT_elt_zero_wide_safe:
+      printf ("XWINT (x%d, 0) == ", depth);
+      print_host_wide_int (p->u.intval);
+      break;
+
+    case DT_const_int:
+      printf ("x%d == const_int_rtx[MAX_SAVED_CONST_INT + (%d)]",
+       depth, (int) p->u.intval);
+      break;
+
+    case DT_veclen_ge:
+      printf ("XVECLEN (x%d, 0) >= %d", depth, p->u.veclen);
+      break;
+
+    case DT_dup:
+      printf ("rtx_equal_p (x%d, operands[%d])", depth, p->u.dup);
+      break;
+
+    case DT_pred:
+      printf ("%s (x%d)", p->u.pred.name, depth);
+      break;
+
+    case DT_c_test:
+      print_c_condition (p->u.c_test);
+      break;
+
+    case DT_accept_insn:
+      ((void)(__builtin_expect(!(subroutine_type == RECOG), 0) ? __builtin_unreachable(), 0 : 0));
+      ((void)(__builtin_expect(!(p->u.insn.num_clobbers_to_add), 0) ? __builtin_unreachable(), 0 : 0));
+      printf ("pnum_clobbers != NULL");
+      break;
+
+    default:
+      __builtin_unreachable();
+    }
+}
+
+/* { dg-final { scan-assembler "printf" } } */
Index: gcc/testsuite/gcc.dg/pr48685.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr48685.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/pr48685.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,11 @@
+/* PR c/48685 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+main ()
+{
+  int v = 1;
+  (void) (1 == 2 ? (void) 0 : (v = 0));
+  return v;
+}
Index: gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,116 @@
+/* { dg-require-effective-target vect_int } */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include "tree-vect.h"
+
+#define N 160 
+
+typedef struct {
+   unsigned char a;
+   unsigned char b;
+   unsigned char c;
+   unsigned char d;
+   unsigned char e;
+   unsigned char f;
+   unsigned char g;
+   unsigned char h;
+} s;
+
+__attribute__ ((noinline)) int
+main1 (s *arr, int n)
+{
+  int i;
+  s *ptr = arr;
+  s res[N];
+  unsigned char x;
+
+  for (i = 0; i < N; i++)
+    {
+      res[i].a = 0;
+      res[i].b = 0;
+      res[i].c = 0;
+      res[i].d = 0;
+      res[i].e = 0;
+      res[i].f = 0;
+      res[i].g = 0;
+      res[i].h = 0;
+      __asm__ volatile ("");
+    }
+
+  /* Check peeling for gaps for unknown loop bound.  */
+  for (i = 0; i < n; i++)
+    {
+      res[i].c = ptr->b + ptr->c;
+      x = ptr->c + ptr->f;
+      res[i].a = x + ptr->b;
+      res[i].d = ptr->b + ptr->c;
+      res[i].b = ptr->c;
+      res[i].f = ptr->f + ptr->e;
+      res[i].e = ptr->b + ptr->e; 
+      res[i].h = ptr->c;   
+      res[i].g = ptr->b + ptr->c;
+      ptr++; 
+    } 
+   
+  /* check results:  */
+  for (i = 0; i < n; i++)
+    { 
+      if (res[i].c != arr[i].b + arr[i].c
+          || res[i].a != arr[i].c + arr[i].f + arr[i].b
+          || res[i].d != arr[i].b + arr[i].c
+          || res[i].b != arr[i].c
+          || res[i].f != arr[i].f + arr[i].e
+          || res[i].e != arr[i].b + arr[i].e
+          || res[i].h != arr[i].c
+          || res[i].g != arr[i].b + arr[i].c)
+        abort ();
+   }
+
+  /* Check also that we don't do more iterations than needed.  */
+  for (i = n; i < N; i++)
+    {
+      if (res[i].c == arr[i].b + arr[i].c
+          || res[i].a == arr[i].c + arr[i].f + arr[i].b
+          || res[i].d == arr[i].b + arr[i].c
+          || res[i].b == arr[i].c
+          || res[i].f == arr[i].f + arr[i].e
+          || res[i].e == arr[i].b + arr[i].e
+          || res[i].h == arr[i].c
+          || res[i].g == arr[i].b + arr[i].c)
+        abort ();
+   }
+
+  return 0;
+}
+
+
+int main (void)
+{
+  int i;
+  s arr[N];
+  
+  check_vect ();
+
+  for (i = 0; i < N; i++)
+    { 
+      arr[i].a = 5;
+      arr[i].b = 6;
+      arr[i].c = 17;
+      arr[i].d = 3;
+      arr[i].e = 16;
+      arr[i].f = 16;
+      arr[i].g = 3;
+      arr[i].h = 56;
+      if (arr[i].a == 178)
+         abort(); 
+    } 
+
+  main1 (arr, N-2);
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { vect_interleave && vect_extract_even_odd } } } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
+  
Index: gcc/testsuite/gcc.dg/vect/pr48172.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr48172.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr48172.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+extern void *memset(void *s, int c, __SIZE_TYPE__ n);
+extern void abort (void);
+
+#define ASIZE 1028
+#define HALF (ASIZE/2)
+
+int main() {
+  unsigned int array[ASIZE];
+  int i;
+
+  memset(array, 0, sizeof(array));
+
+  /* initialize first half of the array */
+  for (i = 0; i < HALF; i++)
+    array[i] = i;
+
+  /* fill second half of array in by summing earlier elements of the array
+     gcc 4.5.1 and 4.5.2 incorrectly vectorize this loop!  aray[1025] is left
+     at 0 for ASIZE=1028 */
+  for (i = 0; i < HALF-1; i++)
+    array[HALF+i] = array[2*i] + array[2*i + 1];
+
+  /* see if we have any failures */
+  for (i = 0; i < HALF - 1; i++)
+    if (array[HALF+i] != array[2*i] + array[2*i + 1])
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr49038.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr49038.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr49038.c	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,42 @@
+#include <sys/mman.h>
+#include <stdio.h>
+
+#define COUNT 320
+#define MMAP_SIZE 0x10000
+#define ADDRESS 0x1122000000
+#define TYPE unsigned short
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+void __attribute__((noinline))
+foo (TYPE *__restrict a, TYPE *__restrict b)
+{
+  int n;
+
+  for (n = 0; n < COUNT; n++)
+    a[n] = b[n * 2];
+}
+
+int
+main (void)
+{
+  void *x;
+  size_t b_offset;
+
+  x = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,
+	    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (x == MAP_FAILED)
+    {
+      perror ("mmap");
+      return 1;
+    }
+
+  b_offset = MMAP_SIZE - (2 * COUNT - 1) * sizeof (TYPE);
+  foo ((unsigned short *) x,
+       (unsigned short *) ((char *) x + b_offset));
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/ada/acats/run_acats
===================================================================
--- a/src/gcc/testsuite/ada/acats/run_acats	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/ada/acats/run_acats	(.../branches/gcc-4_5-branch)
@@ -10,12 +10,12 @@
 # type -p is missing from Solaris 2 /bin/sh and /bin/ksh (ksh88), but both
 # ksh93 and bash have it.
 # type output format differs between ksh88 and ksh93, so avoid it if
-# type -p is present.
+# type -p is present.  Unfortunately, HP-UX /bin/sh ignores -p with type.
 # Fall back to whence which ksh88 and ksh93 provide, but bash does not.
 
 which () {
-    path=`type -p $* 2>/dev/null` && { echo $path; return 0; }
-    path=`type $* 2>/dev/null | awk '{print $NF}'` && { echo $path; return 0; }
+    path=`type -p $* 2>/dev/null` && { echo $path | awk '{print $NF}'; return 0; }
+    path=`type $* 2>/dev/null` && { echo $path | awk '{print $NF}'; return 0; }
     path=`whence $* 2>/dev/null` && { echo $path; return 0; }
     return 1
 }
Index: gcc/testsuite/ada/acats/overflow.lst
===================================================================
--- a/src/gcc/testsuite/ada/acats/overflow.lst	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/ada/acats/overflow.lst	(.../branches/gcc-4_5-branch)
@@ -14,3 +14,4 @@
 c460008
 c460011
 c4a012b
+cb20004
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,495 @@
+2012-01-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/renaming5.ad[sb]: New test.
+
+2012-01-20  Kai Tietz  <ktietz@redhat.com>
+
+	* g++.dg/torture/pr51344.C: Fix typo.
+
+2012-01-19  Kai Tietz  <ktietz@redhat.com>
+
+	* g++.dg/torture/pr51344.C: New test.
+
+2012-01-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/51821
+	* gcc.dg/pr51821.c: New test.
+
+2012-01-12  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	Backport from mainline:
+	2011-01-11  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	* gcc.c-torture/execute/20120110-1.c: New testcase.
+
+2012-01-10  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.c-torture/execute/doloop-1.c,
+	gcc.c-torture/execute/doloop-2.c: New tests.
+
+2012-01-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/51759
+	* gcc.dg/ipa/pr45644.c: New test.
+	* g++.dg/ipa/pr51759.C: Likewise.
+
+2012-01-06  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR middle-end/48660
+	* g++.dg/pr48660.C: New test.
+
+2012-01-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* ada/acats/overflow.lst: Add cb20004.
+
+2012-01-04  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-07-14  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49651
+	* gcc.dg/torture/pr49651.c: New testcase.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-10-12  Paul Koning  <pkoning@gcc.gnu.org>
+
+	PR tree-optimization/50189
+	* g++.dg/torture/pr50189.C: New testcase.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-10-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/49279
+	* gcc.c-torture/execute/pr49279.c: New test.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-05-12  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/48172
+	* gcc.dg/vect/pr48172.c: New testcase.
+
+2011-12-20  Dodji Seketeli  <dodji@redhat.com>
+
+	PR debug/49951
+	* g++.dg/gcov/gcov-2.C: Adjust.
+
+2011-12-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51406
+	PR c++/51161
+	* g++.dg/cpp0x/rv-cast3.C: New.
+	* g++.dg/cpp0x/rv-cast4.C: New.
+
+2011-12-09  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+
+	2011-12-05  Kazu Hirata  <kazu@codesourcery.com>
+
+	PR target/51408
+	* gcc.dg/pr51408.c: New.
+
+2011-12-04  Uros Bizjak  <ubizjak@gmail.com>
+	    Jrmie Detrey  <Jeremie.Detrey@loria.fr>
+
+	PR target/51393
+	* gcc.target/i386/pr51393.c: New test.
+
+2011-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/delay-slot-2.c: New test.
+
+2011-10-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50875
+	* config/i386/sse.md (*avx_unpcklpd256): Remove extra insn
+	constraints.  Change alternative 1 to "x,m,1".
+
+2011-10-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50788
+	* gcc.target/i386/pr50788.c: New test.
+
+2011-10-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50793
+	* g++.dg/init/value9.C: New.
+
+2011-10-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50618
+	* g++.dg/init/vbase1.C: New.
+
+2011-10-13  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/50659
+	* gfortran.dg/proc_decl_27.f90: New.
+
+2011-10-12  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/50565
+	* gcc.c-torture/compile/pr50565-1.c,
+	gcc.c-torture/compile/pr50565-2.c: New tests.
+
+2011-10-11  Janis Johnson  <janisjo@codesourcery.com>
+
+	PR c++/44473
+	* g++.dg/dfp/44473-1.C: New test.
+	* g++.dg/dfp/44473-2.C: New test.
+	* g++.dg/dfp/mangle-1.C: New test.
+	* g++.dg/dfp/mangle-2.C: New test.
+	* g++.dg/dfp/mangle-3.C: New test.
+	* g++.dg/dfp/mangle-4.C: New test.
+	* g++.dg/dfp/mangle-5.C: New test.
+
+2011-10-11  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50273
+	* gfortran.dg/common_16.f90: New.
+
+2011-09-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50464
+	* g++.dg/other/pr50464.C: New test.
+
+2011-09-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2011-09-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/49911
+	* g++.dg/tree-ssa/pr49911.C: New test.
+
+2011-09-01  Mikael Morin  <mikael.morin@sfr.fr>
+
+	PR fortran/50050
+	* gfortran.dg/alloc_comp_initializer_3.f90: New test.
+	* gfortran.dg/pointer_comp_init.f90: New test.
+
+2011-08-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR libfortran/50192
+	* gfortran.dg/widechar_compare_1.f90:  New test.
+
+2011-08-30  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50163
+	* gfortran.dg/initialization_28.f90: New.
+
+2011-08-19  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2011-08-18  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50109
+	* gfortran.dg/namelist_73.f90: New.
+
+2011-08-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42051
+	PR fortran/43896
+	PR fortran/49962
+	* gfortran.dg/class_23.f03: New test.
+
+2011-07-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/49920
+	* gcc.target/i386/pr49920.c: New test.
+
+2011-07-27  Tobias Burnus  <burnus@net-b.de>
+
+	Backported from mainline
+	2011-07-23  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/49791
+	* gfortran.dg/namelist_72.f: New.
+
+2011-07-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/avx-os-support.h: New.
+	* gcc.target/i386/avx-check.h: Include avx-os-support.h
+	(main): Check avx_os_support before the test is run.
+	* gcc.target/i386/aes-avx-check.h: Ditto.
+	* gcc.target/i386/pclmul-avx-check.h: Ditto.
+
+2011-07-23  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/49708
+	* gfortran.dg/allocate_error_3.f90: New.
+
+2011-07-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR debug/47393
+	* g++.dg/debug/dwarf2/icf.C: XFAIL some scan-assembler on
+	mips-sgi-irix*.
+
+2011-07-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	* lib/target-supports.exp (check_avx_os_support_available): New.
+	(check_effective_target_avx_runtime): Use it.
+
+2011-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-07-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/49621
+	* gcc.target/powerpc/altivec-34.c: New test.
+
+	2011-07-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/49644
+	* g++.dg/torture/pr49644.C: New test.
+
+	PR c/49644
+	* gcc.c-torture/execute/pr49644.c: New test.
+
+	PR middle-end/49640
+	* gcc.dg/gomp/pr49640.c: New test.
+
+	2011-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/49619
+	* gcc.dg/pr49619.c: New test.
+
+	2011-05-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/49165
+	* g++.dg/eh/cond6.C: New test.
+
+	2011-05-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/49165
+	* g++.dg/eh/cond5.C: New test.
+
+	PR tree-optimization/49161
+	* gcc.c-torture/execute/pr49161.c: New test.
+
+	2011-05-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/49120
+	* c-decl.c (start_decl): Convert expr to void_type_node.
+
+	PR middle-end/48973
+	* gcc.c-torture/execute/pr48973-1.c: New test.
+	* gcc.c-torture/execute/pr48973-2.c: New test.
+
+	2011-05-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/49039
+	* gcc.c-torture/execute/pr49039.c: New test.
+	* gcc.dg/tree-ssa/pr49039.c: New test.
+	* g++.dg/torture/pr49039.C: New test.
+
+2011-07-15  Jason Merrill  <jason@redhat.com>
+
+	PR testsuite/49643
+	* g++.dg/rtti/anon-ns1.C: Allow for null-termination.
+
+2011-07-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.target/sparc/cas64.c: New test.
+
+2011-07-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* ada/acats/run_acats (which): Extract last field from type -p,
+	type output only if command succeeded.
+
+2011-07-04  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-05-02  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/48822
+	* gcc.dg/torture/pr48822.c: New testcase.
+
+2011-07-04  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-05-23  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49115
+	* g++.dg/torture/pr49115.C: New testcase.
+
+2011-07-04  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49615
+	* g++.dg/torture/pr49615.C: New testcase.
+
+2011-06-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR ada/49511
+	* ada/acats/run_acats (which): Use last field of type -p output.
+
+2011-06-30  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/38752
+	* gcc.c-torture/compile/pr38752.c: New testcase.
+
+2011-06-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt17.ad[sb]: New test.
+
+2011-06-23  Jason Merrill  <jason@redhat.com>
+
+	PR c++/49440
+	* g++.dg/rtti/anon-ns1.C: New.
+
+2011-06-17  Hans-Peter Nilsson  <hp@axis.com>
+
+	Backport from mainline
+	2011-06-17  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR rtl-optimization/48542
+	* gcc.dg/torture/pr48542.c: New test.
+
+2011-06-16  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport form main line
+	2011-06-09  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/49307
+	* gcc.dg/pr49307.c: New.
+
+2011-06-08  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2011-06-01  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/49238
+	* gcc.c-torture/compile/pr49238.c: New.
+
+2011-06-05  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2011-05-30  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/49186
+	* gcc.c-torture/execute/pr49186.c: New.
+
+2011-06-04  Ira Rosen  <ira.rosen@linaro.org>
+
+	PR tree-optimization/49038
+	* gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c: New test.
+	* gcc.dg/vect/pr49038.c: New test.
+
+2011-06-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/45786
+	* gfortran.dg/operator_7.f90:  New test case.
+
+2011-05-31  Duncan Sands  <baldrick@free.fr>
+
+	Backported from 4.6 branch
+	2011-03-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/47714
+	* g++.dg/torture/pr47714.C: New test.
+
+2011-05-29  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	* gcc.target/mips/reg-var-1.c: New test.
+
+2011-05-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/49133
+	* g++.dg/other/pr49133.C: New test.
+
+2011-05-20  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/init/new32.C: New.
+
+2011-05-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.c-torture/execute/960321-1.x: Remove.
+
+2011-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2011-05-10  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/48857
+	* gcc.target/powerpc/pr48857.c: New file, make sure V2DI arguments
+	are passed and returned in vector registers.
+
+2011-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2011-05-07  Zdenek Dvorak  <ook@ucw.cz>
+
+	PR tree-optimization/48837
+	* gcc.dg/pr48837.c: New testcase.
+
+2011-05-09  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/template/nontype23.C: New.
+
+2011-05-05  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/init/new30.C: New.
+
+2011-05-05  Julian Brown  <julian@codesourcery.com>
+
+	* gcc.target/arm/neon-vset_lanes8.c: New test.
+
+2011-05-05  Ira Rosen  <ira.rosen@linaro.org>
+
+	Backport from mainline:
+	2011-04-18  Ulrich Weigand  <ulrich.weigand@linaro.org>
+		    Ira Rosen  <ira.rosen@linaro.org>
+
+	PR target/48252
+	* gcc.target/arm/pr48252.c: New test.
+
+2011-05-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2011-04-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/48708
+	* gcc.target/i386/pr48708.c: New test.
+
+2011-05-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2010-12-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.target/i386/sse2-init-v2di-2.c: Add "-dp" and update
+	expected scan.
+
+2011-05-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/48774
+	* gcc.dg/pr48774.c: New test.
+
+	Backport from mainline
+	2011-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/48809
+	* gcc.c-torture/execute/pr48809.c: New test.
+
+	2011-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/48742
+	* gcc.c-torture/compile/pr48742.c: New test.
+
+	2011-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/48685
+	* gcc.dg/pr48685.c: New test.
+
+2011-04-27  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/parse/ambig6.C: New.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
@@ -48,7 +540,7 @@
 
 2011-04-18  Richard Guenther  <rguenther@suse.de>
 
-	Backported from 4.6 branch 
+	Backported from 4.6 branch
 	2011-03-11  Jakub Jelinek  <jakub@redhat.com>
 
 	PR c++/48035
@@ -318,7 +810,7 @@
 	* gcc.dg/torture/pr45967.c: New testcase.
 	* gcc.dg/torture/pr45967-2.c: Likewise.
 	* gcc.dg/torture/pr45967-3.c: Likewise.
-	* gcc.dg/torture/pr39074-2.c: Adjust. 
+	* gcc.dg/torture/pr39074-2.c: Adjust.
 	* gcc.dg/torture/pta-escape-1.c: Likewise
 	* gcc.dg/torture/pta-ptrarith-1.c: Likewise
 	* gcc.dg/tree-ssa/pta-callused.c: Likewise
@@ -1284,11 +1776,11 @@
 
 2010-09-06  Dodji Seketeli  <dodji@redhat.com>
 
-    	PR c++/45200
-    	PR c++/45293
-    	PR c++/45558
-    	* g++.dg/template/typedef34.C: New test.
-    	* g++.dg/template/typedef35.C: New test.
+	PR c++/45200
+	PR c++/45293
+	PR c++/45558
+	* g++.dg/template/typedef34.C: New test.
+	* g++.dg/template/typedef35.C: New test.
 
 2010-09-04  Tobias Burnus  <burnus@net-b.de>
 
@@ -4146,7 +4638,7 @@
 	* gfortran.dg/read_x_eof.f90: New test.
 	* gfortran.dg/read_x_past.f: Update test.
 
-2010-03-10  Jan Hubicka   <jh@suse.cz>
+2010-03-10  Jan Hubicka  <jh@suse.cz>
 
 	* gcc.c-torture/compile/pr43288.c: New test.
 
Index: gcc/testsuite/g++.dg/other/pr50464.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/pr50464.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/other/pr50464.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,170 @@
+// { dg-do compile { target i?86-*-* x86_64-*-* } }
+// { dg-options "-O3 -mxop" }
+
+typedef long unsigned int size_t;
+typedef unsigned long ulong_t;
+typedef signed long slong_t;
+
+  template<typename _Iterator>
+    struct iterator_traits
+    {
+      typedef typename _Iterator::reference reference;
+    };
+
+  template<typename _Tp>
+    struct iterator_traits<_Tp*>
+    {
+      typedef _Tp& reference;
+    };
+
+  template<typename _Iterator, typename _Container>
+    class __normal_iterator
+    {
+    protected:
+      _Iterator _M_current;
+      typedef iterator_traits<_Iterator> __traits_type;
+
+    public:
+      typedef typename __traits_type::reference reference;
+
+      explicit
+      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
+
+      reference
+      operator*() const
+      { return *_M_current; }
+
+      __normal_iterator&
+      operator++()
+      {
+         ++_M_current;
+         return *this;
+      }
+
+      const _Iterator&
+      base() const
+      { return _M_current; }
+    };
+
+  template<typename _Iterator, typename _Container>
+    inline bool
+    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
+        const __normal_iterator<_Iterator, _Container>& __rhs)
+    { return __lhs.base() != __rhs.base(); }
+
+  template<typename _Tp>
+    class allocator
+    {
+    public:
+      typedef _Tp* pointer;
+      typedef _Tp value_type;
+
+      template<typename _Tp1>
+        struct rebind
+        { typedef allocator<_Tp1> other; };
+
+       pointer allocate(size_t __n, const void* = 0)
+       {
+          return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
+       }
+    };
+
+  template<typename _Tp, typename _Alloc>
+    struct _Vector_base
+    {
+      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
+
+      struct _Vector_impl
+      : public _Tp_alloc_type
+      {
+        typename _Tp_alloc_type::pointer _M_start;
+        typename _Tp_alloc_type::pointer _M_finish;
+        typename _Tp_alloc_type::pointer _M_end_of_storage;
+
+        _Vector_impl(_Tp_alloc_type const& __a) { }
+      };
+
+    public:
+      typedef _Alloc allocator_type;
+
+      _Vector_base(size_t __n, const allocator_type& __a)
+      : _M_impl(__a)
+      {
+        this->_M_impl._M_start = this->_M_allocate(__n);
+        this->_M_impl._M_finish = this->_M_impl._M_start;
+        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
+      }
+
+    public:
+      _Vector_impl _M_impl;
+
+      typename _Tp_alloc_type::pointer
+      _M_allocate(size_t __n)
+      { return __n != 0 ? _M_impl.allocate(__n) : 0; }
+
+    };
+
+  template<typename _Tp, typename _Alloc = allocator<_Tp> >
+    class vector : protected _Vector_base<_Tp, _Alloc>
+    {
+      typedef _Vector_base<_Tp, _Alloc> _Base;
+      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
+
+    public:
+      typedef _Tp value_type;
+      typedef typename _Tp_alloc_type::pointer pointer;
+      typedef __normal_iterator<pointer, vector> iterator;
+      typedef _Alloc allocator_type;
+
+    protected:
+      using _Base::_M_allocate;
+      using _Base::_M_impl;
+
+    public:
+
+      explicit
+      vector(size_t __n, const value_type& __value = value_type(),
+      const allocator_type& __a = allocator_type())
+      : _Base(__n, __a)
+      { _M_fill_initialize(__n, __value); }
+
+      iterator begin()
+      { return iterator(this->_M_impl._M_start); }
+
+      iterator end()
+      { return iterator(this->_M_impl._M_finish); }
+
+    protected:
+      void
+      _M_fill_initialize(size_t __n, const value_type& __value)
+      {
+         this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
+      }
+    };
+
+  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
+    _OutputIterator
+    replace_copy(_InputIterator __first, _InputIterator __last,
+   _OutputIterator __result,
+   const _Tp& __old_value, const _Tp& __new_value)
+    {
+      ;
+      for (; __first != __last; ++__first, ++__result)
+         if (*__first == __old_value)
+            *__result = __new_value;
+         else
+            *__result = *__first;
+      return __result;
+    }
+
+extern size_t shape_rank;
+
+void createDataspaceIdentifier()
+{
+  vector< ulong_t > dataspaceDims( shape_rank );
+  vector< ulong_t > maxDataspaceDims( shape_rank );
+
+  replace_copy(
+    dataspaceDims.begin(), dataspaceDims.end(),
+    maxDataspaceDims.begin(), ulong_t( 0 ), ((ulong_t)(slong_t)(-1)) );
+}
Index: gcc/testsuite/g++.dg/other/pr49133.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/pr49133.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/other/pr49133.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,37 @@
+/* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -msse2" } */
+/* { dg-require-effective-target sse2 } */
+/* { dg-require-effective-target sse2_runtime } */
+
+#include <xmmintrin.h>
+
+extern "C" void abort ();
+
+typedef double double_a __attribute__((__may_alias__));
+
+struct V
+{
+  __m128d data;
+};
+
+int
+main()
+{
+  V a;
+  __m128d b;
+
+  b = _mm_set_pd (1., 0.);
+  a.data = _mm_set_pd (1., 0.);
+  a.data = _mm_add_pd (a.data,
+		       _mm_and_pd (_mm_cmpeq_pd (a.data, _mm_set1_pd (0.)),
+				   _mm_set1_pd (2.)));
+  reinterpret_cast<double_a *>(&a.data)[1] += 1.;
+  b = _mm_add_pd (b, _mm_and_pd (_mm_cmpeq_pd (b, _mm_set1_pd (0.)),
+				 _mm_set1_pd (1.)));
+  b = _mm_add_pd (b, _mm_and_pd (_mm_cmpeq_pd (b, _mm_set1_pd (1.)),
+				 _mm_set1_pd (1.)));
+  if (_mm_movemask_pd (_mm_cmpeq_pd (a.data, b)) != 0x3)
+    abort();
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/rtti/anon-ns1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/rtti/anon-ns1.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/rtti/anon-ns1.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,15 @@
+// PR c++/49440
+// The typeinfo name for A should start with * so we compare
+// it by address rather than contents.
+
+// { dg-final { scan-assembler "\"\*N\[^\"\]+1AE" } }
+
+namespace
+{
+  class A { };
+}
+
+void f()
+{
+  throw A();
+}
Index: gcc/testsuite/g++.dg/tree-ssa/pr49911.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr49911.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr49911.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,41 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-rtti -fno-exceptions -fno-strict-aliasing -fdump-tree-vrp2" } */
+
+
+extern  void JS_Assert();
+typedef enum {
+eax,         ecx,         edx,         ebx,         esp,         ebp,
+esi,         edi     }
+RegisterID;
+union StateRemat {
+  RegisterID reg_;
+  int offset_;
+};
+static StateRemat FromRegister(RegisterID reg) {
+  StateRemat sr;
+  sr.reg_ = reg;
+  return sr;
+}
+static StateRemat FromAddress3(int address) {
+  StateRemat sr;
+    sr.offset_ = address;
+  //sr.offset_ = 0;
+  if (address < 46 &&    address >= 0) {
+    JS_Assert();
+  }
+  return sr;
+}
+struct FrameState {
+  StateRemat dataRematInfo2(bool y, int z) {
+    if (y)         return FromRegister(RegisterID(1));
+    return FromAddress3(z);
+  }
+};
+FrameState frame;
+StateRemat x;
+void jsop_setelem(bool y, int z) {
+  x = frame.dataRematInfo2(y, z);
+}
+
+/* { dg-final { scan-tree-dump-times "Folding predicate.*45" 0 "vrp2"} } */
+/* { dg-final { cleanup-tree-dump "vrp2" } } */
Index: gcc/testsuite/g++.dg/debug/dwarf2/icf.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/debug/dwarf2/icf.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/debug/dwarf2/icf.C	(.../branches/gcc-4_5-branch)
@@ -40,11 +40,11 @@
 
 // Verify that we get .debug_dcall and .debug_vcall tables generated
 // and that we see entries for both virtual calls. 
-// { dg-final { scan-assembler "\\.section.*\.debug_dcall" } }
+// { dg-final { scan-assembler "\\.section.*\.debug_dcall" { xfail mips-sgi-irix* } } }
 // { dg-final { scan-assembler "\\.section.*\.debug_vcall" } }
-// { dg-final { scan-assembler "New caller" } }
-// { dg-final { scan-assembler "Caller DIE offset" } }
+// { dg-final { scan-assembler "New caller" { xfail mips-sgi-irix* } } }
+// { dg-final { scan-assembler "Caller DIE offset" { xfail mips-sgi-irix* } } }
 // { dg-final { scan-assembler "Point of call" } }
-// { dg-final { scan-assembler "Callee DIE offset" } }
+// { dg-final { scan-assembler "Callee DIE offset" { xfail mips-sgi-irix* } } }
 // { dg-final { scan-assembler "0x0.*Vtable slot" } }
 // { dg-final { scan-assembler "0x1.*Vtable slot" } }
Index: gcc/testsuite/g++.dg/pr48660.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr48660.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/pr48660.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,22 @@
+template<int N> struct val { char a[N]; };
+
+class Base
+{
+public:
+  virtual val<1> get1() const = 0;
+  virtual val<2> get2() const = 0;
+  virtual val<3> get3() const = 0;
+  virtual val<4> get4() const = 0;
+};
+
+class Derived : public virtual Base
+{
+public:
+  virtual val<1> get1() const { return foo->get1(); }
+  virtual val<2> get2() const { return foo->get2(); }
+  virtual val<3> get3() const { return foo->get3(); }
+  virtual val<4> get4() const { return foo->get4(); }
+  Base *foo;
+};
+
+Base* make() { return new Derived; }
Index: gcc/testsuite/g++.dg/parse/ambig6.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/parse/ambig6.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/parse/ambig6.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,12 @@
+// PR c++/48046
+
+namespace N1 { typedef int   T; } // { dg-error "" }
+namespace N2 { typedef float T; } // { dg-error "" }
+
+int main()
+{
+  using namespace N1;
+  using namespace N2;
+
+  static T t;			// { dg-error "" }
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-cast3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/rv-cast3.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/rv-cast3.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,18 @@
+// PR c++/51406
+// { dg-do run }
+// { dg-options "-std=c++0x" }
+
+extern "C" int printf(const char *,...);
+extern "C" void abort();
+
+struct A { int a; A() : a(1) {} };
+struct B { int b; B() : b(2) {} };
+struct X : A, B {};
+
+int main() {
+    X x;
+    int a=static_cast<A&&>(x).a;
+    int b=static_cast<B&&>(x).b;
+    // printf ("%d %d\n", a, b);
+    if (a!=1 || b!=2) abort();
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-cast4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/rv-cast4.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/rv-cast4.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,13 @@
+// PR c++/51161
+// { dg-options "-std=c++0x" }
+
+struct A{};
+struct B : A{};
+struct C : A{};
+struct D : B, C{};
+
+int main()
+{
+  D d;
+  static_cast<A &&>(d);		// { dg-error "ambiguous" }
+}
Index: gcc/testsuite/g++.dg/eh/cond6.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/eh/cond6.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/eh/cond6.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,43 @@
+// PR c++/49165
+// { dg-do run }
+
+extern "C" void abort ();
+
+int
+foo (bool x, int y)
+{
+  if (y < 10 && (x ? 1 : throw 1))
+    y++;
+  if (y > 20 || (x ? 1 : throw 2))
+    y++;
+  return y;
+}
+
+int
+main ()
+{
+  if (foo (true, 0) != 2
+      || foo (true, 10) != 11
+      || foo (false, 30) != 31)
+    abort ();
+  try
+    {
+      foo (false, 0);
+      abort ();
+    }
+  catch (int i)
+    {
+      if (i != 1)
+	abort ();
+    }
+  try
+    {
+      foo (false, 10);
+      abort ();
+    }
+  catch (int i)
+    {
+      if (i != 2)
+	abort ();
+    }
+}
Index: gcc/testsuite/g++.dg/eh/cond5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/eh/cond5.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/eh/cond5.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,43 @@
+// PR c++/49165
+// { dg-do run }
+
+extern "C" void abort ();
+
+int
+foo (bool x, int y)
+{
+  if (y < 10 && (x ? true : throw 1))
+    y++;
+  if (y > 20 || (x ? true : throw 2))
+    y++;
+  return y;
+}
+
+int
+main ()
+{
+  if (foo (true, 0) != 2
+      || foo (true, 10) != 11
+      || foo (false, 30) != 31)
+    abort ();
+  try
+    {
+      foo (false, 0);
+      abort ();
+    }
+  catch (int i)
+    {
+      if (i != 1)
+	abort ();
+    }
+  try
+    {
+      foo (false, 10);
+      abort ();
+    }
+  catch (int i)
+    {
+      if (i != 2)
+	abort ();
+    }
+}
Index: gcc/testsuite/g++.dg/gcov/gcov-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gcov/gcov-2.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/gcov/gcov-2.C	(.../branches/gcc-4_5-branch)
@@ -20,7 +20,7 @@
 
 void foo()
 {
-  C c;					/* count(2) */
+  C c;					/* count(1) */
   c.seti (1);				/* count(1) */
 }
 
Index: gcc/testsuite/g++.dg/init/new30.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/new30.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/init/new30.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,15 @@
+// PR c++/40975
+
+struct data_type
+{
+    // constructor required to reproduce compiler bug
+    data_type() {}
+};
+
+struct ptr_type
+{
+    // array new as default argument required to reproduce compiler bug
+    ptr_type (data_type* ptr = new data_type[1]) { delete[] ptr; }
+};
+
+ptr_type obj;
Index: gcc/testsuite/g++.dg/init/vbase1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/vbase1.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/init/vbase1.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,39 @@
+// PR c++/50618
+// { dg-do run }
+
+struct Base
+{
+    const int text;
+    Base():text(1) {}
+    Base(int aText)
+    : text(aText) {}
+};
+struct SubA : public virtual Base
+{
+protected:
+  int x;
+public:
+  SubA(int aX)
+  : x(aX) {}
+};
+class SubB : public virtual Base
+{};
+struct Diamond : public SubA, public SubB
+{
+    Diamond(int text)
+    : Base(text), SubA(5), SubB() {}
+
+    void printText()
+    {
+        if(text != 2)
+          __builtin_abort();
+        if(x!=5)
+          __builtin_abort();
+    }
+};
+
+int main(int, char**)
+{
+    Diamond x(2);
+    x.printText();
+}
Index: gcc/testsuite/g++.dg/init/new32.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/new32.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/init/new32.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,16 @@
+// PR c++/48873
+
+#include <new>
+
+struct D {
+private:
+  ~D();
+};
+
+template<class T>
+T& create();
+
+void f()
+{
+  D* dp = new (((void*) 0)) D(create<D>()); // #
+}
Index: gcc/testsuite/g++.dg/init/value9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/value9.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/init/value9.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,32 @@
+// PR c++/50793
+// { dg-do run }
+
+struct NonTrivial
+{
+  NonTrivial() { }
+};
+
+struct S
+{
+  NonTrivial nt;
+  int i;
+};
+
+int f(S s)
+{
+  s.i = 0xdeadbeef;
+  return s.i;
+}
+
+int g(S s = S())
+{
+  return s.i;
+}
+
+int main()
+{
+  f(S());  // make stack dirty
+
+  if ( g() )
+    __builtin_abort();
+}
Index: gcc/testsuite/g++.dg/torture/pr47714.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr47714.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr47714.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,16 @@
+struct A { virtual ~A () {} };
+struct B { virtual ~B () {} };
+struct C { virtual const A *foo (int) const = 0; };
+struct E : public B, public A { };
+struct F : public C
+{
+  virtual const E *foo (int) const;
+};
+void bar (int &);
+
+const E *
+F::foo (int x) const
+{
+  bar (x);
+  return __null;
+}
Index: gcc/testsuite/g++.dg/torture/pr49615.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr49615.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr49615.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-g" } */
+
+template <class T>
+static inline bool Dispatch (T* obj, void (T::*func) ())
+{
+  (obj->*func) ();
+}
+class C
+{
+  bool f (int);
+  void g ();
+};
+bool C::f (int n)
+{
+  bool b;
+  switch (n)
+    {
+      case 0:
+	  b = Dispatch (this, &C::g);
+      case 1:
+	  b = Dispatch (this, &C::g);
+    }
+}
+void C::g ()
+{
+  for (;;) { }
+}
+
Index: gcc/testsuite/g++.dg/torture/pr51344.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr51344.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr51344.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+class A;
+
+template <class T>
+class B
+{
+  friend __attribute__((cdecl)) A& operator >>(A& a, B& b)
+  {
+    return a;
+  }
+};
Index: gcc/testsuite/g++.dg/torture/pr50189.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr50189.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr50189.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,120 @@
+// { dg-do run }
+
+extern "C" void abort (void);
+class CCUTILS_KeyedScalarLevelPosition
+{
+public:
+
+    typedef enum
+    {
+        UNINITED = 0,
+        AT_BEGIN = 1,
+        AT_END = 2,
+        AT_KEY = 3
+
+    } position_t;
+
+    bool is_init() const
+    { return(m_timestamp != UNINITED); }
+
+    bool is_at_begin() const
+    { return(m_timestamp == AT_BEGIN); }
+
+    position_t get_state() const
+    {
+        return((m_timestamp >= AT_KEY)
+             ? AT_KEY
+             : ((position_t)m_timestamp));
+    }
+
+    void set_at_begin()
+    { m_timestamp = AT_BEGIN; }
+
+    unsigned int get_index() const
+    { return(m_index); }
+
+    void set_pos(unsigned int a_index, unsigned int a_timestmap)
+    {
+        m_index = a_index;
+        m_timestamp = a_timestmap;
+    }
+
+    bool check_pos(unsigned int a_num_entries, unsigned int a_timestamp) const
+    {
+        if (get_state() != AT_KEY)
+            return(false);
+
+        if (m_timestamp != a_timestamp)
+            return(false);
+
+        return(m_index < a_num_entries);
+    }
+
+    void set_not_init()
+    { m_timestamp = 0; }
+
+private:
+
+    unsigned int m_timestamp;
+    unsigned int m_index;
+
+};
+
+class CCUTILS_KeyedScalarPosition
+{
+public:
+
+    CCUTILS_KeyedScalarLevelPosition m_L1;
+    CCUTILS_KeyedScalarLevelPosition m_L2;
+};
+
+class baz
+{
+public:
+    int *n[20];
+    unsigned int m_cur_array_len;
+    unsigned int m_timestamp;
+
+    unsigned int _get_timestamp() const
+    { return(m_timestamp); }
+
+    bool _check_L1_pos(const CCUTILS_KeyedScalarPosition &a_position) const
+    {
+        return(a_position.m_L1.check_pos(
+                   m_cur_array_len, _get_timestamp()));
+    }
+
+    void *next (CCUTILS_KeyedScalarPosition &);
+};
+
+void * baz::next (CCUTILS_KeyedScalarPosition &a_position)
+{
+    if (a_position.m_L1.is_at_begin() || (!a_position.m_L1.is_init()))
+    {
+        a_position.m_L1.set_pos(0, _get_timestamp());
+        a_position.m_L2.set_at_begin();
+    }
+    else if (!_check_L1_pos(a_position))
+        return(0);
+
+    return n[a_position.m_L1.get_index ()];
+}
+
+int main (int, char **)
+{
+    baz obj;
+    CCUTILS_KeyedScalarPosition a_pos;
+    void *ret;
+    int n[5];
+    
+    obj.n[0] = n;
+    obj.m_cur_array_len = 1;
+    obj.m_timestamp = 42;
+    
+    a_pos.m_L1.set_pos (0, 42);
+    
+    ret = obj.next (a_pos);
+    if (ret == 0)
+      abort ();
+    return 0;
+}
Index: gcc/testsuite/g++.dg/torture/pr49115.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr49115.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr49115.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,25 @@
+// { dg-do run }
+
+extern "C" void abort (void);
+struct MyException {};
+struct Data {
+    int nr;
+    Data() : nr(66) {}
+};
+Data __attribute__((noinline,noclone)) getData(int i)
+{
+  if (i) throw MyException();
+  Data data;
+  data.nr = i;
+  return data;
+}
+int main(int, char **)
+{
+  Data data;
+  try {
+      data = getData(1);
+  } catch (MyException& e) {
+      if (data.nr != 66)
+	abort ();
+  }
+}
Index: gcc/testsuite/g++.dg/torture/pr49039.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr49039.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr49039.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,76 @@
+// PR tree-optimization/49039
+// { dg-do run }
+
+template <class T1, class T2>
+struct pair
+{
+  T1 first;
+  T2 second;
+  pair (const T1 & a, const T2 & b):first (a), second (b) {}
+};
+
+template <class T1, class T2>
+inline pair <T1, T2>
+make_pair (T1 x, T2 y)
+{
+  return pair <T1, T2> (x, y);
+}
+
+typedef __SIZE_TYPE__ size_t;
+struct S
+{
+  const char *Data;
+  size_t Length;
+  static size_t min (size_t a, size_t b) { return a < b ? a : b; }
+  static size_t max (size_t a, size_t b) { return a > b ? a : b; }
+  S () :Data (0), Length (0) { }
+  S (const char *Str) : Data (Str), Length (__builtin_strlen (Str)) {}
+  S (const char *data, size_t length) : Data (data), Length (length) {}
+  bool empty () const { return Length == 0; }
+  size_t size () const { return Length; }
+  S slice (size_t Start, size_t End) const
+  {
+    Start = min (Start, Length);
+    End = min (max (Start, End), Length);
+    return S (Data + Start, End - Start);
+  }
+  pair <S, S> split (char Separator) const
+  {
+    size_t Idx = find (Separator);
+    if (Idx == ~size_t (0))
+      return make_pair (*this, S ());
+    return make_pair (slice (0, Idx), slice (Idx + 1, ~size_t (0)));
+  }
+  size_t find (char C, size_t From = 0) const
+  {
+    for (size_t i = min (From, Length), e = Length; i != e; ++i)
+      if (Data[i] == C)
+	return i;
+    return ~size_t (0);
+  }
+};
+
+void
+Test (const char *arg)
+{
+  S Desc (arg);
+  while (!Desc.empty ())
+    {
+      pair <S, S> Split = Desc.split ('-');
+      S Token = Split.first;
+      Desc = Split.second;
+      if (Token.empty ())
+	continue;
+      Split = Token.split (':');
+      S Specifier = Split.first;
+      if (Specifier.empty ())
+	__builtin_abort ();
+    }
+}
+
+int
+main ()
+{
+  Test ("-");
+  return 0;
+}
Index: gcc/testsuite/g++.dg/torture/pr49644.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr49644.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr49644.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,17 @@
+// PR c/49644
+// { dg-do run }
+
+extern "C" void abort ();
+
+int
+main ()
+{
+  _Complex double a[12], *c = a, s = 3.0 + 1.0i;
+  double b[12] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, *d = b;
+  int i;
+  for (i = 0; i < 6; i++)
+    *c++ = *d++ * s;
+  if (c != a + 6 || d != b + 6)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/ipa/pr51759.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr51759.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr51759.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-O2"  } */
+
+extern "C" void abort (void);
+struct S
+{
+  void __attribute__((noinline)) set(unsigned val)
+    {
+      data = val;
+      if (data != val)
+        abort ();
+    }
+  int pad0;
+  unsigned pad1 : 8;
+  unsigned data : 24;
+  int pad2;
+};
+int main()
+{
+  S s;
+  s.pad2 = -1;
+  s.set(0);
+  if (s.pad2 != -1)
+    abort ();
+}
+
Index: gcc/testsuite/g++.dg/dfp/mangle-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/dfp/mangle-1.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/dfp/mangle-1.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,40 @@
+// { dg-do compile }
+
+// Mangling of classes from std::decimal are special-cased.
+// Derived from g++.dg/abi/mangle13.C.
+
+namespace std {
+  namespace decimal {
+    class decimal64 {
+      public:
+	typedef float __decfloat64 __attribute__ ((mode (DD)));
+	explicit decimal64 (float __r):__val (__r) {}
+      private:
+	__decfloat64 __val;
+    };
+  }
+}
+
+struct A {
+  template <typename T> std::decimal::decimal64 f ();
+  std::decimal::decimal64 operator+();
+  operator std::decimal::decimal64 ();
+  template <typename T>
+  std::decimal::decimal64 operator-();
+};
+
+typedef std::decimal::decimal64 (A::*P)();
+
+template <P> struct S {};
+
+template <typename T> void g (S<&T::template f<std::decimal::decimal64> >) {}
+template <typename T> void g (S<&T::operator+ >) {}
+template <typename T> void g (S<&T::operator std::decimal::decimal64>) {}
+template <typename T> void g (S<&T::template operator- <std::decimal::decimal64> >) {}
+
+template void g<A> (S<&A::f<std::decimal::decimal64> >);
+template void g<A> (S<&A::operator+>);
+template void g<A> (S<&A::operator std::decimal::decimal64>);
+
+// { dg-final { scan-assembler "\n?_Z1gI1AEv1SIXadsrT_1fIDdEEE\[: \t\n\]" } }
+// { dg-final { scan-assembler "\n?_Z1gI1AEv1SIXadsrT_plEE\[: \t\n\]" } }
Index: gcc/testsuite/g++.dg/dfp/mangle-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/dfp/mangle-2.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/dfp/mangle-2.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,28 @@
+// { dg-do compile }
+
+// Mangling of classes from std::decimal are special-cased.
+// Derived from g++.dg/abi/mangle15.C.
+
+namespace std {
+  namespace decimal {
+    class decimal64 {
+      public:
+	typedef float __decfloat64 __attribute__ ((mode (DD)));
+	explicit decimal64 (float __r):__val (__r) {}
+      private:
+	__decfloat64 __val;
+    };
+  }
+}
+
+struct A {
+  template <typename T> std::decimal::decimal64 f ();
+};
+
+typedef std::decimal::decimal64 (A::*P)();
+
+template <P> struct S {};
+
+void g (S<&A::f<std::decimal::decimal64> >) {}
+
+// { dg-final { scan-assembler "\n?_Z1g1SIXadL_ZN1A1fIDdEEDdvEEE\[: \t\n\]" } }
Index: gcc/testsuite/g++.dg/dfp/44473-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/dfp/44473-1.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/dfp/44473-1.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,122 @@
+/* { dg-do assemble } */
+
+/* Minimized from the testcase in PR c++/44473; mangling of decimal types
+   did not include CV qualifiers. */
+
+namespace std
+{
+  namespace decimal
+  {
+    class decimal32
+    {
+    public:
+      typedef float __decfloat32 __attribute__ ((mode (SD)));
+      explicit decimal32 (float __r):__val (__r) {}
+    private:
+      __decfloat32 __val;
+    };
+  };
+
+  template <typename _BI1, typename _BI2>
+  _BI2 copy_backward (_BI1 __first, _BI2 __result);
+}
+
+namespace __gnu_cxx
+{
+  template <typename _Iterator, typename _Container>
+  class __normal_iterator
+  {
+  public:
+    explicit __normal_iterator (const _Iterator & __i) {}
+    const _Iterator & base () const {}
+  };
+
+  template <typename _IteratorL, typename _IteratorR, typename _Container>
+  bool operator== (const __normal_iterator <_IteratorL, _Container> &__lhs,
+		   const __normal_iterator <_IteratorR, _Container> &__rhs)
+  {
+    return __lhs.base () == __rhs.base ();
+  }
+
+  template <typename _Tp>
+  class new_allocator
+  {
+  public:
+    typedef _Tp *pointer;
+    typedef const _Tp *const_pointer;
+    template <typename _Tp1>
+    struct rebind
+    {
+      typedef new_allocator <_Tp1> other;
+    };
+  };
+}
+
+namespace std
+{
+  template <typename _Tp>
+  class allocator:public __gnu_cxx::new_allocator <_Tp> {};
+
+  template <typename _Tp, typename _Alloc>
+  struct _Vector_base
+  {
+    typedef typename _Alloc::template rebind <_Tp>::other _Tp_alloc_type;
+    struct _Vector_impl:public _Tp_alloc_type
+    {
+      typename _Tp_alloc_type::pointer _M_finish;
+    };
+  public:  _Vector_impl _M_impl;
+  };
+
+  template <typename _Tp, typename _Alloc = std::allocator <_Tp> >
+  class vector:protected _Vector_base <_Tp, _Alloc>
+  {
+    typedef _Vector_base <_Tp, _Alloc> _Base;
+    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
+  public:
+    typedef _Tp value_type;
+    typedef typename _Tp_alloc_type::pointer pointer;
+    typedef typename _Tp_alloc_type::const_pointer const_pointer;
+    typedef __gnu_cxx::__normal_iterator <pointer, vector> iterator;
+    typedef __gnu_cxx::__normal_iterator <const_pointer, vector>
+      const_iterator;
+    const_iterator begin () const;
+    iterator end ()
+    {
+      return iterator (this->_M_impl._M_finish);
+    }
+    const_iterator end () const
+    {
+      return const_iterator (this->_M_impl._M_finish);
+    }
+    bool empty () const
+    {
+      return begin () == end ();
+    }
+    void push_back (const value_type & __x)
+    {
+      _M_insert_aux (end ());
+    }
+    void _M_insert_aux (iterator __position);
+  };
+
+  template <typename _Tp, typename _Alloc>
+  void vector <_Tp, _Alloc>::_M_insert_aux (iterator __position)
+  {
+    std::copy_backward (__position.base (), this->_M_impl._M_finish - 1);
+  }
+}
+
+std::vector <std::decimal::decimal32> vec;
+
+int
+foo ()
+{
+  return (vec.empty ()) ? 1 : 0;
+}
+
+bool
+bar ()
+{
+  vec.push_back (std::decimal::decimal32 (0));
+}
Index: gcc/testsuite/g++.dg/dfp/mangle-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/dfp/mangle-3.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/dfp/mangle-3.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,28 @@
+// { dg-do compile }
+
+// Mangling of classes from std::decimal are special-cased.
+// Derived from g++.dg/abi/mangle20-1.C.
+
+namespace std {
+  namespace decimal {
+    class decimal64 {
+      public:
+	typedef float __decfloat64 __attribute__ ((mode (DD)));
+	explicit decimal64 (int __r):__val (__r) {}
+      private:
+	__decfloat64 __val;
+    };
+  }
+}
+
+template <int I> void f(std::decimal::decimal64 (*)[2]) {}
+template <int I> void g(std::decimal::decimal64 (*)[I+2]) {}
+
+static const std::decimal::decimal64 I(1);
+static const std::decimal::decimal64 J(2);
+
+template void f<1>(std::decimal::decimal64 (*)[2]);
+template void g<1>(std::decimal::decimal64 (*)[3]);
+
+//  { dg-final { scan-assembler "\n_?_Z1fILi1EEvPA2_Dd\[: \t\n\]" } }
+//  { dg-final { scan-assembler "\n_?_Z1gILi1EEvPAplT_Li2E_Dd\[: \t\n\]" } }
Index: gcc/testsuite/g++.dg/dfp/44473-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/dfp/44473-2.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/dfp/44473-2.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,25 @@
+// { dg-do compile }
+
+// Mangling of classes from std::decimal are special-cased.
+
+namespace std {
+  namespace decimal {
+    class decimal64 {
+      public:
+	typedef float __decfloat64 __attribute__ ((mode (DD)));
+	explicit decimal64 (int __r):__val (__r) {}
+      private:
+	__decfloat64 __val;
+    };
+  }
+}
+
+int bar (const std::decimal::decimal64 & x) { }
+
+int foo ()
+{
+  std::decimal::decimal64 x(0);
+  bar (x);
+}
+
+// { dg-final { scan-assembler "_Z3barRKDd:" } }
Index: gcc/testsuite/g++.dg/dfp/mangle-4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/dfp/mangle-4.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/dfp/mangle-4.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,35 @@
+// { dg-do compile }
+
+// Mangling of classes from std::decimal are special-cased.
+// Derived from g++.dg/abi/mangle30.C.
+
+namespace std {
+  namespace decimal {
+    class decimal64 {
+      public:
+	typedef float __decfloat64 __attribute__ ((mode (DD)));
+	explicit decimal64 (int __r):__val (__r) {}
+      private:
+	__decfloat64 __val;
+    };
+  }
+}
+
+struct A
+{
+  template <class T>
+  struct B
+  {
+    typedef T myT;
+  };
+};
+
+template <class T>
+void f (T t, typename T::template B<std::decimal::decimal64>::myT u, typename T::template B<int>::myT v);
+
+void foo ()
+{
+  f (A(), std::decimal::decimal64(0), 1);
+}
+
+// { dg-final { scan-assembler "_Z1fI1AEvT_NS1_1BIDdE3myTENS2_IiE3myTE" } }
Index: gcc/testsuite/g++.dg/dfp/mangle-5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/dfp/mangle-5.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/dfp/mangle-5.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,29 @@
+// { dg-do compile }
+
+// Mangling of classes from std::decimal are special-cased.
+// Derived from g++.dg/abi/mangle35.C.
+
+namespace std {
+  namespace decimal {
+    class decimal128 {
+      public:
+	typedef float __decfloat128 __attribute__ ((mode (TD)));
+	explicit decimal128 (int __r):__val (__r) {}
+      private:
+	__decfloat128 __val;
+    };
+  }
+}
+
+template<void (*)()> struct A {};
+
+template<typename> void foo();
+
+template<typename T> A<foo<T> > bar();
+
+void baz()
+{
+  bar<std::decimal::decimal128>();
+}
+
+// { dg-final { scan-assembler "_Z3barIDeE1AIX3fooIT_EEEv" } }
Index: gcc/testsuite/g++.dg/template/nontype23.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/nontype23.C	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/g++.dg/template/nontype23.C	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,9 @@
+// PR c++/48936
+
+template <bool C> int foo (void);
+template <class T> struct S
+{
+  static const unsigned int a = sizeof (T);
+  enum { c = sizeof (foo <(a == 0)> ()) };
+};
+S<int> x;
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_5-branch)
@@ -960,8 +960,8 @@
 	    check_runtime_nocache sse_os_support_available {
 		int main ()
 		{
-		    __asm__ volatile ("movss %xmm2,%xmm1");
-		    return 0;
+		  asm volatile ("movss %xmm2,%xmm1");
+		  return 0;
 		}
 	    } "-msse"
 	} else {
@@ -970,6 +970,29 @@
     }]
 }
 
+# Return 1 if the target OS supports running AVX executables, 0
+# otherwise.  Cache the result.
+
+proc check_avx_os_support_available { } {
+    return [check_cached_effective_target avx_os_support_available {
+	# If this is not the right target then we can skip the test.
+	if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {
+	    expr 0
+	} else {
+	    # Check that OS has AVX and SSE saving enabled.
+	    check_runtime_nocache avx_os_support_available {
+		int main ()
+		{
+		  unsigned int eax, edx;
+
+		  asm ("xgetbv" : "=a" (eax), "=d" (edx) : "c" (0));
+		  return (eax & 6) != 6;
+		}
+	    } ""
+	}
+    }]
+}
+
 # Return 1 if the target supports executing SSE instructions, 0
 # otherwise.  Cache the result.
 
@@ -1064,7 +1087,8 @@
 
 proc check_effective_target_avx_runtime { } {
     if { [check_effective_target_avx]
-	 && [check_avx_hw_available] } {
+	 && [check_avx_hw_available]
+	 && [check_avx_os_support_available] } {
 	return 1
     }
     return 0
Index: gcc/testsuite/gfortran.dg/namelist_72.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/namelist_72.f	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/namelist_72.f	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,33 @@
+! { dg-do run }
+!
+! PR fortran/49791
+!
+! Contributed by Elliott Sales de Andrade
+!
+      program namelist_test
+
+      dimension xpos(5000), ypos(5000)
+      namelist /geometry/ xpos, ypos
+
+      xpos = -huge(xpos)
+      ypos = -huge(ypos)
+
+      open(unit=4,file='geometry.in')
+      write(4,'(a)') '$geometry'
+      write(4,'(a)') ' xpos(1)= 0.00, 0.10, 0.20, 0.30, 0.40,'
+      write(4,'(a)') ' ypos(1)= 0.50, 0.60, 0.70, 0.80, 0.90,'
+      write(4,'(a)') '$end'
+
+      close(4)
+
+      open (unit=4,file='geometry.in',status='old',form='formatted')
+      read (4,geometry)
+      close(4, status='delete')
+
+      !print *, 'xpos', xpos(1:10), 'ypos', ypos(1:10)
+
+      if (any (xpos(1:5) /= [0.00, 0.10, 0.20, 0.30, 0.40]))call abort()
+      if (any (ypos(1:5) /= [0.50, 0.60, 0.70, 0.80, 0.90]))call abort()
+      if (any (xpos(6:) /= -huge(xpos))) call abort ()
+      if (any (ypos(6:) /= -huge(ypos))) call abort ()
+      end
Index: gcc/testsuite/gfortran.dg/alloc_comp_initializer_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/alloc_comp_initializer_3.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/alloc_comp_initializer_3.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+!
+! PR fortran/50050
+! Out of bound whilst releasing initialization of allocate object
+!
+! Contributed by someone <sigurdkn@gmail.com>
+
+program bug
+  implicit none
+  type foo
+    integer, pointer :: a => null()
+  end type
+  type(foo), dimension(:,:), allocatable :: data
+  allocate(data(1:1,1)) ! This used to lead to an ICE
+end program
Index: gcc/testsuite/gfortran.dg/allocate_error_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocate_error_3.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocate_error_3.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+!
+! PR 49708: [4.5/4.6/4.7 Regression] ICE with allocate and no dimensions
+!
+! Contributed by <fnordxyz@yahoo.com>
+
+  real, pointer :: x(:)
+  allocate(x)            ! { dg-error "Array specification required" }
+end 
Index: gcc/testsuite/gfortran.dg/namelist_73.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/namelist_73.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/namelist_73.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! PR fortran/50109
+!
+! Contributed by Jim Hanson
+!
+      program namelist_test
+
+      integer nfp
+      namelist /indata/ nfp
+
+      nfp = 99
+      open(unit=4, status='scratch')
+      write(4,'(a)') '$indata'
+      write(4,'(a)') 'NFP = 5,'
+      write(4,'(a)') "!  "
+      write(4,'(a)') "! "
+      write(4,'(a)') "!  "
+      write(4,'(a)') '/'
+
+      rewind(4)
+      read (4,nml=indata)
+      close(4)
+
+!      write(*,*) nfp
+      if (nfp /= 5) call abort()
+
+      end
Index: gcc/testsuite/gfortran.dg/class_23.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/class_23.f03	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/class_23.f03	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+!
+! PR 42051: [OOP] ICE on array-valued function with CLASS formal argument
+!
+! Original test case by Damian Rouson <damian@rouson.net>
+! Modified by Janus Weil <janus@gcc.gnu.org>
+
+  type grid
+  end type 
+
+contains
+
+  function return_x(this) result(this_x)
+    class(grid) :: this
+    real  ,dimension(1) :: this_x
+  end function
+
+  subroutine output()
+    type(grid) :: mesh
+    real ,dimension(1) :: x
+    x = return_x(mesh)
+  end subroutine
+
+end
Index: gcc/testsuite/gfortran.dg/initialization_28.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/initialization_28.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/initialization_28.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+!
+! PR fortran/50163
+!
+! Contributed by Philip Mason
+!
+character(len=2) :: xx ='aa'
+integer :: iloc=index(xx,'bb') ! { dg-error "has not been declared or is a variable" }
+end
Index: gcc/testsuite/gfortran.dg/proc_decl_27.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/proc_decl_27.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/proc_decl_27.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+!
+! PR 50659: [4.5/4.6/4.7 Regression] [F03] ICE on invalid with procedure interface
+!
+! Contributed by Andrew Benson <abenson@caltech.edu>
+
+module m1
+  integer :: arrSize
+end module
+
+module m2
+contains
+  function Proc (arg)
+    use m1
+    double precision, dimension(arrSize) :: proc
+    double precision :: arg
+  end function
+end
+
+  use m2
+  implicit none
+  procedure(Proc) :: Proc_Get
+end
+
+! { dg-final { cleanup-modules "m1 m2" } }
Index: gcc/testsuite/gfortran.dg/pr50875.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr50875.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr50875.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,39 @@
+! { dg-do compile { target { i?86-*-* x86_64-*-* } } }
+! { dg-options "-O3 -mavx" }
+!
+! PR fortran/50875.f90
+
+module test
+
+  implicit none
+
+  integer, parameter :: dp=kind(1.d0)
+
+  integer :: P = 2
+
+  real(kind=dp), allocatable :: real_array_A(:),real_array_B(:,:)
+  complex(kind=dp), allocatable :: cmplx_array_A(:) 
+
+contains
+
+  subroutine routine_A
+
+    integer :: i
+
+    allocate(cmplx_array_A(P),real_array_B(P,P),real_array_A(P))
+
+    real_array_A = 1
+    real_array_B = 1
+
+    do i = 1, p
+       cmplx_array_A = cmplx(real_array_B(:,i),0.0_dp,dp)
+       cmplx_array_A = cmplx_array_A * exp(cmplx(0.0_dp,real_array_A+1))
+    end do
+
+    deallocate(cmplx_array_A,real_array_B,real_array_A)
+
+  end subroutine routine_A
+
+end module test
+
+! { dg-final { cleanup-modules "test" } }
Index: gcc/testsuite/gfortran.dg/widechar_compare_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/widechar_compare_1.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/widechar_compare_1.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,10 @@
+! { dg-do run }
+! PR 50192 - on little-endian systems, this used to fail.
+program main
+  character(kind=4,len=2) :: c1, c2
+  c1 = 4_' '
+  c2 = 4_' '
+  c1(1:1) = transfer(257, mold=c1(1:1))
+  c2(1:1) = transfer(64, mold=c2(1:1))
+  if (c1 < c2) call abort
+end program main
Index: gcc/testsuite/gfortran.dg/pointer_comp_init_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_comp_init_1.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_comp_init_1.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,30 @@
+! { dg-do compile }
+!
+! PR fortran/50050
+! ICE whilst trying to access NULL shape.
+
+! Reduced from the FoX library http://www1.gly.bris.ac.uk/~walker/FoX/
+! Contributed by Andrew Benson <abenson@its.caltech.edu>
+
+module m_common_attrs
+  implicit none
+
+  type dict_item
+  end type dict_item
+
+  type dict_item_ptr
+     type(dict_item), pointer :: d => null()
+  end type dict_item_ptr
+
+contains
+
+  subroutine add_item_to_dict()
+    type(dict_item_ptr), pointer :: tempList(:)
+    integer :: n
+
+    allocate(tempList(0:n+1)) 
+  end subroutine add_item_to_dict
+
+end module m_common_attrs
+
+! { dg-final { cleanup-modules "m_common_attrs" } }
Index: gcc/testsuite/gfortran.dg/common_16.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/common_16.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/common_16.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-options "-pedantic -mdalign" { target sh*-*-* } }
+!
+! PR fortran/50273
+!
+subroutine test()
+   character :: a
+   integer   :: b
+   character :: c
+   common /global_var/ a, b, c ! { dg-warning "Padding of 3 bytes required before 'b' in COMMON" }
+   print *, a, b, c
+end subroutine test
Index: gcc/testsuite/gfortran.dg/operator_7.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/operator_7.f90	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/testsuite/gfortran.dg/operator_7.f90	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,27 @@
+! { dg-do compile }
+! PR fortran/45786 - operators were not correctly marked as public
+! if the alternative form was used.
+! Test case contributed by Neil Carlson.
+module foo_type
+  private
+  public :: foo, operator(==)
+  type :: foo
+    integer :: bar
+  end type
+  interface operator(.eq.)
+    module procedure eq_foo
+  end interface
+contains
+  logical function eq_foo (a, b)
+    type(foo), intent(in) :: a, b
+    eq_foo = (a%bar == b%bar)
+  end function
+end module
+
+ subroutine use_it (a, b)
+  use foo_type
+  type(foo) :: a, b
+  print *, a == b
+end subroutine
+
+! { dg-final { cleanup-modules "foo_type" } }
Index: gcc/cp/typeck.c
===================================================================
--- a/src/gcc/cp/typeck.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/typeck.c	(.../branches/gcc-4_5-branch)
@@ -4297,6 +4297,7 @@
 		{
 		case MULT_EXPR:
 		case TRUNC_DIV_EXPR:
+		  op1 = save_expr (op1);
 		  imag = build2 (resultcode, real_type, imag, op1);
 		  /* Fall through.  */
 		case PLUS_EXPR:
@@ -4315,6 +4316,7 @@
 	      switch (code)
 		{
 		case MULT_EXPR:
+		  op0 = save_expr (op0);
 		  imag = build2 (resultcode, real_type, op0, imag);
 		  /* Fall through.  */
 		case PLUS_EXPR:
@@ -5672,8 +5674,18 @@
       && reference_related_p (TREE_TYPE (type), intype)
       && (c_cast_p || at_least_as_qualified_p (TREE_TYPE (type), intype)))
     {
-      expr = build_typed_address (expr, type);
-      return convert_from_reference (expr);
+      /* Handle the lvalue case here by casting to lvalue reference and
+	 then changing it to an rvalue reference.  Casting an xvalue to
+	 rvalue reference will be handled by the main code path.  */
+      tree lref = cp_build_reference_type (TREE_TYPE (type), false);
+      result = (perform_direct_initialization_if_possible
+		(lref, expr, c_cast_p, complain));
+      result = cp_fold_convert (type, result);
+      /* Make sure we don't fold back down to a named rvalue reference,
+	 because that would be an lvalue.  */
+      if (DECL_P (result))
+	result = build1 (NON_LVALUE_EXPR, type, result);
+      return convert_from_reference (result);
     }
 
   orig = expr;
Index: gcc/cp/init.c
===================================================================
--- a/src/gcc/cp/init.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/init.c	(.../branches/gcc-4_5-branch)
@@ -1460,7 +1460,12 @@
 	 zero out the object first.  */
       else if (TYPE_NEEDS_CONSTRUCTING (type))
 	{
-	  init = build_zero_init (type, NULL_TREE, /*static_storage_p=*/false);
+	  tree field_size = NULL_TREE;
+	  if (exp != true_exp && CLASSTYPE_AS_BASE (type) != type)
+	    /* Don't clobber already initialized virtual bases.  */
+	    field_size = TYPE_SIZE (CLASSTYPE_AS_BASE (type));
+	  init = build_zero_init_1 (type, NULL_TREE, /*static_storage_p=*/false,
+				    field_size);
 	  init = build2 (INIT_EXPR, type, exp, init);
 	  finish_expr_stmt (init);
 	  /* And then call the constructor.  */
Index: gcc/cp/class.c
===================================================================
--- a/src/gcc/cp/class.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/class.c	(.../branches/gcc-4_5-branch)
@@ -681,21 +681,10 @@
    the abstract.  */
 
 void
-set_linkage_according_to_type (tree type, tree decl)
+set_linkage_according_to_type (tree type ATTRIBUTE_UNUSED, tree decl)
 {
-  /* If TYPE involves a local class in a function with internal
-     linkage, then DECL should have internal linkage too.  Other local
-     classes have no linkage -- but if their containing functions
-     have external linkage, it makes sense for DECL to have external
-     linkage too.  That will allow template definitions to be merged,
-     for example.  */
-  if (no_linkage_check (type, /*relaxed_p=*/true))
-    {
-      TREE_PUBLIC (decl) = 0;
-      DECL_INTERFACE_KNOWN (decl) = 1;
-    }
-  else
-    TREE_PUBLIC (decl) = 1;
+  TREE_PUBLIC (decl) = 1;
+  determine_visibility (decl);
 }
 
 /* Create a VAR_DECL for a primary or secondary vtable for CLASS_TYPE.
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-4_5-branch)
@@ -12877,8 +12877,17 @@
 	cleanup = call;
     }
 
+  /* build_delete sets the location of the destructor call to the
+     current location, even though the destructor is going to be
+     called later, at the end of the current scope.  This can lead to
+     a "jumpy" behaviour for users of debuggers when they step around
+     the end of the block.  So let's unset the location of the
+     destructor call instead.  */
+  if (cleanup != NULL && EXPR_P (cleanup))
+    SET_EXPR_LOCATION (cleanup, UNKNOWN_LOCATION);
   return cleanup;
 }
+
 
 /* When a stmt has been parsed, this function is called.  */
 
Index: gcc/cp/method.c
===================================================================
--- a/src/gcc/cp/method.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/method.c	(.../branches/gcc-4_5-branch)
@@ -374,6 +374,7 @@
       DECL_CONTEXT (x) = thunk_fndecl;
       SET_DECL_RTL (x, NULL_RTX);
       DECL_HAS_VALUE_EXPR_P (x) = 0;
+      TREE_ADDRESSABLE (x) = 0;
       t = x;
     }
   a = nreverse (t);
Index: gcc/cp/tree.c
===================================================================
--- a/src/gcc/cp/tree.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/tree.c	(.../branches/gcc-4_5-branch)
@@ -1732,7 +1732,11 @@
       tree u;
 
       if (TREE_CODE (TREE_OPERAND (t, 1)) == AGGR_INIT_EXPR)
-	u = build_cplus_new (TREE_TYPE (t), TREE_OPERAND (t, 1));
+	{
+	  u = build_cplus_new (TREE_TYPE (t), TREE_OPERAND (t, 1));
+	  if (AGGR_INIT_ZERO_FIRST (TREE_OPERAND (t, 1)))
+	    AGGR_INIT_ZERO_FIRST (TREE_OPERAND (u, 1)) = true;
+	}
       else
 	u = build_target_expr_with_type (TREE_OPERAND (t, 1), TREE_TYPE (t));
 
@@ -2954,7 +2958,8 @@
   if (!TREE_SIDE_EFFECTS (exp))
     init_expr = NULL_TREE;
   else if (!real_lvalue_p (exp)
-	   || !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (exp)))
+	   || (!TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (exp))
+	       && !TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (exp))))
     {
       init_expr = get_target_expr (exp);
       exp = TARGET_EXPR_SLOT (init_expr);
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,79 @@
+2012-01-19  Kai Tietz  <ktietz@redhat.com>
+
+	PR c++/51344
+	* decl2.c (save_template_attributes): Use merge_attributes
+	instead of chaining up via TREE_CHAIN.
+
+2011-12-20  Dodji Seketeli  <dodji@redhat.com>
+
+	PR debug/49951
+	* decl.c (cxx_maybe_build_cleanup): Don't set location of the call
+	to the destructor.
+
+2011-12-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51406
+	PR c++/51161
+	* typeck.c (build_static_cast_1): Fix cast of lvalue to
+	base rvalue reference.
+
+2011-10-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50793
+	* tree.c (bot_manip): Propagate AGGR_INIT_ZERO_FIRST.
+
+2011-10-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50618
+	* init.c (expand_aggr_init_1): Don't zero-initialize virtual
+	bases of a base subobject.
+
+2011-10-11  Janis Johnson  <janisjo@codesourcery.com>
+
+	PR c++/44473
+	* mangle.c (write_type): Handle CV qualifiers for decimal classes.
+
+2011-07-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-07-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/49644
+	* typeck.c (cp_build_binary_op): For MULT_EXPR and TRUNC_DIV_EXPR with
+	one non-complex and one complex argument, call save_expr on both
+	operands.
+
+2011-06-23  Jason Merrill  <jason@redhat.com>
+
+	PR c++/49440
+	* class.c (set_linkage_according_to_type): Hand off to
+	determine_visibility.
+
+2011-05-31  Duncan Sands  <baldrick@free.fr>
+
+	Backported from 4.6 branch
+	2011-03-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/47714
+	* method.c (use_thunk): Clear addressable flag of thunk arguments.
+
+2011-05-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/48873
+	* tree.c (stabilize_expr): Don't make gratuitous copies of classes.
+
+2011-05-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/48936
+	* decl2.c (mark_used): Instantiate constant variables even
+	in unevaluated context.
+
+2011-04-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/48046
+	* parser.c (cp_parser_diagnose_invalid_type_name): Commit
+	to tentative parse sooner.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: gcc/cp/decl2.c
===================================================================
--- a/src/gcc/cp/decl2.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/decl2.c	(.../branches/gcc-4_5-branch)
@@ -1189,9 +1189,9 @@
 
   old_attrs = *q;
 
-  /* Place the late attributes at the beginning of the attribute
+  /* Merge the late attributes at the beginning with the attribute
      list.  */
-  TREE_CHAIN (tree_last (late_attrs)) = *q;
+  late_attrs = merge_attributes (late_attrs, *q);
   *q = late_attrs;
 
   if (!DECL_P (*decl_p) && *decl_p == TYPE_MAIN_VARIANT (*decl_p))
@@ -3991,8 +3991,6 @@
 void
 mark_used (tree decl)
 {
-  HOST_WIDE_INT saved_processing_template_decl = 0;
-
   /* If DECL is a BASELINK for a single function, then treat it just
      like the DECL for the function.  Otherwise, if the BASELINK is
      for an overloaded function, we don't know which function was
@@ -4029,9 +4027,6 @@
       error ("used here");
       return;
     }
-  /* If we don't need a value, then we don't need to synthesize DECL.  */
-  if (cp_unevaluated_operand != 0)
-    return;
 
   /* We can only check DECL_ODR_USED on variables or functions with
      DECL_LANG_SPECIFIC set, and these are also the only decls that we
@@ -4059,9 +4054,10 @@
      DECL.  However, if DECL is a static data member initialized with
      a constant, we need the value right now because a reference to
      such a data member is not value-dependent.  */
-  if (TREE_CODE (decl) == VAR_DECL
-      && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl)
-      && DECL_CLASS_SCOPE_P (decl))
+  if (DECL_INTEGRAL_CONSTANT_VAR_P (decl)
+      && !DECL_INITIAL (decl)
+      && DECL_LANG_SPECIFIC (decl)
+      && DECL_TEMPLATE_INSTANTIATION (decl))
     {
       /* Don't try to instantiate members of dependent types.  We
 	 cannot just use dependent_type_p here because this function
@@ -4071,12 +4067,14 @@
       if (CLASSTYPE_TEMPLATE_INFO ((DECL_CONTEXT (decl)))
 	  && uses_template_parms (CLASSTYPE_TI_ARGS (DECL_CONTEXT (decl))))
 	return;
-      /* Pretend that we are not in a template, even if we are, so
-	 that the static data member initializer will be processed.  */
-      saved_processing_template_decl = processing_template_decl;
-      processing_template_decl = 0;
+      instantiate_decl (decl, /*defer_ok=*/false,
+			/*expl_inst_class_mem_p=*/false);
     }
 
+  /* If we don't need a value, then we don't need to synthesize DECL.  */
+  if (cp_unevaluated_operand != 0)
+    return;
+
   if (processing_template_decl)
     return;
 
@@ -4149,8 +4147,6 @@
        need.  Therefore, we always try to defer instantiation.  */
     instantiate_decl (decl, /*defer_ok=*/true,
 		      /*expl_inst_class_mem_p=*/false);
-
-  processing_template_decl = saved_processing_template_decl;
 }
 
 #include "gt-cp-decl2.h"
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-4_5-branch)
@@ -2333,6 +2333,7 @@
 				      location_t location)
 {
   tree decl, old_scope;
+  cp_parser_commit_to_tentative_parse (parser);
   /* Try to lookup the identifier.  */
   old_scope = parser->scope;
   parser->scope = scope;
@@ -2423,7 +2424,6 @@
       else
 	gcc_unreachable ();
     }
-  cp_parser_commit_to_tentative_parse (parser);
 }
 
 /* Check for a common situation where a type-name should be present,
Index: gcc/cp/mangle.c
===================================================================
--- a/src/gcc/cp/mangle.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cp/mangle.c	(.../branches/gcc-4_5-branch)
@@ -1778,11 +1778,6 @@
   if (find_substitution (type))
     return;
 
-  /* According to the C++ ABI, some library classes are passed the
-     same as the scalar type of their single member and use the same
-     mangling.  */
-  if (TREE_CODE (type) == RECORD_TYPE && TYPE_TRANSPARENT_AGGR (type))
-    type = TREE_TYPE (first_field (type));
 
   if (write_CV_qualifiers_for_type (type) > 0)
     /* If TYPE was CV-qualified, we just wrote the qualifiers; now
@@ -1802,6 +1797,12 @@
       /* See through any typedefs.  */
       type = TYPE_MAIN_VARIANT (type);
 
+      /* According to the C++ ABI, some library classes are passed the
+	 same as the scalar type of their single member and use the same
+	 mangling.  */
+      if (TREE_CODE (type) == RECORD_TYPE && TYPE_TRANSPARENT_AGGR (type))
+	type = TREE_TYPE (first_field (type));
+
       if (TYPE_PTRMEM_P (type))
 	write_pointer_to_member_type (type);
       else
Index: gcc/caller-save.c
===================================================================
--- a/src/gcc/caller-save.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/caller-save.c	(.../branches/gcc-4_5-branch)
@@ -439,101 +439,93 @@
 void
 setup_save_areas (void)
 {
-  int i, j, k;
-  unsigned int r;
+  int i, j, k, freq;
   HARD_REG_SET hard_regs_used;
+  struct saved_hard_reg *saved_reg;
+  rtx insn;
+  struct insn_chain *chain, *next;
+  unsigned int regno;
+  HARD_REG_SET hard_regs_to_save, used_regs, this_insn_sets;
+  reg_set_iterator rsi;
 
-  /* Allocate space in the save area for the largest multi-register
-     pseudos first, then work backwards to single register
-     pseudos.  */
-
-  /* Find and record all call-used hard-registers in this function.  */
   CLEAR_HARD_REG_SET (hard_regs_used);
-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)
-    if (reg_renumber[i] >= 0 && REG_N_CALLS_CROSSED (i) > 0)
-      {
-	unsigned int regno = reg_renumber[i];
-	unsigned int endregno
-	  = end_hard_regno (GET_MODE (regno_reg_rtx[i]), regno);
-	for (r = regno; r < endregno; r++)
-	  if (call_used_regs[r])
-	    SET_HARD_REG_BIT (hard_regs_used, r);
-      }
 
-  if (optimize && flag_ira_share_save_slots)
+  /* Find every CALL_INSN and record which hard regs are live across the
+     call into HARD_REG_MAP and HARD_REGS_USED.  */
+  initiate_saved_hard_regs ();
+  /* Create hard reg saved regs.  */
+  for (chain = reload_insn_chain; chain != 0; chain = next)
     {
-      rtx insn, slot;
-      struct insn_chain *chain, *next;
-      char *saved_reg_conflicts;
-      unsigned int regno;
-      int next_k, freq;
-      struct saved_hard_reg *saved_reg, *saved_reg2, *saved_reg3;
-      int call_saved_regs_num;
-      struct saved_hard_reg *call_saved_regs[FIRST_PSEUDO_REGISTER];
-      HARD_REG_SET hard_regs_to_save, used_regs, this_insn_sets;
-      reg_set_iterator rsi;
-      int best_slot_num;
-      int prev_save_slots_num;
-      rtx prev_save_slots[FIRST_PSEUDO_REGISTER];
+      insn = chain->insn;
+      next = chain->next;
+      if (!CALL_P (insn)
+	  || find_reg_note (insn, REG_NORETURN, NULL))
+	continue;
+      freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));
+      REG_SET_TO_HARD_REG_SET (hard_regs_to_save,
+			       &chain->live_throughout);
+      COPY_HARD_REG_SET (used_regs, call_used_reg_set);
 
-      initiate_saved_hard_regs ();
-      /* Create hard reg saved regs.  */
-      for (chain = reload_insn_chain; chain != 0; chain = next)
+      /* Record all registers set in this call insn.  These don't
+	 need to be saved.  N.B. the call insn might set a subreg
+	 of a multi-hard-reg pseudo; then the pseudo is considered
+	 live during the call, but the subreg that is set
+	 isn't.  */
+      CLEAR_HARD_REG_SET (this_insn_sets);
+      note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);
+      /* Sibcalls are considered to set the return value.  */
+      if (SIBLING_CALL_P (insn) && crtl->return_rtx)
+	mark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);
+
+      AND_COMPL_HARD_REG_SET (used_regs, call_fixed_reg_set);
+      AND_COMPL_HARD_REG_SET (used_regs, this_insn_sets);
+      AND_HARD_REG_SET (hard_regs_to_save, used_regs);
+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+	if (TEST_HARD_REG_BIT (hard_regs_to_save, regno))
+	  {
+	    if (hard_reg_map[regno] != NULL)
+	      hard_reg_map[regno]->call_freq += freq;
+	    else
+	      saved_reg = new_saved_hard_reg (regno, freq);
+	    SET_HARD_REG_BIT (hard_regs_used, regno);
+	  }
+      /* Look through all live pseudos, mark their hard registers.  */
+      EXECUTE_IF_SET_IN_REG_SET
+	(&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno, rsi)
 	{
-	  insn = chain->insn;
-	  next = chain->next;
-	  if (!CALL_P (insn)
-	      || find_reg_note (insn, REG_NORETURN, NULL))
+	  int r = reg_renumber[regno];
+	  int bound;
+
+	  if (r < 0)
 	    continue;
-	  freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));
-	  REG_SET_TO_HARD_REG_SET (hard_regs_to_save,
-				   &chain->live_throughout);
-	  COPY_HARD_REG_SET (used_regs, call_used_reg_set);
 
-	  /* Record all registers set in this call insn.  These don't
-	     need to be saved.  N.B. the call insn might set a subreg
-	     of a multi-hard-reg pseudo; then the pseudo is considered
-	     live during the call, but the subreg that is set
-	     isn't.  */
-	  CLEAR_HARD_REG_SET (this_insn_sets);
-	  note_stores (PATTERN (insn), mark_set_regs, &this_insn_sets);
-	  /* Sibcalls are considered to set the return value.  */
-	  if (SIBLING_CALL_P (insn) && crtl->return_rtx)
-	    mark_set_regs (crtl->return_rtx, NULL_RTX, &this_insn_sets);
-
-	  AND_COMPL_HARD_REG_SET (used_regs, call_fixed_reg_set);
-	  AND_COMPL_HARD_REG_SET (used_regs, this_insn_sets);
-	  AND_HARD_REG_SET (hard_regs_to_save, used_regs);
-	  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
-	    if (TEST_HARD_REG_BIT (hard_regs_to_save, regno))
+	  bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];
+	  for (; r < bound; r++)
+	    if (TEST_HARD_REG_BIT (used_regs, r))
 	      {
-		if (hard_reg_map[regno] != NULL)
-		  hard_reg_map[regno]->call_freq += freq;
+		if (hard_reg_map[r] != NULL)
+		  hard_reg_map[r]->call_freq += freq;
 		else
-		  saved_reg = new_saved_hard_reg (regno, freq);
+		  saved_reg = new_saved_hard_reg (r, freq);
+		 SET_HARD_REG_BIT (hard_regs_to_save, r);
+		 SET_HARD_REG_BIT (hard_regs_used, r);
 	      }
-	  /* Look through all live pseudos, mark their hard registers.  */
-	  EXECUTE_IF_SET_IN_REG_SET
-	    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno, rsi)
-	    {
-	      int r = reg_renumber[regno];
-	      int bound;
+	}
+    }
 
-	      if (r < 0)
-		continue;
+  /* If requested, figure out which hard regs can share save slots.  */
+  if (optimize && flag_ira_share_save_slots)
+    {
+      rtx slot;
+      char *saved_reg_conflicts;
+      int next_k;
+      struct saved_hard_reg *saved_reg2, *saved_reg3;
+      int call_saved_regs_num;
+      struct saved_hard_reg *call_saved_regs[FIRST_PSEUDO_REGISTER];
+      int best_slot_num;
+      int prev_save_slots_num;
+      rtx prev_save_slots[FIRST_PSEUDO_REGISTER];
 
-	      bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];
-	      for (; r < bound; r++)
-		if (TEST_HARD_REG_BIT (used_regs, r))
-		  {
-		    if (hard_reg_map[r] != NULL)
-		      hard_reg_map[r]->call_freq += freq;
-		    else
-		      saved_reg = new_saved_hard_reg (r, freq);
-		    SET_HARD_REG_BIT (hard_regs_to_save, r);
-		  }
-	    }
-	}
       /* Find saved hard register conflicts.  */
       saved_reg_conflicts = (char *) xmalloc (saved_regs_num * saved_regs_num);
       memset (saved_reg_conflicts, 0, saved_regs_num * saved_regs_num);
@@ -691,8 +683,10 @@
     }
   else
     {
-      /* Now run through all the call-used hard-registers and allocate
-	 space for them in the caller-save area.  Try to allocate space
+      /* We are not sharing slots. 
+
+	 Run through all the call-used hard-registers and allocate
+	 space for each in the caller-save area.  Try to allocate space
 	 in a manner which allows multi-register saves/restores to be done.  */
 
       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
Index: gcc/lto-streamer-out.c
===================================================================
--- a/src/gcc/lto-streamer-out.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/lto-streamer-out.c	(.../branches/gcc-4_5-branch)
@@ -2302,7 +2302,7 @@
       enum gcc_plugin_symbol_kind kind;
       enum gcc_plugin_symbol_visibility visibility;
       int slot_num;
-      uint64_t size;
+      unsigned HOST_WIDEST_INT size;
       const char *comdat;
 
       /* None of the following kinds of symbols are needed in the
@@ -2367,10 +2367,9 @@
 	}
 
       if (kind == GCCPK_COMMON
-	  && DECL_SIZE (t)
-	  && TREE_CODE (DECL_SIZE (t)) == INTEGER_CST)
-	size = (((uint64_t) TREE_INT_CST_HIGH (DECL_SIZE (t))) << 32)
-	  | TREE_INT_CST_LOW (DECL_SIZE (t));
+	  && DECL_SIZE_UNIT (t)
+	  && TREE_CODE (DECL_SIZE_UNIT (t)) == INTEGER_CST)
+	size = TREE_INT_CST_LOW (DECL_SIZE_UNIT (t));
       else
 	size = 0;
 
Index: gcc/tree-ssa-dom.c
===================================================================
--- a/src/gcc/tree-ssa-dom.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-ssa-dom.c	(.../branches/gcc-4_5-branch)
@@ -209,12 +209,11 @@
     {
       enum tree_code subcode = gimple_assign_rhs_code (stmt);
 
-      expr->type = NULL_TREE;
-
       switch (get_gimple_rhs_class (subcode))
         {
         case GIMPLE_SINGLE_RHS:
           expr->kind = EXPR_SINGLE;
+	  expr->type = TREE_TYPE (gimple_assign_rhs1 (stmt));
           expr->ops.single.rhs = gimple_assign_rhs1 (stmt);
           break;
         case GIMPLE_UNARY_RHS:
Index: gcc/ifcvt.c
===================================================================
--- a/src/gcc/ifcvt.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/ifcvt.c	(.../branches/gcc-4_5-branch)
@@ -3818,7 +3818,7 @@
 		    basic_block other_bb, basic_block new_dest, int reversep)
 {
   rtx head, end, jump, earliest = NULL_RTX, old_dest, new_label = NULL_RTX;
-  bitmap merge_set = NULL;
+  bitmap merge_set = NULL, merge_set_noclobber = NULL;
   /* Number of pending changes.  */
   int n_validated_changes = 0;
 
@@ -3951,11 +3951,14 @@
 
       /* Collect:
 	   MERGE_SET = set of registers set in MERGE_BB
+	   MERGE_SET_NOCLOBBER = like MERGE_SET, but only includes registers
+	     that are really set, not just clobbered.
 	   TEST_LIVE = set of registers live at EARLIEST
-	   TEST_SET  = set of registers set between EARLIEST and the
-		       end of the block.  */
+	   TEST_SET = set of registers set between EARLIEST and the
+	     end of the block.  */
 
       merge_set = BITMAP_ALLOC (&reg_obstack);
+      merge_set_noclobber = BITMAP_ALLOC (&reg_obstack);
 
       /* If we allocated new pseudos (e.g. in the conditional move
 	 expander called from noce_emit_cmove), we must resize the
@@ -3967,13 +3970,8 @@
 	{
 	  if (NONDEBUG_INSN_P (insn))
 	    {
-	      unsigned int uid = INSN_UID (insn);
-	      df_ref *def_rec;
-	      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
-		{
-		  df_ref def = *def_rec;
-		  bitmap_set_bit (merge_set, DF_REF_REGNO (def));
-		}
+	      df_simulate_find_defs (insn, merge_set);
+	      df_simulate_find_noclobber_defs (insn, merge_set_noclobber);
 	    }
 	}
 
@@ -3984,7 +3982,7 @@
 	  unsigned i;
 	  bitmap_iterator bi;
 
-          EXECUTE_IF_SET_IN_BITMAP (merge_set, 0, i, bi)
+          EXECUTE_IF_SET_IN_BITMAP (merge_set_noclobber, 0, i, bi)
 	    {
 	      if (i < FIRST_PSEUDO_REGISTER
 		  && ! fixed_regs[i]
@@ -4015,12 +4013,14 @@
 	}
 
       /* We can perform the transformation if
-	   MERGE_SET & (TEST_SET | TEST_LIVE)
+	   MERGE_SET_NOCLOBBER & TEST_SET
 	 and
+	   MERGE_SET & TEST_LIVE
+	 and
 	   TEST_SET & DF_LIVE_IN (merge_bb)
 	 are empty.  */
 
-      if (bitmap_intersect_p (merge_set, test_set)
+      if (bitmap_intersect_p (merge_set_noclobber, test_set)
 	  || bitmap_intersect_p (merge_set, test_live)
 	  || bitmap_intersect_p (test_set, df_get_live_in (merge_bb)))
 	intersect = true;
@@ -4104,10 +4104,11 @@
 	  unsigned i;
 	  bitmap_iterator bi;
 
-	  EXECUTE_IF_SET_IN_BITMAP (merge_set, 0, i, bi)
+	  EXECUTE_IF_SET_IN_BITMAP (merge_set_noclobber, 0, i, bi)
 	    remove_reg_equal_equiv_notes_for_regno (i);
 
 	  BITMAP_FREE (merge_set);
+	  BITMAP_FREE (merge_set_noclobber);
 	}
 
       reorder_insns (head, end, PREV_INSN (earliest));
@@ -4128,7 +4129,10 @@
   cancel_changes (0);
  fail:
   if (merge_set)
-    BITMAP_FREE (merge_set);
+    {
+      BITMAP_FREE (merge_set);
+      BITMAP_FREE (merge_set_noclobber);
+    }
   return FALSE;
 }
 
Index: gcc/dwarf2out.c
===================================================================
--- a/src/gcc/dwarf2out.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/dwarf2out.c	(.../branches/gcc-4_5-branch)
@@ -4254,6 +4254,12 @@
 		      Only on head of list */
   const char *section; /* Section this loclist is relative to */
   dw_loc_descr_ref expr;
+  /* True if all addresses in this and subsequent lists are known to be
+     resolved.  */
+  bool resolved_addr;
+  /* True if this list has been replaced by dw_loc_next.  */
+  bool replaced;
+  bool emitted;
 } dw_loc_list_node;
 
 #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)
@@ -5757,6 +5763,19 @@
 /* Table of decl location linked lists.  */
 static GTY ((param_is (var_loc_list))) htab_t decl_loc_table;
 
+/* A cached location list.  */
+struct GTY (()) cached_dw_loc_list_def {
+  /* The DECL_UID of the decl that this entry describes.  */
+  unsigned int decl_id;
+
+  /* The cached location list.  */
+  dw_loc_list_ref loc_list;
+};
+typedef struct cached_dw_loc_list_def cached_dw_loc_list;
+
+/* Table of cached location lists.  */
+static GTY ((param_is (cached_dw_loc_list))) htab_t cached_dw_loc_list_table;
+
 /* A pointer to the base of a list of references to DIE's that
    are uniquely identified by their tag, presence/absence of
    children DIE's, and list of attribute/value pairs.  */
@@ -6110,7 +6129,7 @@
 static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);
 static void insert_float (const_rtx, unsigned char *);
 static rtx rtl_for_decl_location (tree);
-static bool add_location_or_const_value_attribute (dw_die_ref, tree,
+static bool add_location_or_const_value_attribute (dw_die_ref, tree, bool,
 						   enum dwarf_attribute);
 static bool tree_add_const_value_attribute (dw_die_ref, tree);
 static bool tree_add_const_value_attribute_for_decl (dw_die_ref, tree);
@@ -7729,6 +7748,24 @@
     htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));
 }
 
+/* Returns a hash value for X (which really is a cached_dw_loc_list_list).  */
+
+static hashval_t
+cached_dw_loc_list_table_hash (const void *x)
+{
+  return (hashval_t) ((const cached_dw_loc_list *) x)->decl_id;
+}
+
+/* Return nonzero if decl_id of cached_dw_loc_list X is the same as
+   UID of decl *Y.  */
+
+static int
+cached_dw_loc_list_table_eq (const void *x, const void *y)
+{
+  return (((const cached_dw_loc_list *) x)->decl_id
+	  == DECL_UID ((const_tree) y));
+}
+
 /* Equate a DIE to a particular declaration.  */
 
 static void
@@ -10353,6 +10390,10 @@
 {
   dw_loc_list_ref curr = list_head;
 
+  if (list_head->emitted)
+    return;
+  list_head->emitted = true;
+
   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);
 
   /* Walk the location list, and output each range + expression.  */
@@ -15918,15 +15959,22 @@
    these things can crop up in other ways also.)  Note that one type of
    constant value which can be passed into an inlined function is a constant
    pointer.  This can happen for example if an actual argument in an inlined
-   function call evaluates to a compile-time constant address.  */
+   function call evaluates to a compile-time constant address.
 
+   CACHE_P is true if it is worth caching the location list for DECL,
+   so that future calls can reuse it rather than regenerate it from scratch.
+   This is true for BLOCK_NONLOCALIZED_VARS in inlined subroutines,
+   since we will need to refer to them each time the function is inlined.  */
+
 static bool
-add_location_or_const_value_attribute (dw_die_ref die, tree decl,
+add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,
 				       enum dwarf_attribute attr)
 {
   rtx rtl;
   dw_loc_list_ref list;
   var_loc_list *loc_list;
+  cached_dw_loc_list *cache;
+  void **slot;
 
   if (TREE_CODE (decl) == ERROR_MARK)
     return false;
@@ -15962,7 +16010,34 @@
 	  && add_const_value_attribute (die, rtl))
 	 return true;
     }
-  list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2);
+  /* If this decl is from BLOCK_NONLOCALIZED_VARS, we might need its
+     list several times.  See if we've already cached the contents.  */
+  list = NULL;
+  if (loc_list == NULL || cached_dw_loc_list_table == NULL)
+    cache_p = false;
+  if (cache_p)
+    {
+      cache = (cached_dw_loc_list *)
+	htab_find_with_hash (cached_dw_loc_list_table, decl, DECL_UID (decl));
+      if (cache)
+	list = cache->loc_list;
+    }
+  if (list == NULL)
+    {
+      list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2);
+      /* It is usually worth caching this result if the decl is from
+	 BLOCK_NONLOCALIZED_VARS and if the list has at least two elements.  */
+      if (cache_p && list && list->dw_loc_next)
+	{
+	  slot = htab_find_slot_with_hash (cached_dw_loc_list_table, decl,
+					   DECL_UID (decl), INSERT);
+	  cache = (cached_dw_loc_list *)
+	    ggc_alloc_cleared (sizeof (cached_dw_loc_list));
+	  cache->decl_id = DECL_UID (decl);
+	  cache->loc_list = list;
+	  *slot = cache;
+	}
+    }
   if (list)
     {
       add_AT_location_description (die, attr, list);
@@ -17530,7 +17605,7 @@
         equate_decl_number_to_die (node, parm_die);
       if (! DECL_ABSTRACT (node_or_origin))
 	add_location_or_const_value_attribute (parm_die, node_or_origin,
-					       DW_AT_location);
+					       node == NULL, DW_AT_location);
 
       break;
 
@@ -17710,6 +17785,7 @@
   tree context;
   int was_abstract;
   htab_t old_decl_loc_table;
+  htab_t old_cached_dw_loc_list_table;
 
   /* Make sure we have the actual abstract inline, not a clone.  */
   decl = DECL_ORIGIN (decl);
@@ -17723,7 +17799,9 @@
      DIE.  Be sure to not clobber the outer location table nor use it or we would
      get locations in abstract instantces.  */
   old_decl_loc_table = decl_loc_table;
+  old_cached_dw_loc_list_table = cached_dw_loc_list_table;
   decl_loc_table = NULL;
+  cached_dw_loc_list_table = NULL;
 
   /* Be sure we've emitted the in-class declaration DIE (if any) first, so
      we don't get confused by DECL_ABSTRACT.  */
@@ -17748,6 +17826,7 @@
 
   current_function_decl = save_fn;
   decl_loc_table = old_decl_loc_table;
+  cached_dw_loc_list_table = old_cached_dw_loc_list_table;
   pop_cfun ();
 }
 
@@ -18429,9 +18508,8 @@
           && !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl_or_origin)))
 	defer_location (decl_or_origin, var_die);
       else
-        add_location_or_const_value_attribute (var_die,
-					       decl_or_origin,
-					       DW_AT_location);
+        add_location_or_const_value_attribute (var_die, decl_or_origin,
+					       decl == NULL, DW_AT_location);
       add_pubname (decl_or_origin, var_die);
     }
   else
@@ -20037,6 +20115,7 @@
   dwarf2out_decl (decl);
 
   htab_empty (decl_loc_table);
+  htab_empty (cached_dw_loc_list_table);
 }
 
 /* Output a marker (i.e. a label) for the beginning of the generated code for
@@ -20637,6 +20716,11 @@
   decl_loc_table = htab_create_ggc (10, decl_loc_table_hash,
 				    decl_loc_table_eq, NULL);
 
+  /* Allocate the cached_dw_loc_list_table.  */
+  cached_dw_loc_list_table
+    = htab_create_ggc (10, cached_dw_loc_list_table_hash,
+		       cached_dw_loc_list_table_eq, NULL);
+
   /* Allocate the initial hunk of the decl_scope_table.  */
   decl_scope_table = VEC_alloc (tree, gc, 256);
 
@@ -21261,30 +21345,53 @@
 {
   dw_die_ref c;
   dw_attr_ref a;
-  dw_loc_list_ref *curr;
+  dw_loc_list_ref *curr, *start, loc;
   unsigned ix;
 
   for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)
     switch (AT_class (a))
       {
       case dw_val_class_loc_list:
-	curr = AT_loc_list_ptr (a);
-	while (*curr)
+	start = curr = AT_loc_list_ptr (a);
+	loc = *curr;
+	gcc_assert (loc);
+	/* The same list can be referenced more than once.  See if we have
+	   already recorded the result from a previous pass.  */
+	if (loc->replaced)
+	  *curr = loc->dw_loc_next;
+	else if (!loc->resolved_addr)
 	  {
-	    if (!resolve_addr_in_expr ((*curr)->expr))
+	    /* As things stand, we do not expect or allow one die to
+	       reference a suffix of another die's location list chain.
+	       References must be identical or completely separate.
+	       There is therefore no need to cache the result of this
+	       pass on any list other than the first; doing so
+	       would lead to unnecessary writes.  */
+	    while (*curr)
 	      {
-		dw_loc_list_ref next = (*curr)->dw_loc_next;
-		if (next && (*curr)->ll_symbol)
+		gcc_assert (!(*curr)->replaced && !(*curr)->resolved_addr);
+		if (!resolve_addr_in_expr ((*curr)->expr))
 		  {
-		    gcc_assert (!next->ll_symbol);
-		    next->ll_symbol = (*curr)->ll_symbol;
+		    dw_loc_list_ref next = (*curr)->dw_loc_next;
+		    if (next && (*curr)->ll_symbol)
+		      {
+			gcc_assert (!next->ll_symbol);
+			next->ll_symbol = (*curr)->ll_symbol;
+		      }
+		    *curr = next;
 		  }
-		*curr = next;
+		else
+		  curr = &(*curr)->dw_loc_next;
 	      }
+	    if (loc == *start)
+	      loc->resolved_addr = 1;
 	    else
-	      curr = &(*curr)->dw_loc_next;
+	      {
+		loc->replaced = 1;
+		loc->dw_loc_next = *start;
+	      }
 	  }
-	if (!AT_loc_list (a))
+	if (!*start)
 	  {
 	    remove_AT (die, a->dw_attr);
 	    ix--;
@@ -21344,6 +21451,7 @@
       add_location_or_const_value_attribute (
         VEC_index (deferred_locations, deferred_locations_list, i)->die,
         VEC_index (deferred_locations, deferred_locations_list, i)->variable,
+	false,
 	DW_AT_location);
     }
 
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-4_5-branch)
@@ -2220,6 +2220,111 @@
   return tgtblk;
 }
 
+/* Copy BLKmode value SRC into a register of mode MODE.  Return the
+   register if it contains any data, otherwise return null.
+
+   This is used on targets that return BLKmode values in registers.  */
+
+rtx
+copy_blkmode_to_reg (enum machine_mode mode, tree src)
+{
+  int i, n_regs;
+  unsigned HOST_WIDE_INT bitpos, xbitpos, padding_correction = 0, bytes;
+  unsigned int bitsize;
+  rtx *dst_words, dst, x, src_word = NULL_RTX, dst_word = NULL_RTX;
+  enum machine_mode dst_mode;
+
+  gcc_assert (TYPE_MODE (TREE_TYPE (src)) == BLKmode);
+
+  x = expand_normal (src);
+
+  bytes = int_size_in_bytes (TREE_TYPE (src));
+  if (bytes == 0)
+    return NULL_RTX;
+
+  /* If the structure doesn't take up a whole number of words, see
+     whether the register value should be padded on the left or on
+     the right.  Set PADDING_CORRECTION to the number of padding
+     bits needed on the left side.
+
+     In most ABIs, the structure will be returned at the least end of
+     the register, which translates to right padding on little-endian
+     targets and left padding on big-endian targets.  The opposite
+     holds if the structure is returned at the most significant
+     end of the register.  */
+  if (bytes % UNITS_PER_WORD != 0
+      && (targetm.calls.return_in_msb (TREE_TYPE (src))
+	  ? !BYTES_BIG_ENDIAN
+	  : BYTES_BIG_ENDIAN))
+    padding_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)
+					   * BITS_PER_UNIT));
+
+  n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+  dst_words = XALLOCAVEC (rtx, n_regs);
+  bitsize = MIN (TYPE_ALIGN (TREE_TYPE (src)), BITS_PER_WORD);
+
+  /* Copy the structure BITSIZE bits at a time.  */
+  for (bitpos = 0, xbitpos = padding_correction;
+       bitpos < bytes * BITS_PER_UNIT;
+       bitpos += bitsize, xbitpos += bitsize)
+    {
+      /* We need a new destination pseudo each time xbitpos is
+	 on a word boundary and when xbitpos == padding_correction
+	 (the first time through).  */
+      if (xbitpos % BITS_PER_WORD == 0
+	  || xbitpos == padding_correction)
+	{
+	  /* Generate an appropriate register.  */
+	  dst_word = gen_reg_rtx (word_mode);
+	  dst_words[xbitpos / BITS_PER_WORD] = dst_word;
+
+	  /* Clear the destination before we move anything into it.  */
+	  emit_move_insn (dst_word, CONST0_RTX (word_mode));
+	}
+
+      /* We need a new source operand each time bitpos is on a word
+	 boundary.  */
+      if (bitpos % BITS_PER_WORD == 0)
+	src_word = operand_subword_force (x, bitpos / BITS_PER_WORD, BLKmode);
+
+      /* Use bitpos for the source extraction (left justified) and
+	 xbitpos for the destination store (right justified).  */
+      store_bit_field (dst_word, bitsize, xbitpos % BITS_PER_WORD, word_mode,
+		       extract_bit_field (src_word, bitsize,
+					  bitpos % BITS_PER_WORD, 1,
+					  NULL_RTX, word_mode, word_mode));
+    }
+
+  if (mode == BLKmode)
+    {
+      /* Find the smallest integer mode large enough to hold the
+	 entire structure.  */
+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);
+	   mode != VOIDmode;
+	   mode = GET_MODE_WIDER_MODE (mode))
+	/* Have we found a large enough mode?  */
+	if (GET_MODE_SIZE (mode) >= bytes)
+	  break;
+
+      /* A suitable mode should have been found.  */
+      gcc_assert (mode != VOIDmode);
+    }
+
+  if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (word_mode))
+    dst_mode = word_mode;
+  else
+    dst_mode = mode;
+  dst = gen_reg_rtx (dst_mode);
+
+  for (i = 0; i < n_regs; i++)
+    emit_move_insn (operand_subword (dst, i, 0, dst_mode), dst_words[i]);
+
+  if (mode != dst_mode)
+    dst = gen_lowpart (mode, dst);
+
+  return dst;
+}
+
 /* Add a USE expression for REG to the (possibly empty) list pointed
    to by CALL_FUSAGE.  REG must denote a hard register.  */
 
@@ -4380,7 +4485,9 @@
   if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from, from)
       && COMPLETE_TYPE_P (TREE_TYPE (from))
       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) == INTEGER_CST
-      && ! (((TREE_CODE (to) == VAR_DECL || TREE_CODE (to) == PARM_DECL)
+      && ! (((TREE_CODE (to) == VAR_DECL
+	      || TREE_CODE (to) == PARM_DECL
+	      || TREE_CODE (to) == RESULT_DECL)
 	     && REG_P (DECL_RTL (to)))
 	    || TREE_CODE (to) == SSA_NAME))
     {
@@ -4426,12 +4533,15 @@
       rtx temp;
 
       push_temp_slots ();
-      temp = expand_expr (from, NULL_RTX, GET_MODE (to_rtx), EXPAND_NORMAL);
+      if (REG_P (to_rtx) && TYPE_MODE (TREE_TYPE (from)) == BLKmode)
+	temp = copy_blkmode_to_reg (GET_MODE (to_rtx), from);
+      else
+	temp = expand_expr (from, NULL_RTX, GET_MODE (to_rtx), EXPAND_NORMAL);
 
       if (GET_CODE (to_rtx) == PARALLEL)
 	emit_group_load (to_rtx, temp, TREE_TYPE (from),
 			 int_size_in_bytes (TREE_TYPE (from)));
-      else
+      else if (temp)
 	emit_move_insn (to_rtx, temp);
 
       preserve_temp_slots (to_rtx);
@@ -6906,6 +7016,14 @@
 				modifier == EXPAND_INITIALIZER
 				? EXPAND_INITIALIZER : EXPAND_CONST_ADDRESS);
 
+	  if (TREE_ADDRESSABLE (exp)
+	      && ! MEM_P (result)
+	      && ! targetm.calls.allocate_stack_slots_for_args ())
+	    {
+	      error ("local frame unavailable (naked function?)");
+	      return result;
+	    }
+
 	  /* If the DECL isn't in memory, then the DECL wasn't properly
 	     marked TREE_ADDRESSABLE, which will be either a front-end
 	     or a tree optimizer bug.  */
@@ -8144,7 +8262,10 @@
       op1 = gen_label_rtx ();
       jumpifnot_1 (code, treeop0, treeop1, op1, -1);
 
-      emit_move_insn (target, const1_rtx);
+      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))
+	emit_move_insn (target, constm1_rtx);
+      else
+	emit_move_insn (target, const1_rtx);
 
       emit_label (op1);
       return target;
@@ -8517,11 +8638,15 @@
 	  return temp;
 	}
 
-      /* If the mode of DECL_RTL does not match that of the decl, it
-	 must be a promoted value.  We return a SUBREG of the wanted mode,
-	 but mark it so that we know that it was already extended.  */
+      /* If the mode of DECL_RTL does not match that of the decl,
+	 there are two cases: we are dealing with a BLKmode value
+	 that is returned in a register, or we are dealing with
+	 a promoted value.  In the latter case, return a SUBREG
+	 of the wanted mode, but mark it so that we know that it
+	 was already extended.  */
 
       if (REG_P (decl_rtl)
+	  && DECL_MODE (exp) != BLKmode
 	  && GET_MODE (decl_rtl) != DECL_MODE (exp))
 	{
 	  enum machine_mode pmode;
@@ -10036,7 +10161,8 @@
 
   if ((code == NE || code == EQ)
       && TREE_CODE (arg0) == BIT_AND_EXPR && integer_zerop (arg1)
-      && integer_pow2p (TREE_OPERAND (arg0, 1)))
+      && integer_pow2p (TREE_OPERAND (arg0, 1))
+      && (TYPE_PRECISION (ops->type) != 1 || TYPE_UNSIGNED (ops->type)))
     {
       tree type = lang_hooks.types.type_for_mode (mode, unsignedp);
       return expand_expr (fold_single_bit_test (loc,
@@ -10056,7 +10182,9 @@
 
   /* Try a cstore if possible.  */
   return emit_store_flag_force (target, code, op0, op1,
-			        operand_mode, unsignedp, 1);
+				operand_mode, unsignedp,
+				(TYPE_PRECISION (ops->type) == 1
+				 && !TYPE_UNSIGNED (ops->type)) ? -1 : 1);
 }
 
 
Index: gcc/expr.h
===================================================================
--- a/src/gcc/expr.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/expr.h	(.../branches/gcc-4_5-branch)
@@ -460,6 +460,8 @@
 /* Copy BLKmode object from a set of registers.  */
 extern rtx copy_blkmode_from_reg (rtx, rtx, tree);
 
+extern rtx copy_blkmode_to_reg (enum machine_mode, tree);
+
 /* Mark REG as holding a parameter for the next CALL_INSN.  */
 extern void use_reg (rtx *, rtx);
 
Index: gcc/recog.c
===================================================================
--- a/src/gcc/recog.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/recog.c	(.../branches/gcc-4_5-branch)
@@ -2991,6 +2991,7 @@
   static int search_ofs;
   enum reg_class cl;
   HARD_REG_SET live;
+  df_ref *def_rec;
   int i;
 
   gcc_assert (from < MAX_INSNS_PER_PEEP2 + 1);
@@ -3008,13 +3009,15 @@
 
   while (from != to)
     {
-      HARD_REG_SET this_live;
+      gcc_assert (peep2_insn_data[from].insn != NULL_RTX);
 
+      /* Don't use registers set or clobbered by the insn.  */
+      for (def_rec = DF_INSN_DEFS (peep2_insn_data[from].insn);
+	   *def_rec; def_rec++)
+	SET_HARD_REG_BIT (live, DF_REF_REGNO (*def_rec));
+
       if (++from >= MAX_INSNS_PER_PEEP2 + 1)
 	from = 0;
-      gcc_assert (peep2_insn_data[from].insn != NULL_RTX);
-      REG_SET_TO_HARD_REG_SET (this_live, peep2_insn_data[from].live_before);
-      IOR_HARD_REG_SET (live, this_live);
     }
 
   cl = (class_str[0] == 'r' ? GENERAL_REGS
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,18 @@
+2012-01-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/46192
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: In the case of a
+	renaming, preserve the volatileness through the indirection, if any.
+
+2012-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (addressable_p) <COMPONENT_REF>: Fix thinko.
+
+2011-07-14  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR ada/46350
+	* s-taprop-hpux-dce.adb (Abort_Task): Remove unnecessary cast.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: gcc/ada/gcc-interface/decl.c
===================================================================
--- a/src/gcc/ada/gcc-interface/decl.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/ada/gcc-interface/decl.c	(.../branches/gcc-4_5-branch)
@@ -942,6 +942,14 @@
 		   entity is always accessed indirectly through it.  */
 		else
 		  {
+		    /* We need to preserve the volatileness of the renamed
+		       object through the indirection.  */
+		    if (TREE_THIS_VOLATILE (gnu_expr)
+			&& !TYPE_VOLATILE (gnu_type))
+		      gnu_type
+			= build_qualified_type (gnu_type,
+						(TYPE_QUALS (gnu_type)
+						 | TYPE_QUAL_VOLATILE));
 		    gnu_type = build_reference_type (gnu_type);
 		    inner_const_flag = TREE_READONLY (gnu_expr);
 		    const_flag = true;
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- a/src/gcc/ada/gcc-interface/trans.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/ada/gcc-interface/trans.c	(.../branches/gcc-4_5-branch)
@@ -7017,7 +7017,7 @@
 		    || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))
 		       >= TYPE_ALIGN (TREE_TYPE (gnu_expr))))
 	       /* The field of a padding record is always addressable.  */
-	       || TYPE_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))
+	       || TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))
 	      && addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE));
 
     case ARRAY_REF:  case ARRAY_RANGE_REF:
Index: gcc/ada/s-taprop-hpux-dce.adb
===================================================================
--- a/src/gcc/ada/s-taprop-hpux-dce.adb	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/ada/s-taprop-hpux-dce.adb	(.../branches/gcc-4_5-branch)
@@ -888,8 +888,7 @@
 
       if T.Common.State = Interrupt_Server_Blocked_On_Event_Flag then
          System.Interrupt_Management.Operations.Interrupt_Self_Process
-           (System.Interrupt_Management.Interrupt_ID
-             (PIO.Get_Interrupt_ID (T)));
+           (PIO.Get_Interrupt_ID (T));
       end if;
    end Abort_Task;
 
Index: gcc/lto-streamer-in.c
===================================================================
--- a/src/gcc/lto-streamer-in.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/lto-streamer-in.c	(.../branches/gcc-4_5-branch)
@@ -1445,9 +1445,9 @@
 {
   const struct lto_function_header *header;
   struct data_in *data_in;
-  int32_t cfg_offset;
-  int32_t main_offset;
-  int32_t string_offset;
+  int cfg_offset;
+  int main_offset;
+  int string_offset;
   struct lto_input_block ib_cfg;
   struct lto_input_block ib_main;
 
Index: gcc/c-decl.c
===================================================================
--- a/src/gcc/c-decl.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/c-decl.c	(.../branches/gcc-4_5-branch)
@@ -3909,7 +3909,7 @@
     return 0;
 
   if (expr)
-    add_stmt (expr);
+    add_stmt (fold_convert (void_type_node, expr));
 
   if (TREE_CODE (decl) != FUNCTION_DECL && MAIN_NAME_P (DECL_NAME (decl)))
     warning (OPT_Wmain, "%q+D is usually a function", decl);
Index: gcc/fortran/interface.c
===================================================================
--- a/src/gcc/fortran/interface.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/interface.c	(.../branches/gcc-4_5-branch)
@@ -1213,7 +1213,55 @@
     }
 }
 
+/* Given an intrinsic op, return an equivalent op if one exists,
+   or INTRINSIC_NONE otherwise.  */
 
+gfc_intrinsic_op
+gfc_equivalent_op (gfc_intrinsic_op op)
+{
+  switch(op)
+    {
+    case INTRINSIC_EQ:
+      return INTRINSIC_EQ_OS;
+
+    case INTRINSIC_EQ_OS:
+      return INTRINSIC_EQ;
+
+    case INTRINSIC_NE:
+      return INTRINSIC_NE_OS;
+
+    case INTRINSIC_NE_OS:
+      return INTRINSIC_NE;
+
+    case INTRINSIC_GT:
+      return INTRINSIC_GT_OS;
+
+    case INTRINSIC_GT_OS:
+      return INTRINSIC_GT;
+
+    case INTRINSIC_GE:
+      return INTRINSIC_GE_OS;
+
+    case INTRINSIC_GE_OS:
+      return INTRINSIC_GE;
+
+    case INTRINSIC_LT:
+      return INTRINSIC_LT_OS;
+
+    case INTRINSIC_LT_OS:
+      return INTRINSIC_LT;
+
+    case INTRINSIC_LE:
+      return INTRINSIC_LE_OS;
+
+    case INTRINSIC_LE_OS:
+      return INTRINSIC_LE;
+
+    default:
+      return INTRINSIC_NONE;
+    }
+}
+
 /* For the namespace, check generic, user operator and intrinsic
    operator interfaces for consistency and to remove duplicate
    interfaces.  We traverse the whole namespace, counting on the fact
@@ -1253,75 +1301,19 @@
 
       for (ns2 = ns; ns2; ns2 = ns2->parent)
 	{
+	  gfc_intrinsic_op other_op;
+	  
 	  if (check_interface1 (ns->op[i], ns2->op[i], 0,
 				interface_name, true))
 	    goto done;
 
-	  switch (i)
-	    {
-	      case INTRINSIC_EQ:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_EQ_OS],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_EQ_OS:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_EQ],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_NE:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_NE_OS],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_NE_OS:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_NE],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_GT:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GT_OS],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_GT_OS:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GT],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_GE:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GE_OS],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_GE_OS:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GE],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_LT:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LT_OS],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_LT_OS:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LT],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_LE:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LE_OS],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      case INTRINSIC_LE_OS:
-		if (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LE],
-				      0, interface_name, true)) goto done;
-		break;
-
-	      default:
-		break;
-            }
+	  /* i should be gfc_intrinsic_op, but has to be int with this cast
+	     here for stupid C++ compatibility rules.  */
+	  other_op = gfc_equivalent_op ((gfc_intrinsic_op) i);
+	  if (other_op != INTRINSIC_NONE
+	    &&  check_interface1 (ns->op[i], ns2->op[other_op],
+				  0, interface_name, true))
+	    goto done;
 	}
     }
 
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-4_5-branch)
@@ -2638,12 +2638,14 @@
   ss = gfc_walk_expr (e);
   if (ss == gfc_ss_terminator)
     {
+      parmse->ss = NULL;
       gfc_conv_expr_reference (parmse, e);
       tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);
       gfc_add_modify (&parmse->pre, ctree, tmp);
     }
   else
     {
+      parmse->ss = ss;
       gfc_conv_expr (parmse, e);
       gfc_add_modify (&parmse->pre, ctree, parmse->expr);
     }
Index: gcc/fortran/decl.c
===================================================================
--- a/src/gcc/fortran/decl.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/decl.c	(.../branches/gcc-4_5-branch)
@@ -6062,8 +6062,19 @@
 	case INTERFACE_INTRINSIC_OP:
 	  if (gfc_current_ns->operator_access[op] == ACCESS_UNKNOWN)
 	    {
+	      gfc_intrinsic_op other_op;
+
 	      gfc_current_ns->operator_access[op] =
 		(st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;
+
+	      /* Handle the case if there is another op with the same
+		 function, for INTRINSIC_EQ vs. INTRINSIC_EQ_OS and so on.  */
+	      other_op = gfc_equivalent_op (op);
+
+	      if (other_op != INTRINSIC_NONE)
+		gfc_current_ns->operator_access[other_op] =
+		  (st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;
+
 	    }
 	  else
 	    {
Index: gcc/fortran/trans-common.c
===================================================================
--- a/src/gcc/fortran/trans-common.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/trans-common.c	(.../branches/gcc-4_5-branch)
@@ -1060,14 +1060,12 @@
   HOST_WIDE_INT offset;
   HOST_WIDE_INT current_offset;
   unsigned HOST_WIDE_INT align;
-  unsigned HOST_WIDE_INT max_align;
   bool saw_equiv;
 
   common_segment = NULL;
   offset = 0;
   current_offset = 0;
   align = 1;
-  max_align = 1;
   saw_equiv = false;
 
   /* Add symbols to the segment.  */
@@ -1110,7 +1108,7 @@
 	  if (gfc_option.flag_align_commons)
 	    offset = align_segment (&align);
 
-	  if (offset & (max_align - 1))
+	  if (offset)
 	    {
 	      /* The required offset conflicts with previous alignment
 		 requirements.  Insert padding immediately before this
@@ -1133,8 +1131,6 @@
 	  /* Apply the offset to the new segments.  */
 	  apply_segment_offset (current_segment, offset);
 	  current_offset += offset;
-	  if (max_align < align)
-	    max_align = align;
 
 	  /* Add the new segments to the common block.  */
 	  common_segment = add_segments (common_segment, current_segment);
@@ -1154,11 +1150,11 @@
   if (common_segment->offset != 0 && gfc_option.warn_align_commons)
     {
       if (strcmp (common->name, BLANK_COMMON_NAME))
-	gfc_warning ("COMMON '%s' at %L requires %d bytes of padding at start; "
+	gfc_warning ("COMMON '%s' at %L requires %d bytes of padding; "
 		     "reorder elements or use -fno-align-commons",
 		     common->name, &common->where, (int)common_segment->offset);
       else
-	gfc_warning ("COMMON at %L requires %d bytes of padding at start; "
+	gfc_warning ("COMMON at %L requires %d bytes of padding; "
 		     "reorder elements or use -fno-align-commons",
 		     &common->where, (int)common_segment->offset);
     }
Index: gcc/fortran/gfortran.h
===================================================================
--- a/src/gcc/fortran/gfortran.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/gfortran.h	(.../branches/gcc-4_5-branch)
@@ -2718,6 +2718,7 @@
 gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);
 bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);
 bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);
+gfc_intrinsic_op gfc_equivalent_op (gfc_intrinsic_op);
 
 /* io.c */
 extern gfc_st_label format_asterisk;
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,47 @@
+2011-10-13  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/50659
+	* expr.c (replace_symbol): Only do replacement if the symbol is a dummy.
+
+2011-10-11  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50273
+	* trans-common.c (translate_common): Fix -Walign-commons check.
+
+2011-09-01  Mikael Morin  <mikael.morin@sfr.fr>
+
+	PR fortran/50050
+	* resolve.c (gfc_expr_to_initialize): Don't copy rank.
+	Free copied shape.  Recalculate shape and rank.
+
+2011-08-30  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50163
+	* check_init_expr (check_init_expr): Return when an error occured.
+
+2011-08-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42051
+	PR fortran/43896
+	PR fortran/49962
+	* trans-expr.c (gfc_conv_derived_to_class): Handle array-valued
+	functions with CLASS formal arguments.
+
+2011-07-23  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/49708
+	* resolve.c (resolve_allocate_expr): Fix diagnostics for pointers.
+
+2011-06-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/45786
+	* interface.c (gfc_equivalent_op):  New function.
+	(gfc_check_interface):  Use gfc_equivalent_op instead
+	of switch statement.
+	* decl.c (access_attr_decl):  Also set access to an
+	equivalent operator.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: gcc/fortran/expr.c
===================================================================
--- a/src/gcc/fortran/expr.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/expr.c	(.../branches/gcc-4_5-branch)
@@ -2335,6 +2335,9 @@
 	    m = MATCH_ERROR;
 	  }
 
+	if (m == MATCH_ERROR)
+	  return FAILURE;
+
 	/* Try to scalarize an elemental intrinsic function that has an
 	   array argument.  */
 	isym = gfc_find_function (e->symtree->n.sym->name);
@@ -3777,8 +3780,9 @@
   return error_found ? FAILURE : SUCCESS;
 }
 
-/* Walk an expression tree and replace all symbols with a corresponding symbol
-   in the formal_ns of "sym". Needed for copying interfaces in PROCEDURE
+
+/* Walk an expression tree and replace all dummy symbols by the corresponding
+   symbol in the formal_ns of "sym". Needed for copying interfaces in PROCEDURE
    statements. The boolean return value is required by gfc_traverse_expr.  */
 
 static bool
@@ -3787,14 +3791,12 @@
   if ((expr->expr_type == EXPR_VARIABLE 
        || (expr->expr_type == EXPR_FUNCTION
 	   && !gfc_is_intrinsic (expr->symtree->n.sym, 0, expr->where)))
-      && expr->symtree->n.sym->ns == sym->ts.interface->formal_ns)
+      && expr->symtree->n.sym->ns == sym->ts.interface->formal_ns
+      && expr->symtree->n.sym->attr.dummy)
     {
-      gfc_symtree *stree;
-      gfc_namespace *ns = sym->formal_ns;
-      /* Don't use gfc_get_symtree as we prefer to fail badly if we don't find
-	 the symtree rather than create a new one (and probably fail later).  */
-      stree = gfc_find_symtree (ns ? ns->sym_root : gfc_current_ns->sym_root,
-		      		expr->symtree->n.sym->name);
+      gfc_symtree *root = sym->formal_ns ? sym->formal_ns->sym_root
+					 : gfc_current_ns->sym_root;
+      gfc_symtree *stree = gfc_find_symtree (root, expr->symtree->n.sym->name);
       gcc_assert (stree);
       stree->n.sym->attr = expr->symtree->n.sym->attr;
       expr->symtree = stree;
@@ -3808,6 +3810,7 @@
   gfc_traverse_expr (expr, dest, &replace_symbol, 0);
 }
 
+
 /* The following is analogous to 'replace_symbol', and needed for copying
    interfaces for procedure pointer components. The argument 'sym' must formally
    be a gfc_symbol, so that the function can be passed to gfc_traverse_expr.
Index: gcc/fortran/resolve.c
===================================================================
--- a/src/gcc/fortran/resolve.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/fortran/resolve.c	(.../branches/gcc-4_5-branch)
@@ -6172,10 +6172,19 @@
 	for (i = 0; i < ref->u.ar.dimen; i++)
 	  ref->u.ar.start[i] = ref->u.ar.end[i] = ref->u.ar.stride[i] = NULL;
 
-	result->rank = ref->u.ar.dimen;
 	break;
       }
 
+  if (result->shape != NULL)
+    {
+      for (i = 0; i < result->rank; i++)
+	mpz_clear (result->shape[i]);
+      gfc_free (result->shape);
+      result->shape = NULL;
+    }
+
+  /* Recalculate rank, shape, etc.  */
+  gfc_resolve_expr (result);
   return result;
 }
 
@@ -6402,7 +6411,7 @@
 	}
     }
 
-  if (pointer || dimension == 0)
+  if (dimension == 0)
     return SUCCESS;
 
   /* Make sure the next-to-last reference node is an array specification.  */
Index: gcc/regmove.c
===================================================================
--- a/src/gcc/regmove.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/regmove.c	(.../branches/gcc-4_5-branch)
@@ -859,7 +859,7 @@
 	  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)
 	    break;
 
-	  if (call_used_regs [REGNO (dst)]
+	  if ((HARD_REGISTER_P (dst) && call_used_regs [REGNO (dst)])
 	      || find_reg_fusage (p, CLOBBER, dst))
 	    break;
 	}
Index: gcc/tree-vectorizer.h
===================================================================
--- a/src/gcc/tree-vectorizer.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-vectorizer.h	(.../branches/gcc-4_5-branch)
@@ -242,6 +242,12 @@
   /* The unrolling factor needed to SLP the loop. In case of that pure SLP is
      applied to the loop, i.e., no unrolling is needed, this is 1.  */
   unsigned slp_unrolling_factor;
+
+  /* When we have strided data accesses with gaps, we may introduce invalid
+     memory accesses.  We peel the last iteration of the loop to prevent
+     this.  */
+  bool peeling_for_gaps;
+
 } *loop_vec_info;
 
 /* Access Functions.  */
@@ -266,6 +272,7 @@
 #define LOOP_VINFO_STRIDED_STORES(L)       (L)->strided_stores
 #define LOOP_VINFO_SLP_INSTANCES(L)        (L)->slp_instances
 #define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor
+#define LOOP_VINFO_PEELING_FOR_GAPS(L)     (L)->peeling_for_gaps
 
 #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \
 VEC_length (gimple, (L)->may_misalign_stmts) > 0
Index: gcc/df.h
===================================================================
--- a/src/gcc/df.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/df.h	(.../branches/gcc-4_5-branch)
@@ -51,7 +51,7 @@
 #define DF_RD      3      /* Reaching Defs. */
 #define DF_CHAIN   4      /* Def-Use and/or Use-Def Chains. */
 #define DF_BYTE_LR 5      /* Subreg tracking lr.  */
-#define DF_NOTE    6      /* REG_DEF and REG_UNUSED notes. */
+#define DF_NOTE    6      /* REG_DEAD and REG_UNUSED notes. */
 #define DF_MD      7      /* Multiple Definitions. */
 
 #define DF_LAST_PROBLEM_PLUS1 (DF_MD + 1)
@@ -978,6 +978,7 @@
 extern void df_md_add_problem (void);
 extern void df_md_simulate_artificial_defs_at_top (basic_block, bitmap);
 extern void df_md_simulate_one_insn (basic_block, rtx, bitmap);
+extern void df_simulate_find_noclobber_defs (rtx, bitmap);
 extern void df_simulate_find_defs (rtx, bitmap);
 extern void df_simulate_defs (rtx, bitmap);
 extern void df_simulate_uses (rtx, bitmap);
Index: gcc/lto-section-in.c
===================================================================
--- a/src/gcc/lto-section-in.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/lto-section-in.c	(.../branches/gcc-4_5-branch)
@@ -294,7 +294,7 @@
     = (const struct lto_simple_header *) data;
 
   struct lto_input_block* ib_main;
-  int32_t main_offset = sizeof (struct lto_simple_header);
+  int main_offset = sizeof (struct lto_simple_header);
 
   if (!data)
     return NULL;
Index: gcc/tree-vect-loop.c
===================================================================
--- a/src/gcc/tree-vect-loop.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-vect-loop.c	(.../branches/gcc-4_5-branch)
@@ -711,6 +711,7 @@
   LOOP_VINFO_STRIDED_STORES (res) = VEC_alloc (gimple, heap, 10);
   LOOP_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 10);
   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;
+  LOOP_VINFO_PEELING_FOR_GAPS (res) = false;
 
   return res;
 }
@@ -2053,6 +2054,10 @@
 	  peel_iters_prologue = niters < peel_iters_prologue ?
 					niters : peel_iters_prologue;
 	  peel_iters_epilogue = (niters - peel_iters_prologue) % vf;
+	  /* If we need to peel for gaps, but no peeling is required, we have
+	     to peel VF iterations.  */
+	  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) && !peel_iters_epilogue)
+	    peel_iters_epilogue = vf;
 	}
     }
 
@@ -4212,7 +4217,8 @@
   do_peeling_for_loop_bound
     = (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)
        || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)
-	   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0));
+	   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)
+       || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));
 
   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)
       || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))
Index: gcc/tree-vect-data-refs.c
===================================================================
--- a/src/gcc/tree-vect-data-refs.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-vect-data-refs.c	(.../branches/gcc-4_5-branch)
@@ -1450,7 +1450,7 @@
   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);
   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);
   HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);
-  HOST_WIDE_INT stride;
+  HOST_WIDE_INT stride, last_accessed_element = 1;
   bool slp_impossible = false;
 
   /* For interleaving, STRIDE is STEP counted in elements, i.e., the size of the
@@ -1479,6 +1479,16 @@
 	      fprintf (vect_dump, " step ");
 	      print_generic_expr (vect_dump, step, TDF_SLIM);
 	    }
+
+	  if (loop_vinfo)
+	    {
+	      LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = true;
+
+	      if (vect_print_dump_info (REPORT_DETAILS))
+		fprintf (vect_dump, "Data access with gaps requires scalar "
+				    "epilogue loop");
+	    }
+
 	  return true;
 	}
       if (vect_print_dump_info (REPORT_DETAILS))
@@ -1531,6 +1541,7 @@
               next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));
               continue;
             }
+
           prev = next;
 
           /* Check that all the accesses have the same STEP.  */
@@ -1561,6 +1572,8 @@
               gaps += diff - 1;
 	    }
 
+	  last_accessed_element += diff;
+
           /* Store the gap from the previous member of the group. If there is no
              gap in the access, DR_GROUP_GAP is always 1.  */
           DR_GROUP_GAP (vinfo_for_stmt (next)) = diff;
@@ -1652,6 +1665,15 @@
             VEC_safe_push (gimple, heap, BB_VINFO_STRIDED_STORES (bb_vinfo),
                            stmt);
         }
+
+      /* There is a gap in the end of the group.  */
+      if (stride - last_accessed_element > 0 && loop_vinfo)
+	{
+	  LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = true;
+	  if (vect_print_dump_info (REPORT_DETAILS))
+	    fprintf (vect_dump, "Data access with gaps requires scalar "
+				"epilogue loop");
+	}
     }
 
   return true;
Index: gcc/c-typeck.c
===================================================================
--- a/src/gcc/c-typeck.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/c-typeck.c	(.../branches/gcc-4_5-branch)
@@ -9655,6 +9655,7 @@
 		{
 		case MULT_EXPR:
 		case TRUNC_DIV_EXPR:
+		  op1 = c_save_expr (op1);
 		  imag = build2 (resultcode, real_type, imag, op1);
 		  /* Fall through.  */
 		case PLUS_EXPR:
@@ -9675,6 +9676,7 @@
 	      switch (code)
 		{
 		case MULT_EXPR:
+		  op0 = c_save_expr (op0);
 		  imag = build2 (resultcode, real_type, op0, imag);
 		  /* Fall through.  */
 		case PLUS_EXPR:
@@ -9800,7 +9802,7 @@
 		warn_for_sign_compare (location, orig_op0_folded,
 				       orig_op1_folded, op0, op1,
 				       result_type, resultcode);
-	      if (!in_late_binary_op)
+	      if (!in_late_binary_op && !int_operands)
 		{
 		  if (!op0_maybe_const || TREE_CODE (op0) != INTEGER_CST)
 		    op0 = c_wrap_maybe_const (op0, !op0_maybe_const);
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-4_5-branch)
@@ -1953,8 +1953,14 @@
 		  ret = MIN (ret, tret);
 		}
 	    }
+	  else
+	    {
+	      tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p, post_p,
+				    is_gimple_reg, fb_rvalue);
+	      ret = MIN (ret, tret);
+	    }
 
-	  if (!TREE_OPERAND (t, 3))
+	  if (TREE_OPERAND (t, 3) == NULL_TREE)
 	    {
 	      tree elmt_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (t, 0)));
 	      tree elmt_size = unshare_expr (array_ref_element_size (t));
@@ -1973,11 +1979,17 @@
 		  ret = MIN (ret, tret);
 		}
 	    }
+	  else
+	    {
+	      tret = gimplify_expr (&TREE_OPERAND (t, 3), pre_p, post_p,
+				    is_gimple_reg, fb_rvalue);
+	      ret = MIN (ret, tret);
+	    }
 	}
       else if (TREE_CODE (t) == COMPONENT_REF)
 	{
 	  /* Set the field offset into T and gimplify it.  */
-	  if (!TREE_OPERAND (t, 2))
+	  if (TREE_OPERAND (t, 2) == NULL_TREE)
 	    {
 	      tree offset = unshare_expr (component_ref_field_offset (t));
 	      tree field = TREE_OPERAND (t, 1);
@@ -1996,6 +2008,12 @@
 		  ret = MIN (ret, tret);
 		}
 	    }
+	  else
+	    {
+	      tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p, post_p,
+				    is_gimple_reg, fb_rvalue);
+	      ret = MIN (ret, tret);
+	    }
 	}
     }
 
@@ -2496,7 +2514,9 @@
 			   new_locus);
       append_to_statement_list (t, &expr);
     }
-  else if (TREE_CODE (pred) == COND_EXPR)
+  else if (TREE_CODE (pred) == COND_EXPR
+	   && !VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (pred, 1)))
+	   && !VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (pred, 2))))
     {
       location_t new_locus;
 
@@ -2504,8 +2524,11 @@
 	 if (a)
 	   if (b) goto yes; else goto no;
 	 else
-	   if (c) goto yes; else goto no;  */
+	   if (c) goto yes; else goto no;
 
+	 Don't do this if one of the arms has void type, which can happen
+	 in C++ when the arm is throw.  */
+
       /* Keep the original source location on the first 'if'.  Set the source
 	 location of the ? on the second 'if'.  */
       new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;
Index: gcc/loop-doloop.c
===================================================================
--- a/src/gcc/loop-doloop.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/loop-doloop.c	(.../branches/gcc-4_5-branch)
@@ -334,14 +334,11 @@
    describes the loop, DESC describes the number of iterations of the
    loop, and DOLOOP_INSN is the low-overhead looping insn to emit at the
    end of the loop.  CONDITION is the condition separated from the
-   DOLOOP_SEQ.  COUNT is the number of iterations of the LOOP.
-   ZERO_EXTEND_P says to zero extend COUNT after the increment of it to
-   word_mode from FROM_MODE.  */
+   DOLOOP_SEQ.  COUNT is the number of iterations of the LOOP.  */
 
 static void
 doloop_modify (struct loop *loop, struct niter_desc *desc,
-	       rtx doloop_seq, rtx condition, rtx count,
-	       bool zero_extend_p, enum machine_mode from_mode)
+	       rtx doloop_seq, rtx condition, rtx count)
 {
   rtx counter_reg;
   rtx tmp, noloop = NULL_RTX;
@@ -415,12 +412,8 @@
     }
 
   if (increment_count)
-    count = simplify_gen_binary (PLUS, from_mode, count, const1_rtx);
+    count = simplify_gen_binary (PLUS, mode, count, const1_rtx);
 
-  if (zero_extend_p)
-    count = simplify_gen_unary (ZERO_EXTEND, word_mode,
-				count, from_mode);
-
   /* Insert initialization of the count register into the loop header.  */
   start_sequence ();
   tmp = force_operand (count, counter_reg);
@@ -555,7 +548,6 @@
   struct niter_desc *desc;
   unsigned word_mode_size;
   unsigned HOST_WIDE_INT word_mode_max;
-  bool zero_extend_p = false;
 
   if (dump_file)
     fprintf (dump_file, "Doloop: Processing loop %d.\n", loop->num);
@@ -630,7 +622,8 @@
     {
       if (word_mode_size > GET_MODE_BITSIZE (mode))
 	{
-	  zero_extend_p = true;
+	  count = simplify_gen_unary (ZERO_EXTEND, word_mode,
+				      count, mode);
 	  iterations = simplify_gen_unary (ZERO_EXTEND, word_mode,
 					   iterations, mode);
 	  iterations_max = simplify_gen_unary (ZERO_EXTEND, word_mode,
@@ -674,8 +667,7 @@
       return false;
     }
 
-  doloop_modify (loop, desc, doloop_seq, condition, count,
-		 zero_extend_p, mode);
+  doloop_modify (loop, desc, doloop_seq, condition, count);
   return true;
 }
 
Index: gcc/tree-cfgcleanup.c
===================================================================
--- a/src/gcc/tree-cfgcleanup.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-cfgcleanup.c	(.../branches/gcc-4_5-branch)
@@ -560,7 +560,7 @@
 	   BB is present in the cfg.  */
 	if (bb == NULL
 	    || bb->index < NUM_FIXED_BLOCKS
-	    || bb->index >= n_basic_blocks
+	    || bb->index >= last_basic_block
 	    || BASIC_BLOCK (bb->index) != bb
 	    || last_stmt (bb) == stmt
 	    || !gimple_call_noreturn_p (stmt))
Index: gcc/tree-sra.c
===================================================================
--- a/src/gcc/tree-sra.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-sra.c	(.../branches/gcc-4_5-branch)
@@ -771,12 +771,13 @@
 	  disqualify_candidate (base, "Encountered a variable sized access.");
 	  return NULL;
 	}
-      if ((offset % BITS_PER_UNIT) != 0 || (size % BITS_PER_UNIT) != 0)
+      if (TREE_CODE (expr) == COMPONENT_REF
+	  && DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))
 	{
-	  disqualify_candidate (base,
-				"Encountered an acces not aligned to a byte.");
+	  disqualify_candidate (base, "Encountered a bit-field access.");
 	  return NULL;
 	}
+      gcc_assert ((offset % BITS_PER_UNIT) == 0);
 
       if (ptr)
 	mark_parm_dereference (base, offset + size, stmt);
@@ -1854,13 +1855,25 @@
       && build_ref_for_offset (NULL, TREE_TYPE (root->base), root->offset,
 			       root->type, false))
     {
+      bool new_integer_type;
+      if (TREE_CODE (root->type) == ENUMERAL_TYPE)
+	{
+	  tree rt = root->type;
+	  root->type = build_nonstandard_integer_type (TYPE_PRECISION (rt),
+						       TYPE_UNSIGNED (rt));
+	  new_integer_type = true;
+	}
+      else
+	new_integer_type = false;
+
       if (dump_file && (dump_flags & TDF_DETAILS))
 	{
 	  fprintf (dump_file, "Marking ");
 	  print_generic_expr (dump_file, root->base, 0);
-	  fprintf (dump_file, " offset: %u, size: %u: ",
+	  fprintf (dump_file, " offset: %u, size: %u ",
 		   (unsigned) root->offset, (unsigned) root->size);
-	  fprintf (dump_file, " to be replaced.\n");
+	  fprintf (dump_file, " to be replaced%s.\n",
+		   new_integer_type ? " with an integer": "");
 	}
 
       root->grp_to_be_replaced = 1;
Index: gcc/lto/lto.c
===================================================================
--- a/src/gcc/lto/lto.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/lto/lto.c	(.../branches/gcc-4_5-branch)
@@ -157,7 +157,7 @@
   uint32_t ix;
   tree decl;
   uint32_t i, j;
-  
+
   ix = *data++;
   decl = lto_streamer_cache_get (data_in->reader_cache, (int) ix);
   if (TREE_CODE (decl) != FUNCTION_DECL)
@@ -200,9 +200,9 @@
 		VEC(ld_plugin_symbol_resolution_t,heap) *resolutions)
 {
   const struct lto_decl_header *header = (const struct lto_decl_header *) data;
-  const int32_t decl_offset = sizeof (struct lto_decl_header);
-  const int32_t main_offset = decl_offset + header->decl_state_size;
-  const int32_t string_offset = main_offset + header->main_size;
+  const int decl_offset = sizeof (struct lto_decl_header);
+  const int main_offset = decl_offset + header->decl_state_size;
+  const int string_offset = main_offset + header->main_size;
   struct lto_input_block ib_main;
   struct data_in *data_in;
   unsigned int i;
@@ -250,17 +250,20 @@
 
   if (data_ptr != data_end)
     internal_error ("bytecode stream: garbage at the end of symbols section");
-  
+
   /* Set the current decl state to be the global state. */
   decl_data->current_decl_state = decl_data->global_decl_state;
 
   lto_data_in_delete (data_in);
 }
 
-/* strtoll is not portable. */
-int64_t
-lto_parse_hex (const char *p) {
-  uint64_t ret = 0;
+/* Custom version of strtoll, which is not portable.  */
+
+HOST_WIDEST_INT
+lto_parse_hex (const char *p)
+{
+  HOST_WIDEST_INT ret = 0;
+
   for (; *p != '\0'; ++p)
     {
       char c = *p;
@@ -276,6 +279,7 @@
         internal_error ("could not parse hex number");
       ret |= part;
     }
+
   return ret;
 }
 
@@ -311,7 +315,7 @@
     {
       int t;
       char offset_p[17];
-      int64_t offset;
+      HOST_WIDEST_INT offset;
       t = fscanf (resolution, "@0x%16s", offset_p);
       if (t != 1)
         internal_error ("could not parse file offset");
Index: gcc/lto/lto.h
===================================================================
--- a/src/gcc/lto/lto.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/lto/lto.h	(.../branches/gcc-4_5-branch)
@@ -58,6 +58,6 @@
   size_t len;
 };
 
-int64_t lto_parse_hex (const char *p);
+extern HOST_WIDEST_INT lto_parse_hex (const char *p);
 
 #endif /* LTO_H */
Index: gcc/lto/ChangeLog
===================================================================
--- a/src/gcc/lto/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/lto/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,15 @@
+2011-12-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* lto.h (lto_parse_hex): Reinstate.
+	* lto.c (lto_parse_hex): Make global again.
+
+2011-12-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* lto.h (lto_parse_hex): Delete.
+	* lto.c (lto_read_decls): Use 'int' for offsets.
+	(lto_parse_hex): Make static and return proper 64-bit host type.
+	(lto_resolution_read): Use proper 64-bit host type.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: gcc/ipa-prop.c
===================================================================
--- a/src/gcc/ipa-prop.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/ipa-prop.c	(.../branches/gcc-4_5-branch)
@@ -2134,9 +2134,9 @@
 {
   const struct lto_function_header *header =
     (const struct lto_function_header *) data;
-  const int32_t cfg_offset = sizeof (struct lto_function_header);
-  const int32_t main_offset = cfg_offset + header->cfg_size;
-  const int32_t string_offset = main_offset + header->main_size;
+  const int cfg_offset = sizeof (struct lto_function_header);
+  const int main_offset = cfg_offset + header->cfg_size;
+  const int string_offset = main_offset + header->main_size;
   struct data_in *data_in;
   struct lto_input_block ib_main;
   unsigned int i;
Index: gcc/tree-ssa-dce.c
===================================================================
--- a/src/gcc/tree-ssa-dce.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-ssa-dce.c	(.../branches/gcc-4_5-branch)
@@ -509,7 +509,14 @@
 
   /* If the stmt lhs kills ref, then we can stop walking.  */
   if (gimple_has_lhs (def_stmt)
-      && TREE_CODE (gimple_get_lhs (def_stmt)) != SSA_NAME)
+      && TREE_CODE (gimple_get_lhs (def_stmt)) != SSA_NAME
+      /* The assignment is not necessarily carried out if it can throw
+         and we can catch it in the current function where we could inspect
+	 the previous value.
+         ???  We only need to care about the RHS throwing.  For aggregate
+	 assignments or similar calls and non-call exceptions the LHS
+	 might throw as well.  */
+      && !stmt_can_throw_internal (def_stmt))
     {
       tree base, lhs = gimple_get_lhs (def_stmt);
       HOST_WIDE_INT size, offset, max_size;
Index: gcc/tree-vect-stmts.c
===================================================================
--- a/src/gcc/tree-vect-stmts.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-vect-stmts.c	(.../branches/gcc-4_5-branch)
@@ -1416,7 +1416,7 @@
 		}
 	      else
 		{
-		  vec_oprnd1 = gimple_call_arg (new_stmt, 2*i);
+		  vec_oprnd1 = gimple_call_arg (new_stmt, 2*i + 1);
 		  vec_oprnd0
 		    = vect_get_vec_def_for_stmt_copy (dt[i], vec_oprnd1);
 		  vec_oprnd1
Index: gcc/tree-inline.c
===================================================================
--- a/src/gcc/tree-inline.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-inline.c	(.../branches/gcc-4_5-branch)
@@ -4179,14 +4179,16 @@
 					 CONSTRUCTOR_ELTS (*tp));
       *tp = new_tree;
     }
+  else if (code == STATEMENT_LIST)
+    /* We used to just abort on STATEMENT_LIST, but we can run into them
+       with statement-expressions (c++/40975).  */
+    copy_statement_list (tp);
   else if (TREE_CODE_CLASS (code) == tcc_type)
     *walk_subtrees = 0;
   else if (TREE_CODE_CLASS (code) == tcc_declaration)
     *walk_subtrees = 0;
   else if (TREE_CODE_CLASS (code) == tcc_constant)
     *walk_subtrees = 0;
-  else
-    gcc_assert (code != STATEMENT_LIST);
   return NULL_TREE;
 }
 
Index: gcc/combine.c
===================================================================
--- a/src/gcc/combine.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/combine.c	(.../branches/gcc-4_5-branch)
@@ -5298,7 +5298,7 @@
 	{
 	  /* Try to simplify the expression further.  */
 	  rtx tor = simplify_gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));
-	  temp = combine_simplify_rtx (tor, mode, in_dest);
+	  temp = combine_simplify_rtx (tor, VOIDmode, in_dest);
 
 	  /* If we could, great.  If not, do not go ahead with the IOR
 	     replacement, since PLUS appears in many special purpose
Index: gcc/tree-outof-ssa.c
===================================================================
--- a/src/gcc/tree-outof-ssa.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-outof-ssa.c	(.../branches/gcc-4_5-branch)
@@ -233,9 +233,10 @@
 
   var = SSA_NAME_VAR (partition_to_var (SA.map, dest));
   src_mode = TYPE_MODE (TREE_TYPE (src));
-  dest_mode = promote_decl_mode (var, &unsignedp);
+  dest_mode = GET_MODE (SA.partition_to_pseudo[dest]);
   gcc_assert (src_mode == TYPE_MODE (TREE_TYPE (var)));
-  gcc_assert (dest_mode == GET_MODE (SA.partition_to_pseudo[dest]));
+  gcc_assert (!REG_P (SA.partition_to_pseudo[dest])
+	      || dest_mode == promote_decl_mode (var, &unsignedp));
 
   if (src_mode != dest_mode)
     {
Index: gcc/var-tracking.c
===================================================================
--- a/src/gcc/var-tracking.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/var-tracking.c	(.../branches/gcc-4_5-branch)
@@ -4134,8 +4134,9 @@
   VALUE_RECURSED_INTO (val) = true;
 
   for (node = var->var_part[0].loc_chain; node; node = node->next)
-    if (MEM_P (node->loc) && MEM_EXPR (node->loc) == expr
-	&& MEM_OFFSET (node->loc) == 0)
+    if (MEM_P (node->loc)
+	&& MEM_EXPR (node->loc) == expr
+	&& INT_MEM_OFFSET (node->loc) == 0)
       {
 	where = node;
 	break;
@@ -4198,11 +4199,10 @@
 	{
 	  for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)
 	    {
-	      /* We want to remove dying MEMs that doesn't refer to
-		 DECL.  */
+	      /* We want to remove dying MEMs that doesn't refer to DECL.  */
 	      if (GET_CODE (loc->loc) == MEM
 		  && (MEM_EXPR (loc->loc) != decl
-		      || MEM_OFFSET (loc->loc))
+		      || INT_MEM_OFFSET (loc->loc) != 0)
 		  && !mem_dies_at_call (loc->loc))
 		break;
 	      /* We want to move here MEMs that do refer to DECL.  */
@@ -4246,7 +4246,7 @@
 
 	  if (GET_CODE (loc->loc) != MEM
 	      || (MEM_EXPR (loc->loc) == decl
-		  && MEM_OFFSET (loc->loc) == 0)
+		  && INT_MEM_OFFSET (loc->loc) == 0)
 	      || !mem_dies_at_call (loc->loc))
 	    {
 	      if (old_loc != loc->loc && emit_notes)
Index: gcc/c-common.c
===================================================================
--- a/src/gcc/c-common.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/c-common.c	(.../branches/gcc-4_5-branch)
@@ -4031,14 +4031,15 @@
       /* Distribute the conversion into the arms of a COND_EXPR.  */
       if (c_dialect_cxx ())
 	{
+	  tree op1 = TREE_OPERAND (expr, 1);
+	  tree op2 = TREE_OPERAND (expr, 2);
+	  /* In C++ one of the arms might have void type if it is throw.  */
+	  if (!VOID_TYPE_P (TREE_TYPE (op1)))
+	    op1 = c_common_truthvalue_conversion (location, op1);
+	  if (!VOID_TYPE_P (TREE_TYPE (op2)))
+	    op2 = c_common_truthvalue_conversion (location, op2);
 	  expr = fold_build3_loc (location, COND_EXPR, truthvalue_type_node,
-			      TREE_OPERAND (expr, 0),
-			      c_common_truthvalue_conversion (location,
-							      TREE_OPERAND (expr,
-									    1)),
-			      c_common_truthvalue_conversion (location,
-							      TREE_OPERAND (expr,
-									    2)));
+				  TREE_OPERAND (expr, 0), op1, op2);
 	  goto ret;
 	}
       else
Index: gcc/df-problems.c
===================================================================
--- a/src/gcc/df-problems.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/df-problems.c	(.../branches/gcc-4_5-branch)
@@ -3748,9 +3748,22 @@
   for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
     {
       df_ref def = *def_rec;
-      /* If the def is to only part of the reg, it does
-	 not kill the other defs that reach here.  */
-      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))
+      bitmap_set_bit (defs, DF_REF_REGNO (def));
+    }
+}
+
+/* Find the set of real DEFs, which are not clobbers, for INSN.  */
+
+void
+df_simulate_find_noclobber_defs (rtx insn, bitmap defs)
+{
+  df_ref *def_rec;
+  unsigned int uid = INSN_UID (insn);
+
+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
+    {
+      df_ref def = *def_rec;
+      if (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))
 	bitmap_set_bit (defs, DF_REF_REGNO (def));
     }
 }
@@ -3903,13 +3916,9 @@
    the block, starting with the first one.
    ----------------------------------------------------------------------------*/
 
-/* Apply the artificial uses and defs at the top of BB in a forwards
-   direction.  ??? This is wrong; defs mark the point where a pseudo
-   becomes live when scanning forwards (unless a def is unused).  Since
-   there are no REG_UNUSED notes for artificial defs, passes that
-   require artificial defs probably should not call this function
-   unless (as is the case for fwprop) they are correct when liveness
-   bitmaps are *under*estimated.  */
+/* Initialize the LIVE bitmap, which should be copied from DF_LIVE_IN or
+   DF_LR_IN for basic block BB, for forward scanning by marking artificial
+   defs live.  */
 
 void
 df_simulate_initialize_forwards (basic_block bb, bitmap live)
@@ -3921,7 +3930,7 @@
     {
       df_ref def = *def_rec;
       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)
-	bitmap_clear_bit (live, DF_REF_REGNO (def));
+	bitmap_set_bit (live, DF_REF_REGNO (def));
     }
 }
 
@@ -3942,7 +3951,7 @@
      while here the scan is performed forwards!  So, first assume that the
      def is live, and if this is not true REG_UNUSED notes will rectify the
      situation.  */
-  df_simulate_find_defs (insn, live);
+  df_simulate_find_noclobber_defs (insn, live);
 
   /* Clear all of the registers that go dead.  */
   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-4_5-branch)
@@ -2422,7 +2422,7 @@
 	tm_file="${tm_file} sparc/sol2.h"
 	case ${target} in
 	    sparc64-*-* | sparcv9-*-*)
-		tm_file="${tm_file} sparc/sol2-64.h"
+		tm_file="sparc/sol2-64.h ${tm_file}"
 		;;
 	    *)
 		test x$with_cpu != x || with_cpu=v9
Index: gcc/tree-ssa-structalias.c
===================================================================
--- a/src/gcc/tree-ssa-structalias.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-ssa-structalias.c	(.../branches/gcc-4_5-branch)
@@ -266,6 +266,7 @@
 static varinfo_t first_or_preceding_vi_for_offset (varinfo_t,
 						   unsigned HOST_WIDE_INT);
 static varinfo_t lookup_vi_for_tree (tree);
+static inline bool type_can_have_subvars (const_tree);
 
 /* Pool of variable info structures.  */
 static alloc_pool variable_info_pool;
@@ -3187,10 +3188,51 @@
 	  {
 	  case INDIRECT_REF:
 	    {
+	      struct constraint_expr cs;
+	      varinfo_t vi, curr;
 	      get_constraint_for_1 (TREE_OPERAND (t, 0), results, address_p,
 				    lhs_p);
 	      do_deref (results);
-	      return;
+
+	      /* If we are not taking the address then make sure to process
+		 all subvariables we might access.  */
+	      if (address_p)
+		return;
+
+	      cs = *VEC_last (ce_s, *results);
+	      if (cs.type == DEREF
+		  && type_can_have_subvars (TREE_TYPE (t)))
+		{
+		  /* For dereferences this means we have to defer it
+		     to solving time.  */
+		  VEC_last (ce_s, *results)->offset = UNKNOWN_OFFSET;
+		  return;
+		}
+	      if (cs.type != SCALAR)
+		return;
+
+	      vi = get_varinfo (cs.var);
+	      curr = vi->next;
+	      if (!vi->is_full_var
+		  && curr)
+		{
+		  unsigned HOST_WIDE_INT size;
+		  if (host_integerp (TYPE_SIZE (TREE_TYPE (t)), 1))
+		    size = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (t)));
+		  else
+		    size = -1;
+		  for (; curr; curr = curr->next)
+		    {
+		      if (curr->offset - vi->offset < size)
+			{
+			  cs.var = curr->id;
+			  VEC_safe_push (ce_s, heap, *results, &cs);
+			}
+		      else
+			break;
+		    }
+                }
+              return;
 	    }
 	  case ARRAY_REF:
 	  case ARRAY_RANGE_REF:
@@ -3968,15 +4010,6 @@
 	  && DECL_P (lhsop)
 	  && is_global_var (lhsop))
 	make_escape_constraint (rhsop);
-      /* If this is a conversion of a non-restrict pointer to a
-	 restrict pointer track it with a new heapvar.  */
-      else if (gimple_assign_cast_p (t)
-	       && POINTER_TYPE_P (TREE_TYPE (rhsop))
-	       && POINTER_TYPE_P (TREE_TYPE (lhsop))
-	       && !TYPE_RESTRICT (TREE_TYPE (rhsop))
-	       && TYPE_RESTRICT (TREE_TYPE (lhsop)))
-	make_constraint_from_restrict (get_vi_for_tree (lhsop),
-				       "CAST_RESTRICT");
     }
   /* Handle escapes through return.  */
   else if (gimple_code (t) == GIMPLE_RETURN
@@ -4210,6 +4243,15 @@
 	 fieldoff_compare);
 }
 
+/* Return true if T is a type that can have subvars.  */
+
+static inline bool
+type_can_have_subvars (const_tree t)
+{
+  /* Aggregates without overlapping fields can have subvars.  */
+  return TREE_CODE (t) == RECORD_TYPE;
+}
+
 /* Return true if V is a tree that we can have subvars for.
    Normally, this is any aggregate type.  Also complex
    types which are not gimple registers can have subvars.  */
@@ -4225,11 +4267,7 @@
   if (!DECL_P (v))
     return false;
 
-  /* Aggregates without overlapping fields can have subvars.  */
-  if (TREE_CODE (TREE_TYPE (v)) == RECORD_TYPE)
-    return true;
-
-  return false;
+  return type_can_have_subvars (TREE_TYPE (v));
 }
 
 /* Return true if T is a type that does contain pointers.  */
Index: gcc/lto-opts.c
===================================================================
--- a/src/gcc/lto-opts.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/lto-opts.c	(.../branches/gcc-4_5-branch)
@@ -351,7 +351,7 @@
   size_t len;
   const char *data;
   const struct lto_simple_header *header;
-  int32_t opts_offset;
+  int opts_offset;
   struct lto_input_block ib;
 
   data = lto_get_section_data (file_data, LTO_section_opts, NULL, &len);
Index: gcc/tree-switch-conversion.c
===================================================================
--- a/src/gcc/tree-switch-conversion.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/tree-switch-conversion.c	(.../branches/gcc-4_5-branch)
@@ -549,7 +549,7 @@
 build_arrays (gimple swtch)
 {
   tree arr_index_type;
-  tree tidx, sub, tmp;
+  tree tidx, sub, tmp, utype;
   gimple stmt;
   gimple_stmt_iterator gsi;
   int i;
@@ -557,14 +557,20 @@
 
   gsi = gsi_for_stmt (swtch);
 
+  /* Make sure we do not generate arithmetics in a subrange.  */
+  utype = TREE_TYPE (info.index_expr);
+  if (TREE_TYPE (utype))
+    utype = lang_hooks.types.type_for_mode (TYPE_MODE (TREE_TYPE (utype)), 1);
+  else
+    utype = lang_hooks.types.type_for_mode (TYPE_MODE (utype), 1);
+
   arr_index_type = build_index_type (info.range_size);
-  tmp = create_tmp_var (TREE_TYPE (info.index_expr), "csti");
+  tmp = create_tmp_var (utype, "csui");
   add_referenced_var (tmp);
   tidx = make_ssa_name (tmp, NULL);
-  sub = fold_build2_loc (loc, MINUS_EXPR,
-		     TREE_TYPE (info.index_expr), info.index_expr,
-		     fold_convert_loc (loc, TREE_TYPE (info.index_expr),
-				       info.range_min));
+  sub = fold_build2_loc (loc, MINUS_EXPR, utype,
+			 fold_convert_loc (loc, utype, info.index_expr),
+			 fold_convert_loc (loc, utype, info.range_min));
   sub = force_gimple_operand_gsi (&gsi, sub,
 				  false, NULL, true, GSI_SAME_STMT);
   stmt = gimple_build_assign (tidx, sub);
@@ -673,12 +679,7 @@
   tree label_decl2 = create_artificial_label (UNKNOWN_LOCATION);
   tree label_decl3 = create_artificial_label (UNKNOWN_LOCATION);
   gimple label1, label2, label3;
-
-  tree utype;
-  tree tmp_u_1, tmp_u_2, tmp_u_var;
-  tree cast;
-  gimple cast_assign, minus_assign;
-  tree ulb, minus;
+  tree utype, tidx;
   tree bound;
 
   gimple cond_stmt;
@@ -692,49 +693,24 @@
   gcc_assert (info.default_values);
   bb0 = gimple_bb (swtch);
 
-  /* Make sure we do not generate arithmetics in a subrange.  */
-  if (TREE_TYPE (TREE_TYPE (info.index_expr)))
-    utype = lang_hooks.types.type_for_mode
-      (TYPE_MODE (TREE_TYPE (TREE_TYPE (info.index_expr))), 1);
-  else
-    utype = lang_hooks.types.type_for_mode
-      (TYPE_MODE (TREE_TYPE (info.index_expr)), 1);
+  tidx = gimple_assign_lhs (info.arr_ref_first);
+  utype = TREE_TYPE (tidx);
 
   /* (end of) block 0 */
   gsi = gsi_for_stmt (info.arr_ref_first);
-  tmp_u_var = create_tmp_var (utype, "csui");
-  add_referenced_var (tmp_u_var);
-  tmp_u_1 = make_ssa_name (tmp_u_var, NULL);
+  gsi_next (&gsi);
 
-  cast = fold_convert_loc (loc, utype, info.index_expr);
-  cast_assign = gimple_build_assign (tmp_u_1, cast);
-  SSA_NAME_DEF_STMT (tmp_u_1) = cast_assign;
-  gsi_insert_before (&gsi, cast_assign, GSI_SAME_STMT);
-  update_stmt (cast_assign);
-
-  ulb = fold_convert_loc (loc, utype, info.range_min);
-  minus = fold_build2_loc (loc, MINUS_EXPR, utype, tmp_u_1, ulb);
-  minus = force_gimple_operand_gsi (&gsi, minus, false, NULL, true,
-				    GSI_SAME_STMT);
-  tmp_u_2 = make_ssa_name (tmp_u_var, NULL);
-  minus_assign = gimple_build_assign (tmp_u_2, minus);
-  SSA_NAME_DEF_STMT (tmp_u_2) = minus_assign;
-  gsi_insert_before (&gsi, minus_assign, GSI_SAME_STMT);
-  update_stmt (minus_assign);
-
   bound = fold_convert_loc (loc, utype, info.range_size);
-  cond_stmt = gimple_build_cond (LE_EXPR, tmp_u_2, bound, NULL_TREE, NULL_TREE);
+  cond_stmt = gimple_build_cond (LE_EXPR, tidx, bound, NULL_TREE, NULL_TREE);
   gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);
   update_stmt (cond_stmt);
 
   /* block 2 */
-  gsi = gsi_for_stmt (info.arr_ref_first);
   label2 = gimple_build_label (label_decl2);
   gsi_insert_before (&gsi, label2, GSI_SAME_STMT);
   last_assign = gen_def_assigns (&gsi);
 
   /* block 1 */
-  gsi = gsi_for_stmt (info.arr_ref_first);
   label1 = gimple_build_label (label_decl1);
   gsi_insert_before (&gsi, label1, GSI_SAME_STMT);
 
Index: gcc/config/alpha/linux-unwind.h
===================================================================
--- a/src/gcc/config/alpha/linux-unwind.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/alpha/linux-unwind.h	(.../branches/gcc-4_5-branch)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Alpha Linux.
-   Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2011 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -36,16 +36,17 @@
 {
   unsigned int *pc = context->ra;
   struct sigcontext *sc;
-  long new_cfa, i;
+  long new_cfa;
+  int i;
 
   if (pc[0] != 0x47fe0410		/* mov $30,$16 */
-      || pc[2] != 0x00000083		/* callsys */)
+      || pc[2] != 0x00000083)		/* callsys */
     return _URC_END_OF_STACK;
   if (context->cfa == 0)
     return _URC_END_OF_STACK;
   if (pc[1] == 0x201f0067)		/* lda $0,NR_sigreturn */
     sc = context->cfa;
-  else if (pc[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */
+  else if (pc[1] == 0x201f015f)		/* lda $0,NR_rt_sigreturn */
     {
       struct rt_sigframe {
 	struct siginfo info;
@@ -55,6 +56,7 @@
     }
   else
     return _URC_END_OF_STACK;
+
   new_cfa = sc->sc_regs[30];
   fs->regs.cfa_how = CFA_REG_OFFSET;
   fs->regs.cfa_reg = 30;
@@ -63,16 +65,35 @@
     {
       fs->regs.reg[i].how = REG_SAVED_OFFSET;
       fs->regs.reg[i].loc.offset
-	= (long)&sc->sc_regs[i] - new_cfa;
+	= (long) &sc->sc_regs[i] - new_cfa;
     }
   for (i = 0; i < 31; ++i)
     {
       fs->regs.reg[i+32].how = REG_SAVED_OFFSET;
       fs->regs.reg[i+32].loc.offset
-	= (long)&sc->sc_fpregs[i] - new_cfa;
+	= (long) &sc->sc_fpregs[i] - new_cfa;
     }
   fs->regs.reg[64].how = REG_SAVED_OFFSET;
   fs->regs.reg[64].loc.offset = (long)&sc->sc_pc - new_cfa;
   fs->retaddr_column = 64;
+  fs->signal_frame = 1;
+
   return _URC_NO_REASON;
 }
+
+#define MD_FROB_UPDATE_CONTEXT alpha_frob_update_context
+
+/* Fix up for signal handlers that don't have S flag set.  */
+
+static void
+alpha_frob_update_context (struct _Unwind_Context *context,
+			   _Unwind_FrameState *fs ATTRIBUTE_UNUSED)
+{
+  unsigned int *pc = context->ra;
+
+  if (pc[0] == 0x47fe0410		/* mov $30,$16 */
+      && pc[2] == 0x00000083		/* callsys */
+      && (pc[1] == 0x201f0067		/* lda $0,NR_sigreturn */
+	  || pc[1] == 0x201f015f))	/* lda $0,NR_rt_sigreturn */
+    _Unwind_SetSignalFrame (context, 1);
+}
Index: gcc/config/alpha/alpha.c
===================================================================
--- a/src/gcc/config/alpha/alpha.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/alpha/alpha.c	(.../branches/gcc-4_5-branch)
@@ -4915,6 +4915,13 @@
   return m;
 }
 
+static void
+alpha_instantiate_decls (void)
+{
+  if (cfun->machine->gp_save_rtx != NULL_RTX)
+    instantiate_decl_rtl (cfun->machine->gp_save_rtx);
+}
+
 static int
 alpha_ra_ever_killed (void)
 {
@@ -11125,6 +11132,9 @@
 #undef TARGET_TRAMPOLINE_INIT
 #define TARGET_TRAMPOLINE_INIT alpha_trampoline_init
 
+#undef TARGET_INSTANTIATE_DECLS
+#define TARGET_INSTANTIATE_DECLS alpha_instantiate_decls
+
 #undef TARGET_SECONDARY_RELOAD
 #define TARGET_SECONDARY_RELOAD alpha_secondary_reload
 
Index: gcc/config/sparc/sol2-64.h
===================================================================
--- a/src/gcc/config/sparc/sol2-64.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sparc/sol2-64.h	(.../branches/gcc-4_5-branch)
@@ -1,7 +1,7 @@
 /* Definitions of target machine for GCC, for bi-arch SPARC
    running Solaris 2, defaulting to 64-bit code generation.
 
-   Copyright (C) 1999, 2010 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2010, 2011 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -19,7 +19,4 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-#undef TARGET_DEFAULT
-#define TARGET_DEFAULT \
-  (MASK_V9 + MASK_PTR64 + MASK_64BIT /* + MASK_HARD_QUAD */ + \
-   MASK_STACK_BIAS + MASK_APP_REGS + MASK_FPU + MASK_LONG_DOUBLE_128)
+#define TARGET_64BIT_DEFAULT 1
Index: gcc/config/sparc/sparc.md
===================================================================
--- a/src/gcc/config/sparc/sparc.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sparc/sparc.md	(.../branches/gcc-4_5-branch)
@@ -28,6 +28,7 @@
   [(UNSPEC_MOVE_PIC		0)
    (UNSPEC_UPDATE_RETURN	1)
    (UNSPEC_LOAD_PCREL_SYM	2)
+   (UNSPEC_FRAME_BLOCKAGE      3)
    (UNSPEC_MOVE_PIC_LABEL	5)
    (UNSPEC_SETH44		6)
    (UNSPEC_SETM44		7)
@@ -2477,11 +2478,9 @@
 			(match_operand:I 3 "arith10_operand" "")))]
   "TARGET_V9 && !(<I:MODE>mode == DImode && TARGET_ARCH32)"
 {
-  enum rtx_code code = GET_CODE (operands[1]);
   rtx cc_reg;
 
-  if (GET_MODE (XEXP (operands[1], 0)) == DImode
-      && ! TARGET_ARCH64)
+  if (GET_MODE (XEXP (operands[1], 0)) == DImode && !TARGET_ARCH64)
     FAIL;
 
   if (GET_MODE (XEXP (operands[1], 0)) == TFmode && !TARGET_HARD_QUAD)
@@ -2492,12 +2491,14 @@
   if (XEXP (operands[1], 1) == const0_rtx
       && GET_CODE (XEXP (operands[1], 0)) == REG
       && GET_MODE (XEXP (operands[1], 0)) == DImode
-      && v9_regcmp_p (code))
+      && v9_regcmp_p (GET_CODE (operands[1])))
     cc_reg = XEXP (operands[1], 0);
   else
     cc_reg = gen_compare_reg (operands[1]);
 
-  operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);
+  operands[1]
+    = gen_rtx_fmt_ee (GET_CODE (operands[1]), GET_MODE (cc_reg), cc_reg,
+		      const0_rtx);
 })
 
 (define_expand "mov<F:mode>cc"
@@ -2507,11 +2508,9 @@
 			(match_operand:F 3 "register_operand" "")))]
   "TARGET_V9 && TARGET_FPU"
 {
-  enum rtx_code code = GET_CODE (operands[1]);
   rtx cc_reg;
 
-  if (GET_MODE (XEXP (operands[1], 0)) == DImode
-      && ! TARGET_ARCH64)
+  if (GET_MODE (XEXP (operands[1], 0)) == DImode && !TARGET_ARCH64)
     FAIL;
 
   if (GET_MODE (XEXP (operands[1], 0)) == TFmode && !TARGET_HARD_QUAD)
@@ -2522,12 +2521,14 @@
   if (XEXP (operands[1], 1) == const0_rtx
       && GET_CODE (XEXP (operands[1], 0)) == REG
       && GET_MODE (XEXP (operands[1], 0)) == DImode
-      && v9_regcmp_p (code))
+      && v9_regcmp_p (GET_CODE (operands[1])))
     cc_reg = XEXP (operands[1], 0);
   else
     cc_reg = gen_compare_reg (operands[1]);
 
-  operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);
+  operands[1]
+    = gen_rtx_fmt_ee (GET_CODE (operands[1]), GET_MODE (cc_reg), cc_reg,
+		      const0_rtx);
 })
 
 ;; Conditional move define_insns
@@ -6315,9 +6316,7 @@
 			       (if_then_else (eq_attr "isa" "v9")
 					     (const_int 2)
 					     (const_int 3))
-			       (if_then_else (eq_attr "isa" "v9")
-					     (const_int 3)
-					     (const_int 4)))
+			       (const_int 4))
 	       (eq_attr "empty_delay_slot" "true")
 		 (if_then_else (eq_attr "delayed_branch" "true")
 			       (const_int 2)
@@ -6333,6 +6332,25 @@
   ""
   [(set_attr "length" "0")])
 
+;; Do not schedule instructions accessing memory before this point.
+
+(define_expand "frame_blockage"
+  [(set (match_dup 0)
+	(unspec:BLK [(match_dup 1)] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+  operands[1] = stack_pointer_rtx;
+})
+
+(define_insn "*frame_blockage<P:mode>"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_operand:P 1 "" "")] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+  ""
+  [(set_attr "length" "0")])
+
 (define_expand "probe_stack"
   [(set (match_operand 0 "memory_operand" "") (const_int 0))]
   ""
@@ -6491,8 +6509,8 @@
 		      (const_int 4)))])
 
 ;; For __builtin_setjmp we need to flush register windows iff the function
-;; calls alloca as well, because otherwise the register window might be
-;; saved after %sp adjustment and thus setjmp would crash
+;; calls alloca as well, because otherwise the current register window might
+;; be saved after the %sp adjustment and thus setjmp would crash.
 (define_expand "builtin_setjmp_setup"
   [(match_operand 0 "register_operand" "r")]
   ""
@@ -6531,19 +6549,26 @@
                (eq_attr "pic" "true")
                  (const_int 4)] (const_int 3)))])
 
-;; Pattern for use after a setjmp to store FP and the return register
-;; into the stack area.
+;; Pattern for use after a setjmp to store registers into the save area.
 
 (define_expand "setjmp"
   [(const_int 0)]
   ""
 {
   rtx mem;
-  
+
+  if (flag_pic)
+    {
+      mem = gen_rtx_MEM (Pmode,
+			 plus_constant (stack_pointer_rtx,
+					SPARC_STACK_BIAS + 7 * UNITS_PER_WORD));
+      emit_insn (gen_rtx_SET (VOIDmode, mem, pic_offset_table_rtx));
+    }
+
   mem = gen_rtx_MEM (Pmode,
 		     plus_constant (stack_pointer_rtx,
 				    SPARC_STACK_BIAS + 14 * UNITS_PER_WORD));
-  emit_insn (gen_rtx_SET (VOIDmode, mem, frame_pointer_rtx));
+  emit_insn (gen_rtx_SET (VOIDmode, mem, hard_frame_pointer_rtx));
 
   mem = gen_rtx_MEM (Pmode,
 		     plus_constant (stack_pointer_rtx,
Index: gcc/config/sparc/sparc-protos.h
===================================================================
--- a/src/gcc/config/sparc/sparc-protos.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sparc/sparc-protos.h	(.../branches/gcc-4_5-branch)
@@ -48,6 +48,7 @@
 extern int check_pic (int);
 extern int short_branch (int, int);
 extern void sparc_profile_hook (int);
+extern void sparc_optimization_options (int, int);
 extern void sparc_override_options (void);
 extern void sparc_output_scratch_registers (FILE *);
 
Index: gcc/config/sparc/sparc.c
===================================================================
--- a/src/gcc/config/sparc/sparc.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sparc/sparc.c	(.../branches/gcc-4_5-branch)
@@ -627,6 +627,17 @@
   return true;
 }
 
+/* Specify default optimizations.  */
+
+void
+sparc_optimization_options (int l ATTRIBUTE_UNUSED, int s ATTRIBUTE_UNUSED)
+{
+  /* Disable save slot sharing for call-clobbered registers by default.
+     The IRA sharing algorithm works on single registers only and this
+     pessimizes for double floating-point registers.  */
+  flag_ira_share_save_slots = 0;
+}
+
 /* Validate and override various options, and do some machine dependent
    initialization.  */
 
@@ -2767,11 +2778,6 @@
   if (get_attr_length (trial) != 1)
     return 0;
 
-  /* If there are any call-saved registers, we should scan TRIAL if it
-     does not reference them.  For now just make it easy.  */
-  if (num_gfregs)
-    return 0;
-
   /* If the function uses __builtin_eh_return, the eh_return machinery
      occupies the delay slot.  */
   if (crtl->calls_eh_return)
@@ -4093,7 +4099,7 @@
 	    emit_move_insn (gen_rtx_REG (mode, regno), mem);
 
 	  /* Always preserve double-word alignment.  */
-	  offset = (offset + 7) & -8;
+	  offset = (offset + 8) & -8;
 	}
     }
 
@@ -4200,7 +4206,7 @@
      example, the regrename pass has special provisions to not rename to
      non-leaf registers in a leaf function.  */
   sparc_leaf_function_p
-    = optimize > 0 && leaf_function_p () && only_leaf_regs_used ();
+    = optimize > 0 && current_function_is_leaf && only_leaf_regs_used ();
 
   /* Need to use actual_fsize, since we are also allocating
      space for our callee (and our own register save area).  */
@@ -4230,8 +4236,9 @@
       else if (actual_fsize <= 8192)
 	{
 	  insn = emit_insn (gen_stack_pointer_inc (GEN_INT (-4096)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+
 	  /* %sp is still the CFA register.  */
-	  RTX_FRAME_RELATED_P (insn) = 1;
 	  insn
 	    = emit_insn (gen_stack_pointer_inc (GEN_INT (4096-actual_fsize)));
 	}
@@ -4253,8 +4260,18 @@
       else if (actual_fsize <= 8192)
 	{
 	  insn = emit_insn (gen_save_register_window (GEN_INT (-4096)));
+
 	  /* %sp is not the CFA register anymore.  */
 	  emit_insn (gen_stack_pointer_inc (GEN_INT (4096-actual_fsize)));
+
+	  /* Make sure no %fp-based store is issued until after the frame is
+	     established.  The offset between the frame pointer and the stack
+	     pointer is calculated relative to the value of the stack pointer
+	     at the end of the function prologue, and moving instructions that
+	     access the stack via the frame pointer between the instructions
+	     that decrement the stack pointer could result in accessing the
+	     register window save area, which is volatile.  */
+	  emit_insn (gen_frame_blockage ());
 	}
       else
 	{
@@ -4324,6 +4341,7 @@
 sparc_can_use_return_insn_p (void)
 {
   return sparc_prologue_data_valid_p
+	 && num_gfregs == 0
 	 && (actual_fsize == 0 || !sparc_leaf_function_p);
 }
 
@@ -4425,18 +4443,20 @@
 	     machinery occupies the delay slot.  */
 	  gcc_assert (! final_sequence);
 
-	  if (! flag_delayed_branch)
-	    fputs ("\tadd\t%fp, %g1, %fp\n", asm_out_file);
+          if (flag_delayed_branch)
+	    {
+	      if (TARGET_V9)
+		fputs ("\treturn\t%i7+8\n", asm_out_file);
+	      else
+		fputs ("\trestore\n\tjmp\t%o7+8\n", asm_out_file);
 
-	  if (TARGET_V9)
-	    fputs ("\treturn\t%i7+8\n", asm_out_file);
+	      fputs ("\t add\t%sp, %g1, %sp\n", asm_out_file);
+	    }
 	  else
-	    fputs ("\trestore\n\tjmp\t%o7+8\n", asm_out_file);
-
-	  if (flag_delayed_branch)
-	    fputs ("\t add\t%sp, %g1, %sp\n", asm_out_file);
-	  else
-	    fputs ("\t nop\n", asm_out_file);
+	    {
+	      fputs ("\trestore\n\tadd\t%sp, %g1, %sp\n", asm_out_file);
+	      fputs ("\tjmp\t%o7+8\n\t nop\n", asm_out_file);
+	    }
 	}
       else if (final_sequence)
 	{
@@ -9267,7 +9287,7 @@
 bool
 sparc_frame_pointer_required (void)
 {
-  return !(leaf_function_p () && only_leaf_regs_used ());
+  return !(current_function_is_leaf && only_leaf_regs_used ());
 }
 
 /* The way this is structured, we can't eliminate SFP in favor of SP
Index: gcc/config/sparc/sparc.h
===================================================================
--- a/src/gcc/config/sparc/sparc.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sparc/sparc.h	(.../branches/gcc-4_5-branch)
@@ -414,6 +414,7 @@
 %{mcpu=sparclite:-Asparclite} \
 %{mcpu=sparclite86x:-Asparclite} \
 %{mcpu=f930:-Asparclite} %{mcpu=f934:-Asparclite} \
+%{mcpu=v8:-Av8} \
 %{mv8plus:-Av8plus} \
 %{mcpu=v9:-Av9} \
 %{mcpu=ultrasparc:%{!mv8plus:-Av9a}} \
@@ -501,7 +502,8 @@
 #define CAN_DEBUG_WITHOUT_FP
 
 /* Option handling.  */
-
+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE) \
+  sparc_optimization_options ((LEVEL), (SIZE))
 #define OVERRIDE_OPTIONS  sparc_override_options ()
 
 /* Mask of all CPU selection flags.  */
Index: gcc/config/sparc/sol2.h
===================================================================
--- a/src/gcc/config/sparc/sol2.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sparc/sol2.h	(.../branches/gcc-4_5-branch)
@@ -153,11 +153,18 @@
 #undef SUN_INTEGER_MULTIPLY_64
 #define SUN_INTEGER_MULTIPLY_64 1
 
-/* Solaris allows 64 bit out and global registers in 32 bit mode.
-   sparc_override_options will disable V8+ if not generating V9 code.  */
+/* Solaris allows 64-bit out and global registers to be used in 32-bit mode.
+   sparc_override_options will disable V8+ if either not generating V9 code
+   or generating 64-bit code.  */
 #undef TARGET_DEFAULT
-#define TARGET_DEFAULT (MASK_V8PLUS + MASK_APP_REGS + MASK_FPU \
-			+ MASK_LONG_DOUBLE_128)
+#ifdef TARGET_64BIT_DEFAULT
+#define TARGET_DEFAULT \
+  (MASK_V9 + MASK_64BIT + MASK_PTR64 + MASK_STACK_BIAS + \
+   MASK_V8PLUS + MASK_APP_REGS + MASK_FPU + MASK_LONG_DOUBLE_128)
+#else
+#define TARGET_DEFAULT \
+  (MASK_V8PLUS + MASK_APP_REGS + MASK_FPU + MASK_LONG_DOUBLE_128)
+#endif
 
 /* Solaris-specific #pragmas are implemented on top of attributes.  Hook in
    the bits from config/sol2.c.  */
Index: gcc/config/sparc/sol2-unwind.h
===================================================================
--- a/src/gcc/config/sparc/sol2-unwind.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sparc/sol2-unwind.h	(.../branches/gcc-4_5-branch)
@@ -123,10 +123,10 @@
 	  /* This matches the call_user_handler pattern for Solaris 10.
 	     There are 2 cases so we look for the return address of the
 	     caller's caller frame in order to do more pattern matching.  */
-	  unsigned int sah_pattern
-	    = *(unsigned int *)(*(unsigned long *)(this_cfa + 176 + 15*8) - 4);
+	  unsigned long sah_address
+	    = *(unsigned long *)(this_cfa + 176 + 15*8);
 
-          if (sah_pattern == 0x92100019)
+          if (sah_address && *(unsigned int *)(sah_address - 4) == 0x92100019)
 	    /* This is the same setup as for Solaris 9, see below.  */
 	    regs_off = 176 + 176 + 176 + 304;
 	  else
@@ -371,10 +371,10 @@
 	  /* This matches the call_user_handler pattern for Solaris 10.
 	     There are 2 cases so we look for the return address of the
 	     caller's caller frame in order to do more pattern matching.  */
-	  unsigned int sah_pattern
-	    = *(unsigned int *)(*(unsigned int *)(this_cfa + 96 + 15*4) - 4);
+	  unsigned int sah_address
+	    = *(unsigned int *)(this_cfa + 96 + 15*4);
 
-          if (sah_pattern == 0x92100019)
+          if (sah_address && *(unsigned int *)(sah_address - 4) == 0x92100019)
 	    /* This is the same setup as for Solaris 9, see below.  */
 	    regs_off = 96 + 96 + 96 + 160;
 	  else
Index: gcc/config/rx/rx.h
===================================================================
--- a/src/gcc/config/rx/rx.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rx/rx.h	(.../branches/gcc-4_5-branch)
@@ -168,7 +168,7 @@
 
 #define HANDLE_PRAGMA_PACK_PUSH_POP	1
 
-#define HAVE_PRE_DECCREMENT		1
+#define HAVE_PRE_DECREMENT		1
 #define HAVE_POST_INCREMENT		1
 
 #define MOVE_RATIO(SPEED) 		((SPEED) ? 4 : 2)
Index: gcc/config/rx/rx.md
===================================================================
--- a/src/gcc/config/rx/rx.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rx/rx.md	(.../branches/gcc-4_5-branch)
@@ -709,24 +709,24 @@
      (clobber (reg:CC CC_REG))])]
   ""
 {
-  /* ??? Support other conditions via cstore into a temporary?  */
-  if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)
+  /* One operand must be a constant or a register, the other must be a register.  */
+  if (   ! CONSTANT_P (operands[2])
+      && ! CONSTANT_P (operands[3])
+      && ! (REG_P (operands[2]) && REG_P (operands[3])))
     FAIL;
-  /* One operand must be a constant.  */
-  if (!CONSTANT_P (operands[2]) && !CONSTANT_P (operands[3]))
-    FAIL;
 })
 
 (define_insn_and_split "*movsicc"
-  [(set (match_operand:SI     0 "register_operand" "=r,r")
+  [(set (match_operand:SI     0 "register_operand" "=r,r,r")
 	(if_then_else:SI
-	  (match_operator 5 "rx_z_comparison_operator"
-	   [(match_operand:SI 3 "register_operand"  "r,r")
-	    (match_operand:SI 4 "rx_source_operand" "riQ,riQ")])
-	  (match_operand:SI   1 "nonmemory_operand" "i,ri")
-	  (match_operand:SI   2 "nonmemory_operand" "ri,i")))
+	  (match_operator     5 "comparison_operator"
+	   [(match_operand:SI 3 "register_operand"  "r,r,r")
+	    (match_operand:SI 4 "rx_source_operand" "riQ,riQ,riQ")])
+	  (match_operand:SI   1 "nonmemory_operand" "i,ri,r")
+	  (match_operand:SI   2 "nonmemory_operand" "ri,i,r")))
    (clobber (reg:CC CC_REG))]
-  "CONSTANT_P (operands[1]) || CONSTANT_P (operands[2])"
+  "(CONSTANT_P (operands[1]) || CONSTANT_P (operands[2]))
+    || (REG_P (operands[1]) && REG_P (operands[2]))"
   "#"
   "&& reload_completed"
   [(const_int 0)]
@@ -743,8 +743,11 @@
   op1 = operands[1];
   op2 = operands[2];
 
-  /* If OP2 is the constant, reverse the sense of the move.  */
-  if (!CONSTANT_P (operands[1]))
+  /* If OP2 is the constant, reverse the sense of the move.
+     Likewise if both operands are registers but OP1 == OP0.  */
+  if ((! CONSTANT_P (operands[1]) && CONSTANT_P (operands[2]))
+      || (REG_P (operands[1]) && REG_P (operands[2])
+          && rtx_equal_p (op0, op1)))
     {
       x = op1, op1 = op2, op2 = x;
       cmp_code = reverse_condition (cmp_code);
@@ -753,7 +756,7 @@
   /* If OP2 does not match the output, copy it into place.  We have allowed
      these alternatives so that the destination can legitimately be one of
      the comparison operands without increasing register pressure.  */
-  if (!rtx_equal_p (op0, op2))
+  if (! rtx_equal_p (op0, op2))
     emit_move_insn (op0, op2);
 
   x = gen_rtx_fmt_ee (cmp_code, VOIDmode, flags, const0_rtx);
@@ -769,16 +772,33 @@
 	    [(reg CC_REG) (const_int 0)])
 	  (match_operand:SI 1 "immediate_operand" "Sint08,Sint16,Sint24,i")
 	  (match_dup 0)))]
-  "reload_completed"
-{
-  if (GET_CODE (operands[2]) == EQ)
-    return "stz\t%1, %0";
-  else
-    return "stnz\t%1, %0";
-}
+  "reload_completed
+   && ((GET_CODE (operands[2]) == EQ) || (GET_CODE (operands[2]) == NE))"
+  {
+    if (GET_CODE (operands[2]) == EQ)
+      return "stz\t%1, %0";
+    else
+     return "stnz\t%1, %0";
+  }
   [(set_attr "length" "4,5,6,7")]
 )
 
+(define_insn "*stcc_reg"
+  [(set (match_operand:SI 0 "register_operand" "+r,r,r,r,r,r")
+	(if_then_else:SI
+	  (match_operator 2 "comparison_operator"
+	    [(reg CC_REG) (const_int 0)])
+	  (match_operand:SI 1 "nonmemory_operand"
+		              "r,Uint04,Sint08,Sint16,Sint24,i")
+	  (match_dup 0)))]
+  "reload_completed"
+  {
+    PUT_CODE (operands[2], reverse_condition (GET_CODE (operands[2])));
+    return "b%B2 1f\n\tmov %1, %0\n1:";
+  }
+  [(set_attr "length" "3,3,4,5,6,7")]
+)
+
 ;; Arithmetic Instructions
 
 (define_insn "abssi2"
Index: gcc/config/rx/rx.c
===================================================================
--- a/src/gcc/config/rx/rx.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rx/rx.c	(.../branches/gcc-4_5-branch)
@@ -2158,10 +2158,10 @@
       if (! valid_psw_flag (op, "clrpsw"))
 	return NULL_RTX;
       return rx_expand_void_builtin_1_arg (op, gen_clrpsw, false);
+    case RX_BUILTIN_SETPSW:  
       if (! valid_psw_flag (op, "setpsw"))
 	return NULL_RTX;
       return rx_expand_void_builtin_1_arg (op, gen_setpsw, false);
-    case RX_BUILTIN_SETPSW:  
     case RX_BUILTIN_INT:     return rx_expand_void_builtin_1_arg
 	(op, gen_int, false);
     case RX_BUILTIN_MACHI:   return rx_expand_builtin_mac (exp, gen_machi);
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-4_5-branch)
@@ -2430,7 +2430,7 @@
   [(set_attr "type" "*,*,mmx,mmxmov,mmxmov,sselog1,ssemov,ssemov,ssemov,sselog1,ssemov,ssemov,ssemov")
    (set (attr "prefix")
      (if_then_else (eq_attr "alternative" "5,6,7,8")
-       (const_string "vex")
+       (const_string "maybe_vex")
        (const_string "orig")))
    (set_attr "mode" "DI,DI,DI,DI,DI,TI,DI,TI,DI,V4SF,V2SF,V4SF,V2SF")])
 
@@ -2468,21 +2468,15 @@
 	return "movdq2q\t{%1, %0|%0, %1}";
 
     case TYPE_SSEMOV:
-      if (TARGET_AVX)
-	{
-	  if (get_attr_mode (insn) == MODE_TI)
-	    return "vmovdqa\t{%1, %0|%0, %1}";
-	  else
-	    return "vmovq\t{%1, %0|%0, %1}";
-	}
-
       if (get_attr_mode (insn) == MODE_TI)
-	return "movdqa\t{%1, %0|%0, %1}";
-      /* FALLTHRU */
+	return "%vmovdqa\t{%1, %0|%0, %1}";
+      /* Handle broken assemblers that require movd instead of movq.  */
+      if (GENERAL_REG_P (operands[0]) || GENERAL_REG_P (operands[1]))
+	return "%vmovd\t{%1, %0|%0, %1}";
+      return "%vmovq\t{%1, %0|%0, %1}";
 
     case TYPE_MMXMOV:
-      /* Moves from and into integer register is done using movd
-	 opcode with REX prefix.  */
+      /* Handle broken assemblers that require movd instead of movq.  */
       if (GENERAL_REG_P (operands[0]) || GENERAL_REG_P (operands[1]))
 	return "movd\t{%1, %0|%0, %1}";
       return "movq\t{%1, %0|%0, %1}";
@@ -2878,7 +2872,7 @@
    && (reload_in_progress || reload_completed
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
        || (!TARGET_SSE_MATH && optimize_function_for_size_p (cfun)
-	   && standard_80387_constant_p (operands[1]))
+	   && standard_80387_constant_p (operands[1]) > 0)
        || GET_CODE (operands[1]) != CONST_DOUBLE
        || memory_operand (operands[0], SFmode))"
 {
@@ -2915,12 +2909,13 @@
 
     case 9: case 10: case 14: case 15:
       return "movd\t{%1, %0|%0, %1}";
-    case 12: case 13:
-      return "%vmovd\t{%1, %0|%0, %1}";
 
     case 11:
       return "movq\t{%1, %0|%0, %1}";
 
+    case 12: case 13:
+      return "%vmovd\t{%1, %0|%0, %1}";
+
     default:
       gcc_unreachable ();
     }
@@ -3048,11 +3043,10 @@
        || (!(TARGET_SSE2 && TARGET_SSE_MATH)
            && optimize_function_for_size_p (cfun)
            && !memory_operand (operands[0], DFmode)
-	   && standard_80387_constant_p (operands[1]))
+	   && standard_80387_constant_p (operands[1]) > 0)
        || GET_CODE (operands[1]) != CONST_DOUBLE
        || ((optimize_function_for_size_p (cfun)
-            || !TARGET_MEMORY_MISMATCH_STALL
-	    || reload_in_progress || reload_completed)
+            || !TARGET_MEMORY_MISMATCH_STALL)
  	   && memory_operand (operands[0], DFmode)))"
 {
   switch (which_alternative)
@@ -3067,6 +3061,7 @@
     case 3:
     case 4:
       return "#";
+
     case 5:
       switch (get_attr_mode (insn))
 	{
@@ -3200,7 +3195,7 @@
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
        || (!(TARGET_SSE2 && TARGET_SSE_MATH)
            && optimize_function_for_size_p (cfun)
-	   && standard_80387_constant_p (operands[1]))
+	   && standard_80387_constant_p (operands[1]) > 0)
        || GET_CODE (operands[1]) != CONST_DOUBLE
        || memory_operand (operands[0], DFmode))"
 {
@@ -3262,7 +3257,8 @@
 
     case 9:
     case 10:
-    return "%vmovd\t{%1, %0|%0, %1}";
+      /* Handle broken assemblers that require movd instead of movq.  */
+      return "%vmovd\t{%1, %0|%0, %1}";
 
     default:
       gcc_unreachable();
@@ -3340,7 +3336,7 @@
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
        || (!(TARGET_SSE2 && TARGET_SSE_MATH)
            && optimize_function_for_size_p (cfun)
-	   && standard_80387_constant_p (operands[1]))
+	   && standard_80387_constant_p (operands[1]) > 0)
        || GET_CODE (operands[1]) != CONST_DOUBLE
        || memory_operand (operands[0], DFmode))"
 {
@@ -3361,11 +3357,11 @@
       switch (get_attr_mode (insn))
 	{
 	case MODE_V4SF:
-	  return "xorps\t%0, %0";
+	  return "%vxorps\t%0, %d0";
 	case MODE_V2DF:
-	  return "xorpd\t%0, %0";
+	  return "%vxorpd\t%0, %d0";
 	case MODE_TI:
-	  return "pxor\t%0, %0";
+	  return "%vpxor\t%0, %d0";
 	default:
 	  gcc_unreachable ();
 	}
@@ -3375,28 +3371,56 @@
       switch (get_attr_mode (insn))
 	{
 	case MODE_V4SF:
-	  return "movaps\t{%1, %0|%0, %1}";
+	  return "%vmovaps\t{%1, %0|%0, %1}";
 	case MODE_V2DF:
-	  return "movapd\t{%1, %0|%0, %1}";
+	  return "%vmovapd\t{%1, %0|%0, %1}";
 	case MODE_TI:
-	  return "movdqa\t{%1, %0|%0, %1}";
+	  return "%vmovdqa\t{%1, %0|%0, %1}";
 	case MODE_DI:
-	  return "movq\t{%1, %0|%0, %1}";
+	  return "%vmovq\t{%1, %0|%0, %1}";
 	case MODE_DF:
-	  return "movsd\t{%1, %0|%0, %1}";
+	  if (TARGET_AVX)
+	    {
+	      if (REG_P (operands[0]) && REG_P (operands[1]))
+		return "vmovsd\t{%1, %0, %0|%0, %0, %1}";
+	      else
+		return "vmovsd\t{%1, %0|%0, %1}";
+	    }
+	  else
+	    return "movsd\t{%1, %0|%0, %1}";
 	case MODE_V1DF:
-	  return "movlpd\t{%1, %0|%0, %1}";
+	  if (TARGET_AVX)
+	    {
+	      if (REG_P (operands[0]))
+		return "vmovlpd\t{%1, %0, %0|%0, %0, %1}";
+	      else
+		return "vmovlpd\t{%1, %0|%0, %1}";
+	    }
+	  else
+	    return "movlpd\t{%1, %0|%0, %1}";
 	case MODE_V2SF:
-	  return "movlps\t{%1, %0|%0, %1}";
+	  if (TARGET_AVX)
+	    {
+	      if (REG_P (operands[0]))
+		return "vmovlps\t{%1, %0, %0|%0, %0, %1}";
+	      else
+		return "vmovlps\t{%1, %0|%0, %1}";
+	    }
+	  else
+	    return "movlps\t{%1, %0|%0, %1}";
 	default:
 	  gcc_unreachable ();
 	}
 
     default:
-      gcc_unreachable();
+      gcc_unreachable ();
     }
 }
   [(set_attr "type" "fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov")
+   (set (attr "prefix")
+     (if_then_else (eq_attr "alternative" "0,1,2,3,4")
+       (const_string "orig")
+       (const_string "maybe_vex")))
    (set (attr "prefix_data16")
      (if_then_else (eq_attr "mode" "V1DF")
        (const_string "1")
@@ -3543,7 +3567,8 @@
   "optimize_function_for_size_p (cfun)
    && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (reload_in_progress || reload_completed
-       || standard_80387_constant_p (operands[1])
+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
+       || standard_80387_constant_p (operands[1]) > 0
        || GET_CODE (operands[1]) != CONST_DOUBLE
        || memory_operand (operands[0], XFmode))"
 {
@@ -3571,6 +3596,7 @@
   "optimize_function_for_speed_p (cfun)
    && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (reload_in_progress || reload_completed
+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
        || GET_CODE (operands[1]) != CONST_DOUBLE
        || memory_operand (operands[0], XFmode))"
 {
@@ -3715,7 +3741,7 @@
     }
   else if (FP_REG_P (r))
     {
-      if (!standard_80387_constant_p (c))
+      if (standard_80387_constant_p (c) < 1)
 	FAIL;
     }
   else if (MMX_REG_P (r))
@@ -3747,7 +3773,7 @@
     }
   else if (FP_REG_P (r))
     {
-      if (!standard_80387_constant_p (c))
+      if (standard_80387_constant_p (c) < 1)
 	FAIL;
     }
   else if (MMX_REG_P (r))
@@ -17658,7 +17684,8 @@
    (set (match_operand:DI 1 "register_operand" "=S")
 	(plus:DI (match_dup 3)
 		 (const_int 8)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "movsq"
   [(set_attr "type" "str")
    (set_attr "mode" "DI")
@@ -17673,7 +17700,8 @@
    (set (match_operand:SI 1 "register_operand" "=S")
 	(plus:SI (match_dup 3)
 		 (const_int 4)))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "movs{l|d}"
   [(set_attr "type" "str")
    (set_attr "mode" "SI")
@@ -17688,7 +17716,8 @@
    (set (match_operand:DI 1 "register_operand" "=S")
 	(plus:DI (match_dup 3)
 		 (const_int 4)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "movs{l|d}"
   [(set_attr "type" "str")
    (set_attr "mode" "SI")
@@ -17703,7 +17732,8 @@
    (set (match_operand:SI 1 "register_operand" "=S")
 	(plus:SI (match_dup 3)
 		 (const_int 2)))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "movsw"
   [(set_attr "type" "str")
    (set_attr "memory" "both")
@@ -17718,7 +17748,8 @@
    (set (match_operand:DI 1 "register_operand" "=S")
 	(plus:DI (match_dup 3)
 		 (const_int 2)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "movsw"
   [(set_attr "type" "str")
    (set_attr "memory" "both")
@@ -17733,7 +17764,8 @@
    (set (match_operand:SI 1 "register_operand" "=S")
 	(plus:SI (match_dup 3)
 		 (const_int 1)))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "movsb"
   [(set_attr "type" "str")
    (set_attr "memory" "both")
@@ -17748,7 +17780,8 @@
    (set (match_operand:DI 1 "register_operand" "=S")
 	(plus:DI (match_dup 3)
 		 (const_int 1)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "movsb"
   [(set_attr "type" "str")
    (set_attr "memory" "both")
@@ -17779,7 +17812,8 @@
    (set (mem:BLK (match_dup 3))
 	(mem:BLK (match_dup 4)))
    (use (match_dup 5))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "rep{%;} movsq"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -17798,7 +17832,8 @@
    (set (mem:BLK (match_dup 3))
 	(mem:BLK (match_dup 4)))
    (use (match_dup 5))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "rep{%;} movs{l|d}"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -17817,7 +17852,8 @@
    (set (mem:BLK (match_dup 3))
 	(mem:BLK (match_dup 4)))
    (use (match_dup 5))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "rep{%;} movs{l|d}"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -17834,7 +17870,8 @@
    (set (mem:BLK (match_dup 3))
 	(mem:BLK (match_dup 4)))
    (use (match_dup 5))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "rep{%;} movsb"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -17851,7 +17888,8 @@
    (set (mem:BLK (match_dup 3))
 	(mem:BLK (match_dup 4)))
    (use (match_dup 5))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "rep{%;} movsb"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -17911,7 +17949,9 @@
   operands[3] = gen_rtx_PLUS (Pmode, operands[0],
 			      GEN_INT (GET_MODE_SIZE (GET_MODE
 						      (operands[2]))));
-  if (TARGET_SINGLE_STRINGOP || optimize_insn_for_size_p ())
+  /* Can't use this if the user has appropriated eax or edi.  */
+  if ((TARGET_SINGLE_STRINGOP || optimize_insn_for_size_p ())
+      && !(fixed_regs[AX_REG] || fixed_regs[DI_REG]))
     {
       emit_insn (gen_strset_singleop (operands[0], operands[1], operands[2],
 				      operands[3]));
@@ -17933,7 +17973,8 @@
    (set (match_operand:DI 0 "register_operand" "=D")
 	(plus:DI (match_dup 1)
 		 (const_int 8)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])"
   "stosq"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
@@ -17945,7 +17986,8 @@
    (set (match_operand:SI 0 "register_operand" "=D")
 	(plus:SI (match_dup 1)
 		 (const_int 4)))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])"
   "stos{l|d}"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
@@ -17957,7 +17999,8 @@
    (set (match_operand:DI 0 "register_operand" "=D")
 	(plus:DI (match_dup 1)
 		 (const_int 4)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])"
   "stos{l|d}"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
@@ -17969,7 +18012,8 @@
    (set (match_operand:SI 0 "register_operand" "=D")
 	(plus:SI (match_dup 1)
 		 (const_int 2)))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])"
   "stosw"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
@@ -17981,7 +18025,8 @@
    (set (match_operand:DI 0 "register_operand" "=D")
 	(plus:DI (match_dup 1)
 		 (const_int 2)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])"
   "stosw"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
@@ -17993,7 +18038,8 @@
    (set (match_operand:SI 0 "register_operand" "=D")
 	(plus:SI (match_dup 1)
 		 (const_int 1)))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])"
   "stosb"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
@@ -18005,7 +18051,8 @@
    (set (match_operand:DI 0 "register_operand" "=D")
 	(plus:DI (match_dup 1)
 		 (const_int 1)))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[DI_REG])"
   "stosb"
   [(set_attr "type" "str")
    (set_attr "memory" "store")
@@ -18032,7 +18079,8 @@
 	(const_int 0))
    (use (match_operand:DI 2 "register_operand" "a"))
    (use (match_dup 4))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])"
   "rep{%;} stosq"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -18049,7 +18097,8 @@
 	(const_int 0))
    (use (match_operand:SI 2 "register_operand" "a"))
    (use (match_dup 4))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])"
   "rep{%;} stos{l|d}"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -18066,7 +18115,8 @@
 	(const_int 0))
    (use (match_operand:SI 2 "register_operand" "a"))
    (use (match_dup 4))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])"
   "rep{%;} stos{l|d}"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -18082,7 +18132,8 @@
 	(const_int 0))
    (use (match_operand:QI 2 "register_operand" "a"))
    (use (match_dup 4))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])"
   "rep{%;} stosb"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -18098,7 +18149,8 @@
 	(const_int 0))
    (use (match_operand:QI 2 "register_operand" "a"))
    (use (match_dup 4))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])"
   "rep{%;} stosb"
   [(set_attr "type" "str")
    (set_attr "prefix_rep" "1")
@@ -18119,8 +18171,8 @@
   if (optimize_insn_for_size_p () && !TARGET_INLINE_ALL_STRINGOPS)
     FAIL;
 
-  /* Can't use this if the user has appropriated esi or edi.  */
-  if (fixed_regs[SI_REG] || fixed_regs[DI_REG])
+  /* Can't use this if the user has appropriated ecx, esi or edi.  */
+  if (fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])
     FAIL;
 
   out = operands[0];
@@ -18214,7 +18266,8 @@
    (clobber (match_operand:SI 0 "register_operand" "=S"))
    (clobber (match_operand:SI 1 "register_operand" "=D"))
    (clobber (match_operand:SI 2 "register_operand" "=c"))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "repz{%;} cmpsb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
@@ -18229,7 +18282,8 @@
    (clobber (match_operand:DI 0 "register_operand" "=S"))
    (clobber (match_operand:DI 1 "register_operand" "=D"))
    (clobber (match_operand:DI 2 "register_operand" "=c"))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "repz{%;} cmpsb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
@@ -18265,7 +18319,8 @@
    (clobber (match_operand:SI 0 "register_operand" "=S"))
    (clobber (match_operand:SI 1 "register_operand" "=D"))
    (clobber (match_operand:SI 2 "register_operand" "=c"))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "repz{%;} cmpsb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
@@ -18283,7 +18338,8 @@
    (clobber (match_operand:DI 0 "register_operand" "=S"))
    (clobber (match_operand:DI 1 "register_operand" "=D"))
    (clobber (match_operand:DI 2 "register_operand" "=c"))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])"
   "repz{%;} cmpsb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
@@ -18295,7 +18351,7 @@
 	(unspec:SI [(match_operand:BLK 1 "general_operand" "")
 		    (match_operand:QI 2 "immediate_operand" "")
 		    (match_operand 3 "immediate_operand" "")] UNSPEC_SCAS))]
-  ""
+  "!TARGET_64BIT"
 {
  if (ix86_expand_strlen (operands[0], operands[1], operands[2], operands[3]))
    DONE;
@@ -18308,7 +18364,7 @@
 	(unspec:DI [(match_operand:BLK 1 "general_operand" "")
 		    (match_operand:QI 2 "immediate_operand" "")
 		    (match_operand 3 "immediate_operand" "")] UNSPEC_SCAS))]
-  ""
+  "TARGET_64BIT"
 {
  if (ix86_expand_strlen (operands[0], operands[1], operands[2], operands[3]))
    DONE;
@@ -18331,7 +18387,8 @@
 		    (match_operand:SI 4 "register_operand" "0")] UNSPEC_SCAS))
    (clobber (match_operand:SI 1 "register_operand" "=D"))
    (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT"
+  "!TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])"
   "repnz{%;} scasb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
@@ -18345,7 +18402,8 @@
 		    (match_operand:DI 4 "register_operand" "0")] UNSPEC_SCAS))
    (clobber (match_operand:DI 1 "register_operand" "=D"))
    (clobber (reg:CC FLAGS_REG))]
-  "TARGET_64BIT"
+  "TARGET_64BIT
+   && !(fixed_regs[AX_REG] || fixed_regs[CX_REG] || fixed_regs[DI_REG])"
   "repnz{%;} scasb"
   [(set_attr "type" "str")
    (set_attr "mode" "QI")
Index: gcc/config/i386/mmx.md
===================================================================
--- a/src/gcc/config/i386/mmx.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/mmx.md	(.../branches/gcc-4_5-branch)
@@ -63,6 +63,7 @@
   DONE;
 })
 
+;; movd instead of movq is required to handle broken assemblers.
 (define_insn "*mov<mode>_internal_rex64"
   [(set (match_operand:MMXMODEI8 0 "nonimmediate_operand"
 				"=rm,r,!?y,!?y ,m  ,!y,*Y2,x,x ,m,r,Yi")
@@ -81,8 +82,8 @@
     %vpxor\t%0, %d0
     %vmovq\t{%1, %0|%0, %1}
     %vmovq\t{%1, %0|%0, %1}
-    %vmovq\t{%1, %0|%0, %1}
-    %vmovq\t{%1, %0|%0, %1}"
+    %vmovd\t{%1, %0|%0, %1}
+    %vmovd\t{%1, %0|%0, %1}"
   [(set_attr "type" "imov,imov,mmx,mmxmov,mmxmov,ssecvt,ssecvt,sselog1,ssemov,ssemov,ssemov,ssemov")
    (set_attr "unit" "*,*,*,*,*,mmx,mmx,*,*,*,*,*")
    (set_attr "prefix_rep" "*,*,*,*,*,1,1,*,1,*,*,*")
@@ -192,6 +193,7 @@
        (const_string "orig")))
    (set_attr "mode" "DI,DI,DI,DI,DI,DI,DI,V4SF,V4SF,V2SF,V2SF,DI,DI")])
 
+;; movd instead of movq is required to handle broken assemblers.
 (define_insn "*movv2sf_internal_rex64"
   [(set (match_operand:V2SF 0 "nonimmediate_operand"
 				"=rm,r ,!?y,!?y ,m ,!y,*Y2,x,x,x,m,r,Yi")
Index: gcc/config/i386/constraints.md
===================================================================
--- a/src/gcc/config/i386/constraints.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/constraints.md	(.../branches/gcc-4_5-branch)
@@ -149,7 +149,7 @@
 (define_constraint "G"
   "Standard 80387 floating point constant."
   (and (match_code "const_double")
-       (match_test "standard_80387_constant_p (op)")))
+       (match_test "standard_80387_constant_p (op) > 0")))
 
 ;; This can theoretically be any mode's CONST0_RTX.
 (define_constraint "C"
Index: gcc/config/i386/athlon.md
===================================================================
--- a/src/gcc/config/i386/athlon.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/athlon.md	(.../branches/gcc-4_5-branch)
@@ -798,7 +798,7 @@
 			 "athlon-direct,athlon-fploadk8,athlon-fadd")
 (define_insn_reservation "athlon_ssecomi" 4
 			 (and (eq_attr "cpu" "athlon,k8,generic64")
-			      (eq_attr "type" "ssecmp"))
+			      (eq_attr "type" "ssecomi"))
 			 "athlon-vector,athlon-fpsched,athlon-fadd")
 (define_insn_reservation "athlon_ssecomi_amdfam10" 3
 			 (and (eq_attr "cpu" "amdfam10")
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-4_5-branch)
@@ -3904,7 +3904,7 @@
   "TARGET_SSE"
 {
   if (!TARGET_AVX)
-    operands[1] = force_reg (V4SFmode, operands[1]);
+    operands[1] = force_reg (SFmode, operands[1]);
 })
 
 (define_insn "*vec_dupv4sf_avx"
@@ -4551,15 +4551,14 @@
   [(set (match_operand:V4DF 0 "register_operand"         "=x,x")
 	(vec_select:V4DF
 	  (vec_concat:V8DF
-	    (match_operand:V4DF 1 "nonimmediate_operand" "xm,x")
-	    (match_operand:V4DF 2 "nonimmediate_operand" " 1,xm"))
+	    (match_operand:V4DF 1 "nonimmediate_operand" " x,m")
+	    (match_operand:V4DF 2 "nonimmediate_operand" "xm,1"))
 	  (parallel [(const_int 0) (const_int 4)
 		     (const_int 2) (const_int 6)])))]
-  "TARGET_AVX
-   && (!MEM_P (operands[1]) || rtx_equal_p (operands[1], operands[2]))"
+  "TARGET_AVX"
   "@
-   vmovddup\t{%1, %0|%0, %1}
-   vunpcklpd\t{%2, %1, %0|%0, %1, %2}"
+   vunpcklpd\t{%2, %1, %0|%0, %1, %2}
+   vmovddup\t{%1, %0|%0, %1}"
   [(set_attr "type" "sselog")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4DF")])
@@ -4964,24 +4963,22 @@
 ;; Avoid combining registers from different units in a single alternative,
 ;; see comment above inline_secondary_memory_needed function in i386.c
 (define_insn "sse2_loadhpd"
-  [(set (match_operand:V2DF 0 "nonimmediate_operand"     "=x,x,x,o,o,o")
+  [(set (match_operand:V2DF 0 "nonimmediate_operand"     "=x,x,o,o,o")
 	(vec_concat:V2DF
 	  (vec_select:DF
-	    (match_operand:V2DF 1 "nonimmediate_operand" " 0,0,x,0,0,0")
+	    (match_operand:V2DF 1 "nonimmediate_operand" " 0,0,0,0,0")
 	    (parallel [(const_int 0)]))
-	  (match_operand:DF 2 "nonimmediate_operand"     " m,x,0,x,*f,r")))]
+	  (match_operand:DF 2 "nonimmediate_operand"     " m,x,x,*f,r")))]
   "TARGET_SSE2 && !(MEM_P (operands[1]) && MEM_P (operands[2]))"
   "@
    movhpd\t{%2, %0|%0, %2}
    unpcklpd\t{%2, %0|%0, %2}
-   shufpd\t{$1, %1, %0|%0, %1, 1}
    #
    #
    #"
-  [(set_attr "type" "ssemov,sselog,sselog,ssemov,fmov,imov")
-   (set_attr "prefix_data16" "1,*,*,*,*,*")
-   (set_attr "length_immediate" "*,*,1,*,*,*")
-   (set_attr "mode" "V1DF,V2DF,V2DF,DF,DF,DF")])
+  [(set_attr "type" "ssemov,sselog,ssemov,fmov,imov")
+   (set_attr "prefix_data16" "1,*,*,*,*")
+   (set_attr "mode" "V1DF,V2DF,DF,DF,DF")])
 
 (define_split
   [(set (match_operand:V2DF 0 "memory_operand" "")
@@ -5137,6 +5134,16 @@
    (set_attr "length_immediate" "*,*,*,1,*,*")
    (set_attr "mode" "DF,V1DF,V1DF,V2DF,V1DF,V1DF")])
 
+(define_expand "vec_dupv2df"
+  [(set (match_operand:V2DF 0 "register_operand" "")
+	(vec_duplicate:V2DF
+	  (match_operand:DF 1 "nonimmediate_operand" "")))]
+  "TARGET_SSE2"
+{
+  if (!TARGET_SSE3)
+    operands[1] = force_reg (DFmode, operands[1]);
+})
+
 (define_insn "*vec_dupv2df_sse3"
   [(set (match_operand:V2DF 0 "register_operand" "=x")
 	(vec_duplicate:V2DF
@@ -5147,7 +5154,7 @@
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "DF")])
 
-(define_insn "vec_dupv2df"
+(define_insn "*vec_dupv2df"
   [(set (match_operand:V2DF 0 "register_operand" "=x")
 	(vec_duplicate:V2DF
 	  (match_operand:DF 1 "register_operand" "0")))]
@@ -7473,9 +7480,8 @@
   "@
    #
    #
-   %vmov{q}\t{%1, %0|%0, %1}"
+   mov{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "*,*,imov")
-   (set_attr "prefix" "*,*,maybe_vex")
    (set_attr "mode" "*,*,DI")])
 
 (define_insn "*sse2_storeq"
@@ -7513,11 +7519,11 @@
    vmovhps\t{%1, %0|%0, %1}
    vpsrldq\t{$8, %1, %0|%0, %1, 8}
    vmovq\t{%H1, %0|%0, %H1}
-   vmov{q}\t{%H1, %0|%0, %H1}"
+   mov{q}\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft1,ssemov,imov")
    (set_attr "length_immediate" "*,1,*,*")
    (set_attr "memory" "*,none,*,*")
-   (set_attr "prefix" "vex")
+   (set_attr "prefix" "vex,vex,vex,orig")
    (set_attr "mode" "V2SF,TI,TI,DI")])
 
 (define_insn "*vec_extractv2di_1_rex64"
@@ -7795,6 +7801,7 @@
        (const_string "vex")))
    (set_attr "mode" "TI,TI,TI,TI,TI,V2SF")])
 
+;; movd instead of movq is required to handle broken assemblers.
 (define_insn "*vec_concatv2di_rex64_sse4_1"
   [(set (match_operand:V2DI 0 "register_operand"     "=x ,x ,Yi,!x,x,x,x")
 	(vec_concat:V2DI
@@ -7804,7 +7811,7 @@
   "@
    pinsrq\t{$0x1, %2, %0|%0, %2, 0x1}
    movq\t{%1, %0|%0, %1}
-   movq\t{%1, %0|%0, %1}
+   movd\t{%1, %0|%0, %1}
    movq2dq\t{%1, %0|%0, %1}
    punpcklqdq\t{%2, %0|%0, %2}
    movlhps\t{%2, %0|%0, %2}
@@ -7815,6 +7822,7 @@
    (set_attr "length_immediate" "1,*,*,*,*,*,*")
    (set_attr "mode" "TI,TI,TI,TI,TI,V4SF,V2SF")])
 
+;; movd instead of movq is required to handle broken assemblers.
 (define_insn "*vec_concatv2di_rex64_sse"
   [(set (match_operand:V2DI 0 "register_operand"     "=Y2 ,Yi,!Y2,Y2,x,x")
 	(vec_concat:V2DI
@@ -7823,7 +7831,7 @@
   "TARGET_64BIT && TARGET_SSE"
   "@
    movq\t{%1, %0|%0, %1}
-   movq\t{%1, %0|%0, %1}
+   movd\t{%1, %0|%0, %1}
    movq2dq\t{%1, %0|%0, %1}
    punpcklqdq\t{%2, %0|%0, %2}
    movlhps\t{%2, %0|%0, %2}
@@ -10576,8 +10584,8 @@
   [(set (match_operand:SSEMODE 0 "register_operand" "=x,x")
 	(if_then_else:SSEMODE
 	  (match_operand:SSEMODE 3 "nonimmediate_operand" "x,m")
-	  (match_operand:SSEMODE 1 "vector_move_operand" "x,x")
-	  (match_operand:SSEMODE 2 "vector_move_operand" "xm,x")))]
+	  (match_operand:SSEMODE 1 "register_operand" "x,x")
+	  (match_operand:SSEMODE 2 "nonimmediate_operand" "xm,x")))]
   "TARGET_XOP"
   "vpcmov\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "sse4arg")])
@@ -10586,8 +10594,8 @@
   [(set (match_operand:AVX256MODE 0 "register_operand" "=x,x")
 	(if_then_else:AVX256MODE
 	  (match_operand:AVX256MODE 3 "nonimmediate_operand" "x,m")
-	  (match_operand:AVX256MODE 1 "vector_move_operand" "x,x")
-	  (match_operand:AVX256MODE 2 "vector_move_operand" "xm,x")))]
+	  (match_operand:AVX256MODE 1 "register_operand" "x,x")
+	  (match_operand:AVX256MODE 2 "nonimmediate_operand" "xm,x")))]
   "TARGET_XOP"
   "vpcmov\t{%3, %2, %1, %0|%0, %1, %2, %3}"
   [(set_attr "type" "sse4arg")])
@@ -12136,8 +12144,7 @@
   [(set (match_operand:AVXMODEF2P 0 "register_operand" "=x")
 	(unspec:AVXMODEF2P
 	  [(match_operand:AVXMODEF2P 1 "memory_operand" "m")
-	   (match_operand:<avxpermvecmode> 2 "register_operand" "x")
-	   (match_dup 0)]
+	   (match_operand:<avxpermvecmode> 2 "register_operand" "x")]
 	  UNSPEC_MASKLOAD))]
   "TARGET_AVX"
   "vmaskmovp<avxmodesuffixf2c>\t{%1, %2, %0|%0, %2, %1}"
Index: gcc/config/i386/darwin.h
===================================================================
--- a/src/gcc/config/i386/darwin.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/darwin.h	(.../branches/gcc-4_5-branch)
@@ -302,3 +302,17 @@
 #define MACHO_SYMBOL_FLAG_VARIABLE ((SYMBOL_FLAG_MACH_DEP) << 3)
 
 #define SUBTARGET32_DEFAULT_CPU "i686"
+
+#define SUBTARGET_INIT_BUILTINS					\
+do {								\
+  darwin_rename_builtins ();					\
+} while(0)
+ 
+/* The system ___divdc3 routine in libSystem on darwin10 is not
+   accurate to 1ulp, ours is, so we avoid ever using the system name
+   for this routine and instead install a non-conflicting name that is
+   accurate.  See darwin_rename_builtins.  */
+#ifdef L_divdc3
+#define DECLARE_LIBRARY_RENAMES \
+  asm(".text; ___divdc3: jmp ___ieee_divdc3 ; .globl ___divdc3");
+#endif
Index: gcc/config/i386/avxintrin.h
===================================================================
--- a/src/gcc/config/i386/avxintrin.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/avxintrin.h	(.../branches/gcc-4_5-branch)
@@ -759,7 +759,7 @@
 
 #ifdef __x86_64__
 extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_insert_epi64 (__m256i __X, int __D, int const __N)
+_mm256_insert_epi64 (__m256i __X, long long __D, int const __N)
 {
   __m128i __Y = _mm256_extractf128_si256 (__X, __N >> 1);
   __Y = _mm_insert_epi64 (__Y, __D, __N % 2);
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-4_5-branch)
@@ -14610,11 +14610,15 @@
       if (req_mode == CCZmode)
 	return 0;
       /* FALLTHRU */
+    case CCZmode:
+      break;
+
     case CCAmode:
     case CCCmode:
     case CCOmode:
     case CCSmode:
-    case CCZmode:
+      if (set_mode != req_mode)
+	return 0;
       break;
 
     default:
@@ -16196,11 +16200,15 @@
     }
   else if (TARGET_XOP)
     {
-      rtx pcmov = gen_rtx_SET (mode, dest,
-			       gen_rtx_IF_THEN_ELSE (mode, cmp,
-						     op_true,
-						     op_false));
-      emit_insn (pcmov);
+      op_true = force_reg (mode, op_true);
+
+      if (!nonimmediate_operand (op_false, mode))
+	op_false = force_reg (mode, op_false);
+
+      emit_insn (gen_rtx_SET (mode, dest,
+			      gen_rtx_IF_THEN_ELSE (mode, cmp,
+						    op_true,
+						    op_false)));
     }
   else
     {
@@ -25067,7 +25075,7 @@
 	 zero above.  We only want to wind up preferring 80387 registers if
 	 we plan on doing computation with them.  */
       if (TARGET_80387
-	  && standard_80387_constant_p (x))
+	  && standard_80387_constant_p (x) > 0)
 	{
 	  /* Limit class to non-sse.  */
 	  if (regclass == FLOAT_SSE_REGS)
@@ -27711,10 +27719,19 @@
       break;
 
     case V2DImode:
-      use_vec_merge = TARGET_SSE4_1;
+      use_vec_merge = TARGET_SSE4_1 && TARGET_64BIT;
       if (use_vec_merge)
 	break;
 
+      tmp = gen_reg_rtx (GET_MODE_INNER (mode));
+      ix86_expand_vector_extract (false, tmp, target, 1 - elt);
+      if (elt == 0)
+	tmp = gen_rtx_VEC_CONCAT (mode, tmp, val);
+      else
+	tmp = gen_rtx_VEC_CONCAT (mode, val, tmp);
+      emit_insn (gen_rtx_SET (VOIDmode, target, tmp));
+      return;
+
     case V2DFmode:
       {
 	rtx op0, op1;
@@ -30652,6 +30669,11 @@
 #undef TARGET_ASM_CODE_END
 #define TARGET_ASM_CODE_END ix86_code_end
 
+#if TARGET_MACHO
+#undef TARGET_INIT_LIBFUNCS
+#define TARGET_INIT_LIBFUNCS darwin_rename_builtins
+#endif
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-i386.h"
Index: gcc/config/darwin-protos.h
===================================================================
--- a/src/gcc/config/darwin-protos.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/darwin-protos.h	(.../branches/gcc-4_5-branch)
@@ -93,3 +93,4 @@
 extern bool darwin_kextabi_p (void);
 extern void darwin_override_options (void);
 extern void darwin_patch_builtins (void);
+extern void darwin_rename_builtins (void);
Index: gcc/config/sh/sh.c
===================================================================
--- a/src/gcc/config/sh/sh.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sh/sh.c	(.../branches/gcc-4_5-branch)
@@ -1945,7 +1945,10 @@
 	  else if (op2h != CONST0_RTX (SImode))
 	    msw_taken = LTU;
 	  else
-	    break;
+	    {
+	      msw_skip = swap_condition (LTU);
+	      break;
+	    }
 	  msw_skip = swap_condition (msw_taken);
 	}
       break;
@@ -1998,6 +2001,13 @@
 	{
 	  operands[1] = op1h;
 	  operands[2] = op2h;
+	  if (reload_completed
+	      && ! arith_reg_or_0_operand (op2h, SImode)
+	      && (true_regnum (op1h) || (comparison != EQ && comparison != NE)))
+	    {
+	      emit_move_insn (scratch, operands[2]);
+	      operands[2] = scratch;
+	    }
 	}
 
       operands[3] = skip_label = gen_label_rtx ();
Index: gcc/config/sh/sh.md
===================================================================
--- a/src/gcc/config/sh/sh.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/sh/sh.md	(.../branches/gcc-4_5-branch)
@@ -149,6 +149,7 @@
   (UNSPEC_DIV_INV_TABLE	37)
   (UNSPEC_ASHIFTRT	35)
   (UNSPEC_THUNK		36)
+  (UNSPEC_CHKADD	38)
   (UNSPEC_SP_SET	40)
   (UNSPEC_SP_TEST	41)
   (UNSPEC_MOVUA		42)
@@ -8438,6 +8439,22 @@
   i++;
 }")
 
+;; op0 = op1 + r12 but hide it before reload completed.  See the comment
+;; in symGOT_load expand.
+
+(define_insn_and_split "chk_guard_add"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(unspec:SI [(match_operand:SI 1 "register_operand" "r")
+		    (reg:SI PIC_REG)]
+		   UNSPEC_CHKADD))]
+  "TARGET_SH1"
+  "#"
+  "TARGET_SH1 && reload_completed"
+  [(set (match_dup 0) (reg:SI PIC_REG))
+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))]
+  ""
+  [(set_attr "type" "arith")])
+
 (define_expand "sym_label2reg"
   [(set (match_operand:SI 0 "" "")
 	(const:SI (unspec:SI [(match_operand:SI 1 "" "")
@@ -8480,13 +8497,9 @@
   else
     emit_move_insn (operands[2], operands[1]);
 
-  emit_move_insn (operands[3], gen_rtx_PLUS (Pmode,
-					     operands[2],
-					     gen_rtx_REG (Pmode, PIC_REG)));
-
   /* When stack protector inserts codes after the result is set to
-     R0, @(rX, r12) will cause a spill failure for R0.  Don't schedule
-     insns to avoid combining (set A (plus rX r12)) and (set op0 (mem A))
+     R0, @(rX, r12) will cause a spill failure for R0.  Use a unspec
+     insn to avoid combining (set A (plus rX r12)) and (set op0 (mem A))
      when rX is a GOT address for the guard symbol.  Ugly but doesn't
      matter because this is a rare situation.  */
   if (!TARGET_SHMEDIA
@@ -8496,7 +8509,10 @@
       && GET_CODE (XVECEXP (XEXP (operands[1], 0), 0, 0)) == SYMBOL_REF
       && strcmp (XSTR (XVECEXP (XEXP (operands[1], 0), 0, 0), 0),
 		 \"__stack_chk_guard\") == 0)
-    emit_insn (gen_blockage ());
+    emit_insn (gen_chk_guard_add (operands[3], operands[2]));
+  else
+    emit_move_insn (operands[3], gen_rtx_PLUS (Pmode, operands[2],
+					       gen_rtx_REG (Pmode, PIC_REG)));
 
   /* N.B. This is not constant for a GOTPLT relocation.  */
   mem = gen_rtx_MEM (Pmode, operands[3]);
Index: gcc/config/lm32/t-lm32
===================================================================
--- a/src/gcc/config/lm32/t-lm32	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/lm32/t-lm32	(.../branches/gcc-4_5-branch)
@@ -1,2 +1,2 @@
 # for multilib
-MULTILIB_OPTIONS = mmultiply-enabled mbarrel-shift-enabled
+MULTILIB_OPTIONS = mbarrel-shift-enabled mmultiply-enabled mdivide-enabled msign-extend-enabled
Index: gcc/config/rs6000/vector.md
===================================================================
--- a/src/gcc/config/rs6000/vector.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rs6000/vector.md	(.../branches/gcc-4_5-branch)
@@ -447,21 +447,21 @@
   [(set (match_operand:VEC_L 0 "vlogical_operand" "")
 	(if_then_else:VEC_L
 	 (ne:CC (match_operand:VEC_L 3 "vlogical_operand" "")
-		(const_int 0))
+		(match_dup 4))
 	 (match_operand:VEC_L 2 "vlogical_operand" "")
 	 (match_operand:VEC_L 1 "vlogical_operand" "")))]
   "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
-  "")
+  "operands[4] = CONST0_RTX (<MODE>mode);")
 
 (define_expand "vector_select_<mode>_uns"
   [(set (match_operand:VEC_L 0 "vlogical_operand" "")
 	(if_then_else:VEC_L
 	 (ne:CCUNS (match_operand:VEC_L 3 "vlogical_operand" "")
-		   (const_int 0))
+		   (match_dup 4))
 	 (match_operand:VEC_L 2 "vlogical_operand" "")
 	 (match_operand:VEC_L 1 "vlogical_operand" "")))]
   "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
-  "")
+  "operands[4] = CONST0_RTX (<MODE>mode);")
 
 ;; Expansions that compare vectors producing a vector result and a predicate,
 ;; setting CR6 to indicate a combined status
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_5-branch)
@@ -5426,10 +5426,11 @@
 
       if (model == TLS_MODEL_GLOBAL_DYNAMIC)
 	{
-	  r3 = gen_rtx_REG (Pmode, 3);
 	  tga = rs6000_tls_get_addr ();
-	  emit_library_call_value (tga, dest, LCT_CONST, Pmode, 1, r3, Pmode);
+	  emit_library_call_value (tga, dest, LCT_CONST, Pmode,
+				   1, const0_rtx, Pmode);
 
+	  r3 = gen_rtx_REG (Pmode, 3);
 	  if (DEFAULT_ABI == ABI_AIX && TARGET_64BIT)
 	    insn = gen_tls_gd_aix64 (r3, got, addr, tga, const0_rtx);
 	  else if (DEFAULT_ABI == ABI_AIX && !TARGET_64BIT)
@@ -5446,11 +5447,12 @@
 	}
       else if (model == TLS_MODEL_LOCAL_DYNAMIC)
 	{
-	  r3 = gen_rtx_REG (Pmode, 3);
 	  tga = rs6000_tls_get_addr ();
 	  tmp1 = gen_reg_rtx (Pmode);
-	  emit_library_call_value (tga, tmp1, LCT_CONST, Pmode, 1, r3, Pmode);
+	  emit_library_call_value (tga, tmp1, LCT_CONST, Pmode,
+				   1, const0_rtx, Pmode);
 
+	  r3 = gen_rtx_REG (Pmode, 3);
 	  if (DEFAULT_ABI == ABI_AIX && TARGET_64BIT)
 	    insn = gen_tls_ld_aix64 (r3, got, tga, const0_rtx);
 	  else if (DEFAULT_ABI == ABI_AIX && !TARGET_64BIT)
@@ -6694,7 +6696,7 @@
 
 /* Nonzero if we can use an AltiVec register to pass this arg.  */
 #define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,TYPE,NAMED)		\
-  ((ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE))	\
+  (ALTIVEC_OR_VSX_VECTOR_MODE (MODE)				\
    && (CUM)->vregno <= ALTIVEC_ARG_MAX_REG			\
    && TARGET_ALTIVEC_ABI					\
    && (NAMED))
@@ -6920,7 +6922,7 @@
    existing library interfaces.
 
    Doubleword align SPE vectors.
-   Quadword align Altivec vectors.
+   Quadword align Altivec/VSX vectors.
    Quadword align large synthetic vector types.   */
 
 int
@@ -6937,7 +6939,7 @@
 	       && int_size_in_bytes (type) >= 8
 	       && int_size_in_bytes (type) < 16))
     return 64;
-  else if ((ALTIVEC_VECTOR_MODE (mode) || VSX_VECTOR_MODE (mode))
+  else if (ALTIVEC_OR_VSX_VECTOR_MODE (mode)
 	   || (type && TREE_CODE (type) == VECTOR_TYPE
 	       && int_size_in_bytes (type) >= 16))
     return 128;
@@ -7082,8 +7084,7 @@
     cum->nargs_prototype--;
 
   if (TARGET_ALTIVEC_ABI
-      && (ALTIVEC_VECTOR_MODE (mode)
-	  || VSX_VECTOR_MODE (mode)
+      && (ALTIVEC_OR_VSX_VECTOR_MODE (mode)
 	  || (type && TREE_CODE (type) == VECTOR_TYPE
 	      && int_size_in_bytes (type) == 16)))
     {
@@ -7677,8 +7678,7 @@
     else
       return gen_rtx_REG (mode, cum->vregno);
   else if (TARGET_ALTIVEC_ABI
-	   && (ALTIVEC_VECTOR_MODE (mode)
-	       || VSX_VECTOR_MODE (mode)
+	   && (ALTIVEC_OR_VSX_VECTOR_MODE (mode)
 	       || (type && TREE_CODE (type) == VECTOR_TYPE
 		   && int_size_in_bytes (type) == 16)))
     {
@@ -16007,7 +16007,7 @@
       op_false = tmp;
     }
 
-  cond2 = gen_rtx_fmt_ee (NE, cc_mode, mask, const0_rtx);
+  cond2 = gen_rtx_fmt_ee (NE, cc_mode, mask, CONST0_RTX (dest_mode));
   emit_insn (gen_rtx_SET (VOIDmode,
 			  dest,
 			  gen_rtx_IF_THEN_ELSE (dest_mode,
@@ -18280,7 +18280,7 @@
 
   /* Some cases that need register indexed addressing.  */
   if ((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))
-      || (TARGET_VSX && VSX_VECTOR_MODE (mode))
+      || (TARGET_VSX && ALTIVEC_OR_VSX_VECTOR_MODE (mode))
       || (TARGET_E500_DOUBLE && mode == DFmode)
       || (TARGET_SPE_ABI
 	  && SPE_VECTOR_MODE (mode)
@@ -18504,7 +18504,7 @@
 {
   /* This blockage is needed so that sched doesn't decide to move
      the sp change before the register restores.  */
-  if (frame_reg_rtx != sp_reg_rtx
+  if (DEFAULT_ABI == ABI_V4
       || (TARGET_SPE_ABI
 	  && info->spe_64bit_regs_used != 0
 	  && info->first_gp_reg_save != 32))
@@ -25565,14 +25565,13 @@
   else if (TREE_CODE (valtype) == COMPLEX_TYPE
 	   && targetm.calls.split_complex_arg)
     return rs6000_complex_function_value (mode);
+  /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same
+     return register is used in both cases, and we won't see V2DImode/V2DFmode
+     for pure altivec, combine the two cases.  */
   else if (TREE_CODE (valtype) == VECTOR_TYPE
 	   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI
-	   && ALTIVEC_VECTOR_MODE (mode))
+	   && ALTIVEC_OR_VSX_VECTOR_MODE (mode))
     regno = ALTIVEC_ARG_RETURN;
-  else if (TREE_CODE (valtype) == VECTOR_TYPE
-	   && TARGET_VSX && TARGET_ALTIVEC_ABI
-	   && VSX_VECTOR_MODE (mode))
-    regno = ALTIVEC_ARG_RETURN;
   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT
 	   && (mode == DFmode || mode == DCmode
 	       || mode == TFmode || mode == TCmode))
@@ -25611,12 +25610,12 @@
 	   && TARGET_HARD_FLOAT && TARGET_FPRS
            && ((TARGET_SINGLE_FLOAT && mode == SFmode) || TARGET_DOUBLE_FLOAT))
     regno = FP_ARG_RETURN;
-  else if (ALTIVEC_VECTOR_MODE (mode)
+  /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same
+     return register is used in both cases, and we won't see V2DImode/V2DFmode
+     for pure altivec, combine the two cases.  */
+  else if (ALTIVEC_OR_VSX_VECTOR_MODE (mode)
 	   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)
     regno = ALTIVEC_ARG_RETURN;
-  else if (VSX_VECTOR_MODE (mode)
-	   && TARGET_VSX && TARGET_ALTIVEC_ABI)
-    regno = ALTIVEC_ARG_RETURN;
   else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)
     return rs6000_complex_function_value (mode);
   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT

Property changes on: gcc/config/rs6000/rs6000.c
___________________________________________________________________
Added: svn:mergeinfo
   Merged /trunk/gcc/config/rs6000/rs6000.c:r162404,173624

Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-4_5-branch)
@@ -844,7 +844,7 @@
   [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?wa")
 	(if_then_else:VSX_L
 	 (ne:CC (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,wa")
-		(const_int 0))
+		(match_operand:VSX_L 4 "zero_constant" ""))
 	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,wa")
 	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,wa")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
@@ -855,7 +855,7 @@
   [(set (match_operand:VSX_L 0 "vsx_register_operand" "=<VSr>,?wa")
 	(if_then_else:VSX_L
 	 (ne:CCUNS (match_operand:VSX_L 1 "vsx_register_operand" "<VSr>,wa")
-		   (const_int 0))
+		   (match_operand:VSX_L 4 "zero_constant" ""))
 	 (match_operand:VSX_L 2 "vsx_register_operand" "<VSr>,wa")
 	 (match_operand:VSX_L 3 "vsx_register_operand" "<VSr>,wa")))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
Index: gcc/config/rs6000/rs6000.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rs6000/rs6000.h	(.../branches/gcc-4_5-branch)
@@ -1038,10 +1038,9 @@
 
 /* When setting up caller-save slots (MODE == VOIDmode) ensure we allocate
    enough space to account for vectors in FP regs. */
-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)	\
-  (TARGET_VSX						\
-   && ((MODE) == VOIDmode || VSX_VECTOR_MODE (MODE)	\
-       || ALTIVEC_VECTOR_MODE (MODE))			\
+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)			\
+  (TARGET_VSX								\
+   && ((MODE) == VOIDmode || ALTIVEC_OR_VSX_VECTOR_MODE (MODE))		\
    && FP_REGNO_P (REGNO)				\
    ? V2DFmode						\
    : choose_hard_reg_mode ((REGNO), (NREGS), false))
@@ -1057,25 +1056,16 @@
 	 ((MODE) == V4SFmode		\
 	  || (MODE) == V2DFmode)	\
 
-#define VSX_SCALAR_MODE(MODE)		\
-	((MODE) == DFmode)
-
-#define VSX_MODE(MODE)			\
-	(VSX_VECTOR_MODE (MODE)		\
-	 || VSX_SCALAR_MODE (MODE))
-
-#define VSX_MOVE_MODE(MODE)		\
-	(VSX_VECTOR_MODE (MODE)		\
-	 || VSX_SCALAR_MODE (MODE)	\
-	 || ALTIVEC_VECTOR_MODE (MODE)	\
-	 || (MODE) == TImode)
-
 #define ALTIVEC_VECTOR_MODE(MODE)	\
 	 ((MODE) == V16QImode		\
 	  || (MODE) == V8HImode		\
 	  || (MODE) == V4SFmode		\
 	  || (MODE) == V4SImode)
 
+#define ALTIVEC_OR_VSX_VECTOR_MODE(MODE)				\
+  (ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE)			\
+   || (MODE) == V2DImode)
+
 #define SPE_VECTOR_MODE(MODE)		\
 	((MODE) == V4HImode          	\
          || (MODE) == V2SFmode          \
@@ -1118,10 +1108,10 @@
    ? ALTIVEC_VECTOR_MODE (MODE2)		\
    : ALTIVEC_VECTOR_MODE (MODE2)		\
    ? ALTIVEC_VECTOR_MODE (MODE1)		\
-   : VSX_VECTOR_MODE (MODE1)			\
-   ? VSX_VECTOR_MODE (MODE2)			\
-   : VSX_VECTOR_MODE (MODE2)			\
-   ? VSX_VECTOR_MODE (MODE1)			\
+   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)		\
+   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)		\
+   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)		\
+   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)		\
    : 1)
 
 /* Post-reload, we can't use any new AltiVec registers, as we already

Property changes on: gcc/config/rs6000/rs6000.h
___________________________________________________________________
Added: svn:mergeinfo
   Merged /trunk/gcc/config/rs6000/rs6000.h:r162404,173624

Index: gcc/config/rs6000/altivec.md
===================================================================
--- a/src/gcc/config/rs6000/altivec.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rs6000/altivec.md	(.../branches/gcc-4_5-branch)
@@ -497,7 +497,7 @@
   [(set (match_operand:VM 0 "altivec_register_operand" "=v")
 	(if_then_else:VM
 	 (ne:CC (match_operand:VM 1 "altivec_register_operand" "v")
-		(const_int 0))
+		(match_operand:VM 4 "zero_constant" ""))
 	 (match_operand:VM 2 "altivec_register_operand" "v")
 	 (match_operand:VM 3 "altivec_register_operand" "v")))]
   "VECTOR_MEM_ALTIVEC_P (<MODE>mode)"
@@ -508,7 +508,7 @@
   [(set (match_operand:VM 0 "altivec_register_operand" "=v")
 	(if_then_else:VM
 	 (ne:CCUNS (match_operand:VM 1 "altivec_register_operand" "v")
-		   (const_int 0))
+		   (match_operand:VM 4 "zero_constant" ""))
 	 (match_operand:VM 2 "altivec_register_operand" "v")
 	 (match_operand:VM 3 "altivec_register_operand" "v")))]
   "VECTOR_MEM_ALTIVEC_P (<MODE>mode)"
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_5-branch)
@@ -12473,7 +12473,11 @@
   [(set (match_operand 0 "memory_operand" "=m")
         (unspec [(const_int 0)] UNSPEC_PROBE_STACK))]
   ""
-  "{st%U0%X0|stw%U0%X0} 0,%0"
+  "*
+{
+  operands[1] = gen_rtx_REG (Pmode, 0);
+  return \"{st%U0%X0|stw%U0%X0} %1,%0\";
+}"
   [(set_attr "type" "store")
    (set_attr "length" "4")])
 
Index: gcc/config/darwin.c
===================================================================
--- a/src/gcc/config/darwin.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/darwin.c	(.../branches/gcc-4_5-branch)
@@ -337,6 +337,34 @@
 
 /* Return a hash value for a SLOT in the indirections hash table.  */
 
+void
+darwin_rename_builtins (void)
+{
+  /* The system ___divdc3 routine in libSystem on darwin10 is not
+     accurate to 1ulp, ours is, so we avoid ever using the system name
+     for this routine and instead install a non-conflicting name that
+     is accurate.
+
+     When -ffast-math or -funsafe-math-optimizations is given, we can
+     use the faster version.  */
+  if (!flag_unsafe_math_optimizations)
+    {
+      int dcode = (BUILT_IN_COMPLEX_DIV_MIN
+		   + DCmode - MIN_MODE_COMPLEX_FLOAT);
+      tree fn = built_in_decls[dcode];
+      /* Fortran and c call TARGET_INIT_BUILTINS and
+	 TARGET_INIT_LIBFUNCS at different times, so we have to put a
+	 call into each to ensure that at least one of them is called
+	 after build_common_builtin_nodes.  A better fix is to add a
+	 new hook to run after build_common_builtin_nodes runs.  */
+      if (fn)
+	set_user_assembler_name (fn, "___ieee_divdc3");
+      fn = implicit_built_in_decls[dcode];
+      if (fn)
+	set_user_assembler_name (fn, "___ieee_divdc3");
+    }
+}
+
 static hashval_t
 machopic_indirection_hash (const void *slot)
 {
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-4_5-branch)
@@ -18237,7 +18237,7 @@
   rtx tmp1 = gen_reg_rtx (mode);
   rtx tmp2 = gen_reg_rtx (mode);
 
-  emit_insn (intfn (tmp1, op1, tmp2, op2));
+  emit_insn (intfn (tmp1, op1, op2, tmp2));
 
   emit_move_insn (mem, tmp1);
   mem = adjust_address (mem, mode, GET_MODE_SIZE (mode));
Index: gcc/config/arm/neon.md
===================================================================
--- a/src/gcc/config/arm/neon.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/arm/neon.md	(.../branches/gcc-4_5-branch)
@@ -680,7 +680,7 @@
           (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_NEON"
 {
-  int elt = ffs ((int) INTVAL (operands[2]) - 1);
+  int elt = ffs ((int) INTVAL (operands[2])) - 1;
   if (BYTES_BIG_ENDIAN)
     elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;
   operands[2] = GEN_INT (elt);
@@ -3895,13 +3895,14 @@
 
 (define_insn "neon_vtrn<mode>_internal"
   [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-	(unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")]
-		     UNSPEC_VTRN1))
-   (set (match_operand:VDQW 2 "s_register_operand" "=w")
-        (unspec:VDQW [(match_operand:VDQW 3 "s_register_operand" "2")]
-		     UNSPEC_VTRN2))]
+        (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
+                      (match_operand:VDQW 2 "s_register_operand" "w")]
+                     UNSPEC_VTRN1))
+   (set (match_operand:VDQW 3 "s_register_operand" "=2")
+         (unspec:VDQW [(match_dup 1) (match_dup 2)]
+                     UNSPEC_VTRN2))]
   "TARGET_NEON"
-  "vtrn.<V_sz_elem>\t%<V_reg>0, %<V_reg>2"
+  "vtrn.<V_sz_elem>\t%<V_reg>0, %<V_reg>3"
   [(set (attr "neon_type")
       (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
                     (const_string "neon_bp_simple")
@@ -3921,13 +3922,14 @@
 
 (define_insn "neon_vzip<mode>_internal"
   [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-	(unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")]
-		     UNSPEC_VZIP1))
-   (set (match_operand:VDQW 2 "s_register_operand" "=w")
-        (unspec:VDQW [(match_operand:VDQW 3 "s_register_operand" "2")]
-		     UNSPEC_VZIP2))]
+        (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
+                      (match_operand:VDQW 2 "s_register_operand" "w")]
+                     UNSPEC_VZIP1))
+   (set (match_operand:VDQW 3 "s_register_operand" "=2")
+        (unspec:VDQW [(match_dup 1) (match_dup 2)]
+                     UNSPEC_VZIP2))]
   "TARGET_NEON"
-  "vzip.<V_sz_elem>\t%<V_reg>0, %<V_reg>2"
+  "vzip.<V_sz_elem>\t%<V_reg>0, %<V_reg>3"
   [(set (attr "neon_type")
       (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
                     (const_string "neon_bp_simple")
@@ -3947,13 +3949,14 @@
 
 (define_insn "neon_vuzp<mode>_internal"
   [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-	(unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")]
+        (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
+                      (match_operand:VDQW 2 "s_register_operand" "w")]
                      UNSPEC_VUZP1))
-   (set (match_operand:VDQW 2 "s_register_operand" "=w")
-        (unspec:VDQW [(match_operand:VDQW 3 "s_register_operand" "2")]
-		     UNSPEC_VUZP2))]
+   (set (match_operand:VDQW 3 "s_register_operand" "=2")
+        (unspec:VDQW [(match_dup 1) (match_dup 2)]
+                     UNSPEC_VUZP2))]
   "TARGET_NEON"
-  "vuzp.<V_sz_elem>\t%<V_reg>0, %<V_reg>2"
+  "vuzp.<V_sz_elem>\t%<V_reg>0, %<V_reg>3"
   [(set (attr "neon_type")
       (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
                     (const_string "neon_bp_simple")
Index: gcc/config/arm/bpabi.h
===================================================================
--- a/src/gcc/config/arm/bpabi.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/arm/bpabi.h	(.../branches/gcc-4_5-branch)
@@ -72,17 +72,10 @@
 #undef  LINK_SPEC
 #define LINK_SPEC BPABI_LINK_SPEC
 
-#if defined (__thumb__)
-#define RENAME_LIBRARY_SET ".thumb_set"
-#else
-#define RENAME_LIBRARY_SET ".set"
-#endif
-
 /* Make __aeabi_AEABI_NAME an alias for __GCC_NAME.  */
 #define RENAME_LIBRARY(GCC_NAME, AEABI_NAME)		\
-  __asm__ (".globl\t__aeabi_" #AEABI_NAME "\n"		\
-	   RENAME_LIBRARY_SET "\t__aeabi_" #AEABI_NAME 	\
-	     ", __" #GCC_NAME "\n");
+  typeof (__##GCC_NAME) __aeabi_##AEABI_NAME \
+    __attribute__((alias ("__" #GCC_NAME)));
 
 /* Give some libgcc functions an additional __aeabi name.  */
 #ifdef L_muldi3
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-4_5-branch)
@@ -3134,7 +3134,7 @@
     bool need_else;
 
     if (which_alternative != 0 || operands[3] != const0_rtx
-        || (code != PLUS && code != MINUS && code != IOR && code != XOR))
+        || (code != PLUS && code != IOR && code != XOR))
       need_else = true;
     else
       need_else = false;
@@ -7994,7 +7994,7 @@
 	(not:SI (match_operator:SI 1 "arm_comparison_operator"
 		 [(match_operand 2 "cc_register" "") (const_int 0)])))]
   "TARGET_ARM"
-  "mov%D1\\t%0, #0\;mvn%d1\\t%0, #1"
+  "mvn%D1\\t%0, #0\;mvn%d1\\t%0, #1"
   [(set_attr "conds" "use")
    (set_attr "length" "8")]
 )
Index: gcc/config/pa/predicates.md
===================================================================
--- a/src/gcc/config/pa/predicates.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/pa/predicates.md	(.../branches/gcc-4_5-branch)
@@ -411,12 +411,16 @@
 
 ;; True iff depi can be used to compute (reg | OP).
 
-(define_predicate "ior_operand"
-  (match_code "const_int")
-{
-  return (GET_CODE (op) == CONST_INT && ior_mask_p (INTVAL (op)));
-})
+(define_predicate "cint_ior_operand"
+  (and (match_code "const_int")
+       (match_test "ior_mask_p (INTVAL (op))")))
 
+;; True iff OP can be used to compute (reg | OP).
+
+(define_predicate "reg_or_cint_ior_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "cint_ior_operand")))
+
 ;; True iff OP is a CONST_INT of the forms 0...0xxxx or
 ;; 0...01...1xxxx. Such values can be the left hand side x in (x <<
 ;; r), using the zvdepi instruction.
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-4_5-branch)
@@ -811,7 +811,7 @@
 			 (match_operand:DI 3 "arith11_operand" "rI"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3,* %3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "sub%I3 %3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -833,7 +833,7 @@
 			 (match_operand:DI 3 "register_operand" "r"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub,* %2,%3,%%r0\;add,dc %%r0,%1,%0"
+  "sub %2,%3,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -856,7 +856,7 @@
 			 (match_operand:DI 3 "int11_operand" "I"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi,* %k3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "addi %k3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -902,7 +902,7 @@
 		  (gtu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "arith11_operand" "rI"))))]
   "TARGET_64BIT"
-  "sub%I3,* %3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "sub%I3 %3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -924,7 +924,7 @@
 				    (match_operand:DI 3 "arith11_operand" "rI")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3,* %3,%2,%%r0\;sub,db %1,%4,%0"
+  "sub%I3 %3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -946,7 +946,7 @@
 		  (ltu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "register_operand" "r"))))]
   "TARGET_64BIT"
-  "sub,* %2,%3,%%r0\;sub,db %1,%%r0,%0"
+  "sub %2,%3,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -968,7 +968,7 @@
 				    (match_operand:DI 3 "register_operand" "r")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub,* %2,%3,%%r0\;sub,db %1,%4,%0"
+  "sub %2,%3,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -991,7 +991,7 @@
 		  (leu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "int11_operand" "I"))))]
   "TARGET_64BIT"
-  "addi,* %k3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "addi %k3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1013,7 +1013,7 @@
 				    (match_operand:DI 3 "int11_operand" "I")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi,* %k3,%2,%%r0\;sub,db %1,%4,%0"
+  "addi %k3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -5686,7 +5686,7 @@
 (define_expand "iordi3"
   [(set (match_operand:DI 0 "register_operand" "")
 	(ior:DI (match_operand:DI 1 "register_operand" "")
-		(match_operand:DI 2 "ior_operand" "")))]
+		(match_operand:DI 2 "reg_or_cint_ior_operand" "")))]
   ""
   "
 {
@@ -5707,7 +5707,7 @@
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,r")
 	(ior:DI (match_operand:DI 1 "register_operand" "0,0")
-		(match_operand:DI 2 "ior_operand" "M,i")))]
+		(match_operand:DI 2 "cint_ior_operand" "M,i")))]
   "TARGET_64BIT"
   "* return output_64bit_ior (operands); "
   [(set_attr "type" "binary,shift")
@@ -5726,19 +5726,14 @@
 (define_expand "iorsi3"
   [(set (match_operand:SI 0 "register_operand" "")
 	(ior:SI (match_operand:SI 1 "register_operand" "")
-		(match_operand:SI 2 "arith32_operand" "")))]
+		(match_operand:SI 2 "reg_or_cint_ior_operand" "")))]
   ""
-  "
-{
-  if (! (ior_operand (operands[2], SImode)
-         || register_operand (operands[2], SImode)))
-    operands[2] = force_reg (SImode, operands[2]);
-}")
+  "")
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	(ior:SI (match_operand:SI 1 "register_operand" "0,0")
-		(match_operand:SI 2 "ior_operand" "M,i")))]
+		(match_operand:SI 2 "cint_ior_operand" "M,i")))]
   ""
   "* return output_ior (operands); "
   [(set_attr "type" "binary,shift")
@@ -7131,7 +7126,7 @@
     {
       rtx index = gen_reg_rtx (SImode);
 
-      operands[1] = GEN_INT (-INTVAL (operands[1]));
+      operands[1] = gen_int_mode (-INTVAL (operands[1]), SImode);
       if (!INT_14_BITS (operands[1]))
 	operands[1] = force_reg (SImode, operands[1]);
       emit_insn (gen_addsi3 (index, operands[0], operands[1]));
Index: gcc/config/pa/pa-protos.h
===================================================================
--- a/src/gcc/config/pa/pa-protos.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/pa/pa-protos.h	(.../branches/gcc-4_5-branch)
@@ -79,7 +79,6 @@
 extern int prefetch_cc_operand (rtx, enum machine_mode);
 extern int prefetch_nocc_operand (rtx, enum machine_mode);
 extern int and_operand (rtx, enum machine_mode);
-extern int ior_operand (rtx, enum machine_mode);
 extern int arith32_operand (rtx, enum machine_mode);
 extern int uint32_operand (rtx, enum machine_mode);
 extern int reg_before_reload_operand (rtx, enum machine_mode);
@@ -94,7 +93,6 @@
 extern int fmpyaddoperands (rtx *);
 extern int fmpysuboperands (rtx *);
 extern int call_operand_address (rtx, enum machine_mode);
-extern int ior_operand (rtx, enum machine_mode);
 extern void emit_bcond_fp (rtx[]);
 extern int emit_move_sequence (rtx *, enum machine_mode, rtx);
 extern int emit_hpdiv_const (rtx *, int);
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-4_5-branch)
@@ -1686,6 +1686,11 @@
   /* Handle the most common case: storing into a register.  */
   else if (register_operand (operand0, mode))
     {
+      /* Legitimize TLS symbol references.  This happens for references
+	 that aren't a legitimate constant.  */
+      if (PA_SYMBOL_REF_TLS_P (operand1))
+	operand1 = legitimize_tls_address (operand1);
+
       if (register_operand (operand1, mode)
 	  || (GET_CODE (operand1) == CONST_INT
 	      && cint_ok_for_move (INTVAL (operand1)))
Index: gcc/config/pa/pa.h
===================================================================
--- a/src/gcc/config/pa/pa.h	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/pa/pa.h	(.../branches/gcc-4_5-branch)
@@ -891,6 +891,9 @@
    && (NEW_HP_ASSEMBLER						\
        || TARGET_GAS						\
        || GET_CODE (X) != LABEL_REF)				\
+   && (!PA_SYMBOL_REF_TLS_P (X)					\
+       || (SYMBOL_REF_TLS_MODEL (X) != TLS_MODEL_GLOBAL_DYNAMIC		\
+	   && SYMBOL_REF_TLS_MODEL (X) != TLS_MODEL_LOCAL_DYNAMIC))	\
    && (!TARGET_64BIT						\
        || GET_CODE (X) != CONST_DOUBLE)				\
    && (!TARGET_64BIT						\
Index: gcc/config/mips/mips.md
===================================================================
--- a/src/gcc/config/mips/mips.md	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/mips/mips.md	(.../branches/gcc-4_5-branch)
@@ -4806,7 +4806,7 @@
 ;; of _gp from the start of this function.  Operand 1 is the incoming
 ;; function address.
 (define_insn_and_split "loadgp_newabi_<mode>"
-  [(set (match_operand:P 0 "register_operand" "=d")
+  [(set (match_operand:P 0 "register_operand" "=&d")
 	(unspec:P [(match_operand:P 1)
 		   (match_operand:P 2 "register_operand" "d")]
 		  UNSPEC_LOADGP))]
Index: gcc/config/mips/mips.c
===================================================================
--- a/src/gcc/config/mips/mips.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/config/mips/mips.c	(.../branches/gcc-4_5-branch)
@@ -1162,7 +1162,7 @@
   }
 };
 
-static rtx mips_find_pic_call_symbol (rtx, rtx);
+static rtx mips_find_pic_call_symbol (rtx, rtx, bool);
 
 /* This hash table keeps track of implicit "mips16" and "nomips16" attributes
    for -mflip_mips16.  It maps decl names onto a boolean mode setting.  */
@@ -9007,6 +9007,11 @@
 static bool
 mips_cfun_call_saved_reg_p (unsigned int regno)
 {
+  /* If the user makes an ordinarily-call-saved register global,
+     that register is no longer call-saved.  */
+  if (global_regs[regno])
+    return false;
+
   /* Interrupt handlers need to save extra registers.  */
   if (cfun->machine->interrupt_handler_p
       && mips_interrupt_extra_call_saved_reg_p (regno))
@@ -14040,12 +14045,16 @@
 }
 
 /* REG is set in DEF.  See if the definition is one of the ways we load a
-   register with a symbol address for a mips_use_pic_fn_addr_reg_p call.  If
-   it is return the symbol reference of the function, otherwise return
-   NULL_RTX.  */
+   register with a symbol address for a mips_use_pic_fn_addr_reg_p call.
+   If it is, return the symbol reference of the function, otherwise return
+   NULL_RTX.
 
+   If RECURSE_P is true, use mips_find_pic_call_symbol to interpret
+   the values of source registers, otherwise treat such registers as
+   having an unknown value.  */
+
 static rtx
-mips_pic_call_symbol_from_set (df_ref def, rtx reg)
+mips_pic_call_symbol_from_set (df_ref def, rtx reg, bool recurse_p)
 {
   rtx def_insn, set;
 
@@ -14072,21 +14081,39 @@
 	  return symbol;
 	}
 
-      /* Follow simple register copies.  */
-      if (REG_P (src))
-	return mips_find_pic_call_symbol (def_insn, src);
+      /* Follow at most one simple register copy.  Such copies are
+	 interesting in cases like:
+
+	     for (...)
+	       {
+	         locally_binding_fn (...);
+	       }
+
+	 and:
+
+	     locally_binding_fn (...);
+	     ...
+	     locally_binding_fn (...);
+
+	 where the load of locally_binding_fn can legitimately be
+	 hoisted or shared.  However, we do not expect to see complex
+	 chains of copies, so a full worklist solution to the problem
+	 would probably be overkill.  */
+      if (recurse_p && REG_P (src))
+	return mips_find_pic_call_symbol (def_insn, src, false);
     }
 
   return NULL_RTX;
 }
 
-/* Find the definition of the use of REG in INSN.  See if the definition is
-   one of the ways we load a register with a symbol address for a
-   mips_use_pic_fn_addr_reg_p call.  If it is return the symbol reference of
-   the function, otherwise return NULL_RTX.  */
+/* Find the definition of the use of REG in INSN.  See if the definition
+   is one of the ways we load a register with a symbol address for a
+   mips_use_pic_fn_addr_reg_p call.  If it is return the symbol reference
+   of the function, otherwise return NULL_RTX.  RECURSE_P is as for
+   mips_pic_call_symbol_from_set.  */
 
 static rtx
-mips_find_pic_call_symbol (rtx insn, rtx reg)
+mips_find_pic_call_symbol (rtx insn, rtx reg, bool recurse_p)
 {
   df_ref use;
   struct df_link *defs;
@@ -14098,7 +14125,7 @@
   defs = DF_REF_CHAIN (use);
   if (!defs)
     return NULL_RTX;
-  symbol = mips_pic_call_symbol_from_set (defs->ref, reg);
+  symbol = mips_pic_call_symbol_from_set (defs->ref, reg, recurse_p);
   if (!symbol)
     return NULL_RTX;
 
@@ -14107,7 +14134,7 @@
     {
       rtx other;
 
-      other = mips_pic_call_symbol_from_set (defs->ref, reg);
+      other = mips_pic_call_symbol_from_set (defs->ref, reg, recurse_p);
       if (!rtx_equal_p (symbol, other))
 	return NULL_RTX;
     }
@@ -14178,7 +14205,7 @@
       if (!REG_P (reg))
 	continue;
 
-      symbol = mips_find_pic_call_symbol (insn, reg);
+      symbol = mips_find_pic_call_symbol (insn, reg, true);
       if (symbol)
 	{
 	  mips_annotate_pic_call_expr (call, symbol);
Index: gcc/cfgrtl.c
===================================================================
--- a/src/gcc/cfgrtl.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/cfgrtl.c	(.../branches/gcc-4_5-branch)
@@ -1640,9 +1640,10 @@
       putc ('\n', outf);
     }
 
-  for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;
-       insn = NEXT_INSN (insn))
-    print_rtl_single (outf, insn);
+  if (bb->index != ENTRY_BLOCK && bb->index != EXIT_BLOCK)
+    for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;
+	 insn = NEXT_INSN (insn))
+      print_rtl_single (outf, insn);
 
   if (df)
     {
Index: gcc/convert.c
===================================================================
--- a/src/gcc/convert.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/convert.c	(.../branches/gcc-4_5-branch)
@@ -728,6 +728,15 @@
 	    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);
 	    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);
 
+	    /* Do not try to narrow operands of pointer subtraction;
+	       that will interfere with other folding.  */
+	    if (ex_form == MINUS_EXPR
+		&& CONVERT_EXPR_P (arg0)
+		&& CONVERT_EXPR_P (arg1)
+		&& POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0)))
+		&& POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg1, 0))))
+	      break;
+
 	    if (outprec >= BITS_PER_WORD
 		|| TRULY_NOOP_TRUNCATION (outprec, inprec)
 		|| inprec > TYPE_PRECISION (TREE_TYPE (arg0))
Index: gcc/reload1.c
===================================================================
--- a/src/gcc/reload1.c	(.../tags/gcc_4_5_3_release)
+++ b/src/gcc/reload1.c	(.../branches/gcc-4_5-branch)
@@ -4487,6 +4487,13 @@
 	{
 	  AND_COMPL_HARD_REG_SET (reg_reloaded_valid, call_used_reg_set);
 	  AND_COMPL_HARD_REG_SET (reg_reloaded_valid, reg_reloaded_call_part_clobbered);
+
+	  /* If this is a call to a setjmp-type function, we must not
+	     reuse any reload reg contents across the call; that will
+	     just be clobbered by other uses of the register in later
+	     code, before the longjmp.  */
+	  if (find_reg_note (insn, REG_SETJMP, NULL_RTX))
+	    CLEAR_HARD_REG_SET (reg_reloaded_valid);
 	}
     }
 
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,13 @@
+2011-07-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2011-06-07  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/49293
+	* testsuite/22_locale/time_get/get_weekday/char/38081-1.cc: Tweak
+	for glibc 2.14.
+	* testsuite/22_locale/time_get/get_weekday/char/38081-2.cc: Likewise.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: libstdc++-v3/testsuite/22_locale/time_get/get_weekday/char/38081-1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/22_locale/time_get/get_weekday/char/38081-1.cc	(.../tags/gcc_4_5_3_release)
+++ b/src/libstdc++-v3/testsuite/22_locale/time_get/get_weekday/char/38081-1.cc	(.../branches/gcc-4_5-branch)
@@ -1,6 +1,6 @@
 // { dg-require-namedlocale "" }
 
-// Copyright (C) 2010 Free Software Foundation
+// Copyright (C) 2010, 2011 Free Software Foundation
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -49,7 +49,11 @@
   // get_weekday(iter_type, iter_type, ios_base&, 
   //             ios_base::iostate&, tm*) const
 
+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 14)
+  iss.str("\xbf\xdd\x2e");
+#else
   iss.str("\xbf\xdd\xd4");
+#endif
   iterator_type is_it01(iss);
   tm time01;
   memset(&time01, -1, sizeof(tm));
@@ -67,7 +71,11 @@
   VERIFY( time02.tm_wday == 1 );
   VERIFY( errorstate == ios_base::eofbit );
 
+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 14)
+  iss.str("\xbf\xdd\x2e\xd5\xd4\xd5\xdb\xec\xdd\xd8\xda");
+#else
   iss.str("\xbf\xdd\xd4\xd5\xd4\xd5\xdb\xec\xdd\xd8\xda");
+#endif
   iterator_type is_it03(iss);
   tm time03;
   memset(&time03, -1, sizeof(tm));
Index: libstdc++-v3/testsuite/22_locale/time_get/get_weekday/char/38081-2.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/22_locale/time_get/get_weekday/char/38081-2.cc	(.../tags/gcc_4_5_3_release)
+++ b/src/libstdc++-v3/testsuite/22_locale/time_get/get_weekday/char/38081-2.cc	(.../branches/gcc-4_5-branch)
@@ -2,7 +2,7 @@
 
 // 2010-01-05  Paolo Carlini  <paolo.carlini@oracle.com>
 
-// Copyright (C) 2010 Free Software Foundation
+// Copyright (C) 2010, 2011 Free Software Foundation
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -50,6 +50,15 @@
   // get_weekday(iter_type, iter_type, ios_base&, 
   //             ios_base::iostate&, tm*) const
 
+#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 14)
+  const char* awdays[7] = { "\u0412\u0441\u002E",
+			    "\u041F\u043D\u002E",
+			    "\u0412\u0442\u002E",
+			    "\u0421\u0440\u002E",
+			    "\u0427\u0442\u002E",
+			    "\u041F\u0442\u002E",
+			    "\u0421\u0431\u002E" };
+#else
   const char* awdays[7] = { "\u0412\u0441\u043A",
 			    "\u041F\u043D\u0434",
 			    "\u0412\u0442\u0440",
@@ -57,6 +66,7 @@
 			    "\u0427\u0442\u0432",
 			    "\u041F\u0442\u043D",
 			    "\u0421\u0431\u0442" };
+#endif
 
   for (int i = 0; i < 7; ++i)
     {
Index: configure.ac
===================================================================
--- a/src/configure.ac	(.../tags/gcc_4_5_3_release)
+++ b/src/configure.ac	(.../branches/gcc-4_5-branch)
@@ -185,9 +185,8 @@
 
 # these libraries are built for the target environment, and are built after
 # the host libraries and the host tools (which may be a cross compiler)
-#
+# Note that libiberty is not a target library.
 target_libraries="target-libgcc \
-		target-libiberty \
 		target-libgloss \
 		target-newlib \
 		target-libgomp \
@@ -506,14 +505,14 @@
     ;;
   *-*-kaos*)
     # Remove unsupported stuff on all kaOS configurations.
-    skipdirs="target-libiberty ${libgcj} target-libstdc++-v3 target-librx"
+    skipdirs="${libgcj} target-libstdc++-v3 target-librx"
     skipdirs="$skipdirs target-libobjc target-examples target-groff target-gperf"
     skipdirs="$skipdirs zlib fastjar target-libjava target-boehm-gc target-zlib"
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
   *-*-netbsd*)
     # Skip some stuff on all NetBSD configurations.
-    noconfigdirs="$noconfigdirs target-newlib target-libiberty target-libgloss"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
 
     # Skip some stuff that's unsupported on some NetBSD configurations.
     case "${target}" in
@@ -525,20 +524,20 @@
     esac
     ;;
   *-*-netware*)
-    noconfigdirs="$noconfigdirs target-newlib target-libiberty target-libgloss ${libgcj} target-libmudflap"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj} target-libmudflap"
     ;;
   *-*-rtems*)
     noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
     ;;
     # The tpf target doesn't support gdb yet.
   *-*-tpf*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty ${libgcj} target-libmudflap gdb tcl tk libgui itcl"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj} target-libmudflap gdb tcl tk libgui itcl"
     ;;
   *-*-uclinux*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libstdc++-v3 ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
@@ -566,7 +565,7 @@
   sh*-*-pe|mips*-*-pe|*arm-wince-pe)
     noconfigdirs="$noconfigdirs ${libgcj}"
     noconfigdirs="$noconfigdirs target-examples"
-    noconfigdirs="$noconfigdirs target-libiberty texinfo send-pr"
+    noconfigdirs="$noconfigdirs texinfo send-pr"
     noconfigdirs="$noconfigdirs tcl tk itcl libgui sim"
     noconfigdirs="$noconfigdirs expect dejagnu"
     # the C++ libraries don't build on top of CE's C libraries
@@ -600,7 +599,7 @@
     libgloss_dir=arm
     ;;
   arm*-*-symbianelf*)
-    noconfigdirs="$noconfigdirs ${libgcj} target-libiberty"
+    noconfigdirs="$noconfigdirs ${libgcj}"
     libgloss_dir=arm
     ;;
   arm-*-pe*)
@@ -619,7 +618,7 @@
     noconfigdirs="$noconfigdirs ld target-libgloss ${libgcj}"
     ;;
   avr-*-*)
-    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj} target-libssp"
+    noconfigdirs="$noconfigdirs target-libstdc++-v3 ${libgcj} target-libssp"
     ;;
   bfin-*-*)
     unsupported_languages="$unsupported_languages java"
@@ -798,7 +797,7 @@
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
-    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-libstdc++-v3 ${libgcj}"
     libgloss_dir=m68hc11
     ;;
   m68k-*-elf*)
@@ -869,7 +868,6 @@
     noconfigdirs="$noconfigdirs gprof ${libgcj}"
     ;;
   mips*-sde-elf*)
-    skipdirs="$skipdirs target-libiberty"
     noconfigdirs="$noconfigdirs ${libgcj}"
     if test x$with_newlib = xyes; then
       noconfigdirs="$noconfigdirs gprof"
@@ -965,7 +963,7 @@
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
   ip2k-*-*)
-    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-libstdc++-v3 ${libgcj}"
     ;;
   *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
@@ -1135,6 +1133,9 @@
     tentative_cc="/usr/cygnus/progressive/bin/gcc"
     host_makefile_frag="config/mh-lynxrs6k"
     ;;
+  i[[3456789]]86-*-darwin* | x86_64-*-darwin*)
+    host_makefile_frag="config/mh-x86-darwin"
+    ;;
   powerpc-*-darwin*)
     host_makefile_frag="config/mh-ppc-darwin"
     ;;
@@ -2105,27 +2106,6 @@
   fi
 done
 
-# Sometimes the tools are distributed with libiberty but with no other
-# libraries.  In that case, we don't want to build target-libiberty.
-# Don't let libgcc imply libiberty either.
-if test -n "${target_configdirs}" ; then
-  libgcc=
-  others=
-  for i in `echo ${target_configdirs} | sed -e s/target-//g` ; do
-    if test "$i" = "libgcc"; then
-      libgcc=target-libgcc
-    elif test "$i" != "libiberty" ; then
-      if test -r $srcdir/$i/configure ; then
-	others=yes;
-	break;
-      fi
-    fi
-  done
-  if test -z "${others}" ; then
-    target_configdirs=$libgcc
-  fi
-fi
-
 # Quietly strip out all directories which aren't configurable in this tree.
 # This relies on all configurable subdirectories being autoconfiscated, which
 # is now the case.
Index: libgfortran/intrinsics/string_intrinsics_inc.c
===================================================================
--- a/src/libgfortran/intrinsics/string_intrinsics_inc.c	(.../tags/gcc_4_5_3_release)
+++ b/src/libgfortran/intrinsics/string_intrinsics_inc.c	(.../branches/gcc-4_5-branch)
@@ -90,7 +90,7 @@
   gfc_charlen_type len;
   int res;
 
-  res = memcmp (s1, s2, ((len1 < len2) ? len1 : len2) * sizeof (CHARTYPE));
+  res = MEMCMP (s1, s2, ((len1 < len2) ? len1 : len2));
   if (res != 0)
     return res;
 
Index: libgfortran/intrinsics/string_intrinsics.c
===================================================================
--- a/src/libgfortran/intrinsics/string_intrinsics.c	(.../tags/gcc_4_5_3_release)
+++ b/src/libgfortran/intrinsics/string_intrinsics.c	(.../branches/gcc-4_5-branch)
@@ -51,7 +51,24 @@
   return b;
 }
 
+/* Compare wide character types, which are handled internally as
+   unsigned 4-byte integers.  */
+int
+memcmp_char4 (const void *a, const void *b, size_t len)
+{
+  const GFC_UINTEGER_4 *pa = a;
+  const GFC_UINTEGER_4 *pb = b;
+  while (len-- > 0)
+    {
+      if (*pa != *pb)
+	return *pa < *pb ? -1 : 1;
+      pa ++;
+      pb ++;
+    }
+  return 0;
+}
 
+
 /* All other functions are defined using a few generic macros in
    string_intrinsics_inc.c, so we avoid code duplication between the
    various character type kinds.  */
@@ -64,6 +81,8 @@
 #define SUFFIX(x) x
 #undef  MEMSET
 #define MEMSET memset
+#undef  MEMCMP
+#define MEMCMP memcmp
 
 #include "string_intrinsics_inc.c"
 
@@ -76,6 +95,8 @@
 #define SUFFIX(x) x ## _char4
 #undef  MEMSET
 #define MEMSET memset_char4
+#undef  MEMCMP
+#define MEMCMP memcmp_char4
 
 #include "string_intrinsics_inc.c"
 
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,30 @@
+2011-08-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR libfortran/50192
+	* intrinsics/string_intrinsics.c (memcmp_char4):  New function.
+	* intrinsics/string_intrinsics_inc.c:  New macro MEMCMP, either
+	set to memcmp or memcmp_char4.
+	(compare_string):  Use MEMCMP, with correct size for it.
+	* libgfortran.h:  Add prototype for memcmp_char4.
+
+2011-08-19  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2011-08-18  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50109
+	* io/list_read.c (eat_separator): Fix skipping over "!" lines.
+
+2011-07-27  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2011-07-23  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/49791
+	* io/list_read.c (nml_parse_qualifier): Remove check to
+	enabled extended read for another case.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: libgfortran/libgfortran.h
===================================================================
--- a/src/libgfortran/libgfortran.h	(.../tags/gcc_4_5_3_release)
+++ b/src/libgfortran/libgfortran.h	(.../branches/gcc-4_5-branch)
@@ -1286,6 +1286,10 @@
 				 gfc_charlen_type, const gfc_char4_t *);
 iexport_proto(compare_string_char4);
 
+extern int memcmp_char4 (const void *, const void *, size_t);
+internal_proto(memcmp_char4);
+
+
 /* random.c */
 
 extern void random_seed_i4 (GFC_INTEGER_4 * size, gfc_array_i4 * put,
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_4_5_3_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-4_5-branch)
@@ -353,12 +353,7 @@
 	      if (c == '!')
 		{
 		  eat_line (dtp);
-		  c = next_char (dtp);
-		  if (c == '!')
-		    {
-		      eat_line (dtp);
-		      c = next_char (dtp);
-		    }
+		  c = '\n';
 		}
 	    }
 	  while (c == '\n' || c == '\r' || c == ' ' || c == '\t');
@@ -2078,7 +2073,6 @@
 		      do not allow excess data to be processed.  */
 		  if (is_array_section == 1
 		      || !(compile_options.allow_std & GFC_STD_GNU)
-		      || !dtp->u.p.ionml->touched
 		      || dtp->u.p.ionml->type == GFC_DTYPE_DERIVED)
 		    ls[dim].end = ls[dim].start;
 		  else
Index: Makefile.def
===================================================================
--- a/src/Makefile.def	(.../tags/gcc_4_5_3_release)
+++ b/src/Makefile.def	(.../branches/gcc-4_5-branch)
@@ -164,7 +164,6 @@
                    missing=maintainer-clean; };
 target_modules = { module= winsup; };
 target_modules = { module= libgloss; no_check=true; };
-target_modules = { module= libiberty; };
 target_modules = { module= gperf; };
 target_modules = { module= examples; no_check=true; no_install=true; };
 target_modules = { module= libffi; };
@@ -532,7 +531,6 @@
 dependencies = { module=configure-target-boehm-gc; on=all-target-libstdc++-v3; };
 dependencies = { module=configure-target-fastjar; on=configure-target-zlib; };
 dependencies = { module=all-target-fastjar; on=all-target-zlib; };
-dependencies = { module=all-target-fastjar; on=all-target-libiberty; };
 dependencies = { module=configure-target-libjava; on=configure-target-zlib; };
 dependencies = { module=configure-target-libjava; on=configure-target-boehm-gc; };
 dependencies = { module=configure-target-libjava; on=configure-target-qthreads; };
@@ -543,9 +541,7 @@
 dependencies = { module=all-target-libjava; on=all-target-qthreads; };
 dependencies = { module=all-target-libjava; on=all-target-libffi; };
 dependencies = { module=configure-target-libobjc; on=configure-target-boehm-gc; };
-dependencies = { module=all-target-libobjc; on=all-target-libiberty; };
 dependencies = { module=all-target-libobjc; on=all-target-boehm-gc; };
-dependencies = { module=all-target-libstdc++-v3; on=all-target-libiberty; };
 dependencies = { module=configure-target-libstdc++-v3; on=configure-target-libgomp; };
 // parallel_list.o and parallel_settings.o depend on omp.h, which is
 // generated by the libgomp configure.  Unfortunately, due to the use of
@@ -560,10 +556,7 @@
 lang_env_dependencies = { module=qthreads; };
 
 dependencies = { module=all-target-libgloss; on=all-target-newlib; };
-dependencies = { module=all-target-winsup; on=all-target-libiberty; };
 dependencies = { module=all-target-winsup; on=all-target-libtermcap; };
-dependencies = { module=configure-target-libiberty; on=all-binutils; };
-dependencies = { module=configure-target-libiberty; on=all-ld; };
 dependencies = { module=configure-target-newlib; on=all-binutils; };
 dependencies = { module=configure-target-newlib; on=all-ld; };
 
Index: boehm-gc/configure.ac
===================================================================
--- a/src/boehm-gc/configure.ac	(.../tags/gcc_4_5_3_release)
+++ b/src/boehm-gc/configure.ac	(.../branches/gcc-4_5-branch)
@@ -193,7 +193,9 @@
 	# The alternate thread library was only introduced in Solaris 8 and
 	# became the default in Solaris 9, so no need for the special code
 	# above otherwise.
-	THREADLIBS=-lpthread
+	# nanosleep, sched_yield, and sem_* only live in librt before
+	# Solaris 11.
+	THREADLIBS="-lpthread -lrt"
 	;;
      *-*-irix*)
 	AC_DEFINE(GC_IRIX_THREADS,1,[support for Irix pthreads])
Index: boehm-gc/ChangeLog
===================================================================
--- a/src/boehm-gc/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/boehm-gc/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,12 @@
+2011-07-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR boehm-gc/49381
+	Backport from mainline:
+	2011-01-31  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (*-*-solaris2*): Add -lrt to THREADLIBS.
+	* configure: Regenerate.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: boehm-gc/configure
===================================================================
--- a/src/boehm-gc/configure	(.../tags/gcc_4_5_3_release)
+++ b/src/boehm-gc/configure	(.../branches/gcc-4_5-branch)
@@ -14910,7 +14910,9 @@
 	# The alternate thread library was only introduced in Solaris 8 and
 	# became the default in Solaris 9, so no need for the special code
 	# above otherwise.
-	THREADLIBS=-lpthread
+	# nanosleep, sched_yield, and sem_* only live in librt before
+	# Solaris 11.
+	THREADLIBS="-lpthread -lrt"
 	;;
      *-*-irix*)
 
Index: libiberty/ChangeLog
===================================================================
--- a/src/libiberty/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/libiberty/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,7 @@
+2011-08-06  Uros Bizjak  <ubizjak@gmail.com>
+
+	* testsuite/test-expandargv.c (writeout_test): Check result of fwrite.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
@@ -284,7 +288,7 @@
 
 2009-04-29  Julian Brown  <julian@codesourcery.com>
 
-	* pex-win32.c (pex_win32_pipe): Add _O_NOINHERIT.    
+	* pex-win32.c (pex_win32_pipe): Add _O_NOINHERIT.
 	(pex_win32_exec_child): Ensure each process has only one handle open
 	on pipe endpoints. Close standard input after creating child for
 	symmetry with standard output/standard error.
@@ -302,7 +306,7 @@
 	section, so that the native build does detect them at configure
 	time.
 	* configure: Regenerated.
-	
+
 2009-04-13  Ozkan Sezer  <sezeroz@gmail.com>
 
         PR target/39397
@@ -402,7 +406,7 @@
 2008-10-08  David Edelsohn  <edelsohn@gnu.org>
 
 	* xstrdup.c: Include <sys/types.h> after "config.h"
- 
+
 2008-10-07  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
 	* configure.ac: Call AC_SYS_LARGEFILE.
Index: libiberty/testsuite/test-expandargv.c
===================================================================
--- a/src/libiberty/testsuite/test-expandargv.c	(.../tags/gcc_4_5_3_release)
+++ b/src/libiberty/testsuite/test-expandargv.c	(.../branches/gcc-4_5-branch)
@@ -189,7 +189,7 @@
 {
   char filename[256];
   FILE *fd;
-  size_t len;
+  size_t len, sys_fwrite;
   char * parse;
 
   /* Unique filename per test */
@@ -208,7 +208,10 @@
   /* Run all possible replaces */
   run_replaces (parse);
 
-  fwrite (parse, len, sizeof (char), fd);
+  sys_fwrite = fwrite (parse, sizeof (char), len, fd);
+  if (sys_fwrite != len)
+    fatal_error (__LINE__, "Failed to write to test file.", errno);
+
   free (parse);
   fclose (fd);
 }
Index: ChangeLog
===================================================================
--- a/src/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,29 @@
+2011-12-18  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* configure: Regenerate.
+
+2011-06-27  Hans-Peter Nilsson  <hp@axis.com>
+
+	PR regression/47836
+	PR bootstrap/23656
+	PR other/47733
+	PR bootstrap/49247
+	PR c/48825
+	* configure.ac (target_libraries): Remove target-libiberty.
+	Remove all target-specific settings adding target-libiberty to
+	skipdirs and noconfigdirs.  Remove checking target_configdirs
+	and removing target-libiberty but keeping target-libgcc if
+	otherwise empty.
+	* Makefile.def (target_modules): Don't add libiberty.
+	(dependencies): Remove all traces of target-libiberty.
+	* configure, Makefile.in: Regenerate.
+
+2011-06-19  Jack Howarth <howarth@bromo.med.uc.edu>
+
+	PR target/49461
+	* configure.ac: Use mh-x86-darwin.
+	* configure: Regenerate.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: libffi/src/alpha/osf.S
===================================================================
--- a/src/libffi/src/alpha/osf.S	(.../tags/gcc_4_5_3_release)
+++ b/src/libffi/src/alpha/osf.S	(.../branches/gcc-4_5-branch)
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   osf.S - Copyright (c) 1998, 2001, 2007, 2008 Red Hat
+   osf.S - Copyright (c) 1998, 2001, 2007, 2008, 2011 Red Hat
    
    Alpha/OSF Foreign Function Interface 
 
@@ -299,33 +299,51 @@
 #endif
 
 #ifdef __ELF__
+# define UA_SI		.4byte
+# define FDE_ENCODING	0x1b	/* pcrel sdata4 */
+# define FDE_ENCODE(X)	.4byte X-.
+# define FDE_ARANGE(X)	.4byte X
+#elif defined __osf__
+# define UA_SI		.align 0; .long
+# define FDE_ENCODING	0x50	/* aligned absolute */
+# define FDE_ENCODE(X)	.align 3; .quad X
+# define FDE_ARANGE(X)	.align 0; .quad X
+#endif
+
+#ifdef __ELF__
 	.section	.eh_frame,EH_FRAME_FLAGS,@progbits
+#elif defined __osf__
+	.data
+	.align 3
+	.globl _GLOBAL__F_ffi_call_osf
+_GLOBAL__F_ffi_call_osf:
+#endif
 __FRAME_BEGIN__:
-	.4byte	$LECIE1-$LSCIE1	# Length of Common Information Entry
+	UA_SI	$LECIE1-$LSCIE1	# Length of Common Information Entry
 $LSCIE1:
-	.4byte	0x0		# CIE Identifier Tag
+	UA_SI	0x0		# CIE Identifier Tag
 	.byte	0x1		# CIE Version
 	.ascii "zR\0"		# CIE Augmentation
 	.byte	0x1		# uleb128 0x1; CIE Code Alignment Factor
 	.byte	0x78		# sleb128 -8; CIE Data Alignment Factor
 	.byte	26		# CIE RA Column
 	.byte	0x1		# uleb128 0x1; Augmentation size
-	.byte	0x1b		# FDE Encoding (pcrel sdata4)
+	.byte	FDE_ENCODING	# FDE Encoding
 	.byte	0xc		# DW_CFA_def_cfa
 	.byte	30		# uleb128 column 30
 	.byte	0		# uleb128 offset 0
 	.align 3
 $LECIE1:
 $LSFDE1:
-	.4byte	$LEFDE1-$LASFDE1		# FDE Length
+	UA_SI	$LEFDE1-$LASFDE1		# FDE Length
 $LASFDE1:
-	.4byte	$LASFDE1-__FRAME_BEGIN__	# FDE CIE offset
-	.4byte	$LFB1-.		# FDE initial location
-	.4byte	$LFE1-$LFB1	# FDE address range
+	UA_SI	$LASFDE1-__FRAME_BEGIN__	# FDE CIE offset
+	FDE_ENCODE($LFB1)			# FDE initial location
+	FDE_ARANGE($LFE1-$LFB1)			# FDE address range
 	.byte	0x0		# uleb128 0x0; Augmentation size
 
 	.byte	0x4		# DW_CFA_advance_loc4
-	.4byte	$LCFI1-$LFB1
+	UA_SI	$LCFI1-$LFB1
 	.byte	0x9a		# DW_CFA_offset, column 26
 	.byte	4		# uleb128 4*-8
 	.byte	0x8f		# DW_CFA_offset, column 15
@@ -335,32 +353,35 @@
 	.byte	32		# uleb128 offset 32
 
 	.byte	0x4		# DW_CFA_advance_loc4
-	.4byte	$LCFI2-$LCFI1
+	UA_SI	$LCFI2-$LCFI1
 	.byte	0xda		# DW_CFA_restore, column 26
 	.align 3
 $LEFDE1:
 
 $LSFDE3:
-	.4byte	$LEFDE3-$LASFDE3		# FDE Length
+	UA_SI	$LEFDE3-$LASFDE3		# FDE Length
 $LASFDE3:
-	.4byte	$LASFDE3-__FRAME_BEGIN__	# FDE CIE offset
-	.4byte	$LFB2-.		# FDE initial location
-	.4byte	$LFE2-$LFB2	# FDE address range
+	UA_SI	$LASFDE3-__FRAME_BEGIN__	# FDE CIE offset
+	FDE_ENCODE($LFB2)			# FDE initial location
+	FDE_ARANGE($LFE2-$LFB2)			# FDE address range
 	.byte	0x0		# uleb128 0x0; Augmentation size
 
 	.byte	0x4		# DW_CFA_advance_loc4
-	.4byte	$LCFI5-$LFB2
+	UA_SI	$LCFI5-$LFB2
 	.byte	0xe		# DW_CFA_def_cfa_offset
 	.byte	0x80,0x1	# uleb128 128
 
 	.byte	0x4		# DW_CFA_advance_loc4
-	.4byte	$LCFI6-$LCFI5
+	UA_SI	$LCFI6-$LCFI5
 	.byte	0x9a		# DW_CFA_offset, column 26
 	.byte	16		# uleb128 offset 16*-8
 	.align 3
 $LEFDE3:
+#if defined __osf__
+	.align 0
+	.long	0		# End of Table
+#endif
 
-#ifdef __linux__
+#if defined __ELF__ && defined __linux__
 	.section	.note.GNU-stack,"",@progbits
 #endif
-#endif
Index: libffi/ChangeLog
===================================================================
--- a/src/libffi/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/libffi/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,13 @@
+2011-05-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2011-04-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* src/alpha/osf.S (UA_SI, FDE_ENCODING, FDE_ENCODE, FDE_ARANGE):
+	Define.
+	Use them to handle ELF vs. ECOFF differences.
+	[__osf__] (_GLOBAL__F_ffi_call_osf): Define.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: config/ChangeLog
===================================================================
--- a/src/config/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/config/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,13 @@
+2011-12-18  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* acx.m4 (Test for GNAT): Update comment and add quotes in final test.
+
+2011-06-19  Jack Howarth <howarth@bromo.med.uc.edu>
+
+	PR target/49461
+	* mh-x86-darwin: Add file and pass -no_pie on BOOT_LDFLAGS for
+	darwin11.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: config/acx.m4
===================================================================
--- a/src/config/acx.m4	(.../tags/gcc_4_5_3_release)
+++ b/src/config/acx.m4	(.../branches/gcc-4_5-branch)
@@ -356,9 +356,9 @@
 ac_c_preproc_warn_flag=yes])# AC_PROG_CPP_WERROR
 
 # Test for GNAT.
-# We require the gnatbind program, and a compiler driver that
-# understands Ada.  We use the user's CC setting, already found,
-# and possibly add $1 to the command-line parameters.
+# We require the gnatbind & gnatmake programs, as well as a compiler driver
+# that understands Ada.  We use the user's CC setting, already found, and
+# possibly add $1 to the command-line parameters.
 #
 # Sets the shell variable have_gnat to yes or no as appropriate, and
 # substitutes GNATBIND and GNATMAKE.
@@ -387,7 +387,7 @@
 fi
 rm -f conftest.*])
 
-if test x$GNATBIND != xno && test x$GNATMAKE != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
+if test "x$GNATBIND" != xno && test "x$GNATMAKE" != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
   have_gnat=yes
 else
   have_gnat=no
Index: config/mh-x86-darwin
===================================================================
--- a/src/config/mh-x86-darwin	(.../tags/gcc_4_5_3_release)
+++ b/src/config/mh-x86-darwin	(.../branches/gcc-4_5-branch)
@@ -0,0 +1,2 @@
+# Ensure we don't try and use -pie, as it is incompatible with pch.
+BOOT_LDFLAGS += `case ${host} in *-*-darwin[1][1-9]*) echo -Wl,-no_pie ;; esac;`
Index: libjava/configure.ac
===================================================================
--- a/src/libjava/configure.ac	(.../tags/gcc_4_5_3_release)
+++ b/src/libjava/configure.ac	(.../branches/gcc-4_5-branch)
@@ -882,9 +882,14 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
-    *-*-darwin[[912]]*)
-      SYSTEMSPEC="-allow_stack_execute"
+    *-*-darwin9*)
+      SYSTEMSPEC="%{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
     ;;
+    *-*-darwin[[12]]*)
+      # Something is incompatible with pie, would be nice to fix it and
+      # remove -no_pie.  PR49461
+      SYSTEMSPEC="-no_pie %{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
+    ;;
     *)
       SYSTEMSPEC=
     ;;
Index: libjava/include/dwarf2-signal.h
===================================================================
--- a/src/libjava/include/dwarf2-signal.h	(.../tags/gcc_4_5_3_release)
+++ b/src/libjava/include/dwarf2-signal.h	(.../branches/gcc-4_5-branch)
@@ -29,21 +29,8 @@
 // then throw an exception.  With the dwarf2 unwinder we don't usually
 // need to do anything, with some minor exceptions.
 
-#ifdef __alpha__
-#define MAKE_THROW_FRAME(_exception)					\
-do									\
-{									\
-  /* Alpha either leaves PC pointing at a faulting instruction or the	\
-   following instruction, depending on the signal.  SEGV always does	\
-   the former, so we adjust the saved PC to point to the following	\
-   instruction; this is what the handler in libgcc expects.  */		\
-  struct sigcontext *_sc = (struct sigcontext *)_p;			\
-  _sc->sc_pc += 4;							\
-}									\
-while (0)
+#ifdef __ia64__
 
-#elif defined(__ia64__)
-
 #define MAKE_THROW_FRAME(_exception)					\
 do									\
 {									\
Index: libjava/ChangeLog
===================================================================
--- a/src/libjava/ChangeLog	(.../tags/gcc_4_5_3_release)
+++ b/src/libjava/ChangeLog	(.../branches/gcc-4_5-branch)
@@ -1,3 +1,24 @@
+2011-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/50888
+	* prims.cc: Don't include ctype.h.
+	(c_isspace): Define.
+	(next_property_key, next_property_value): Use it instead
+	of isspace.
+
+2011-10-18  Uros Bizjak  <ubizjak@gmail.com>
+	    Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/50737
+	* include/dwarf2-signal.h [__alpha__]: Remove MAKE_THROW_FRAME
+	definition.
+
+2011-06-30  Jack Howarth <howarth@bromo.med.uc.edu>
+
+	PR target/49461
+	* libjava/configure.ac (SYSTEMSPEC): Pass -no_pie for darwin11.
+	* libjava/configure: Regenerate.
+
 2011-04-28  Release Manager
 
 	* GCC 4.5.3 released.
Index: libjava/prims.cc
===================================================================
--- a/src/libjava/prims.cc	(.../tags/gcc_4_5_3_release)
+++ b/src/libjava/prims.cc	(.../branches/gcc-4_5-branch)
@@ -38,7 +38,6 @@
 #endif
 
 #ifndef DISABLE_GETENV_PROPERTIES
-#include <ctype.h>
 #include <java-props.h>
 #define PROCESS_GCJ_PROPERTIES process_gcj_properties()
 #else
@@ -985,6 +984,8 @@
 
 #ifndef DISABLE_GETENV_PROPERTIES
 
+#define c_isspace(c) (memchr (" \t\n\r\v\f", c, 6) != NULL)
+
 static char *
 next_property_key (char *s, size_t *length)
 {
@@ -993,7 +994,7 @@
   JvAssert (s);
 
   // Skip over whitespace
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // If we've reached the end, return NULL.  Also return NULL if for
@@ -1005,7 +1006,7 @@
 
   // Determine the length of the property key.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
@@ -1027,19 +1028,19 @@
 
   JvAssert (s);
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   if (*s == ':'
       || *s == '=')
     s++;
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // Determine the length of the property value.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
Index: libjava/configure
===================================================================
--- a/src/libjava/configure	(.../tags/gcc_4_5_3_release)
+++ b/src/libjava/configure	(.../branches/gcc-4_5-branch)
@@ -19754,9 +19754,14 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
-    *-*-darwin[912]*)
-      SYSTEMSPEC="-allow_stack_execute"
+    *-*-darwin9*)
+      SYSTEMSPEC="%{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
     ;;
+    *-*-darwin[12]*)
+      # Something is incompatible with pie, would be nice to fix it and
+      # remove -no_pie.  PR49461
+      SYSTEMSPEC="-no_pie %{!Zdynamiclib:%{!Zbundle:-allow_stack_execute}}"
+    ;;
     *)
       SYSTEMSPEC=
     ;;
