# DP: Fix warnings with -D_FORTIFY_SOURCE and -Wformat-security.

libcpp/

	* macro.c (create_iso_definition): Avoid warnings with
	-Wformat-security.
	* lex.c (cpp_output_token): Avoid warnings with -D_FORTIFY_SOURCE.

gcc/

	* toplev.c (print_to_asm_out_file, print_to_stderr): Avoid warnings with
	-Wformat-security, (pch_option_mismatch) avoid warnings with
	-D_FORTIFY_SOURCE.

	* c-convert.c (convert): Avoid warnings with -Wformat-security.
	* c-typeck.c (convert_arguments, build_unary_op, build_binary_op): Likewise.
	* c-common.c (c_parse_error): Likewise.
	* cfg.c (dump_cfg_bb_info): Likewise.
	* fold-const.c (fold_overflow_warning): Likewise.
	* ira-conflicts.c (print_hard_reg_set): Likewise.
	* opts.c (print_filtered_help): Likewise.
	* tree-switch-conversion.c (do_switchconv): Likewise.
	* collect2.c (collect_execute, scan_prog_file): Likewise.

	* c-ppoutput.c (print_lines_directives_only,scan_translation_unit_trad):
	Avoid warnings with -D_FORTIFY_SOURCE.
	* dbxout.c (dbxout_finish_complex_stabs): Likewise.
	* diagnostic.c (build_message_string): Likewise.
	* final.c (output_operand_lossage): Likewise.
	* tree-data-ref.c (dot_rdg): Likewise.
	* tree-ssa-structalias.c (create_function_info_for,
	create_variable_info_for): Likewise.

gcc/cp/

	* pt.c (tsubst_copy_and_build): Avoid warnings with -Wformat-security.
	* parser.c (cp_parser_check_type_definition,
	cp_parser_non_integral_constant_expression): Likewise.
	* typeck.c (cp_build_binary_op, cp_build_unary_op): Likewise.
	* cvt.c (ocp_convert): Likewise.

gcc/fortran/

	* cpp.c (scan_translation_unit_trad): Avoid warnings with -D_FORTIFY_SOURCE.
	* trans.c (gfc_trans_runtime_error_vararg): Likewise.
	* trans-array.c (gfc_trans_array_bound_check, gfc_conv_array_ref,
	gfc_conv_ss_startstride, gfc_trans_dummy_array_bias,
	gfc_conv_array_parameter): Likewise.
	* trans-io.c (gfc_trans_io_runtime_check, set_string): Likewise.
	* trans-expr.c (gfc_conv_substring): Likewise.

	* decl.c (gfc_match_kind_spec, match_char_kind): Avoid warnings with
	-Wformat-security.
	* intrinsic.c (add_sym, find_sym, make_alias): Likewise.
	* match.c (gfc_match_small_int, gfc_match_small_int_expr): Likewise.
	* matchexp.c (match_primary, match_level_2, match_level_3,
	match_level_4, match_or_operand, match_equiv_operand, match_level_5,
	gfc_match_expr): Likewise.
	* module.c (find_true_name, mio_pool_string, mio_symtree_ref, mio_expr,
	load_generic_interfaces, load_needed, read_module, write_symbol0,
	write_generic, import_iso_c_binding_module, create_int_parameter,
	use_iso_fortran_env_module, gfc_use_module): Likewise.
	* openmp.c (gfc_match_omp_clauses): Likewise.
	* primary.c (match_hollerith_constant, match_string_constant,
	match_keyword_arg): Likewise.
	* symbol.c (gfc_add_component, gfc_new_symtree, gfc_delete_symtree,
	gfc_get_uop, gfc_new_symbol, gfc_get_gsymbol, gen_special_c_interop_ptr,
	gen_cptr_param, gen_fptr_param, gen_shape_param,
	generate_isocbinding_symbol, get_iso_c_sym): Likewise.
	* trans-decl.c (gfc_find_module): Likewise.

gcc/objc/

	* objc-act.c (objc_lookup_protocol): Avoid warnings with
	-Wformat-security.

---
 gcc/c-common.c               |    4 +-
 gcc/c-convert.c              |    2 +-
 gcc/c-ppoutput.c             |    6 ++-
 gcc/c-typeck.c               |    6 +-
 gcc/cfg.c                    |    2 +-
 gcc/collect2.c               |    8 ++--
 gcc/cp/cvt.c                 |    2 +-
 gcc/cp/parser.c              |    4 +-
 gcc/cp/pt.c                  |    2 +-
 gcc/cp/typeck.c              |    4 +-
 gcc/dbxout.c                 |    5 +-
 gcc/diagnostic.c             |    3 +-
 gcc/final.c                  |    5 +-
 gcc/fold-const.c             |    2 +-
 gcc/fortran/cpp.c            |    3 +-
 gcc/fortran/decl.c           |    4 +-
 gcc/fortran/intrinsic.c      |    8 ++--
 gcc/fortran/match.c          |    4 +-
 gcc/fortran/matchexp.c       |   18 ++++----
 gcc/fortran/module.c         |   30 +++++++-------
 gcc/fortran/openmp.c         |    2 +-
 gcc/fortran/primary.c        |    6 +-
 gcc/fortran/symbol.c         |   24 +++++-----
 gcc/fortran/trans-array.c    |   94 +++++++++++++++++++++++++----------------
 gcc/fortran/trans-decl.c     |    2 +-
 gcc/fortran/trans-expr.c     |   22 ++++++----
 gcc/fortran/trans-io.c       |    9 +++-
 gcc/fortran/trans.c          |   11 +++--
 gcc/ira-conflicts.c          |    2 +-
 gcc/objc/objc-act.c          |    2 +-
 gcc/opts.c                   |    2 +-
 gcc/toplev.c                 |    9 +++-
 gcc/tree-data-ref.c          |    3 +-
 gcc/tree-ssa-structalias.c   |   13 ++++--
 gcc/tree-switch-conversion.c |    2 +-
 libcpp/lex.c                 |    6 ++-
 libcpp/macro.c               |    4 +-
 37 files changed, 190 insertions(+), 145 deletions(-)

--- a/src/gcc/c-common.c
+++ b/src/gcc/c-common.c
@@ -7493,11 +7493,11 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token, tree value)
       message = NULL;
     }
   else
-    error (gmsgid);
+    error ("%s", gmsgid);
 
   if (message)
     {
-      error (message);
+      error ("%s", message);
       free (message);
     }
 #undef catenate_messages
--- a/src/gcc/c-convert.c
+++ b/src/gcc/c-convert.c
@@ -79,7 +79,7 @@ convert (tree type, tree expr)
   if ((invalid_conv_diag
        = targetm.invalid_conversion (TREE_TYPE (expr), type)))
     {
-      error (invalid_conv_diag);
+      error ("%s", invalid_conv_diag);
       return error_mark_node;
     }
 
--- a/src/gcc/c-ppoutput.c
+++ b/src/gcc/c-ppoutput.c
@@ -223,8 +223,9 @@ scan_translation_unit (cpp_reader *pfile)
 static void
 print_lines_directives_only (int lines, const void *buf, size_t size)
 {
+  size_t rv_neverused ATTRIBUTE_UNUSED;
   print.src_line += lines;
-  fwrite (buf, 1, size, print.outf);
+  rv_neverused = fwrite (buf, 1, size, print.outf);
 }
 
 /* Writes out the preprocessed file, handling spacing and paste
@@ -256,8 +257,9 @@ scan_translation_unit_trad (cpp_reader *pfile)
   while (_cpp_read_logical_line_trad (pfile))
     {
       size_t len = pfile->out.cur - pfile->out.base;
+      size_t rv_neverused ATTRIBUTE_UNUSED;
       maybe_print_line (pfile->out.first_line);
-      fwrite (pfile->out.base, 1, len, print.outf);
+      rv_neverused = fwrite (pfile->out.base, 1, len, print.outf);
       print.printed = 1;
       if (!CPP_OPTION (pfile, discard_comments))
 	account_for_newlines (pfile->out.base, len);
--- a/src/gcc/c-typeck.c
+++ b/src/gcc/c-typeck.c
@@ -2730,7 +2730,7 @@ convert_arguments (int nargs, tree *argarray,
       else if ((invalid_func_diag =
 		targetm.calls.invalid_arg_for_unprototyped_fn (typelist, fundecl, val)))
 	{
-	  error (invalid_func_diag);
+	  error ("%s", invalid_func_diag);
 	  return -1;
 	}
       else
@@ -2947,7 +2947,7 @@ build_unary_op (location_t location,
   if ((invalid_op_diag
        = targetm.invalid_unary_op (code, TREE_TYPE (xarg))))
     {
-      error_at (location, invalid_op_diag);
+      error_at (location, "%s", invalid_op_diag);
       return error_mark_node;
     }
 
@@ -8095,7 +8095,7 @@ build_binary_op (location_t location, enum tree_code code,
   if ((invalid_op_diag
        = targetm.invalid_binary_op (code, type0, type1)))
     {
-      error_at (location, invalid_op_diag);
+      error_at (location, "%s", invalid_op_diag);
       return error_mark_node;
     }
 
--- a/src/gcc/cfg.c
+++ b/src/gcc/cfg.c
@@ -908,7 +908,7 @@ dump_cfg_bb_info (FILE *file, basic_block bb)
 	else
 	  fprintf (file, ", ");
 	first = false;
-	fprintf (file, bb_bitnames[i]);
+	fprintf (file, "%s", bb_bitnames[i]);
       }
   if (!first)
     fprintf (file, ")");
--- a/src/gcc/collect2.c
+++ b/src/gcc/collect2.c
@@ -1647,10 +1647,10 @@ collect_execute (const char *prog, char **argv, const char *outname,
       if (err != 0)
 	{
 	  errno = err;
-	  fatal_perror (errmsg);
+	  fatal_perror ("%s", errmsg);
 	}
       else
-	fatal (errmsg);
+	fatal ("%s", errmsg);
     }
 
   if (response_arg)
@@ -2137,10 +2137,10 @@ scan_prog_file (const char *prog_name, enum pass which_pass)
       if (err != 0)
 	{
 	  errno = err;
-	  fatal_perror (errmsg);
+	  fatal_perror ("%s", errmsg);
 	}
       else
-	fatal (errmsg);
+	fatal ("%s", errmsg);
     }
 
   int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);
--- a/src/gcc/cp/cvt.c
+++ b/src/gcc/cp/cvt.c
@@ -591,7 +591,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)
   if ((invalid_conv_diag
        = targetm.invalid_conversion (TREE_TYPE (expr), type)))
     {
-      error (invalid_conv_diag);
+      error ("%s", invalid_conv_diag);
       return error_mark_node;
     }
 
--- a/src/gcc/cp/parser.c
+++ b/src/gcc/cp/parser.c
@@ -2204,7 +2204,7 @@ cp_parser_check_type_definition (cp_parser* parser)
     {
       /* Don't use `%s' to print the string, because quotations (`%<', `%>')
 	 in the message need to be interpreted.  */
-      error (parser->type_definition_forbidden_message);
+      error ("%s", parser->type_definition_forbidden_message);
       return false;
     }
   return true;
@@ -2291,7 +2291,7 @@ cp_parser_non_integral_constant_expression (cp_parser  *parser,
 	  char *message = concat (thing,
 				  " cannot appear in a constant-expression",
 				  NULL);
-	  error (message);
+	  error ("%s", message);
 	  free (message);
 	  return true;
 	}
--- a/src/gcc/cp/pt.c
+++ b/src/gcc/cp/pt.c
@@ -11060,7 +11060,7 @@ tsubst_copy_and_build (tree t,
 				     &error_msg,
 				     input_location);
 	if (error_msg)
-	  error (error_msg);
+	  error ("%s", error_msg);
 	if (!function_p && TREE_CODE (decl) == IDENTIFIER_NODE)
 	  decl = unqualified_name_lookup_error (decl);
 	return decl;
--- a/src/gcc/cp/typeck.c
+++ b/src/gcc/cp/typeck.c
@@ -3373,7 +3373,7 @@ cp_build_binary_op (location_t location,
   if ((invalid_op_diag
        = targetm.invalid_binary_op (code, type0, type1)))
     {
-      error (invalid_op_diag);
+      error ("%s", invalid_op_diag);
       return error_mark_node;
     }
 
@@ -4254,7 +4254,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,
 				    : code),
 				   TREE_TYPE (xarg))))
     {
-      error (invalid_op_diag);
+      error ("%s", invalid_op_diag);
       return error_mark_node;
     }
 
--- a/src/gcc/dbxout.c
+++ b/src/gcc/dbxout.c
@@ -847,6 +847,7 @@ dbxout_finish_complex_stabs (tree sym, STAB_CODE_TYPE code,
   int line ATTRIBUTE_UNUSED;
   char *str;
   size_t len;
+  size_t rv_neverused ATTRIBUTE_UNUSED;
 
   line = sym ? DECL_SOURCE_LINE (sym) : 0;
   if (DBX_CONTIN_LENGTH > 0)
@@ -867,7 +868,7 @@ dbxout_finish_complex_stabs (tree sym, STAB_CODE_TYPE code,
       for (;;)
 	{
 	  chunklen = strlen (chunk);
-	  fwrite (chunk, 1, chunklen, asm_out_file);
+	  rv_neverused = fwrite (chunk, 1, chunklen, asm_out_file);
 	  fputs ("\",", asm_out_file);
 
 	  /* Must add an extra byte to account for the NUL separator.  */
@@ -894,7 +895,7 @@ dbxout_finish_complex_stabs (tree sym, STAB_CODE_TYPE code,
       len = obstack_object_size (&stabstr_ob);
       str = XOBFINISH (&stabstr_ob, char *);
       
-      fwrite (str, 1, len, asm_out_file);
+      rv_neverused = fwrite (str, 1, len, asm_out_file);
       DBX_FINISH_STABS (sym, code, line, addr, label, number);
     }
   obstack_free (&stabstr_ob, str);
--- a/src/gcc/diagnostic.c
+++ b/src/gcc/diagnostic.c
@@ -70,9 +70,10 @@ build_message_string (const char *msg, ...)
 {
   char *str;
   va_list ap;
+  size_t rv_neverused ATTRIBUTE_UNUSED;
 
   va_start (ap, msg);
-  vasprintf (&str, msg, ap);
+  rv_neverused = vasprintf (&str, msg, ap);
   va_end (ap);
 
   return str;
--- a/src/gcc/final.c
+++ b/src/gcc/final.c
@@ -2989,12 +2989,13 @@ output_operand_lossage (const char *cmsgid, ...)
   char *new_message;
   const char *pfx_str;
   va_list ap;
+  int rv_neverused ATTRIBUTE_UNUSED;
 
   va_start (ap, cmsgid);
 
   pfx_str = this_is_asm_operands ? _("invalid 'asm': ") : "output_operand: ";
-  asprintf (&fmt_string, "%s%s", pfx_str, _(cmsgid));
-  vasprintf (&new_message, fmt_string, ap);
+  rv_neverused = asprintf (&fmt_string, "%s%s", pfx_str, _(cmsgid));
+  rv_neverused = vasprintf (&new_message, fmt_string, ap);
 
   if (this_is_asm_operands)
     error_for_asm (this_is_asm_operands, "%s", new_message);
--- a/src/gcc/fold-const.c
+++ b/src/gcc/fold-const.c
@@ -1025,7 +1025,7 @@ fold_overflow_warning (const char* gmsgid, enum warn_strict_overflow_code wc)
 	}
     }
   else if (issue_strict_overflow_warning (wc))
-    warning (OPT_Wstrict_overflow, gmsgid);
+    warning (OPT_Wstrict_overflow, "%s", gmsgid);
 }
 
 /* Return true if the built-in mathematical function specified by CODE
--- a/src/gcc/fortran/cpp.c
+++ b/src/gcc/fortran/cpp.c
@@ -729,8 +729,9 @@ scan_translation_unit_trad (cpp_reader *pfile)
   while (_cpp_read_logical_line_trad (pfile))
     {
       size_t len = pfile->out.cur - pfile->out.base;
+      size_t rv_neverused ATTRIBUTE_UNUSED;
       maybe_print_line (pfile->out.first_line);
-      fwrite (pfile->out.base, 1, len, print.outf);
+      rv_neverused = fwrite (pfile->out.base, 1, len, print.outf);
       print.printed = 1;
       if (!CPP_OPTION (pfile, discard_comments))
 	account_for_newlines (pfile->out.base, len);
--- a/src/gcc/fortran/decl.c
+++ b/src/gcc/fortran/decl.c
@@ -1954,7 +1954,7 @@ kind_expr:
 
   if (msg != NULL)
     {
-      gfc_error (msg);
+      gfc_error ("%s", msg);
       m = MATCH_ERROR;
       goto no_match;
     }
@@ -2060,7 +2060,7 @@ match_char_kind (int * kind, int * is_iso_c)
   *is_iso_c = e->ts.is_iso_c;
   if (msg != NULL)
     {
-      gfc_error (msg);
+      gfc_error ("%s", msg);
       m = MATCH_ERROR;
       goto no_match;
     }
--- a/src/gcc/fortran/intrinsic.c
+++ b/src/gcc/fortran/intrinsic.c
@@ -262,11 +262,11 @@ add_sym (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type
       break;
 
     case SZ_NOTHING:
-      next_sym->name = gfc_get_string (name);
+      next_sym->name = gfc_get_string ("%s", name);
 
       strcpy (buf, "_gfortran_");
       strcat (buf, name);
-      next_sym->lib_name = gfc_get_string (buf);
+      next_sym->lib_name = gfc_get_string ("%s", buf);
 
       next_sym->elemental = (cl == CLASS_ELEMENTAL);
       next_sym->inquiry = (cl == CLASS_INQUIRY);
@@ -722,7 +722,7 @@ find_sym (gfc_intrinsic_sym *start, int n, const char *name)
   /* name may be a user-supplied string, so we must first make sure
      that we're comparing against a pointer into the global string
      table.  */
-  const char *p = gfc_get_string (name);
+  const char *p = gfc_get_string ("%s", name);
 
   while (n > 0)
     {
@@ -918,7 +918,7 @@ make_alias (const char *name, int standard)
 
     case SZ_NOTHING:
       next_sym[0] = next_sym[-1];
-      next_sym->name = gfc_get_string (name);
+      next_sym->name = gfc_get_string ("%s", name);
       next_sym->standard = standard;
       next_sym++;
       break;
--- a/src/gcc/fortran/match.c
+++ b/src/gcc/fortran/match.c
@@ -391,7 +391,7 @@ gfc_match_small_int (int *value)
 
   if (p != NULL)
     {
-      gfc_error (p);
+      gfc_error ("%s", p);
       m = MATCH_ERROR;
     }
 
@@ -423,7 +423,7 @@ gfc_match_small_int_expr (int *value, gfc_expr **expr)
 
   if (p != NULL)
     {
-      gfc_error (p);
+      gfc_error ("%s", p);
       m = MATCH_ERROR;
     }
 
--- a/src/gcc/fortran/matchexp.c
+++ b/src/gcc/fortran/matchexp.c
@@ -193,7 +193,7 @@ match_primary (gfc_expr **result)
   return MATCH_YES;
 
 syntax:
-  gfc_error (expression_syntax);
+  gfc_error ("%s", expression_syntax);
   return MATCH_ERROR;
 }
 
@@ -496,7 +496,7 @@ match_level_2 (gfc_expr **result)
       m = match_ext_add_operand (&e);
       if (m == MATCH_NO)
 	{
-	  gfc_error (expression_syntax);
+	  gfc_error ("%s", expression_syntax);
 	  m = MATCH_ERROR;
 	}
     }
@@ -535,7 +535,7 @@ match_level_2 (gfc_expr **result)
 
       m = match_ext_add_operand (&e);
       if (m == MATCH_NO)
-	gfc_error (expression_syntax);
+	gfc_error ("%s", expression_syntax);
       if (m != MATCH_YES)
 	{
 	  gfc_free_expr (all);
@@ -586,7 +586,7 @@ match_level_3 (gfc_expr **result)
       m = match_level_2 (&e);
       if (m == MATCH_NO)
 	{
-	  gfc_error (expression_syntax);
+	  gfc_error ("%s", expression_syntax);
 	  gfc_free_expr (all);
 	}
       if (m != MATCH_YES)
@@ -646,7 +646,7 @@ match_level_4 (gfc_expr **result)
 
   m = match_level_3 (&right);
   if (m == MATCH_NO)
-    gfc_error (expression_syntax);
+    gfc_error ("%s", expression_syntax);
   if (m != MATCH_YES)
     {
       gfc_free_expr (left);
@@ -755,7 +755,7 @@ match_or_operand (gfc_expr **result)
 
       m = match_and_operand (&e);
       if (m == MATCH_NO)
-	gfc_error (expression_syntax);
+	gfc_error ("%s", expression_syntax);
       if (m != MATCH_YES)
 	{
 	  gfc_free_expr (all);
@@ -798,7 +798,7 @@ match_equiv_operand (gfc_expr **result)
 
       m = match_or_operand (&e);
       if (m == MATCH_NO)
-	gfc_error (expression_syntax);
+	gfc_error ("%s", expression_syntax);
       if (m != MATCH_YES)
 	{
 	  gfc_free_expr (all);
@@ -852,7 +852,7 @@ match_level_5 (gfc_expr **result)
 
       m = match_equiv_operand (&e);
       if (m == MATCH_NO)
-	gfc_error (expression_syntax);
+	gfc_error ("%s", expression_syntax);
       if (m != MATCH_YES)
 	{
 	  gfc_free_expr (all);
@@ -911,7 +911,7 @@ gfc_match_expr (gfc_expr **result)
 
       m = match_level_5 (&e);
       if (m == MATCH_NO)
-	gfc_error (expression_syntax);
+	gfc_error ("%s", expression_syntax);
       if (m != MATCH_YES)
 	{
 	  gfc_free_expr (all);
--- a/src/gcc/fortran/module.c
+++ b/src/gcc/fortran/module.c
@@ -805,9 +805,9 @@ find_true_name (const char *name, const char *module)
   gfc_symbol sym;
   int c;
 
-  sym.name = gfc_get_string (name);
+  sym.name = gfc_get_string ("%s", name);
   if (module != NULL)
-    sym.module = gfc_get_string (module);
+    sym.module = gfc_get_string ("%s", module);
   else
     sym.module = NULL;
   t.sym = &sym;
@@ -1612,7 +1612,7 @@ mio_pool_string (const char **stringp)
   else
     {
       require_atom (ATOM_STRING);
-      *stringp = atom_string[0] == '\0' ? NULL : gfc_get_string (atom_string);
+      *stringp = atom_string[0] == '\0' ? NULL : gfc_get_string ("%s", atom_string);
       gfc_free (atom_string);
     }
 }
@@ -2460,7 +2460,7 @@ mio_symtree_ref (gfc_symtree **stp)
 	    {
 	      p->u.rsym.sym = gfc_new_symbol (p->u.rsym.true_name,
 					      gfc_current_ns);
-	      p->u.rsym.sym->module = gfc_get_string (p->u.rsym.module);
+	      p->u.rsym.sym->module = gfc_get_string ("%s", p->u.rsym.module);
 	    }
 
 	  p->u.rsym.symtree->n.sym = p->u.rsym.sym;
@@ -2967,7 +2967,7 @@ mio_expr (gfc_expr **ep)
       else
 	{
 	  require_atom (ATOM_STRING);
-	  e->value.function.name = gfc_get_string (atom_string);
+	  e->value.function.name = gfc_get_string ("%s", atom_string);
 	  gfc_free (atom_string);
 
 	  mio_integer (&flag);
@@ -3695,8 +3695,8 @@ load_generic_interfaces (void)
 	      if (!sym)
 		{
 		  gfc_get_symbol (p, NULL, &sym);
-		  sym->name = gfc_get_string (name);
-		  sym->module = gfc_get_string (module_name);
+		  sym->name = gfc_get_string ("%s", name);
+		  sym->module = gfc_get_string ("%s", module_name);
 		  sym->attr.flavor = FL_PROCEDURE;
 		  sym->attr.generic = 1;
 		  sym->attr.use_assoc = 1;
@@ -3901,7 +3901,7 @@ load_needed (pointer_info *p)
 				 1, &ns->proc_name);
 
       sym = gfc_new_symbol (p->u.rsym.true_name, ns);
-      sym->module = gfc_get_string (p->u.rsym.module);
+      sym->module = gfc_get_string ("%s", p->u.rsym.module);
       strcpy (sym->binding_label, p->u.rsym.binding_label);
 
       associate_integer_pointer (p, sym);
@@ -4162,7 +4162,7 @@ read_module (void)
 		  info->u.rsym.sym = gfc_new_symbol (info->u.rsym.true_name,
 						     gfc_current_ns);
 		  sym = info->u.rsym.sym;
-		  sym->module = gfc_get_string (info->u.rsym.module);
+		  sym->module = gfc_get_string ("%s", info->u.rsym.module);
 
 		  /* TODO: hmm, can we test this?  Do we know it will be
 		     initialized to zeros?  */
@@ -4521,7 +4521,7 @@ write_symbol0 (gfc_symtree *st)
 
   sym = st->n.sym;
   if (sym->module == NULL)
-    sym->module = gfc_get_string (module_name);
+    sym->module = gfc_get_string ("%s", module_name);
 
   if (sym->attr.flavor == FL_PROCEDURE && sym->attr.generic
       && !sym->attr.subroutine && !sym->attr.function)
@@ -4614,7 +4614,7 @@ write_generic (gfc_symtree *st)
     return;
 
   if (sym->module == NULL)
-    sym->module = gfc_get_string (module_name);
+    sym->module = gfc_get_string ("%s", module_name);
 
   mio_symbol_interface (&st->name, &sym->module, &sym->generic);
 }
@@ -4962,7 +4962,7 @@ import_iso_c_binding_module (void)
 
       mod_sym->attr.flavor = FL_MODULE;
       mod_sym->attr.intrinsic = 1;
-      mod_sym->module = gfc_get_string (iso_c_module_name);
+      mod_sym->module = gfc_get_string ("%s", iso_c_module_name);
       mod_sym->from_intmod = INTMOD_ISO_C_BINDING;
     }
 
@@ -5039,7 +5039,7 @@ create_int_parameter (const char *name, int value, const char *modname,
   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree);
   sym = tmp_symtree->n.sym;
 
-  sym->module = gfc_get_string (modname);
+  sym->module = gfc_get_string ("%s", modname);
   sym->attr.flavor = FL_PARAMETER;
   sym->ts.type = BT_INTEGER;
   sym->ts.kind = gfc_default_integer_kind;
@@ -5083,7 +5083,7 @@ use_iso_fortran_env_module (void)
 
       mod_sym->attr.flavor = FL_MODULE;
       mod_sym->attr.intrinsic = 1;
-      mod_sym->module = gfc_get_string (mod);
+      mod_sym->module = gfc_get_string ("%s", mod);
       mod_sym->from_intmod = INTMOD_ISO_FORTRAN_ENV;
     }
   else
@@ -5279,7 +5279,7 @@ gfc_use_module (void)
   fclose (module_fp);
 
   use_stmt = gfc_get_use_list ();
-  use_stmt->module_name = gfc_get_string (module_name);
+  use_stmt->module_name = gfc_get_string ("%s", module_name);
   use_stmt->only_flag = only_flag;
   use_stmt->rename = gfc_rename_list;
   use_stmt->where = use_locus;
--- a/src/gcc/fortran/openmp.c
+++ b/src/gcc/fortran/openmp.c
@@ -396,7 +396,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)
 	      const char *p = gfc_extract_int (cexpr, &collapse);
 	      if (p)
 		{
-		  gfc_error (p);
+		  gfc_error ("%s", p);
 		  collapse = 1;
 		}
 	      else if (collapse <= 0)
--- a/src/gcc/fortran/primary.c
+++ b/src/gcc/fortran/primary.c
@@ -255,7 +255,7 @@ match_hollerith_constant (gfc_expr **result)
       msg = gfc_extract_int (e, &num);
       if (msg != NULL)
 	{
-	  gfc_error (msg);
+	  gfc_error ("%s", msg);
 	  goto cleanup;
 	}
       if (num == 0)
@@ -924,7 +924,7 @@ match_string_constant (gfc_expr **result)
       q = gfc_extract_int (sym->value, &kind);
       if (q != NULL)
 	{
-	  gfc_error (q);
+	  gfc_error ("%s", q);
 	  return MATCH_ERROR;
 	}
       gfc_set_sym_referenced (sym);
@@ -1479,7 +1479,7 @@ match_keyword_arg (gfc_actual_arglist *actual, gfc_actual_arglist *base)
 	  }
     }
 
-  actual->name = gfc_get_string (name);
+  actual->name = gfc_get_string ("%s", name);
   return MATCH_YES;
 
 cleanup:
--- a/src/gcc/fortran/symbol.c
+++ b/src/gcc/fortran/symbol.c
@@ -1759,7 +1759,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,
   else
     tail->next = p;
 
-  p->name = gfc_get_string (name);
+  p->name = gfc_get_string ("%s", name);
   p->loc = gfc_current_locus;
 
   *component = p;
@@ -2251,7 +2251,7 @@ gfc_new_symtree (gfc_symtree **root, const char *name)
   gfc_symtree *st;
 
   st = XCNEW (gfc_symtree);
-  st->name = gfc_get_string (name);
+  st->name = gfc_get_string ("%s", name);
   st->typebound = NULL;
 
   gfc_insert_bbt (root, st, compare_symtree);
@@ -2268,7 +2268,7 @@ gfc_delete_symtree (gfc_symtree **root, const char *name)
 
   st0 = gfc_find_symtree (*root, name);
 
-  st.name = gfc_get_string (name);
+  st.name = gfc_get_string ("%s", name);
   gfc_delete_bbt (root, &st, compare_symtree);
 
   gfc_free (st0);
@@ -2327,7 +2327,7 @@ gfc_get_uop (const char *name)
   st = gfc_new_symtree (&gfc_current_ns->uop_root, name);
 
   uop = st->n.uop = XCNEW (gfc_user_op);
-  uop->name = gfc_get_string (name);
+  uop->name = gfc_get_string ("%s", name);
   uop->access = ACCESS_UNKNOWN;
   uop->ns = gfc_current_ns;
 
@@ -2399,7 +2399,7 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)
   if (strlen (name) > GFC_MAX_SYMBOL_LEN)
     gfc_internal_error ("new_symbol(): Symbol name too long");
 
-  p->name = gfc_get_string (name);
+  p->name = gfc_get_string ("%s", name);
 
   /* Make sure flags for symbol being C bound are clear initially.  */
   p->attr.is_bind_c = 0;
@@ -3280,7 +3280,7 @@ gfc_get_gsymbol (const char *name)
 
   s = XCNEW (gfc_gsymbol);
   s->type = GSYM_UNKNOWN;
-  s->name = gfc_get_string (name);
+  s->name = gfc_get_string ("%s", name);
 
   gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);
 
@@ -3517,7 +3517,7 @@ gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,
     }
 
   /* Module name is some mangled version of iso_c_binding.  */
-  tmp_sym->module = gfc_get_string (module_name);
+  tmp_sym->module = gfc_get_string ("%s", module_name);
   
   /* Say it's from the iso_c_binding module.  */
   tmp_sym->attr.is_iso_c = 1;
@@ -3637,7 +3637,7 @@ gen_cptr_param (gfc_formal_arglist **head,
     }
 
   param_sym->ts.derived = c_ptr_sym;
-  param_sym->module = gfc_get_string (module_name);
+  param_sym->module = gfc_get_string ("%s", module_name);
 
   /* Make new formal arg.  */
   formal_arg = gfc_get_formal_arglist ();
@@ -3682,7 +3682,7 @@ gen_fptr_param (gfc_formal_arglist **head,
 
   /* ISO C Binding type to allow any pointer type as actual param.  */
   param_sym->ts.type = BT_VOID;
-  param_sym->module = gfc_get_string (module_name);
+  param_sym->module = gfc_get_string ("%s", module_name);
    
   /* Make the arg.  */
   formal_arg = gfc_get_formal_arglist ();
@@ -3753,7 +3753,7 @@ gen_shape_param (gfc_formal_arglist **head,
   param_sym->attr.optional = 1;
   param_sym->attr.intent = INTENT_IN;
   param_sym->attr.dimension = 1;
-  param_sym->module = gfc_get_string (module_name);
+  param_sym->module = gfc_get_string ("%s", module_name);
    
   /* Make the arg.  */
   formal_arg = gfc_get_formal_arglist ();
@@ -3957,7 +3957,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,
 			"create symbol");
 
   /* Say what module this symbol belongs to.  */
-  tmp_sym->module = gfc_get_string (mod_name);
+  tmp_sym->module = gfc_get_string ("%s", mod_name);
   tmp_sym->from_intmod = INTMOD_ISO_C_BINDING;
   tmp_sym->intmod_sym_id = s;
 
@@ -4234,7 +4234,7 @@ get_iso_c_sym (gfc_symbol *old_sym, char *new_name,
   strcpy (new_symtree->n.sym->binding_label, new_binding_label);
   new_symtree->n.sym->attr = old_sym->attr;
   new_symtree->n.sym->ts = old_sym->ts;
-  new_symtree->n.sym->module = gfc_get_string (old_sym->module);
+  new_symtree->n.sym->module = gfc_get_string ("%s", old_sym->module);
   new_symtree->n.sym->from_intmod = old_sym->from_intmod;
   new_symtree->n.sym->intmod_sym_id = old_sym->intmod_sym_id;
   /* Build the formal arg list.  */
--- a/src/gcc/fortran/trans-array.c
+++ b/src/gcc/fortran/trans-array.c
@@ -2232,6 +2232,7 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,
   tree tmp;
   char *msg;
   const char * name = NULL;
+  int rv_neverused ATTRIBUTE_UNUSED;
 
   if (!flag_bounds_check)
     return index;
@@ -2270,11 +2271,13 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,
   tmp = gfc_conv_array_lbound (descriptor, n);
   fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp);
   if (name)
-    asprintf (&msg, "%s for array '%s', lower bound of dimension %d exceeded"
-	      "(%%ld < %%ld)", gfc_msg_fault, name, n+1);
+    rv_neverused =
+      asprintf (&msg, "%s for array '%s', lower bound of dimension %d exceeded"
+		"(%%ld < %%ld)", gfc_msg_fault, name, n+1);
   else
-    asprintf (&msg, "%s, lower bound of dimension %d exceeded (%%ld < %%ld)",
-	      gfc_msg_fault, n+1);
+    rv_neverused =
+      asprintf (&msg, "%s, lower bound of dimension %d exceeded (%%ld < %%ld)",
+		gfc_msg_fault, n+1);
   gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,
 			   fold_convert (long_integer_type_node, index),
 			   fold_convert (long_integer_type_node, tmp));
@@ -2286,11 +2289,14 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,
       tmp = gfc_conv_array_ubound (descriptor, n);
       fault = fold_build2 (GT_EXPR, boolean_type_node, index, tmp);
       if (name)
-	asprintf (&msg, "%s for array '%s', upper bound of dimension %d "
-			" exceeded (%%ld > %%ld)", gfc_msg_fault, name, n+1);
+	rv_neverused =
+	  asprintf (&msg, "%s for array '%s', upper bound of dimension %d "
+		    " exceeded (%%ld > %%ld)", gfc_msg_fault, name, n+1);
       else
-	asprintf (&msg, "%s, upper bound of dimension %d exceeded (%%ld > %%ld)",
-		  gfc_msg_fault, n+1);
+	rv_neverused =
+	  asprintf (&msg,
+		    "%s, upper bound of dimension %d exceeded (%%ld > %%ld)",
+		    gfc_msg_fault, n+1);
       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,
 			       fold_convert (long_integer_type_node, index),
 			       fold_convert (long_integer_type_node, tmp));
@@ -2474,6 +2480,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,
 	  /* Check array bounds.  */
 	  tree cond;
 	  char *msg;
+	  int rv_neverused ATTRIBUTE_UNUSED;
 
 	  /* Evaluate the indexse.expr only once.  */
 	  indexse.expr = save_expr (indexse.expr);
@@ -2482,9 +2489,10 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,
 	  tmp = gfc_conv_array_lbound (se->expr, n);
 	  cond = fold_build2 (LT_EXPR, boolean_type_node, 
 			      indexse.expr, tmp);
-	  asprintf (&msg, "%s for array '%s', "
-	            "lower bound of dimension %d exceeded (%%ld < %%ld)",
-		    gfc_msg_fault, sym->name, n+1);
+	  rv_neverused =
+	    asprintf (&msg, "%s for array '%s', "
+		      "lower bound of dimension %d exceeded (%%ld < %%ld)",
+		      gfc_msg_fault, sym->name, n+1);
 	  gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,
 				   fold_convert (long_integer_type_node,
 						 indexse.expr),
@@ -2499,9 +2507,10 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,
 	      tmp = gfc_conv_array_ubound (se->expr, n);
 	      cond = fold_build2 (GT_EXPR, boolean_type_node, 
 				  indexse.expr, tmp);
-	      asprintf (&msg, "%s for array '%s', "
-			"upper bound of dimension %d exceeded (%%ld > %%ld)",
-			gfc_msg_fault, sym->name, n+1);
+	      rv_neverused =
+		asprintf (&msg, "%s for array '%s', "
+			  "upper bound of dimension %d exceeded (%%ld > %%ld)",
+			  gfc_msg_fault, sym->name, n+1);
 	      gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,
 				   fold_convert (long_integer_type_node,
 						 indexse.expr),
@@ -3048,6 +3057,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)
 	  for (n = 0; n < loop->dimen; n++)
 	    {
 	      bool check_upper;
+	      int rv_neverused ATTRIBUTE_UNUSED;
 
 	      dim = info->dim[n];
 	      if (info->ref->u.ar.dimen_type[dim] != DIMEN_RANGE)
@@ -3063,9 +3073,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)
 	      /* Zero stride is not allowed.  */
 	      tmp = fold_build2 (EQ_EXPR, boolean_type_node, info->stride[n],
 				 gfc_index_zero_node);
-	      asprintf (&msg, "Zero stride is not allowed, for dimension %d "
-			"of array '%s'", info->dim[n]+1,
-			ss->expr->symtree->name);
+	      rv_neverused = 
+		asprintf (&msg, "Zero stride is not allowed, for dimension %d "
+			  "of array '%s'", info->dim[n]+1,
+			  ss->expr->symtree->name);
 	      gfc_trans_runtime_check (true, false, tmp, &inner,
 				       &ss->expr->where, msg);
 	      gfc_free (msg);
@@ -3106,9 +3117,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)
 				 lbound);
 	      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
 				 non_zerosized, tmp);
-	      asprintf (&msg, "%s, lower bound of dimension %d of array '%s'"
-			" exceeded (%%ld < %%ld)", gfc_msg_fault,
-			info->dim[n]+1, ss->expr->symtree->name);
+	      rv_neverused =
+		asprintf (&msg, "%s, lower bound of dimension %d of array '%s'"
+			  " exceeded (%%ld < %%ld)", gfc_msg_fault,
+			  info->dim[n]+1, ss->expr->symtree->name);
 	      gfc_trans_runtime_check (true, false, tmp, &inner,
 				       &ss->expr->where, msg,
 				       fold_convert (long_integer_type_node,
@@ -3123,9 +3135,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)
 				     info->start[n], ubound);
 		  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
 				     non_zerosized, tmp);
-	          asprintf (&msg, "%s, upper bound of dimension %d of array "
-			    "'%s' exceeded (%%ld > %%ld)", gfc_msg_fault,
-			    info->dim[n]+1, ss->expr->symtree->name);
+	          rv_neverused =
+		    asprintf (&msg, "%s, upper bound of dimension %d of array "
+			      "'%s' exceeded (%%ld > %%ld)", gfc_msg_fault,
+			      info->dim[n]+1, ss->expr->symtree->name);
 		  gfc_trans_runtime_check (true, false, tmp, &inner,
 			&ss->expr->where, msg,
 			fold_convert (long_integer_type_node, info->start[n]),
@@ -3146,9 +3159,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)
 	      tmp = fold_build2 (LT_EXPR, boolean_type_node, tmp2, lbound);
 	      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
 				 non_zerosized, tmp);
-	      asprintf (&msg, "%s, lower bound of dimension %d of array '%s'"
-			" exceeded (%%ld < %%ld)", gfc_msg_fault,
-			info->dim[n]+1, ss->expr->symtree->name);
+	      rv_neverused =
+		asprintf (&msg, "%s, lower bound of dimension %d of array '%s'"
+			  " exceeded (%%ld < %%ld)", gfc_msg_fault,
+			  info->dim[n]+1, ss->expr->symtree->name);
 	      gfc_trans_runtime_check (true, false, tmp, &inner,
 				       &ss->expr->where, msg,
 				       fold_convert (long_integer_type_node,
@@ -3162,9 +3176,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)
 		  tmp = fold_build2 (GT_EXPR, boolean_type_node, tmp2, ubound);
 		  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
 				     non_zerosized, tmp);
-		  asprintf (&msg, "%s, upper bound of dimension %d of array "
-			    "'%s' exceeded (%%ld > %%ld)", gfc_msg_fault,
-			    info->dim[n]+1, ss->expr->symtree->name);
+		  rv_neverused =
+		    asprintf (&msg, "%s, upper bound of dimension %d of array "
+			      "'%s' exceeded (%%ld > %%ld)", gfc_msg_fault,
+			      info->dim[n]+1, ss->expr->symtree->name);
 		  gfc_trans_runtime_check (true, false, tmp, &inner,
 			&ss->expr->where, msg,
 			fold_convert (long_integer_type_node, tmp2),
@@ -3186,9 +3201,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)
 		  tree tmp3;
 
 		  tmp3 = fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);
-		  asprintf (&msg, "%s, size mismatch for dimension %d "
-			    "of array '%s' (%%ld/%%ld)", gfc_msg_bounds,
-			    info->dim[n]+1, ss->expr->symtree->name);
+		  rv_neverused =
+		    asprintf (&msg, "%s, size mismatch for dimension %d "
+			      "of array '%s' (%%ld/%%ld)", gfc_msg_bounds,
+			      info->dim[n]+1, ss->expr->symtree->name);
 		  gfc_trans_runtime_check (true, false, tmp3, &inner,
 					   &ss->expr->where, msg,
 			fold_convert (long_integer_type_node, tmp),
@@ -4449,14 +4465,16 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)
 	    {
 	      /* Check (ubound(a) - lbound(a) == ubound(b) - lbound(b)).  */
 	      char * msg;
+	      int rv_neverused ATTRIBUTE_UNUSED;
 
 	      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,
 				 ubound, lbound);
               stride2 = fold_build2 (MINUS_EXPR, gfc_array_index_type,
 				     dubound, dlbound);
               tmp = fold_build2 (NE_EXPR, gfc_array_index_type, tmp, stride2);
-	      asprintf (&msg, "%s for dimension %d of array '%s'",
-			gfc_msg_bounds, n+1, sym->name);
+	      rv_neverused =
+		asprintf (&msg, "%s for dimension %d of array '%s'",
+			  gfc_msg_bounds, n+1, sym->name);
 	      gfc_trans_runtime_check (true, false, tmp, &block, &loc, msg);
 	      gfc_free (msg);
 	    }
@@ -5332,12 +5350,14 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,
       if (gfc_option.flag_check_array_temporaries)
 	{
 	  char * msg;
+	  int rv_neverused ATTRIBUTE_UNUSED;
 
 	  if (fsym && proc_name)
-	    asprintf (&msg, "An array temporary was created for argument "
-		      "'%s' of procedure '%s'", fsym->name, proc_name);
+	    rv_neverused =
+	      asprintf (&msg, "An array temporary was created for argument "
+			"'%s' of procedure '%s'", fsym->name, proc_name);
 	  else
-	    asprintf (&msg, "An array temporary was created");
+	    rv_neverused = asprintf (&msg, "An array temporary was created");
 
 	  tmp = build_fold_indirect_ref (desc);
 	  tmp = gfc_conv_array_data (tmp);
--- a/src/gcc/fortran/trans-decl.c
+++ b/src/gcc/fortran/trans-decl.c
@@ -3071,7 +3071,7 @@ gfc_find_module (const char *name)
     {
       struct module_htab_entry *entry = GGC_CNEW (struct module_htab_entry);
 
-      entry->name = gfc_get_string (name);
+      entry->name = gfc_get_string ("%s", name);
       entry->decls = htab_create_ggc (10, module_htab_decls_hash,
 				      module_htab_decls_eq, NULL);
       *slot = (void *) entry;
--- a/src/gcc/fortran/trans-expr.c
+++ b/src/gcc/fortran/trans-expr.c
@@ -400,6 +400,8 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,
 
   if (flag_bounds_check)
     {
+      int rv_neverused ATTRIBUTE_UNUSED;
+
       tree nonempty = fold_build2 (LE_EXPR, boolean_type_node,
 				   start.expr, end.expr);
 
@@ -409,11 +411,13 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,
       fault = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node,
 			   nonempty, fault);
       if (name)
-	asprintf (&msg, "Substring out of bounds: lower bound (%%ld) of '%s' "
-		  "is less than one", name);
+	rv_neverused =
+	  asprintf (&msg, "Substring out of bounds: lower bound (%%ld) of '%s' "
+		    "is less than one", name);
       else
-	asprintf (&msg, "Substring out of bounds: lower bound (%%ld)"
-		  "is less than one");
+	rv_neverused =
+	  asprintf (&msg, "Substring out of bounds: lower bound (%%ld)"
+		    "is less than one");
       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,
 			       fold_convert (long_integer_type_node,
 					     start.expr));
@@ -425,11 +429,13 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,
       fault = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node,
 			   nonempty, fault);
       if (name)
-	asprintf (&msg, "Substring out of bounds: upper bound (%%ld) of '%s' "
-		  "exceeds string length (%%ld)", name);
+	rv_neverused =
+	  asprintf (&msg, "Substring out of bounds: upper bound (%%ld) of '%s' "
+		    "exceeds string length (%%ld)", name);
       else
-	asprintf (&msg, "Substring out of bounds: upper bound (%%ld) "
-		  "exceeds string length (%%ld)");
+	rv_neverused =
+	  asprintf (&msg, "Substring out of bounds: upper bound (%%ld) "
+		    "exceeds string length (%%ld)");
       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,
 			       fold_convert (long_integer_type_node, end.expr),
 			       fold_convert (long_integer_type_node,
--- a/src/gcc/fortran/trans-io.c
+++ b/src/gcc/fortran/trans-io.c
@@ -232,6 +232,7 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,
   tree tmp;
   tree arg1, arg2, arg3;
   char *message;
+  int rv_neverused ATTRIBUTE_UNUSED;
 
   if (integer_zerop (cond))
     return;
@@ -243,7 +244,7 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,
   
   arg2 = build_int_cst (integer_type_node, error_code),
   
-  asprintf (&message, "%s", _(msgid));
+  rv_neverused = asprintf (&message, "%s", _(msgid));
   arg3 = gfc_build_addr_expr (pchar_type_node,
 			      gfc_build_localized_cstring_const (message));
   gfc_free(message);
@@ -660,14 +661,16 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,
     {
       char * msg;
       tree cond;
+      int rv_neverused ATTRIBUTE_UNUSED;
 
       gfc_conv_label_variable (&se, e);
       tmp = GFC_DECL_STRING_LEN (se.expr);
       cond = fold_build2 (LT_EXPR, boolean_type_node,
 			  tmp, build_int_cst (TREE_TYPE (tmp), 0));
 
-      asprintf(&msg, "Label assigned to variable '%s' (%%ld) is not a format "
-	       "label", e->symtree->name);
+      rv_neverused =
+	asprintf(&msg, "Label assigned to variable '%s' (%%ld) is not a format "
+		 "label", e->symtree->name);
       gfc_trans_runtime_check (true, false, cond, &se.pre, &e->where, msg,
 			       fold_convert (long_integer_type_node, tmp));
       gfc_free (msg);
--- a/src/gcc/fortran/trans.c
+++ b/src/gcc/fortran/trans.c
@@ -371,6 +371,7 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,
   char *message;
   const char *p;
   int line, nargs, i;
+  int rv_neverused ATTRIBUTE_UNUSED;
 
   /* Compute the number of extra arguments from the format string.  */
   for (p = msgid, nargs = 0; *p; p++)
@@ -387,18 +388,18 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,
   if (where)
     {
       line = LOCATION_LINE (where->lb->location);
-      asprintf (&message, "At line %d of file %s",  line,
-		where->lb->file->filename);
+      rv_neverused = asprintf (&message, "At line %d of file %s",  line,
+			       where->lb->file->filename);
     }
   else
-    asprintf (&message, "In file '%s', around line %d",
-	      gfc_source_file, input_line + 1);
+    rv_neverused = asprintf (&message, "In file '%s', around line %d",
+			     gfc_source_file, input_line + 1);
 
   arg = gfc_build_addr_expr (pchar_type_node,
 			     gfc_build_localized_cstring_const (message));
   gfc_free(message);
   
-  asprintf (&message, "%s", _(msgid));
+  rv_neverused = asprintf (&message, "%s", _(msgid));
   arg2 = gfc_build_addr_expr (pchar_type_node,
 			      gfc_build_localized_cstring_const (message));
   gfc_free(message);
--- a/src/gcc/ira-conflicts.c
+++ b/src/gcc/ira-conflicts.c
@@ -664,7 +664,7 @@ print_hard_reg_set (FILE *file, const char *title, HARD_REG_SET set)
 {
   int i, start;
 
-  fprintf (file, title);
+  fputs (title, file);
   for (start = -1, i = 0; i < FIRST_PSEUDO_REGISTER; i++)
     {
       if (TEST_HARD_REG_BIT (set, i))
--- a/src/gcc/objc/objc-act.c
+++ b/src/gcc/objc/objc-act.c
@@ -988,7 +988,7 @@ objc_lookup_protocol (tree proto, tree cls, tree typ, bool warn)
       strcat (errbuf, " the \'");
       strcat (errbuf, IDENTIFIER_POINTER (PROTOCOL_NAME (proto)));
       strcat (errbuf, "\' protocol");
-      warning (0, errbuf);
+      warning (0, "%s", errbuf);
     }
 
   return false;
--- a/src/gcc/opts.c
+++ b/src/gcc/opts.c
@@ -1287,7 +1287,7 @@ print_filtered_help (unsigned int include_flags,
 		      if (* (const char **) option->flag_var != NULL)
 			snprintf (new_help + strlen (new_help),
 				  sizeof (new_help) - strlen (new_help),
-				  * (const char **) option->flag_var);
+				  "%s", * (const char **) option->flag_var);
 		    }
 		  else
 		    sprintf (new_help + strlen (new_help),
--- a/src/gcc/toplev.c
+++ b/src/gcc/toplev.c
@@ -1182,7 +1182,7 @@ print_to_asm_out_file (print_switch_type type, const char * text)
     case SWITCH_TYPE_ENABLED:
       if (prepend_sep)
 	fputc (' ', asm_out_file);
-      fprintf (asm_out_file, text);
+      fputs (text, asm_out_file);
       /* No need to return the length here as
 	 print_single_switch has already done it.  */
       return 0;
@@ -1211,7 +1211,7 @@ print_to_stderr (print_switch_type type, const char * text)
       /* Drop through.  */
 
     case SWITCH_TYPE_DESCRIPTIVE:
-      fprintf (stderr, text);
+      fputs (text, stderr);
       /* No need to return the length here as
 	 print_single_switch has already done it.  */
       return 0;
@@ -1437,8 +1437,11 @@ static const char *
 pch_option_mismatch (const char *option)
 {
   char *r;
+  int rv_neverused ATTRIBUTE_UNUSED;
 
-  asprintf (&r, _("created and used with differing settings of '%s'"), option);
+  rv_neverused = asprintf (&r,
+			   _("created and used with differing settings of '%s'"),
+			   option);
   if (r == NULL)
     return _("out of memory");
   return r;
--- a/src/gcc/tree-data-ref.c
+++ b/src/gcc/tree-data-ref.c
@@ -4607,13 +4607,14 @@ dot_rdg_1 (FILE *file, struct graph *rdg)
 void
 dot_rdg (struct graph *rdg)
 {
+  int rv_neverused ATTRIBUTE_UNUSED;
   FILE *file = fopen ("/tmp/rdg.dot", "w");
   gcc_assert (file != NULL);
 
   dot_rdg_1 (file, rdg);
   fclose (file);
 
-  system ("dotty /tmp/rdg.dot");
+  rv_neverused = system ("dotty /tmp/rdg.dot");
 }
 
 
--- a/src/gcc/tree-ssa-structalias.c
+++ b/src/gcc/tree-ssa-structalias.c
@@ -4240,6 +4240,7 @@ create_function_info_for (tree decl, const char *name)
   tree arg;
   unsigned int i;
   bool is_varargs = false;
+  int rv_neverused ATTRIBUTE_UNUSED;
 
   /* Create the variable info.  */
 
@@ -4279,7 +4280,7 @@ create_function_info_for (tree decl, const char *name)
 	argdecl = arg;
 
       newindex = VEC_length (varinfo_t, varmap);
-      asprintf (&tempname, "%s.arg%d", name, i-1);
+      rv_neverused = asprintf (&tempname, "%s.arg%d", name, i-1);
       newname = ggc_strdup (tempname);
       free (tempname);
 
@@ -4315,7 +4316,7 @@ create_function_info_for (tree decl, const char *name)
 	resultdecl = DECL_RESULT (decl);
 
       newindex = VEC_length (varinfo_t, varmap);
-      asprintf (&tempname, "%s.result", name);
+      rv_neverused = asprintf (&tempname, "%s.result", name);
       newname = ggc_strdup (tempname);
       free (tempname);
 
@@ -4474,9 +4475,11 @@ create_variable_info_for (tree decl, const char *name)
 	  newindex = VEC_length (varinfo_t, varmap);
 	  if (dump_file)
 	    {
-	      asprintf (&tempname, "%s." HOST_WIDE_INT_PRINT_DEC
-			"+" HOST_WIDE_INT_PRINT_DEC,
-			vi->name, fo->offset, fo->size);
+	      int rv_neverused ATTRIBUTE_UNUSED;
+
+	      rv_neverused = asprintf (&tempname, "%s." HOST_WIDE_INT_PRINT_DEC
+				       "+" HOST_WIDE_INT_PRINT_DEC,
+				       vi->name, fo->offset, fo->size);
 	      newname = ggc_strdup (tempname);
 	      free (tempname);
 	    }
--- a/src/gcc/tree-switch-conversion.c
+++ b/src/gcc/tree-switch-conversion.c
@@ -858,7 +858,7 @@ do_switchconv (void)
 	      {
 		gcc_assert (info.reason);
 		fprintf (dump_file, "Bailing out - ");
-		fprintf (dump_file, info.reason);
+		fprintf (dump_file, "%s", info.reason);
 		fprintf (dump_file, "--------------------------------\n");
 	      }
 	  }
--- a/src/libcpp/lex.c
+++ b/src/libcpp/lex.c
@@ -1512,6 +1512,8 @@ cpp_type2name (enum cpp_ttype type)
 void
 cpp_output_token (const cpp_token *token, FILE *fp)
 {
+  size_t rv_neverused ATTRIBUTE_UNUSED;
+
   switch (TOKEN_SPELL (token))
     {
     case SPELL_OPERATOR:
@@ -1545,7 +1547,7 @@ cpp_output_token (const cpp_token *token, FILE *fp)
 	    {
 	      unsigned char buffer[10];
 	      i += utf8_to_ucn (buffer, name + i) - 1;
-	      fwrite (buffer, 1, 10, fp);
+	      rv_neverused = fwrite (buffer, 1, 10, fp);
 	    }
 	  else
 	    fputc (NODE_NAME (token->val.node)[i], fp);
@@ -1553,7 +1555,7 @@ cpp_output_token (const cpp_token *token, FILE *fp)
       break;
 
     case SPELL_LITERAL:
-      fwrite (token->val.str.text, 1, token->val.str.len, fp);
+      rv_neverused = fwrite (token->val.str.text, 1, token->val.str.len, fp);
       break;
 
     case SPELL_NONE:
--- a/src/libcpp/macro.c
+++ b/src/libcpp/macro.c
@@ -1701,7 +1701,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)
 	     function-like macros, but not at the end.  */
 	  if (following_paste_op)
 	    {
-	      cpp_error (pfile, CPP_DL_ERROR, paste_op_error_msg);
+	      cpp_error (pfile, CPP_DL_ERROR, "%s", paste_op_error_msg);
 	      return false;
 	    }
 	  break;
@@ -1714,7 +1714,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)
 	     function-like macros, but not at the beginning.  */
 	  if (macro->count == 1)
 	    {
-	      cpp_error (pfile, CPP_DL_ERROR, paste_op_error_msg);
+	      cpp_error (pfile, CPP_DL_ERROR, "%s", paste_op_error_msg);
 	      return false;
 	    }
 
