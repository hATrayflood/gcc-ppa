diff -urN gcc.orig/config/i386/i386.c gcc/config/i386/i386.c
--- gcc.orig/config/i386/i386.c	2006-11-17 08:01:22.000000000 +0100
+++ gcc/config/i386/i386.c	2007-08-26 20:40:16.000949869 +0200
@@ -2738,6 +2738,30 @@
 	    }
 	  break;
 
+	case SET_TYPE:
+          if (bytes <= 4)
+            {
+              classes[0] = X86_64_INTEGERSI_CLASS;
+              return 1;
+            }
+          else if (bytes <= 8)
+            {
+              classes[0] = X86_64_INTEGER_CLASS;
+              return 1;
+            }
+          else if (bytes <= 12)
+            {
+              classes[0] = X86_64_INTEGER_CLASS;
+              classes[1] = X86_64_INTEGERSI_CLASS;
+              return 2;
+            }
+          else
+            {
+              classes[0] = X86_64_INTEGER_CLASS;
+              classes[1] = X86_64_INTEGER_CLASS;
+              return 2;
+            }
+
 	default:
 	  gcc_unreachable ();
 	}
diff -urN gcc.orig/config/ia64/ia64.c gcc/config/ia64/ia64.c
--- gcc.orig/config/ia64/ia64.c	2006-12-21 14:06:37.000000000 +0100
+++ gcc/config/ia64/ia64.c	2007-08-26 20:40:16.010950020 +0200
@@ -3842,6 +3842,7 @@
     case BOOLEAN_TYPE:	case CHAR_TYPE:		case POINTER_TYPE:
     case OFFSET_TYPE:	case REFERENCE_TYPE:	case METHOD_TYPE:
     case LANG_TYPE:		case FUNCTION_TYPE:
+    case SET_TYPE:
       return VOIDmode;
 
       /* Fortran complex types are supposed to be HFAs, so we need to handle
diff -urN gcc.orig/config/sparc/sparc.c gcc/config/sparc/sparc.c
--- gcc.orig/config/sparc/sparc.c	2006-04-14 09:02:43.000000000 +0200
+++ gcc/config/sparc/sparc.c	2007-08-26 20:40:16.010950020 +0200
@@ -7019,6 +7019,7 @@
 	case VECTOR_TYPE:
 	case CHAR_TYPE:		/* GNU Pascal CHAR type.  Not used in C.  */
 	case BOOLEAN_TYPE:	/* GNU Fortran BOOLEAN type.  */
+        case SET_TYPE:          /* GNU Pascal SET type.  */
 	case LANG_TYPE:		/* ? */
 	  return qualifiers;
   
diff -urN gcc.orig/dbxout.c gcc/dbxout.c
--- gcc.orig/dbxout.c	2005-10-06 02:47:21.000000000 +0200
+++ gcc/dbxout.c	2007-08-26 20:40:16.010950020 +0200
@@ -1916,7 +1916,7 @@
 	{
 	  stabstr_S ("@s");
 	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
-	  stabstr_S (";-20;");
+	  stabstr_S (";-20");
 	}
       else
 	{
@@ -1933,7 +1933,7 @@
 	{
 	  stabstr_S ("@s");
 	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
-	  stabstr_S (";-16;");
+	  stabstr_S (";-16");
 	}
       else /* Define as enumeral type (False, True) */
 	stabstr_S ("eFalse:0,True:1,;");
@@ -1972,6 +1972,22 @@
 	}
       break;
 
+    case SET_TYPE:
+      if (use_gnu_debug_info_extensions)
+	{
+	  stabstr_S ("@s");
+          stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
+          stabstr_C (';');
+
+	  /* Check if a bitstring type, which in Chill is
+	     different from a [power]set.  */
+	  if (TYPE_STRING_FLAG (type))
+	    stabstr_S ("@S;");
+	}
+      stabstr_C ('S');
+      dbxout_type (TYPE_DOMAIN (type), 0);
+      break;
+
     case ARRAY_TYPE:
       /* Make arrays of packed bits look like bitstrings for chill.  */
       if (TYPE_PACKED (type) && use_gnu_debug_info_extensions)
@@ -2435,7 +2451,7 @@
          we see following the TREE_TYPE chain.  */
 
       t = type;
-      while (POINTER_TYPE_P (t))
+      while (POINTER_TYPE_P (t) && !TYPE_NAME (t))
         t = TREE_TYPE (t);
 
       /* RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, and ENUMERAL_TYPE
diff -urN gcc.orig/dwarf2out.c gcc/dwarf2out.c
--- gcc.orig/dwarf2out.c	2006-12-27 23:23:55.000000000 +0100
+++ gcc/dwarf2out.c	2007-08-26 20:40:16.020950171 +0200
@@ -8230,6 +8230,7 @@
     case OFFSET_TYPE:
     case LANG_TYPE:
     case VECTOR_TYPE:
+    case SET_TYPE:
       return 0;
 
     default:
@@ -9036,9 +9037,12 @@
 {
   dw_loc_descr_ref ret, ret1;
   int have_address = 0;
-  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));
+  int unsignedp /* = TYPE_UNSIGNED (TREE_TYPE (loc)) */;
   enum dwarf_location_atom op;
 
+  gcc_assert (TREE_TYPE (loc));
+  unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));
+
   /* ??? Most of the time we do not take proper care for sign/zero
      extending the values properly.  Hopefully this won't be a real
      problem...  */
@@ -9413,6 +9417,19 @@
       }
       break;
 
+#ifdef GPC
+    case REAL_CST:
+    case FLOAT_EXPR:
+    case RDIV_EXPR:
+    case STRING_CST:
+      /* In Pascal it's possible for array bounds to contain floating point
+         expressions (e.g., p/test/emil11c.pas). I don't know if it's
+         possible to represent them in dwarf2, but it doesn't seem terribly
+         important since this occurs quite rarely. -- Frank */
+      return 0;
+#endif
+
+
     case FIX_TRUNC_EXPR:
     case FIX_CEIL_EXPR:
     case FIX_FLOOR_EXPR:
@@ -11166,6 +11183,16 @@
   add_type_attribute (array_die, element_type, 0, 0, context_die);
 }
 
+static void
+gen_set_type_die (tree type, dw_die_ref context_die)
+{
+  dw_die_ref type_die
+    = new_die (DW_TAG_set_type, scope_die_for (type, context_die), type);
+
+  equate_type_number_to_die (type, type_die);
+  add_type_attribute (type_die, TREE_TYPE (type), 0, 0, context_die);
+}
+
 #if 0
 static void
 gen_entry_point_die (tree decl, dw_die_ref context_die)
@@ -12523,6 +12550,11 @@
       gen_ptr_to_mbr_type_die (type, context_die);
       break;
 
+    case SET_TYPE:
+      gen_type_die (TYPE_DOMAIN (type), context_die);
+      gen_set_type_die (type, context_die);
+      break;
+
     case FUNCTION_TYPE:
       /* Force out return type (in case it wasn't forced out already).  */
       gen_type_die (TREE_TYPE (type), context_die);
diff -urN gcc.orig/expr.c gcc/expr.c
--- gcc.orig/expr.c	2006-11-02 18:18:52.000000000 +0100
+++ gcc/expr.c	2007-08-26 20:40:16.030950322 +0200
@@ -4639,6 +4639,10 @@
     case REFERENCE_TYPE:
       return 1;
 
+    case SET_TYPE:
+      /* @@@@@@ return something more accurate ... */
+      return -1;
+
     case VOID_TYPE:
     case METHOD_TYPE:
     case FUNCTION_TYPE:
@@ -4659,6 +4663,10 @@
       HOST_WIDE_INT nz_elts, nc_elts, count, elts;
       bool must_clear;
 
+      if (TREE_TYPE (exp) && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)
+      /* If there are no ranges of true bits, it is all zero.  */
+        return CONSTRUCTOR_ELTS (exp) == NULL_TREE;
+
       categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count, &must_clear);
       if (must_clear)
 	return 1;
@@ -5293,6 +5301,229 @@
 		      gen_rtx_PARALLEL (GET_MODE (target), vector)));
 	break;
       }
+
+    case SET_TYPE:
+    {
+      tree elt = CONSTRUCTOR_ELTS (exp);
+      unsigned HOST_WIDE_INT nbytes = int_size_in_bytes (type), nbits;
+      tree domain = TYPE_DOMAIN (type);
+      tree domain_min, domain_max, bitlength;
+
+      /* The default implementation strategy is to extract the constant
+         parts of the constructor, use that to initialize the target,
+         and then "or" in whatever non-constant ranges we need in addition.
+
+         If a large set is all zero or all ones, it is
+         probably better to set it using memset (if available) or bzero.
+         Also, if a large set has just a single range, it may also be
+         better to first clear all the first clear the set (using
+         bzero/memset), and set the bits we want.  */
+
+      /* Check for all zeros.  */
+      if (elt == NULL_TREE && size > 0)
+        {
+          if (!cleared)
+            clear_storage (target, GEN_INT (size), BLOCK_OP_NORMAL);
+          return;
+        }
+
+#ifndef GPC
+      domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));
+      domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));
+#else /* GPC */
+      domain_min = convert (sbitsizetype, TYPE_MIN_VALUE (domain));
+      domain_max = convert (sbitsizetype, TYPE_MAX_VALUE (domain));
+
+      /* Align the set.  */
+      if (set_alignment)
+        domain_min = size_binop (BIT_AND_EXPR, domain_min, sbitsize_int (-(int)
+set_alignment));
+
+#endif /* GPC */
+      bitlength = size_binop (PLUS_EXPR,
+                              size_binop (MINUS_EXPR, domain_max, domain_min),
+#ifndef GPC
+                              ssize_int (1));
+#else /* GPC */
+                              sbitsize_int (1));
+#endif /* GPC */
+
+#ifdef GPC
+      if (TREE_INT_CST_HIGH (bitlength)) {
+        error ("set size too big for host integers");
+        return;
+      }
+#endif /* GPC */
+      nbits = tree_low_cst (bitlength, 1);
+#ifdef GPC
+      bitlength = convert (sizetype, bitlength);
+#endif /* GPC */
+
+      /* For "small" sets, or "medium-sized" (up to 32 bytes) sets that
+         are "complicated" (more than one range), initialize (the
+         constant parts) by copying from a constant.  */
+      if (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD
+          || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))
+        {
+#ifndef GPC
+          unsigned int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));
+#endif /* not GPC */
+          enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);
+          char *bit_buffer = alloca (nbits);
+          HOST_WIDE_INT word = 0;
+          unsigned int bit_pos = 0;
+          unsigned int ibit = 0;
+          unsigned int offset = 0;  /* In bytes from beginning of set.  */
+
+          elt = get_set_constructor_bits (exp, bit_buffer, nbits);
+          for (;;)
+            {
+              if (bit_buffer[ibit])
+                {
+#ifndef GPC
+                  if (BYTES_BIG_ENDIAN)
+#else /* GPC */
+                  if (set_words_big_endian)
+#endif /* GPC */
+                    word |= (((HOST_WIDE_INT)1) << (set_word_size - 1 - bit_pos));
+                  else
+                    word |= ((HOST_WIDE_INT)1) << bit_pos;
+                }
+
+              bit_pos++;  ibit++;
+              if (bit_pos >= set_word_size || ibit == nbits)
+                {
+                  if (word != 0 || ! cleared)
+                    {
+                      rtx datum = gen_int_mode (word, mode);
+                      rtx to_rtx;
+
+                      /* The assumption here is that it is safe to use
+                         XEXP if the set is multi-word, but not if
+                         it's single-word.  */
+                      if (GET_CODE (target) == MEM)
+                        to_rtx = adjust_address (target, mode, offset);
+                      else if (offset == 0)
+                        to_rtx = target;
+                      else
+                        abort ();
+                      emit_move_insn (to_rtx, datum);
+                    }
+
+                  if (ibit == nbits)
+                    break;
+                  word = 0;
+                  bit_pos = 0;
+                  offset += set_word_size / BITS_PER_UNIT;
+                }
+            }
+        }
+      else if (!cleared)
+   /* GPC expects bits outside the range to be cleared. (fjf1010.pas)
+      Though this check might be "dead" in this GCC version since it only
+      applies to single ranges with constant bounds, and those are apparently
+      always stored as constants anyway, not initialized via `__setbits'. */
+#ifndef GPC
+        /* Don't bother clearing storage if the set is all ones.  */
+        if (TREE_CHAIN (elt) != NULL_TREE
+            || (TREE_PURPOSE (elt) == NULL_TREE
+                ? nbits != 1
+                : ( ! host_integerp (TREE_VALUE (elt), 0)
+                   || ! host_integerp (TREE_PURPOSE (elt), 0)
+                   || (tree_low_cst (TREE_VALUE (elt), 0)
+                       - tree_low_cst (TREE_PURPOSE (elt), 0) + 1
+                       != (HOST_WIDE_INT) nbits))))
+#endif
+          clear_storage (target, expr_size (exp), BLOCK_OP_NORMAL);
+
+      for (; elt != NULL_TREE; elt = TREE_CHAIN (elt))
+        {
+          /* Start of range of element or NULL.  */
+          tree startbit = TREE_PURPOSE (elt);
+          /* End of range of element, or element value.  */
+          tree endbit   = TREE_VALUE (elt);
+          HOST_WIDE_INT startb, endb;
+          rtx bitlength_rtx, startbit_rtx, endbit_rtx, targetx;
+
+          bitlength_rtx = expand_expr (bitlength,
+                                       NULL_RTX, MEM, EXPAND_CONST_ADDRESS);
+
+          /* Handle non-range tuple element like [ expr ].  */
+          if (startbit == NULL_TREE)
+            {
+              startbit = save_expr (endbit);
+              endbit = startbit;
+            }
+
+#ifndef GPC
+          startbit = convert (sizetype, startbit);
+          endbit = convert (sizetype, endbit);
+#endif /* not GPC */
+          if (! integer_zerop (domain_min))
+            {
+#ifdef GPC
+              startbit = convert (sbitsizetype, startbit);
+              endbit = convert (sbitsizetype, endbit);
+#endif /* GPC */
+              startbit = size_binop (MINUS_EXPR, startbit, domain_min);
+              endbit = size_binop (MINUS_EXPR, endbit, domain_min);
+            }
+#ifdef GPC
+          startbit = convert (sizetype, startbit);
+          endbit = convert (sizetype, endbit);
+#endif /* GPC */
+          startbit_rtx = expand_expr (startbit, NULL_RTX, MEM,
+                                      EXPAND_CONST_ADDRESS);
+          endbit_rtx = expand_expr (endbit, NULL_RTX, MEM,
+                                    EXPAND_CONST_ADDRESS);
+
+          if (REG_P (target))
+            {
+              targetx
+                = assign_temp
+                  ((build_qualified_type ((*lang_hooks.types.type_for_mode)
+                                          (GET_MODE (target), 0),
+                                          TYPE_QUAL_CONST)),
+                   0, 1, 1);
+              emit_move_insn (targetx, target);
+            }
+
+          else if (GET_CODE (target) == MEM)
+            targetx = target;
+          else
+            abort ();
+
+          /* Optimization:  If startbit and endbit are constants divisible
+             by BITS_PER_UNIT, call memset instead.  */
+          if (
+              TREE_CODE (startbit) == INTEGER_CST
+              && TREE_CODE (endbit) == INTEGER_CST
+              && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0
+              && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)
+            {
+              emit_library_call (memset_libfunc, LCT_NORMAL,
+                                 VOIDmode, 3,
+                                 plus_constant (XEXP (targetx, 0),
+                                                startb / BITS_PER_UNIT),
+                                 Pmode,
+                                 constm1_rtx, TYPE_MODE (integer_type_node),
+                                 GEN_INT ((endb - startb) / BITS_PER_UNIT),
+                                 TYPE_MODE (sizetype));
+            }
+          else
+            emit_library_call (setbits_libfunc, LCT_NORMAL,
+                               VOIDmode, 4, XEXP (targetx, 0),
+                               Pmode, bitlength_rtx, TYPE_MODE (sizetype),
+                               startbit_rtx, TYPE_MODE (sizetype),
+                               endbit_rtx, TYPE_MODE (sizetype));
+
+          if (REG_P (target))
+          if (REG_P (target))
+            emit_move_insn (target, targetx);
+        }
+
+        break;
+    }
       
     default:
       gcc_unreachable ();
@@ -5592,9 +5823,19 @@
 	       index, then convert to sizetype and multiply by the size of
 	       the array element.  */
 	    if (! integer_zerop (low_bound))
+#ifdef GPC
+            /* I think that address arithmetic should always be done on
+               sizetype or its variants -- for Pascal signed seems to be the
+               correct choice (and generates slightly better code). -- Waldek */
+              index = convert (sizetype, convert (bitsizetype,
+                      size_binop (MINUS_EXPR,
+                        convert (sbitsizetype, index),
+                        convert (sbitsizetype, low_bound))));
+#else
+
 	      index = fold_build2 (MINUS_EXPR, TREE_TYPE (index),
 				   index, low_bound);
-
+#endif
 	    offset = size_binop (PLUS_EXPR, offset,
 			         size_binop (MULT_EXPR,
 					     convert (sizetype, index),
@@ -6704,11 +6945,18 @@
       /* Variables inherited from containing functions should have
 	 been lowered by this point.  */
       context = decl_function_context (exp);
-      gcc_assert (!context
+//      gcc_assert 
+      if (!context
 		  || context == current_function_decl
 		  || TREE_STATIC (exp)
 		  /* ??? C++ creates functions that are not TREE_STATIC.  */
-		  || TREE_CODE (exp) == FUNCTION_DECL);
+		  || TREE_CODE (exp) == FUNCTION_DECL)
+        ;
+      else
+        {
+          debug_tree (exp);
+          gcc_unreachable ();
+        }
 
       /* This is the case of an array whose size is to be determined
 	 from its initializer, while the initializer is still being parsed.
@@ -8642,7 +8890,7 @@
 tree
 string_constant (tree arg, tree *ptr_offset)
 {
-  tree array, offset;
+  tree array, offset, lb = size_zero_node;
   STRIP_NOPS (arg);
 
   if (TREE_CODE (arg) == ADDR_EXPR)
@@ -8656,6 +8904,7 @@
 	{
 	  array = TREE_OPERAND (arg, 0);
 	  offset = size_zero_node;
+          goto do_lb;
 	}
       else if (TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF)
 	{
@@ -8664,6 +8913,7 @@
 	  if (TREE_CODE (array) != STRING_CST
 	      && TREE_CODE (array) != VAR_DECL)
 	    return 0;
+          lb = array_ref_low_bound (TREE_OPERAND (arg, 0));
 	}
       else
 	return 0;
@@ -8692,10 +8942,26 @@
 	}
       else
 	return 0;
+  do_lb:    
+      if (TREE_TYPE (array) && TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE)
+        {
+          tree domain_type = TYPE_DOMAIN (TREE_TYPE (array));
+          if (domain_type && TYPE_MIN_VALUE (domain_type))
+#if 0
+            lb = SUBSTITUTE_PLACEHOLDER_IN_EXPR (
+                   TYPE_MIN_VALUE (domain_type), array);
+#else
+          lb = TYPE_MIN_VALUE (domain_type);
+#endif
+        }
     }
   else
     return 0;
 
+  if (! integer_zerop (lb))
+    offset = size_diffop (fold_convert (sizetype, offset),
+                          fold_convert (sizetype, lb));
+
   if (TREE_CODE (array) == STRING_CST)
     {
       *ptr_offset = convert (sizetype, offset);
diff -urN gcc.orig/fold-const.c gcc/fold-const.c
--- gcc.orig/fold-const.c	2007-01-03 09:15:24.000000000 +0100
+++ gcc/fold-const.c	2007-08-26 20:40:16.030950322 +0200
@@ -5960,6 +5960,10 @@
   bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (arg0));
   int overflow;
 
+  /* Overflow check does not work for unsigned numbers */
+  if (TYPE_UNSIGNED (TREE_TYPE (arg0)))
+    return NULL_TREE;
+
   /* We have to do this the hard way to detect unsigned overflow.
      prod = int_const_binop (MULT_EXPR, arg01, arg1, 0);  */
   overflow = mul_double_with_sign (TREE_INT_CST_LOW (arg01),
diff -urN gcc.orig/function.c gcc/function.c
--- gcc.orig/function.c	2006-11-28 13:01:45.000000000 +0100
+++ gcc/function.c	2007-08-26 20:40:16.040950472 +0200
@@ -3118,7 +3118,11 @@
   if (TYPE_P (t))
     {
       if (POINTER_TYPE_P (t))
+#ifndef GPC
 	*walk_subtrees = 1;
+#else
+        *walk_subtrees = 0;
+#endif
       else if (TYPE_SIZE (t) && !TREE_CONSTANT (TYPE_SIZE (t))
 	       && !TYPE_SIZES_GIMPLIFIED (t))
 	{
diff -urN gcc.orig/gcc.c gcc/gcc.c
--- gcc.orig/gcc.c	2006-11-07 15:26:21.000000000 +0100
+++ gcc/gcc.c	2007-08-26 20:40:16.040950472 +0200
@@ -794,8 +794,8 @@
 "%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\
  %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\
  %{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}%{!c:%{!S:-auxbase %b}}\
- %{g*} %{O*} %{W*&pedantic*} %{w} %{std*&ansi&trigraphs}\
- %{v:-version} %{pg:-p} %{p} %{f*} %{undef}\
+ %{g*} %{O*} %{f*&W*&pedantic*&w} %{std*&ansi&trigraphs}\
+ %{v:-version} %{pg:-p} %{p} %{undef}\
  %{Qn:-fno-ident} %{--help:--help}\
  %{--target-help:--target-help}\
  %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\
diff -urN gcc.orig/gimplify.c gcc/gimplify.c
--- gcc.orig/gimplify.c	2006-11-19 17:15:47.000000000 +0100
+++ gcc/gimplify.c	2007-08-26 20:40:16.040950472 +0200
@@ -342,7 +342,7 @@
 
 /* Create a new temporary name with PREFIX.  Returns an identifier.  */
 
-static GTY(()) unsigned int tmp_var_id_num;
+static GTY(()) unsigned int tmp_var_id_num = 155419;
 
 tree
 create_tmp_var_name (const char *prefix)
@@ -2710,15 +2710,35 @@
 	  cref = build (ARRAY_REF, array_elt_type, unshare_expr (object),
 			purpose, NULL_TREE, NULL_TREE);
 	}
+#if 0
+      else if (DECL_BIT_FIELD (purpose))
+        {
+          tree bioff = size_binop (PLUS_EXPR, 
+            DECL_FIELD_BIT_OFFSET (purpose),
+            size_binop (MULT_EXPR, 
+              bitsize_int (BITS_PER_UNIT),
+              convert (bitsizetype, DECL_FIELD_OFFSET (purpose))));
+          cref = build3 (BIT_FIELD_REF, TREE_TYPE (purpose),
+                      unshare_expr (object), bioff, 
+                      DECL_SIZE (purpose));
+          BIT_FIELD_REF_UNSIGNED (cref) = TYPE_UNSIGNED (TREE_TYPE (purpose));
+        }
+#endif
       else
 	{
-	  gcc_assert (TREE_CODE (purpose) == FIELD_DECL);
+//	  gcc_assert (TREE_CODE (purpose) == FIELD_DECL);
+          if (TREE_CODE (purpose) != FIELD_DECL)
+            {
+              debug_tree (purpose);
+              gcc_unreachable ();
+            }
 	  cref = build (COMPONENT_REF, TREE_TYPE (purpose),
 			unshare_expr (object), purpose, NULL_TREE);
 	}
 
       if (TREE_CODE (value) == CONSTRUCTOR
-	  && TREE_CODE (TREE_TYPE (value)) != VECTOR_TYPE)
+	  && TREE_CODE (TREE_TYPE (value)) != VECTOR_TYPE
+          && TREE_CODE (TREE_TYPE (value)) != SET_TYPE)
 	gimplify_init_ctor_eval (cref, CONSTRUCTOR_ELTS (value),
 				 pre_p, cleared);
       else
@@ -2749,6 +2769,10 @@
   if (TREE_CODE (ctor) != CONSTRUCTOR)
     return GS_UNHANDLED;
 
+  ret = lang_hooks.gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p);
+  if (ret != GS_UNHANDLED)
+    return ret;
+  
   ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,
 		       is_gimple_lvalue, fb_lvalue);
   if (ret == GS_ERROR)
@@ -2790,7 +2814,7 @@
 	    DECL_INITIAL (object) = ctor;
 	    TREE_STATIC (object) = 1;
 	    if (!DECL_NAME (object))
-	      DECL_NAME (object) = create_tmp_var_name ("C");
+	      DECL_NAME (object) = create_tmp_var_name ("c_C");
 	    walk_tree (&DECL_INITIAL (object), force_labels_r, NULL, NULL);
 
 	    /* ??? C++ doesn't automatically append a .<number> to the
@@ -2863,7 +2887,7 @@
 
 	    if (size > 0 && !can_move_by_pieces (size, align))
 	      {
-		tree new = create_tmp_var_raw (type, "C");
+		tree new = create_tmp_var_raw (type, "r_C");
 
 		gimple_add_tmp_var (new);
 		TREE_STATIC (new) = 1;
@@ -4514,6 +4538,10 @@
 	      goto dont_recalculate;
 
 	    default:
+              if (!(TREE_CODE (*expr_p) == TRUTH_AND_EXPR
+                          || TREE_CODE (*expr_p) == TRUTH_OR_EXPR
+                          || TREE_CODE (*expr_p) == TRUTH_XOR_EXPR))
+                debug_tree (*expr_p);
 	      gcc_assert (TREE_CODE (*expr_p) == TRUTH_AND_EXPR
 			  || TREE_CODE (*expr_p) == TRUTH_OR_EXPR
 			  || TREE_CODE (*expr_p) == TRUTH_XOR_EXPR);
@@ -4704,6 +4732,10 @@
   return ret;
 }
 
+extern void (*lang_remember_gimplified_type)(tree);
+
+void (*lang_remember_gimplified_type)(tree) = 0;
+
 /* Look through TYPE for variable-sized objects and gimplify each such
    size that we find.  Add to LIST_P any statements generated.  */
 
@@ -4724,6 +4756,12 @@
 
   TYPE_SIZES_GIMPLIFIED (type) = 1;
 
+  if (lang_remember_gimplified_type)
+    lang_remember_gimplified_type (type);
+  
+  gimplify_one_sizepos (&TYPE_SIZE (type), list_p);
+  gimplify_one_sizepos (&TYPE_SIZE_UNIT (type), list_p);
+
   switch (TREE_CODE (type))
     {
     case INTEGER_TYPE:
@@ -4754,12 +4792,16 @@
 	if (TREE_CODE (field) == FIELD_DECL)
 	  {
 	    gimplify_one_sizepos (&DECL_FIELD_OFFSET (field), list_p);
-	    gimplify_type_sizes (TREE_TYPE (field), list_p);
 	  }
+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))
+        if (TREE_CODE (field) == FIELD_DECL)
+          gimplify_type_sizes (TREE_TYPE (field), list_p);
       break;
 
     case POINTER_TYPE:
     case REFERENCE_TYPE:
+      break;
+
       gimplify_type_sizes (TREE_TYPE (type), list_p);
       break;
 
@@ -4767,9 +4809,6 @@
       break;
     }
 
-  gimplify_one_sizepos (&TYPE_SIZE (type), list_p);
-  gimplify_one_sizepos (&TYPE_SIZE_UNIT (type), list_p);
-
   for (t = TYPE_NEXT_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))
     {
       TYPE_SIZE (t) = TYPE_SIZE (type);
@@ -4778,6 +4817,11 @@
     }
 }
 
+
+extern void (*lang_remember_gimplified_sizepos)(tree *);
+
+void (*lang_remember_gimplified_sizepos)(tree *) = 0;
+
 /* A subroutine of gimplify_type_sizes to make sure that *EXPR_P,
    a size or position, has had all of its SAVE_EXPRs evaluated.
    We add any required statements to STMT_P.  */
@@ -4787,6 +4831,12 @@
 {
   tree type, expr = *expr_p;
 
+  if (expr == NULL_TREE || TREE_CODE (expr) == INTEGER_CST)
+    return;
+
+  if (lang_remember_gimplified_sizepos)
+    lang_remember_gimplified_sizepos(expr_p);
+
   /* We don't do anything if the value isn't there, is constant, or contains
      A PLACEHOLDER_EXPR.  We also don't want to do anything if it's already
      a VAR_DECL.  If it's a VAR_DECL from another function, the gimplifier
@@ -4890,9 +4940,18 @@
 	     a pointer to the array type.  We must allow this in order to
 	     properly represent assigning the address of an array in C into
 	     pointer to the element type.  */
+/*
 	  gcc_assert (TREE_CODE (otype) == ARRAY_TYPE
 		      && POINTER_TYPE_P (ptype)
 		      && cpt_same_type (TREE_TYPE (otype), dtype));
+*/
+          if (!(TREE_CODE (otype) == ARRAY_TYPE
+                      && POINTER_TYPE_P (ptype)
+                      && cpt_same_type (TREE_TYPE (otype), dtype)))
+            {
+              debug_tree (t);
+              gcc_unreachable ();
+            }
 	  break;
 	}
       break;
diff -urN gcc.orig/ipa-type-escape.c gcc/ipa-type-escape.c
--- gcc.orig/ipa-type-escape.c	2005-09-25 07:28:01.000000000 +0200
+++ gcc/ipa-type-escape.c	2007-08-26 20:40:16.040950472 +0200
@@ -260,9 +260,23 @@
 type_to_consider (tree type)
 {
   /* Strip the *'s off.  */
+  tree otype = type;
+  long cnt = 0;
+  long ocnt = 0;
   type = TYPE_MAIN_VARIANT (type);
   while (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)
-    type = TYPE_MAIN_VARIANT (TREE_TYPE (type));
+    {
+      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));
+      if (type == otype)
+        return false;
+      if (cnt > ocnt)
+        {
+          ocnt += cnt;
+          otype = type;
+        }
+      else
+        cnt ++;
+    }
 
   switch (TREE_CODE (type))
     {
diff -urN gcc.orig/print-tree.c gcc/print-tree.c
--- gcc.orig/print-tree.c	2005-10-13 01:34:09.000000000 +0200
+++ gcc/print-tree.c	2007-08-26 20:40:16.050950623 +0200
@@ -580,7 +580,7 @@
 
       if (TREE_CODE (node) == ENUMERAL_TYPE)
 	print_node (file, "values", TYPE_VALUES (node), indent + 4);
-      else if (TREE_CODE (node) == ARRAY_TYPE)
+      else if (TREE_CODE (node) == ARRAY_TYPE || TREE_CODE (node) == SET_TYPE)
 	print_node (file, "domain", TYPE_DOMAIN (node), indent + 4);
       else if (TREE_CODE (node) == VECTOR_TYPE)
 	fprintf (file, " nunits %d", (int) TYPE_VECTOR_SUBPARTS (node));
diff -urN gcc.orig/reload1.c gcc/reload1.c
--- gcc.orig/reload1.c	2006-06-14 11:24:44.000000000 +0200
+++ gcc/reload1.c	2007-08-26 20:40:16.050950623 +0200
@@ -1254,7 +1254,10 @@
   reg_equiv_memory_loc = 0;
 
   if (offsets_known_at)
-    free (offsets_known_at);
+    {
+//      free (offsets_known_at);
+      offsets_known_at = 0;
+    }
   if (offsets_at)
     free (offsets_at);
 
diff -urN gcc.orig/stor-layout.c gcc/stor-layout.c
--- gcc.orig/stor-layout.c	2006-10-04 09:01:27.000000000 +0200
+++ gcc/stor-layout.c	2007-08-26 20:40:16.050950623 +0200
@@ -19,6 +19,7 @@
 Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
 02110-1301, USA.  */
 
+/* @@ PATCHED FOR GPC 20060322 @@ */
 
 #include "config.h"
 #include "system.h"
@@ -53,6 +54,21 @@
    called only by a front end.  */
 static int reference_types_internal = 0;
 
+/* If nonzero, the alignment of a bitstring or (power-)set value, in bits.
+   May be overridden by front-ends.  */
+unsigned int set_alignment = 0;
+
+/* The word size of a bitstring or (power-)set value, in bits.
+   Must be non-zero.
+   May be overridden by front-ends.  */
+unsigned int set_word_size = BITS_PER_UNIT;
+
+/* If non-zero, bits in (power-)sets start with the highest bit.
+   May be overridden by front-ends.
+   In order to be backward-compatible, the Chill frontend should
+   initialize this to BYTES_BIG_ENDIAN.  */
+unsigned int set_words_big_endian = 0;
+
 static void finalize_record_size (record_layout_info);
 static void finalize_type_size (tree);
 static void place_union_field (record_layout_info, tree);
@@ -1899,6 +1915,50 @@
       }
       break;
 
+    case SET_TYPE:  /* Used by Chill and Pascal.  */
+      if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST
+          || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST)
+        abort ();
+      else
+        {
+          int alignment = set_alignment ? set_alignment : set_word_size;
+          tree lower_bound = convert (sbitsizetype,
+                        TYPE_MIN_VALUE (TYPE_DOMAIN (type)));
+          tree upper_bound = convert (sbitsizetype,
+                        TYPE_MAX_VALUE (TYPE_DOMAIN (type)));
+          tree size_in_bits, rounded_size;
+          if (set_alignment)
+            {
+              lower_bound = round_down (lower_bound, alignment);
+            }
+          size_in_bits = size_binop (PLUS_EXPR,
+                                size_binop (MINUS_EXPR,
+                                        upper_bound,
+                                        lower_bound),
+                                sbitsize_int(1));
+          rounded_size = round_up (size_in_bits, alignment);
+
+          if ( TREE_INT_CST_HIGH (rounded_size)
+                || TREE_INT_CST_LOW (rounded_size) > (unsigned) alignment)
+            {
+                TYPE_MODE (type) = BLKmode;
+            }
+          else
+            {
+                TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);
+            }
+
+          TYPE_SIZE (type) = convert (bitsizetype, rounded_size);
+          TYPE_SIZE_UNIT (type) = convert (sizetype,
+                                size_binop ( CEIL_DIV_EXPR,
+                                        rounded_size,
+                                        sbitsize_int (BITS_PER_UNIT)));
+          TYPE_ALIGN (type) = alignment;
+          TYPE_USER_ALIGN (type) = 0;
+          TYPE_PRECISION (type) = TREE_INT_CST_LOW (size_in_bits);
+        }
+      break;
+
     default:
       gcc_unreachable ();
     }
@@ -1995,9 +2055,9 @@
   t = build_distinct_type_copy (type);
   /* We do want to use sizetype's cache, as we will be replacing that
      type.  */
-  TYPE_CACHED_VALUES (t) = TYPE_CACHED_VALUES (sizetype);
-  TYPE_CACHED_VALUES_P (t) = TYPE_CACHED_VALUES_P (sizetype);
-  TREE_TYPE (TYPE_CACHED_VALUES (t)) = type;
+  TYPE_CACHED_VALUES (t) = NULL_TREE /* TYPE_CACHED_VALUES (sizetype) */;
+  TYPE_CACHED_VALUES_P (t) = 0 ; /* TYPE_CACHED_VALUES_P (sizetype);
+  TREE_TYPE (TYPE_CACHED_VALUES (t)) = type; */
   TYPE_UID (t) = TYPE_UID (sizetype);
   TYPE_IS_SIZETYPE (t) = 1;
   
@@ -2009,8 +2069,8 @@
   TYPE_NAME (t) = get_identifier ("bit_size_type");
   /* We do want to use bitsizetype's cache, as we will be replacing that
      type.  */
-  TYPE_CACHED_VALUES (t) = TYPE_CACHED_VALUES (bitsizetype);
-  TYPE_CACHED_VALUES_P (t) = TYPE_CACHED_VALUES_P (bitsizetype);
+  TYPE_CACHED_VALUES (t) = NULL_TREE /* TYPE_CACHED_VALUES (bitsizetype) */;
+  TYPE_CACHED_VALUES_P (t) = 0 /* TYPE_CACHED_VALUES_P (bitsizetype) */;
   TYPE_PRECISION (t) = precision;
   TYPE_UID (t) = TYPE_UID (bitsizetype);
   TYPE_IS_SIZETYPE (t) = 1;
diff -urN gcc.orig/toplev.c gcc/toplev.c
--- gcc.orig/toplev.c	2006-08-03 13:33:49.000000000 +0200
+++ gcc/toplev.c	2007-08-26 20:40:16.050950623 +0200
@@ -803,9 +803,13 @@
 /* A subroutine of check_global_declarations.  Issue appropriate warnings
    for the global declaration DECL.  */
 
+volatile int dump_global_decl_trees = 0;
 void
 check_global_declaration_1 (tree decl)
 {
+  if (dump_global_decl_trees)
+    debug_tree (decl);
+
   /* Warn about any function declared static but not defined.  We don't
      warn about variables, because many programs have static variables
      that exist only to get some text into the object file.  */
@@ -1110,6 +1114,27 @@
 void
 print_version (FILE *file, const char *indent)
 {
+#ifdef GPC
+  extern const char *lang_version_string;
+  static const char fmt1[] =
+#ifdef __GNUC__
+    N_("%s%s%s version %s%s (%s)\n%s\tcompiled by GNU C version %s.\n")
+#else
+    N_("%s%s%s version %s%s (%s) compiled by CC.\n")
+#endif
+    ;
+  static const char fmt2[] =
+    N_("%s%sGGC heuristics: --param ggc-min-expand=%d --param ggc-min-heapsize=%d\n");
+#ifndef __VERSION__
+#define __VERSION__ "[?]"
+#endif
+
+  fprintf (file,
+           file == stderr ? _(fmt1) : fmt1,
+           indent, *indent != 0 ? " " : "",
+           lang_hooks.name, lang_version_string, version_string, TARGET_NAME,
+           indent, __VERSION__);
+#else
   static const char fmt1[] =
 #ifdef __GNUC__
     N_("%s%s%s version %s (%s)\n%s\tcompiled by GNU C version %s.\n")
@@ -1122,11 +1147,13 @@
 #ifndef __VERSION__
 #define __VERSION__ "[?]"
 #endif
+
   fprintf (file,
 	   file == stderr ? _(fmt1) : fmt1,
 	   indent, *indent != 0 ? " " : "",
 	   lang_hooks.name, version_string, TARGET_NAME,
 	   indent, __VERSION__);
+#endif
   fprintf (file,
 	   file == stderr ? _(fmt2) : fmt2,
 	   indent, *indent != 0 ? " " : "",
diff -urN gcc.orig/tree.c gcc/tree.c
--- gcc.orig/tree.c	2007-01-05 21:59:15.000000000 +0100
+++ gcc/tree.c	2007-08-26 20:40:16.070950925 +0200
@@ -800,9 +800,16 @@
       if (t)
 	{
 	  /* Make sure no one is clobbering the shared constant.  */
+          if (!(TREE_TYPE (t) == type))
+            debug_tree (t);
 	  gcc_assert (TREE_TYPE (t) == type);
+          if (!(TREE_INT_CST_LOW (t) == low))
+            debug_tree (t);
 	  gcc_assert (TREE_INT_CST_LOW (t) == low);
+          if (!(TREE_INT_CST_HIGH (t) == hi))
+            debug_tree (t);
 	  gcc_assert (TREE_INT_CST_HIGH (t) == hi);
+
 	}
       else
 	{
@@ -2131,6 +2138,7 @@
 	      || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (type)));
 
     case ARRAY_TYPE:
+    case SET_TYPE:
       /* We're already checked the component type (TREE_TYPE), so just check
 	 the index type.  */
       return type_contains_placeholder_p (TYPE_DOMAIN (type));
@@ -3142,7 +3150,8 @@
   if (EXPR_LOCUS (node)
       && EXPR_LINENO (node) == line
       && (EXPR_FILENAME (node) == file
-	  || !strcmp (EXPR_FILENAME (node), file)))
+         || (EXPR_FILENAME (node) &&  file
+                && ! strcmp (EXPR_FILENAME (node), file))))
     {
       last_annotated_node = EXPR_LOCUS (node);
       return;
@@ -3154,7 +3163,8 @@
   if (last_annotated_node
       && last_annotated_node->line == line
       && (last_annotated_node->file == file
-	  || !strcmp (last_annotated_node->file, file)))
+         || (last_annotated_node->file &&  file
+                && ! strcmp (last_annotated_node->file, file))))
     {
       SET_EXPR_LOCUS (node, last_annotated_node);
       return;
@@ -5007,6 +5017,7 @@
   TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (type);
   TYPE_ALIGN (itype) = TYPE_ALIGN (type);
   TYPE_USER_ALIGN (itype) = TYPE_USER_ALIGN (type);
+  TYPE_UNSIGNED (itype) = TYPE_UNSIGNED (type);
 
   if (host_integerp (lowval, 0) && highval != 0 && host_integerp (highval, 0))
     return type_hash_canon (tree_low_cst (highval, 0)
@@ -5970,6 +5981,137 @@
   return get_file_function_name_long (p);
 }
 
+/* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.
+   The result is placed in BUFFER (which has length BIT_SIZE),
+   with one bit in each char ('\000' or '\001').
+
+   If the constructor is constant, NULL_TREE is returned.
+   Otherwise, a TREE_LIST of the non-constant elements is emitted.  */
+
+tree
+get_set_constructor_bits (tree init, char *buffer, int bit_size)
+{
+  int i;
+  tree vals;
+  HOST_WIDE_INT domain_min
+    = tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (init))), 0);
+  HOST_WIDE_INT low_limit = domain_min;
+  tree non_const_bits = NULL_TREE;
+
+  if (set_alignment)
+    /* Note: `domain_min -= domain_min % set_alignment' would be wrong for negative
+       numbers (rounding towards 0, while we have to round towards -inf). */
+    domain_min &= -(int) set_alignment;
+
+  low_limit -= domain_min;
+
+  for (i = 0; i < bit_size; i++)
+    buffer[i] = 0;
+
+  for (vals = TREE_OPERAND (init, 0) /* CONSTRUCTOR_ELTS (init) */;
+       vals != NULL_TREE; vals = TREE_CHAIN (vals))
+    {
+      if (!host_integerp (TREE_VALUE (vals), 0)
+	  || (TREE_PURPOSE (vals) != NULL_TREE
+	      && !host_integerp (TREE_PURPOSE (vals), 0)))
+	non_const_bits
+	  = tree_cons (TREE_PURPOSE (vals), TREE_VALUE (vals), non_const_bits);
+      else if (TREE_PURPOSE (vals) != NULL_TREE)
+	{
+	  /* Set a range of bits to ones.  */
+	  HOST_WIDE_INT lo_index
+	    = tree_low_cst (TREE_PURPOSE (vals), 0) - domain_min;
+	  HOST_WIDE_INT hi_index
+	    = tree_low_cst (TREE_VALUE (vals), 0) - domain_min;
+
+          if (lo_index < low_limit || hi_index >= bit_size)
+            {
+              error ("invalid initializer for set");
+              return NULL_TREE;
+            }
+
+	  gcc_assert (lo_index >= 0);
+	  gcc_assert (lo_index < bit_size);
+	  gcc_assert (hi_index >= 0);
+	  gcc_assert (hi_index < bit_size);
+	  for (; lo_index <= hi_index; lo_index++)
+	    buffer[lo_index] = 1;
+	}
+      else
+	{
+	  /* Set a single bit to one.  */
+	  HOST_WIDE_INT index
+	    = tree_low_cst (TREE_VALUE (vals), 0) - domain_min;
+	  if (index < 0 || index >= bit_size)
+	    {
+	      error ("invalid initializer for set");
+	      return NULL_TREE;
+	    }
+	  buffer[index] = 1;
+	}
+    }
+  return non_const_bits;
+}
+
+/* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.
+   The result is placed in BUFFER (which is an array of bytes).
+   If the constructor is constant, NULL_TREE is returned.
+   Otherwise, a TREE_LIST of the non-constant elements is emitted.  */
+
+tree
+get_set_constructor_bytes (tree init, unsigned char *buffer, int wd_size)
+{
+  int i;
+#ifdef GPC
+  int bit_size = wd_size * BITS_PER_UNIT;
+  unsigned int bit_pos = 0;
+#else /* not GPC */
+  int set_word_size = BITS_PER_UNIT;
+  int bit_size = wd_size * set_word_size;
+  int bit_pos = 0;
+#endif /* not GPC */
+  unsigned char *bytep = buffer;
+  char *bit_buffer = alloca (bit_size);
+  tree non_const_bits = get_set_constructor_bits (init, bit_buffer, bit_size);
+
+  for (i = 0; i < wd_size; i++)
+    buffer[i] = 0;
+
+  for (i = 0; i < bit_size; i++)
+    {
+#ifdef GPC
+      if (bit_buffer[i])
+      {
+          int k = bit_pos / BITS_PER_UNIT;
+          if (WORDS_BIG_ENDIAN)
+            k = set_word_size / BITS_PER_UNIT - 1 - k;
+        if (set_words_big_endian)
+          bytep[k] |= (1 << (BITS_PER_UNIT - 1 - bit_pos % BITS_PER_UNIT));
+        else
+          bytep[k] |= (1 << (bit_pos % BITS_PER_UNIT));
+      }
+      bit_pos++;
+      if (bit_pos >= set_word_size)
+        {
+          bit_pos = 0;
+          bytep += set_word_size / BITS_PER_UNIT;
+        }
+#else /* not GPC */
+      if (bit_buffer[i])
+	{
+	  if (BYTES_BIG_ENDIAN)
+	    *bytep |= (1 << (set_word_size - 1 - bit_pos));
+	  else
+	    *bytep |= 1 << bit_pos;
+	}
+      bit_pos++;
+      if (bit_pos >= set_word_size)
+	bit_pos = 0, bytep++;
+#endif
+    }
+  return non_const_bits;
+}
+
 #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)
 
 /* Complain that the tree code of NODE does not match the expected 0
@@ -6645,6 +6787,15 @@
       {
 	unsigned HOST_WIDE_INT idx;
 
+#if 0
+      /* Set is empty if it has no elements.  */
+      if (TREE_CODE (TREE_TYPE (init)) == SET_TYPE && elt)
+        return false;
+#else
+      if (TREE_CODE (TREE_TYPE (init)) == SET_TYPE)
+        gcc_unreachable ();
+#endif
+        
 	FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), idx, elt)
 	  if (!initializer_zerop (elt))
 	    return false;
diff -urN gcc.orig/tree-cfg.c gcc/tree-cfg.c
--- gcc.orig/tree-cfg.c	2006-11-19 17:09:19.000000000 +0100
+++ gcc/tree-cfg.c	2007-08-26 20:40:16.060950774 +0200
@@ -3642,10 +3642,17 @@
 	  if (decl_function_context (LABEL_EXPR_LABEL (stmt))
 	      != current_function_decl)
 	    {
-	      error ("label %s has incorrect context in bb %d",
-		     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),
-		     bb->index);
-	      err = 1;
+              tree ldecl = DECL_NAME (LABEL_EXPR_LABEL (stmt));
+              const char * ln = ldecl ? IDENTIFIER_POINTER (ldecl): "????";
+#if 0
+              error ("label %s has incorrect context in bb %d\n",
+                     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),
+                     bb->index);
+#else
+              error ("label %s has incorrect context in bb %d\n", ln,
+                      bb->index);
+#endif
+              err = 1;
 	    }
 	}
 
diff -urN gcc.orig/tree.def gcc/tree.def
--- gcc.orig/tree.def	2006-02-10 18:32:10.000000000 +0100
+++ gcc/tree.def	2007-08-26 20:40:16.070950925 +0200
@@ -254,6 +254,12 @@
    includes the hidden argument for "self".  */
 DEFTREECODE (METHOD_TYPE, "method_type", tcc_type, 0)
 
+/* Types of sets for Pascal.  Special fields are the same as
+   in an array type.  The target type is always a boolean type.
+   Used for both bitstrings and powersets in Chill;
+   TYPE_STRING_FLAG indicates a bitstring.  */
+DEFTREECODE (SET_TYPE, "set_type", tcc_type, 0)
+
 /* This is a language-specific kind of type.
    Its meaning is defined by the language front end.
    layout_type does not know how to lay this out,
diff -urN gcc.orig/tree-flow-inline.h gcc/tree-flow-inline.h
--- gcc.orig/tree-flow-inline.h	2006-04-18 15:24:45.000000000 +0200
+++ gcc/tree-flow-inline.h	2007-08-26 20:40:16.060950774 +0200
@@ -1470,7 +1470,8 @@
     return false;
 
   return (AGGREGATE_TYPE_P (TREE_TYPE (v)) &&
-	  TREE_CODE (TREE_TYPE (v)) != ARRAY_TYPE);
+	  TREE_CODE (TREE_TYPE (v)) != ARRAY_TYPE
+          && TREE_CODE (TREE_TYPE (v)) != SET_TYPE);
 }
 
   
diff -urN gcc.orig/tree.h gcc/tree.h
--- gcc.orig/tree.h	2007-02-09 03:52:53.000000000 +0100
+++ gcc/tree.h	2007-08-26 20:40:16.070950925 +0200
@@ -704,6 +704,9 @@
 #define NOT_RECORD_OR_UNION_CHECK(T) \
   TREE_NOT_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)
 
+#define ARRAY_OR_SET_CHECK(T)            \
+  TREE_CHECK2 (T, ARRAY_TYPE, SET_TYPE)
+
 #define NUMERICAL_TYPE_CHECK(T)					\
   TREE_CHECK5 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE,	\
 	       CHAR_TYPE, REAL_TYPE)
@@ -817,7 +820,8 @@
 
 #define AGGREGATE_TYPE_P(TYPE) \
   (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \
-   || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE)
+   || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE \
+   || TREE_CODE (TYPE) == SET_TYPE)
 
 /* Nonzero if TYPE represents a pointer or reference type.
    (It should be renamed to INDIRECT_TYPE_P.)  Keep these checks in
@@ -1618,7 +1622,7 @@
 #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)
 #define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)
 #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)
-#define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type.values)
+#define TYPE_DOMAIN(NODE) (ARRAY_OR_SET_CHECK (NODE)->type.values)
 #define TYPE_FIELDS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.values)
 #define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type.values)
 #define TYPE_ORIG_SIZE_TYPE(NODE)			\
@@ -3555,6 +3559,15 @@
 /* and its original value in bytes, specified via -fpack-struct=<value>.  */
 extern unsigned int initial_max_fld_align;
 
+/* If nonzero, the alignment of a bitstring or (power-)set value, in bits.  */
+extern unsigned int set_alignment;
+
+/* The word size of a bitstring or (power-)set value, in bits.  */
+extern unsigned int set_word_size;
+
+/* If non-zero, bits in (power-)sets start with the highest bit.  */
+extern unsigned int set_words_big_endian;
+
 /* Concatenate two lists (chains of TREE_LIST nodes) X and Y
    by making the last node in X point to Y.
    Returns X, except if X is 0 returns Y.  */
diff -urN gcc.orig/tree-nested.c gcc/tree-nested.c
--- gcc.orig/tree-nested.c	2006-07-20 17:43:44.000000000 +0200
+++ gcc/tree-nested.c	2007-08-26 20:40:16.060950774 +0200
@@ -1173,6 +1173,8 @@
   if (!elt)
     return NULL_TREE;
   new_label = elt->new;
+  DECL_CONTEXT (new_label) = DECL_CONTEXT (label);
+//  mark_decl_referenced (new_label);
 
   /* If there's any possibility that the previous statement falls through,
      then we must branch around the new non-local label.  */
diff -urN gcc.orig/tree-sra.c gcc/tree-sra.c
--- gcc.orig/tree-sra.c	2005-11-21 01:55:57.000000000 +0100
+++ gcc/tree-sra.c	2007-08-26 20:40:16.060950774 +0200
@@ -1368,6 +1368,9 @@
 	      && (!can_completely_scalarize_p (elt)
 		  || !type_can_instantiate_all_elements (elt->type)))
 	    use_block_copy = true;
+          if (TREE_TYPE (elt->type)
+              && full_size != full_count*TYPE_PRECISION (TREE_TYPE (elt->type)))
+            use_block_copy = true;
 	}
       elt->use_block_copy = use_block_copy;
 
diff -urN gcc.orig/tree-ssa-dom.c gcc/tree-ssa-dom.c
--- gcc.orig/tree-ssa-dom.c	2006-11-17 10:01:31.000000000 +0100
+++ gcc/tree-ssa-dom.c	2007-08-26 20:40:16.060950774 +0200
@@ -2804,12 +2804,26 @@
       val_type = TREE_TYPE (val);
 
       /* While both types are pointers, get the type of the object
-	 pointed to.  */
-      while (POINTER_TYPE_P (op_type) && POINTER_TYPE_P (val_type))
-	{
-	  op_type = TREE_TYPE (op_type);
-	  val_type = TREE_TYPE (val_type);
-	}
+	 pointed to. Do not get trapped in cycles.  */
+      {
+        long cnt = 0, maxcnt = 11;
+        tree op_type0 = op_type;
+        while (POINTER_TYPE_P (op_type) && POINTER_TYPE_P (val_type))
+	  {
+	    op_type = TREE_TYPE (op_type);
+	    val_type = TREE_TYPE (val_type);
+            if (op_type == op_type0)
+              return false;
+            cnt ++;
+            if (cnt > maxcnt)
+              {
+                op_type0 = op_type;
+                maxcnt += maxcnt;
+                if (maxcnt < 0)
+                  return false;
+              }
+	  }
+      }
 
       /* Make sure underlying types match before propagating a constant by
 	 converting the constant to the proper type.  Note that convert may
diff -urN gcc.orig/varasm.c gcc/varasm.c
--- gcc.orig/varasm.c	2006-10-16 11:58:48.000000000 +0200
+++ gcc/varasm.c	2007-08-26 20:40:16.070950925 +0200
@@ -2449,6 +2449,18 @@
 	      + const_hash_1 (TREE_IMAGPART (exp)));
 
     case CONSTRUCTOR:
+      if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)
+        {
+          char *tmp;
+
+          len = int_size_in_bytes (TREE_TYPE (exp));
+          tmp = alloca (len);
+          gcc_unreachable ();
+          get_set_constructor_bytes (exp, (unsigned char *) tmp, len);
+          p = tmp;
+          break;
+        }
+      else
       {
 	unsigned HOST_WIDE_INT idx;
 	tree value;
@@ -2576,6 +2588,30 @@
 	typecode = TREE_CODE (TREE_TYPE (t1));
 	if (typecode != TREE_CODE (TREE_TYPE (t2)))
 	  return 0;
+      if (typecode == SET_TYPE)
+        {
+          int len = int_size_in_bytes (TREE_TYPE (t2));
+          unsigned char *tmp1, *tmp2;
+
+          if (TYPE_MAIN_VARIANT (TREE_TYPE (t1)) !=
+                TYPE_MAIN_VARIANT (TREE_TYPE (t2)))
+            return 0;
+
+          if (int_size_in_bytes (TREE_TYPE (t1)) != len)
+            return 0;
+
+          tmp1 = alloca (len);
+          tmp2 = alloca (len);
+
+          gcc_unreachable ();
+          if (get_set_constructor_bytes (t1, tmp1, len) != NULL_TREE)
+            return 0;
+          if (get_set_constructor_bytes (t2, tmp2, len) != NULL_TREE)
+            return 0;
+
+          return memcmp (tmp1, tmp2, len) == 0;
+        }
+
 
 	if (typecode == ARRAY_TYPE)
 	  {
@@ -2708,6 +2744,24 @@
 	VEC(constructor_elt, gc) *v;
 	unsigned HOST_WIDE_INT idx;
 	tree purpose, value;
+
+#if 0
+        tree list = copy_list (CONSTRUCTOR_ELTS (exp));
+        tree tail;
+
+        CONSTRUCTOR_ELTS (copy) = list;
+        for (tail = list; tail; tail = TREE_CHAIN (tail))
+          TREE_VALUE (tail) = copy_constant (TREE_VALUE (tail));
+
+        if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)
+          for (tail = list; tail; tail = TREE_CHAIN (tail))
+            TREE_PURPOSE (tail) = copy_constant (TREE_PURPOSE (tail));
+
+        return copy;
+#else
+        if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)
+          gcc_unreachable ();
+#endif
 	
 	v = VEC_alloc(constructor_elt, gc, VEC_length(constructor_elt,
 						      CONSTRUCTOR_ELTS (exp)));
@@ -3748,7 +3802,12 @@
 	/* Allow conversions to struct or union types if the value
 	   inside is okay.  */
 	if (TREE_CODE (dest_type) == RECORD_TYPE
-	    || TREE_CODE (dest_type) == UNION_TYPE)
+	    || TREE_CODE (dest_type) == UNION_TYPE
+#ifdef GPC
+            || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE
+#endif
+           )
+
 	  return initializer_constant_valid_p (src, endtype);
       }
       break;
@@ -4044,6 +4103,23 @@
       output_constructor (exp, size, align);
       return;
 
+    case SET_TYPE:
+      if (TREE_CODE (exp) == INTEGER_CST)
+        assemble_integer (expand_expr (exp, NULL_RTX,
+                                       VOIDmode, EXPAND_INITIALIZER),
+                          thissize, align, 1);
+      else if (TREE_CODE (exp) == CONSTRUCTOR)
+        {
+          unsigned char *buffer = alloca (thissize);
+          gcc_unreachable ();
+          if (get_set_constructor_bytes (exp, buffer, thissize))
+            abort ();
+          assemble_string ((char *) buffer, thissize);
+        }
+      else
+        error ("unknown set constructor type");
+      return;
+
     case ERROR_MARK:
       return;
 
