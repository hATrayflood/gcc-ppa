#! /bin/sh -e

# DP: libffi backport

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p1 < $0
        cd ${dir}libffi && autoconf2.59
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p1 < $0
        rm -f ${dir}libffi/configure
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0


diff -urN old/libffi/Makefile.am src/libffi/Makefile.am
--- old/libffi/Makefile.am	2005-07-19 21:15:36.000000000 +0000
+++ src/libffi/Makefile.am	2006-08-03 21:47:15.336009808 +0000
@@ -26,7 +26,8 @@
 	src/sparc/ffi.c \
 	src/x86/ffi.c src/x86/sysv.S src/x86/win32.S \
 	src/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \
-	src/pa/ffi.c src/pa/linux.S src/frv/eabi.S src/frv/ffitarget.h
+	src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \
+	src/frv/eabi.S src/frv/ffitarget.h
 
 ## ################################################################
 
@@ -141,9 +142,12 @@
 if SH64
 nodist_libffi_la_SOURCES += src/sh64/sysv.S src/sh64/ffi.c
 endif
-if PA
+if PA_LINUX
 nodist_libffi_la_SOURCES += src/pa/linux.S src/pa/ffi.c
 endif
+if PA_HPUX
+nodist_libffi_la_SOURCES += src/pa/hpux32.S src/pa/ffi.c
+endif
 
 libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)
 nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)
@@ -154,3 +158,8 @@
 
 AM_CPPFLAGS = -I. -I$(top_srcdir)/include -Iinclude -I$(top_srcdir)/src
 AM_CCASFLAGS = $(AM_CPPFLAGS)
+
+# No install-html support
+.PHONY: install-html
+install-html:
+
diff -urN old/libffi/Makefile.in src/libffi/Makefile.in
--- old/libffi/Makefile.in	2006-05-24 23:46:15.000000000 +0000
+++ src/libffi/Makefile.in	2006-08-03 21:47:14.273171384 +0000
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.5 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -59,7 +59,8 @@
 @X86_64_TRUE@am__append_18 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S
 @SH_TRUE@am__append_19 = src/sh/sysv.S src/sh/ffi.c
 @SH64_TRUE@am__append_20 = src/sh64/sysv.S src/sh64/ffi.c
-@PA_TRUE@am__append_21 = src/pa/linux.S src/pa/ffi.c
+@PA_LINUX_TRUE@am__append_21 = src/pa/linux.S src/pa/ffi.c
+@PA_HPUX_TRUE@am__append_22 = src/pa/hpux32.S src/pa/ffi.c
 DIST_COMMON = README $(am__configure_deps) $(srcdir)/../compile \
 	$(srcdir)/../config.guess $(srcdir)/../config.sub \
 	$(srcdir)/../depcomp $(srcdir)/../install-sh \
@@ -123,7 +124,8 @@
 @X86_64_TRUE@	src/x86/ffi.lo src/x86/sysv.lo
 @SH_TRUE@am__objects_19 = src/sh/sysv.lo src/sh/ffi.lo
 @SH64_TRUE@am__objects_20 = src/sh64/sysv.lo src/sh64/ffi.lo
-@PA_TRUE@am__objects_21 = src/pa/linux.lo src/pa/ffi.lo
+@PA_LINUX_TRUE@am__objects_21 = src/pa/linux.lo src/pa/ffi.lo
+@PA_HPUX_TRUE@am__objects_22 = src/pa/hpux32.lo src/pa/ffi.lo
 nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \
 	$(am__objects_3) $(am__objects_4) $(am__objects_5) \
 	$(am__objects_6) $(am__objects_7) $(am__objects_8) \
@@ -131,21 +133,22 @@
 	$(am__objects_12) $(am__objects_13) $(am__objects_14) \
 	$(am__objects_15) $(am__objects_16) $(am__objects_17) \
 	$(am__objects_18) $(am__objects_19) $(am__objects_20) \
-	$(am__objects_21)
+	$(am__objects_21) $(am__objects_22)
 libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) \
 	$(nodist_libffi_la_OBJECTS)
 libffi_convenience_la_LIBADD =
-am__objects_22 = src/debug.lo src/prep_cif.lo src/types.lo \
+am__objects_23 = src/debug.lo src/prep_cif.lo src/types.lo \
 	src/raw_api.lo src/java_raw_api.lo
-am_libffi_convenience_la_OBJECTS = $(am__objects_22)
-am__objects_23 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \
+am_libffi_convenience_la_OBJECTS = $(am__objects_23)
+am__objects_24 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \
 	$(am__objects_4) $(am__objects_5) $(am__objects_6) \
 	$(am__objects_7) $(am__objects_8) $(am__objects_9) \
 	$(am__objects_10) $(am__objects_11) $(am__objects_12) \
 	$(am__objects_13) $(am__objects_14) $(am__objects_15) \
 	$(am__objects_16) $(am__objects_17) $(am__objects_18) \
-	$(am__objects_19) $(am__objects_20) $(am__objects_21)
-nodist_libffi_convenience_la_OBJECTS = $(am__objects_23)
+	$(am__objects_19) $(am__objects_20) $(am__objects_21) \
+	$(am__objects_22)
+nodist_libffi_convenience_la_OBJECTS = $(am__objects_24)
 libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \
 	$(nodist_libffi_convenience_la_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I.
@@ -250,6 +253,8 @@
 MIPS_LINUX_FALSE = @MIPS_LINUX_FALSE@
 MIPS_LINUX_TRUE = @MIPS_LINUX_TRUE@
 OBJEXT = @OBJEXT@
+PA64_HPUX_FALSE = @PA64_HPUX_FALSE@
+PA64_HPUX_TRUE = @PA64_HPUX_TRUE@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
@@ -257,8 +262,10 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
-PA_FALSE = @PA_FALSE@
-PA_TRUE = @PA_TRUE@
+PA_HPUX_FALSE = @PA_HPUX_FALSE@
+PA_HPUX_TRUE = @PA_HPUX_TRUE@
+PA_LINUX_FALSE = @PA_LINUX_FALSE@
+PA_LINUX_TRUE = @PA_LINUX_TRUE@
 POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@
 POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@
 POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@
@@ -359,7 +366,8 @@
 	src/sparc/ffi.c \
 	src/x86/ffi.c src/x86/sysv.S src/x86/win32.S \
 	src/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \
-	src/pa/ffi.c src/pa/linux.S src/frv/eabi.S src/frv/ffitarget.h
+	src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \
+	src/frv/eabi.S src/frv/ffitarget.h
 
 
 # Work around what appears to be a GNU make bug handling MAKEFLAGS
@@ -412,7 +420,7 @@
 	$(am__append_12) $(am__append_13) $(am__append_14) \
 	$(am__append_15) $(am__append_16) $(am__append_17) \
 	$(am__append_18) $(am__append_19) $(am__append_20) \
-	$(am__append_21)
+	$(am__append_21) $(am__append_22)
 libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)
 nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)
 AM_CFLAGS = -Wall -g -fexceptions
@@ -695,6 +703,8 @@
 src/pa/linux.lo: src/pa/$(am__dirstamp) \
 	src/pa/$(DEPDIR)/$(am__dirstamp)
 src/pa/ffi.lo: src/pa/$(am__dirstamp) src/pa/$(DEPDIR)/$(am__dirstamp)
+src/pa/hpux32.lo: src/pa/$(am__dirstamp) \
+	src/pa/$(DEPDIR)/$(am__dirstamp)
 libffi.la: $(libffi_la_OBJECTS) $(libffi_la_DEPENDENCIES) 
 	$(LINK) -rpath $(toolexeclibdir) $(libffi_la_LDFLAGS) $(libffi_la_OBJECTS) $(libffi_la_LIBADD) $(LIBS)
 libffi_convenience.la: $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_DEPENDENCIES) 
@@ -742,6 +752,8 @@
 	-rm -f src/mips/o32.lo
 	-rm -f src/pa/ffi.$(OBJEXT)
 	-rm -f src/pa/ffi.lo
+	-rm -f src/pa/hpux32.$(OBJEXT)
+	-rm -f src/pa/hpux32.lo
 	-rm -f src/pa/linux.$(OBJEXT)
 	-rm -f src/pa/linux.lo
 	-rm -f src/powerpc/aix.$(OBJEXT)
@@ -908,7 +920,13 @@
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -920,7 +938,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done; \
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
@@ -928,7 +946,13 @@
 
 mostlyclean-recursive clean-recursive distclean-recursive \
 maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	case "$@" in \
 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
@@ -949,7 +973,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -1303,6 +1327,10 @@
 	tags tags-recursive uninstall uninstall-am uninstall-info-am \
 	uninstall-toolexeclibLTLIBRARIES
 
+
+# No install-html support
+.PHONY: install-html
+install-html:
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -urN old/libffi/README src/libffi/README
--- old/libffi/README	2004-01-25 06:58:33.000000000 +0000
+++ src/libffi/README	2006-08-03 21:47:15.335009960 +0000
@@ -372,15 +372,6 @@
 arguments' test).
 
 
-What's With The Crazy Comments?
-===============================
-
-You might notice a number of cryptic comments in the code, delimited
-by /*@ and @*/. These are annotations read by the program LCLint, a
-tool for statically checking C programs. You can read all about it at
-<http://larch-www.lcs.mit.edu:8001/larch/lclint/index.html>.
-
-
 History
 =======
 
diff -urN old/libffi/aclocal.m4 src/libffi/aclocal.m4
--- old/libffi/aclocal.m4	2006-05-24 23:46:15.000000000 +0000
+++ src/libffi/aclocal.m4	2006-08-03 21:47:15.342008896 +0000
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.9.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
-# Free Software Foundation, Inc.
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -11,23 +11,11 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
-#                                                        -*- Autoconf -*-
-# Copyright (C) 2002, 2003  Free Software Foundation, Inc.
-# Generated from amversion.in; do not edit by hand.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
@@ -40,28 +28,17 @@
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.9.3])])
-
-# Figure out how to run the assembler.             -*- Autoconf -*-
+	 [AM_AUTOMAKE_VERSION([1.9.5])])
 
-# serial 3
+# Figure out how to run the assembler.                      -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# Copyright (C) 2001, 2003, 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# serial 4
 
 # AM_PROG_AS
 # ----------
@@ -74,24 +51,13 @@
 AC_ARG_VAR([CCASFLAGS], [assembler compiler flags (defaults to CFLAGS)])
 ])
 
-# AM_AUX_DIR_EXPAND
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
 # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
@@ -138,26 +104,16 @@
 am_aux_dir=`cd $ac_aux_dir && pwd`
 ])
 
-# AM_CONDITIONAL                                              -*- Autoconf -*-
-
-# Copyright (C) 1997, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 6
+# serial 7
 
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
@@ -181,26 +137,15 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# serial 7						-*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
+# serial 8
 
 # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
@@ -209,7 +154,6 @@
 # CC etc. in the Makefile, will ask for an AC_PROG_CC use...
 
 
-
 # _AM_DEPENDENCIES(NAME)
 # ----------------------
 # See how the compiler implements dependency checking.
@@ -349,27 +293,16 @@
 AC_SUBST([AMDEPBACKSLASH])
 ])
 
-# Generate code to set up dependency tracking.   -*- Autoconf -*-
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
-#   Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-#serial 2
+#serial 3
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
@@ -428,30 +361,19 @@
      [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
 ])
 
-# Do all the work for Automake.                            -*- Autoconf -*-
+# Do all the work for Automake.                             -*- Autoconf -*-
 
-# This macro actually does too much some checks are only needed if
-# your package does certain things.  But this isn't really a big deal.
-
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# serial 12
 
-# serial 11
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
 
 # AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
 # AM_INIT_AUTOMAKE([OPTIONS])
@@ -553,51 +475,27 @@
 done
 echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
 
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
 AC_DEFUN([AM_PROG_INSTALL_SH],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
 install_sh=${install_sh-"$am_aux_dir/install-sh"}
 AC_SUBST(install_sh)])
 
-#                                                          -*- Autoconf -*-
-# Copyright (C) 2003  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # Check whether the underlying file-system supports filenames
 # with a leading dot.  For instance MS-DOS doesn't.
@@ -612,28 +510,17 @@
 rmdir .tst 2>/dev/null
 AC_SUBST([am__leading_dot])])
 
-# Add --enable-maintainer-mode option to configure.
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 3
+# serial 4
 
 AC_DEFUN([AM_MAINTAINER_MODE],
 [AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
@@ -652,26 +539,15 @@
 
 AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
 
-# Check to see how 'make' treats includes.	-*- Autoconf -*-
-
-# Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # AM_MAKE_INCLUDE()
 # -----------------
@@ -715,29 +591,17 @@
 rm -f confinc confmf
 ])
 
-# serial 2
+# Copyright (C) 1999, 2000, 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
 
 # AM_PROG_CC_C_O
 # --------------
 # Like AC_PROG_CC_C_O, but changed for automake.
-
-# Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
 AC_DEFUN([AM_PROG_CC_C_O],
 [AC_REQUIRE([AC_PROG_CC_C_O])dnl
 AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
@@ -755,27 +619,16 @@
 fi
 ])
 
-#  -*- Autoconf -*-
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# Copyright (C) 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 3
+# serial 4
 
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
@@ -801,27 +654,16 @@
 fi
 ])
 
+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
 # AM_PROG_MKDIR_P
 # ---------------
 # Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.
-
-# Copyright (C) 2003, 2004 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
+#
 # Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories
 # created by `make install' are always world readable, even if the
 # installer happens to have an overly restrictive umask (e.g. 077).
@@ -875,25 +717,14 @@
 fi
 AC_SUBST([mkdir_p])])
 
-# Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004
+# Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 4
+# serial 5
 
 # AM_ENABLE_MULTILIB([MAKEFILE], [REL-TO-TOP-SRCDIR])
 # ---------------------------------------------------
@@ -944,26 +775,15 @@
 CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
 CC="$CC"])])dnl
 
-# Helper functions for option handling.                    -*- Autoconf -*-
+# Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -988,28 +808,16 @@
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
-#
-# Check to make sure that the build environment is sane.
-#
-
-# Copyright (C) 1996, 1997, 2000, 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 3
+# serial 4
 
 # AM_SANITY_CHECK
 # ---------------
@@ -1052,25 +860,14 @@
 fi
 AC_MSG_RESULT(yes)])
 
-# AM_PROG_INSTALL_STRIP
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
+# AM_PROG_INSTALL_STRIP
+# ---------------------
 # One issue with vendor `install' (even GNU) is that you can't
 # specify the program used to strip binaries.  This is especially
 # annoying in cross-compiling environments, where the build's strip
@@ -1093,25 +890,13 @@
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 1
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
+# serial 2
 
 # _AM_PROG_TAR(FORMAT)
 # --------------------
diff -urN old/libffi/configure.ac src/libffi/configure.ac
--- old/libffi/configure.ac	2005-08-11 21:18:24.000000000 +0000
+++ src/libffi/configure.ac	2006-08-03 21:47:15.336009808 +0000
@@ -57,7 +57,7 @@
 sparc*-sun-*) TARGET=SPARC; TARGETDIR=sparc;;
 sparc-*-linux* | sparc-*-netbsdelf* | sparc-*-knetbsd*-gnu) TARGET=SPARC; TARGETDIR=sparc;;
 sparc*-*-rtems*) TARGET=SPARC; TARGETDIR=sparc;;
-sparc64-*-linux* | sparc64-*-netbsd* | sparc64-*-knetbsd*-gnu) TARGET=SPARC; TARGETDIR=sparc;;
+sparc64-*-linux* | sparc64-*-freebsd* | sparc64-*-netbsd* | sparc64-*-knetbsd*-gnu) TARGET=SPARC; TARGETDIR=sparc;;
 alpha*-*-linux* | alpha*-*-osf* | alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu | alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu)
 	TARGET=ALPHA; TARGETDIR=alpha
 	# Support 128-bit long double, changable via command-line switch.
@@ -82,7 +82,9 @@
 sh-*-linux* | sh[[34]]*-*-linux*) TARGET=SH; TARGETDIR=sh;;
 sh-*-rtems*) TARGET=SH; TARGETDIR=sh;;
 sh64-*-linux* | sh5*-*-linux*) TARGET=SH64; TARGETDIR=sh64;;
-hppa-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;
+hppa*-*-linux* | parisc*-*-linux*) TARGET=PA_LINUX; TARGETDIR=pa;;
+hppa*64-*-hpux*) TARGET=PA64_HPUX; TARGETDIR=pa;;
+hppa*-*-hpux*) TARGET=PA_HPUX; TARGETDIR=pa;;
 esac
 
 AC_SUBST(AM_RUNTESTFLAGS)
@@ -111,7 +113,9 @@
 AM_CONDITIONAL(X86_64, test x$TARGET = xX86_64)
 AM_CONDITIONAL(SH, test x$TARGET = xSH)
 AM_CONDITIONAL(SH64, test x$TARGET = xSH64)
-AM_CONDITIONAL(PA, test x$TARGET = xPA)
+AM_CONDITIONAL(PA_LINUX, test x$TARGET = xPA_LINUX)
+AM_CONDITIONAL(PA_HPUX, test x$TARGET = xPA_HPUX)
+AM_CONDITIONAL(PA64_HPUX, test x$TARGET = xPA64_HPUX)
 
 case x$TARGET in
   xMIPS*) TARGET=MIPS ;;
diff -urN old/libffi/include/Makefile.in src/libffi/include/Makefile.in
--- old/libffi/include/Makefile.in	2005-07-19 21:15:36.000000000 +0000
+++ src/libffi/include/Makefile.in	2006-08-03 21:47:14.274171232 +0000
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.5 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -123,6 +123,8 @@
 MIPS_LINUX_FALSE = @MIPS_LINUX_FALSE@
 MIPS_LINUX_TRUE = @MIPS_LINUX_TRUE@
 OBJEXT = @OBJEXT@
+PA64_HPUX_FALSE = @PA64_HPUX_FALSE@
+PA64_HPUX_TRUE = @PA64_HPUX_TRUE@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
@@ -130,8 +132,10 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
-PA_FALSE = @PA_FALSE@
-PA_TRUE = @PA_TRUE@
+PA_HPUX_FALSE = @PA_HPUX_FALSE@
+PA_HPUX_TRUE = @PA_HPUX_TRUE@
+PA_LINUX_FALSE = @PA_LINUX_FALSE@
+PA_LINUX_TRUE = @PA_LINUX_TRUE@
 POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@
 POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@
 POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@
diff -urN old/libffi/src/arm/ffi.c src/libffi/src/arm/ffi.c
--- old/libffi/src/arm/ffi.c	2004-10-27 15:10:22.000000000 +0000
+++ src/libffi/src/arm/ffi.c	2006-08-03 21:47:14.456143568 +0000
@@ -31,9 +31,7 @@
 /* ffi_prep_args is called by the assembly routine once stack space
    has been allocated for the function's arguments */
 
-/*@-exportheader@*/
 void ffi_prep_args(char *stack, extended_cif *ecif)
-/*@=exportheader@*/
 {
   register unsigned int i;
   register void **p_argv;
@@ -136,20 +134,10 @@
   return FFI_OK;
 }
 
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), 
-			  /*@out@*/ extended_cif *, 
-			  unsigned, unsigned, 
-			  /*@out@*/ unsigned *, 
-			  void (*fn)());
-/*@=declundef@*/
-/*@=exportheader@*/
-
-void ffi_call(/*@dependent@*/ ffi_cif *cif, 
-	      void (*fn)(), 
-	      /*@out@*/ void *rvalue, 
-	      /*@dependent@*/ void **avalue)
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, unsigned *, void (*fn)());
+
+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
   extended_cif ecif;
 
@@ -162,9 +150,7 @@
   if ((rvalue == NULL) && 
       (cif->rtype->type == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca(cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;
@@ -173,10 +159,9 @@
   switch (cif->abi) 
     {
     case FFI_SYSV:
-      /*@-usedef@*/
-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, 
-		    cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
+		    fn);
+
       break;
     default:
       FFI_ASSERT(0);
diff -urN old/libffi/src/debug.c src/libffi/src/debug.c
--- old/libffi/src/debug.c	2003-10-21 19:01:58.000000000 +0000
+++ src/libffi/src/debug.c	2006-08-03 21:47:14.466142048 +0000
@@ -31,7 +31,7 @@
 void ffi_stop_here(void)
 {
   /* This function is only useful for debugging purposes.
-     Place a breakpoint on ffi_stop_here to be notified of 
+     Place a breakpoint on ffi_stop_here to be notified of
      significant events. */
 }
 
@@ -50,10 +50,9 @@
 {
   FFI_ASSERT_AT(a != NULL, file, line);
 
-  /*@-usedef@*/
   FFI_ASSERT_AT(a->type <= FFI_TYPE_LAST, file, line);
   FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->size > 0, file, line);
   FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->alignment > 0, file, line);
   FFI_ASSERT_AT(a->type != FFI_TYPE_STRUCT || a->elements != NULL, file, line);
-  /*@=usedef@*/
+
 }
diff -urN old/libffi/src/ffitest.c src/libffi/src/ffitest.c
--- old/libffi/src/ffitest.c	2003-04-18 12:32:36.000000000 +0000
+++ src/libffi/src/ffitest.c	2006-08-03 21:47:14.276170928 +0000
@@ -1,1314 +0,0 @@
-/* -----------------------------------------------------------------------
-   ffitest.c - Copyright (c) 1996, 1997, 1998, 2002, 2003  Red Hat, Inc.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   ``Software''), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be included
-   in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
-   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-   OTHER DEALINGS IN THE SOFTWARE.
-   ----------------------------------------------------------------------- */
-
-#include <ffi.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <float.h>
-
-/* This is lame. Long double support is barely there under SunOS 4.x  */
-#if defined(SPARC) && (SIZEOF_LONG_DOUBLE != 16)
-#define BROKEN_LONG_DOUBLE
-#endif
-
-#define CHECK(x) !(x) ? fail(__FILE__, __LINE__) : 0 
-
-static int fail(char *file, int line)
-{
-  fprintf(stderr, "Test failure: %s line %d\n", file, line);
-  exit(EXIT_FAILURE);
-  /*@notreached@*/
-  return 0;
-}
-
-#define MAX_ARGS 256
-
-static size_t my_strlen(char *s)
-{
-  return (strlen(s));
-}
-
-#ifdef X86_WIN32
-static size_t __attribute__((stdcall)) my_stdcall_strlen(char *s)
-{
-  return (strlen(s));
-}
-#endif /* X86_WIN32 */
-
-static int promotion(signed char sc, signed short ss, 
-		     unsigned char uc, unsigned short us)
-{
-  int r = (int) sc + (int) ss + (int) uc + (int) us;
-
-  return r;
-}
-
-static signed char return_sc(signed char sc)
-{
-  return sc;
-}
-
-static unsigned char return_uc(unsigned char uc)
-{
-  return uc;
-}
-
-static long long return_ll(long long ll)
-{
-  return ll;
-}
-
-static int floating(int a, float b, double c, long double d, int e)
-{
-  int i;
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-  printf("%d %f %f %Lf %d\n", a, (double)b, c, d, e);
-#endif
-
-  i = (int) ((float)a/b + ((float)c/(float)d));
-
-  return i;
-}
-
-static float many(float f1,
-		  float f2,
-		  float f3,
-		  float f4,
-		  float f5,
-		  float f6,
-		  float f7,
-		  float f8,
-		  float f9,
-		  float f10,
-		  float f11,
-		  float f12,
-		  float f13)
-{
-#if 0
-  printf("%f %f %f %f %f %f %f %f %f %f %f %f %f\n",
-	 (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, 
-	 (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,
-	 (double) f11, (double) f12, (double) f13);
-#endif
-
-  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
-}
-
-#ifdef X86_WIN32
-static float __attribute__((stdcall)) stdcall_many(float f1,
-						   float f2,
-						   float f3,
-						   float f4,
-						   float f5,
-						   float f6,
-						   float f7,
-						   float f8,
-						   float f9,
-						   float f10,
-						   float f11,
-						   float f12,
-						   float f13)
-{
-  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
-}
-#endif /* X86_WIN32 */
-
-static double dblit(float f)
-{
-  return f/3.0;
-}
-
-static long double ldblit(float f)
-{
-  return (long double) (((long double) f)/ (long double) 3.0);
-}
-
-typedef struct
-{
-  unsigned char uc;
-  double d;
-  unsigned int ui;
-} test_structure_1;
-
-typedef struct
-{
-  double d1;
-  double d2;
-} test_structure_2;
-
-typedef struct
-{
-  int si;
-} test_structure_3;
-
-typedef struct
-{
-  unsigned ui1;
-  unsigned ui2;
-  unsigned ui3;
-} test_structure_4;
-
-typedef struct
-{
-  char c1;
-  char c2;
-} test_structure_5;
-
-typedef struct
-{
-  float f;
-  double d;
-} test_structure_6;
-
-typedef struct
-{
-  float f1;
-  float f2;
-  double d;
-} test_structure_7;
-
-typedef struct
-{
-  float f1;
-  float f2;
-  float f3;
-  float f4;
-} test_structure_8;
-
-typedef struct
-{
-  float f;
-  int i;
-} test_structure_9;
-
-static test_structure_1 struct1(test_structure_1 ts)
-{
-  /*@-type@*/
-  ts.uc++;
-  /*@=type@*/
-  ts.d--;
-  ts.ui++;
-
-  return ts;
-}
-
-static test_structure_2 struct2(test_structure_2 ts)
-{
-  ts.d1--;
-  ts.d2--;
-
-  return ts;
-}
-
-static test_structure_3 struct3(test_structure_3 ts)
-{
-  ts.si = -(ts.si*2);
-
-  return ts;
-}
-
-static test_structure_4 struct4(test_structure_4 ts)
-{
-  ts.ui3 = ts.ui1 * ts.ui2 * ts.ui3;
-
-  return ts;
-}
-
-static test_structure_5 struct5(test_structure_5 ts1, test_structure_5 ts2)
-{
-  ts1.c1 += ts2.c1;
-  ts1.c2 -= ts2.c2;
-
-  return ts1;
-}
-
-static test_structure_6 struct6 (test_structure_6 ts)
-{
-  ts.f += 1;
-  ts.d += 1;
-
-  return ts;
-}
-
-static test_structure_7 struct7 (test_structure_7 ts)
-{
-  ts.f1 += 1;
-  ts.f2 += 1;
-  ts.d += 1;
-
-  return ts;
-}
-
-static test_structure_8 struct8 (test_structure_8 ts)
-{
-  ts.f1 += 1;
-  ts.f2 += 1;
-  ts.f3 += 1;
-  ts.f4 += 1;
-
-  return ts;
-}
-
-static test_structure_9 struct9 (test_structure_9 ts)
-{
-  ts.f += 1;
-  ts.i += 1;
-
-  return ts;
-}
-
-/* Take an int and a float argument, together with int userdata, and 	*/
-/* return the sum.							*/
-#if FFI_CLOSURES
-static void
-closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)
-{
-  *(ffi_arg*)resp =
-    (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +
-    (int)(*(unsigned long long *)args[2]) + (int)*(int *)args[3] +
-    (int)(*(signed short *)args[4]) +
-    (int)(*(unsigned long long *)args[5]) +
-    (int)*(int *)args[6] + (int)(*(int *)args[7]) +
-    (int)(*(double *)args[8]) + (int)*(int *)args[9] +
-    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
-    (int)*(int *)args[12] + (int)(*(int *)args[13]) +
-    (int)(*(int *)args[14]) +  *(int *)args[15] + (int)(long)userdata;
-
-    	printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	       (int)*(unsigned long long *)args[0], (int)(*(int *)args[1]), 
-	       (int)(*(unsigned long long *)args[2]),
-	       (int)*(int *)args[3], (int)(*(signed short *)args[4]), 
-	       (int)(*(unsigned long long *)args[5]),
-	       (int)*(int *)args[6], (int)(*(int *)args[7]), 
-	       (int)(*(double *)args[8]), (int)*(int *)args[9],
-	       (int)(*(int *)args[10]), (int)(*(float *)args[11]),
-	       (int)*(int *)args[12], (int)(*(int *)args[13]), 
-	       (int)(*(int *)args[14]),*(int *)args[15],
-	       (int)(long)userdata, (int)*(ffi_arg *)resp);
-}
-
-typedef int (*closure_test_type)(unsigned long long, int, unsigned long long, 
-				 int, signed short, unsigned long long, int, 
-				 int, double, int, int, float, int, int, 
-				 int, int);
-
-static void closure_test_fn1(ffi_cif* cif,void* resp,void** args, 
-			     void* userdata)
- {
-    *(ffi_arg*)resp =
-      (int)*(float *)args[0] +(int)(*(float *)args[1]) + 
-      (int)(*(float *)args[2]) + (int)*(float *)args[3] +
-      (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +
-      (int)*(float *)args[6] + (int)(*(int *)args[7]) + 
-      (int)(*(double*)args[8]) + (int)*(int *)args[9] + 
-      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + 
-      (int)*(int *)args[12] + (int)(*(int *)args[13]) + 
-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;
-
-    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	   (int)*(float *)args[0], (int)(*(float *)args[1]), 
-	   (int)(*(float *)args[2]), (int)*(float *)args[3], 
-	   (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),
-	   (int)*(float *)args[6], (int)(*(int *)args[7]),
-	   (int)(*(double *)args[8]), (int)*(int *)args[9],
-	   (int)(*(int *)args[10]), (int)(*(float *)args[11]),
-	   (int)*(int *)args[12], (int)(*(int *)args[13]),
-	   (int)(*(int *)args[14]), *(int *)args[15],
-	   (int)(long)userdata, (int)*(ffi_arg *)resp);
-}
-
-typedef int (*closure_test_type1)(float, float, float, float, signed short, 
-				  float, float, int, double, int, int, float,
-				  int, int, int, int);
-
-static void closure_test_fn2(ffi_cif* cif,void* resp,void** args, 
-			     void* userdata)
- {
-    *(ffi_arg*)resp =
-      (int)*(double *)args[0] +(int)(*(double *)args[1]) + 
-      (int)(*(double *)args[2]) + (int)*(double *)args[3] +
-      (int)(*(signed short *)args[4]) + (int)(*(double *)args[5]) +
-      (int)*(double *)args[6] + (int)(*(int *)args[7]) + 
-      (int)(*(double *)args[8]) + (int)*(int *)args[9] +
-      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + 
-      (int)*(int *)args[12] + (int)(*(float *)args[13]) +
-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;
-
-    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	   (int)*(double *)args[0], (int)(*(double *)args[1]), 
-	   (int)(*(double *)args[2]), (int)*(double *)args[3], 
-	   (int)(*(signed short *)args[4]), (int)(*(double *)args[5]),
-	   (int)*(double *)args[6], (int)(*(int *)args[7]), 
-	   (int)(*(double*)args[8]), (int)*(int *)args[9], 
-	   (int)(*(int *)args[10]), (int)(*(float *)args[11]),
-	   (int)*(int *)args[12], (int)(*(float *)args[13]), 
-	   (int)(*(int *)args[14]), *(int *)args[15], (int)(long)userdata, 
-	   (int)*(ffi_arg *)resp);
- }
-
-typedef int (*closure_test_type2)(double, double, double, double, signed short,
-				  double, double, int, double, int, int, float,
-				  int, float, int, int);
-
-static void closure_test_fn3(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
- {
-    *(ffi_arg*)resp =
-      (int)*(float *)args[0] +(int)(*(float *)args[1]) + 
-      (int)(*(float *)args[2]) + (int)*(float *)args[3] +
-      (int)(*(float *)args[4]) + (int)(*(float *)args[5]) +
-      (int)*(float *)args[6] + (int)(*(float *)args[7]) + 
-      (int)(*(double *)args[8]) + (int)*(int *)args[9] +
-      (int)(*(float *)args[10]) + (int)(*(float *)args[11]) + 
-      (int)*(int *)args[12] + (int)(*(float *)args[13]) +
-      (int)(*(float *)args[14]) +  *(int *)args[15] + (int)(long)userdata;
-
-    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	   (int)*(float *)args[0], (int)(*(float *)args[1]), 
-	   (int)(*(float *)args[2]), (int)*(float *)args[3], 
-	   (int)(*(float *)args[4]), (int)(*(float *)args[5]),
-	   (int)*(float *)args[6], (int)(*(float *)args[7]), 
-	   (int)(*(double *)args[8]), (int)*(int *)args[9], 
-	   (int)(*(float *)args[10]), (int)(*(float *)args[11]),
-	   (int)*(int *)args[12], (int)(*(float *)args[13]), 
-	   (int)(*(float *)args[14]), *(int *)args[15], (int)(long)userdata,
-	   (int)*(ffi_arg *)resp);
- }
-
-typedef int (*closure_test_type3)(float, float, float, float, float, float,
-				  float, float, double, int, float, float, int,
-				  float, float, int);
-#endif
-
-int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-  char *s;
-  signed char sc;
-  unsigned char uc;
-  signed short ss;
-  unsigned short us;
-  unsigned long ul;
-  long long ll;
-  float f;
-  double d;
-  long double ld;
-  signed int si1;
-  signed int si2;
-
-  ffi_arg rint;
-  long long rlonglong;
-
-# if FFI_CLOSURES
-  /* The closure must not be an automatic variable on
-     platforms (Solaris) that forbid stack execution by default. */
-  static ffi_closure cl;
-  ffi_closure *pcl = &cl;
-#endif
-
-  ffi_type * cl_arg_types[17];
-
-  ffi_type ts1_type;
-  ffi_type ts2_type;
-  ffi_type ts3_type;
-  ffi_type ts4_type;  
-  ffi_type ts5_type;
-  ffi_type ts6_type;
-  ffi_type ts7_type;
-  ffi_type ts8_type;
-  ffi_type ts9_type;
-  ffi_type *ts1_type_elements[4];
-  ffi_type *ts2_type_elements[3];
-  ffi_type *ts3_type_elements[2];
-  ffi_type *ts4_type_elements[4];
-  ffi_type *ts5_type_elements[3];
-  ffi_type *ts6_type_elements[3];
-  ffi_type *ts7_type_elements[4];
-  ffi_type *ts8_type_elements[5];
-  ffi_type *ts9_type_elements[3];
-
-  ts1_type.size = 0;
-  ts1_type.alignment = 0;
-  ts1_type.type = FFI_TYPE_STRUCT;
-
-  ts2_type.size = 0;
-  ts2_type.alignment = 0;
-  ts2_type.type = FFI_TYPE_STRUCT;
-
-  ts3_type.size = 0;
-  ts3_type.alignment = 0;
-  ts3_type.type = FFI_TYPE_STRUCT;
-
-  ts4_type.size = 0;
-  ts4_type.alignment = 0;
-  ts4_type.type = FFI_TYPE_STRUCT;
-
-  ts5_type.size = 0;
-  ts5_type.alignment = 0;
-  ts5_type.type = FFI_TYPE_STRUCT;
-
-  ts6_type.size = 0;
-  ts6_type.alignment = 0;
-  ts6_type.type = FFI_TYPE_STRUCT;
-
-  ts7_type.size = 0;
-  ts7_type.alignment = 0;
-  ts7_type.type = FFI_TYPE_STRUCT;
-
-  ts8_type.size = 0;
-  ts8_type.alignment = 0;
-  ts8_type.type = FFI_TYPE_STRUCT;
-
-  ts9_type.size = 0;
-  ts9_type.alignment = 0;
-  ts9_type.type = FFI_TYPE_STRUCT;
-
-  /*@-immediatetrans@*/
-  ts1_type.elements = ts1_type_elements;
-  ts2_type.elements = ts2_type_elements;
-  ts3_type.elements = ts3_type_elements;
-  ts4_type.elements = ts4_type_elements;
-  ts5_type.elements = ts5_type_elements;
-  ts6_type.elements = ts6_type_elements;
-  ts7_type.elements = ts7_type_elements;
-  ts8_type.elements = ts8_type_elements;
-  ts9_type.elements = ts9_type_elements;
-  /*@=immediatetrans@*/
-  
-  ts1_type_elements[0] = &ffi_type_uchar;
-  ts1_type_elements[1] = &ffi_type_double;
-  ts1_type_elements[2] = &ffi_type_uint;
-  ts1_type_elements[3] = NULL;
-  
-  ts2_type_elements[0] = &ffi_type_double;
-  ts2_type_elements[1] = &ffi_type_double;
-  ts2_type_elements[2] = NULL;
-
-  ts3_type_elements[0] = &ffi_type_sint;
-  ts3_type_elements[1] = NULL;
-
-  ts4_type_elements[0] = &ffi_type_uint;
-  ts4_type_elements[1] = &ffi_type_uint;
-  ts4_type_elements[2] = &ffi_type_uint;
-  ts4_type_elements[3] = NULL;
-
-  ts5_type_elements[0] = &ffi_type_schar;
-  ts5_type_elements[1] = &ffi_type_schar;
-  ts5_type_elements[2] = NULL;
-
-  ts6_type_elements[0] = &ffi_type_float;
-  ts6_type_elements[1] = &ffi_type_double;
-  ts6_type_elements[2] = NULL;
-
-  ts7_type_elements[0] = &ffi_type_float;
-  ts7_type_elements[1] = &ffi_type_float;
-  ts7_type_elements[2] = &ffi_type_double;
-  ts7_type_elements[3] = NULL;
-
-  ts8_type_elements[0] = &ffi_type_float;
-  ts8_type_elements[1] = &ffi_type_float;
-  ts8_type_elements[2] = &ffi_type_float;
-  ts8_type_elements[3] = &ffi_type_float;
-  ts8_type_elements[4] = NULL;
-
-  ts9_type_elements[0] = &ffi_type_float;
-  ts9_type_elements[1] = &ffi_type_sint;
-  ts9_type_elements[2] = NULL;
-
-  ul = 0;
-
-  /* return value tests */
-  {
-#if defined(MIPS) /* || defined(ARM) */
-    puts ("long long tests not run. This is a known bug on this architecture.");
-#else
-    args[0] = &ffi_type_sint64;
-    values[0] = &ll;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_sint64, args) == FFI_OK);
-
-    for (ll = 0LL; ll < 100LL; ll++)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
-	CHECK(rlonglong == ll);
-      }
-
-    for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
-	CHECK(rlonglong == ll);
-      }
-#endif
-
-    args[0] = &ffi_type_schar;
-    values[0] = &sc;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_schar, args) == FFI_OK);
-
-    for (sc = (signed char) -127; 
-	 sc < (signed char) 127; /*@-type@*/ sc++ /*@=type@*/)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_sc), &rint, values);
-	CHECK(rint == (ffi_arg) sc);
-      }
-
-    args[0] = &ffi_type_uchar;
-    values[0] = &uc;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_uchar, args) == FFI_OK);
-
-    for (uc = (unsigned char) '\x00'; 
-	 uc < (unsigned char) '\xff'; /*@-type@*/ uc++ /*@=type@*/)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_uc), &rint, values);
-	CHECK(rint == (signed int) uc);
-      }
-
-    printf("%lu return value tests run\n", ul);
-  }
-
-#ifdef BROKEN_LONG_DOUBLE
-  printf ("This architecture has broken `long double' support. No floating point\ntests have been run.\n");
-#else
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_float;
-    values[0] = &f;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_longdouble, args) == FFI_OK);
-
-    f = 3.14159;
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-    printf ("%Lf\n", ldblit(f));
-#endif
-    ld = 666;
-    ffi_call(&cif, FFI_FN(ldblit), &ld, values);
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-    printf ("%Lf, %Lf, %Lf, %Lf\n", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);
-#endif
-
-    /* These are not always the same!! Check for a reasonable delta */
-    /*@-realcompare@*/
-    if (ld - ldblit(f) < LDBL_EPSILON)
-    /*@=realcompare@*/
-	puts("long double return value tests ok!");
-    else
-        CHECK(0);
-  }
-
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_sint;
-    values[0] = &si1;
-    args[1] = &ffi_type_float;
-    values[1] = &f;
-    args[2] = &ffi_type_double;
-    values[2] = &d;
-    args[3] = &ffi_type_longdouble;
-    values[3] = &ld;
-    args[4] = &ffi_type_sint;
-    values[4] = &si2;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,
-		       &ffi_type_sint, args) == FFI_OK);
-
-    si1 = 6;
-    f = 3.14159;
-    d = (double)1.0/(double)3.0;
-    ld = 2.71828182846L;
-    si2 = 10;
-
-    floating (si1, f, d, ld, si2);
-
-    ffi_call(&cif, FFI_FN(floating), &rint, values);
-
-    printf ("%d vs %d\n", (int)rint, floating (si1, f, d, ld, si2));
-
-    CHECK(rint == floating(si1, f, d, ld, si2));
-
-    printf("float arg tests ok!\n");
-  }
-#endif
-
-  /* strlen tests */
-  {
-    args[0] = &ffi_type_pointer;
-    values[0] = (void*) &s;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_sint, args) == FFI_OK);
-
-    s = "a";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 1);
-
-    s = "1234567";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 7);
-
-    s = "1234567890123456789012345";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 25);
-
-    printf("strlen tests passed\n");
-  }
-
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_float;
-    values[0] = &f;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_double, args) == FFI_OK);
-
-    f = 3.14159;
-
-    ffi_call(&cif, FFI_FN(dblit), &d, values);
-
-    /* These are not always the same!! Check for a reasonable delta */
-    /*@-realcompare@*/
-    CHECK(d - dblit(f) < DBL_EPSILON);
-    /*@=realcompare@*/
-
-    printf("double return value tests ok!\n");
-  }
-
-  /* many arg tests */
-  {
-    float ff;
-    float fa[13];
-    
-    for (ul = 0; ul < 13; ul++)
-      {
-	args[ul] = &ffi_type_float;
-	values[ul] = &fa[ul];
-	fa[ul] = (float) ul;
-      }
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, 
-		       &ffi_type_float, args) == FFI_OK);
-
-    /*@-usedef@*/
-    ff = many (fa[0], fa[1],
-	       fa[2], fa[3],
-	       fa[4], fa[5],
-	       fa[6], fa[7],
-	       fa[8], fa[9],
-	       fa[10],fa[11],fa[12]);
-    /*@=usedef@*/
-
-    ffi_call(&cif, FFI_FN(many), &f, values);
-
-    /*@-realcompare@*/
-    if (f - ff < FLT_EPSILON)
-    /*@=realcompare@*/
-	printf("many arg tests ok!\n");
-    else
-#ifdef POWERPC
-	printf("many arg tests failed!  This is a gcc bug.\n");
-#else
-        CHECK(0);
-#endif
-  }
-
-  /* promotion tests */
-  {
-    args[0] = &ffi_type_schar;
-    args[1] = &ffi_type_sshort;
-    args[2] = &ffi_type_uchar;
-    args[3] = &ffi_type_ushort;
-    values[0] = &sc;
-    values[1] = &ss;
-    values[2] = &uc;
-    values[3] = &us;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, 
-		       &ffi_type_sint, args) == FFI_OK);
-
-    us = 0;
-    ul = 0;
-
-    for (sc = (signed char) -127; 
-	 sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)
-      for (ss = -30000; ss <= 30000; ss += 10000)
-	for (uc = (unsigned char) 0; 
-	     uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)
-	  for (us = 0; us <= 60000; us += 10000)
-	    {
-	      ul++;
-	      ffi_call(&cif, FFI_FN(promotion), &rint, values);
-	      CHECK((int)rint == (signed char) sc + (signed short) ss +
-		    (unsigned char) uc + (unsigned short) us);
-	    }
-    printf("%lu promotion tests run\n", ul);
-  }
-
-#ifndef X86_WIN32 /* Structures dont work on Win32 */
-
-  /* struct tests */
-  {
-    test_structure_1 ts1_arg;
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_1 *ts1_result = 
-      (test_structure_1 *) malloc (sizeof(test_structure_1));
-
-    args[0] = &ts1_type;
-    values[0] = &ts1_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts1_type, args) == FFI_OK);
-
-    ts1_arg.uc = '\x01';
-    ts1_arg.d = 3.14159;
-    ts1_arg.ui = 555;
-
-    ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
-
-    CHECK(ts1_result->ui == 556);
-    CHECK(ts1_result->d == 3.14159 - 1);
-
-    puts ("structure test 1 ok!\n");
-
-    free (ts1_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_2 ts2_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_2 *ts2_result = 
-      (test_structure_2 *) malloc (sizeof(test_structure_2));
-
-    args[0] = &ts2_type;
-    values[0] = &ts2_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts2_type, args) == FFI_OK);
-
-    ts2_arg.d1 = 5.55;
-    ts2_arg.d2 = 6.66;
-
-    printf ("%g\n", ts2_arg.d1);
-    printf ("%g\n", ts2_arg.d2);
-
-    ffi_call(&cif, FFI_FN(struct2), ts2_result, values);
-
-    printf ("%g\n", ts2_result->d1);
-    printf ("%g\n", ts2_result->d2);
-    
-    CHECK(ts2_result->d1 == 5.55 - 1);
-    CHECK(ts2_result->d2 == 6.66 - 1);
-
-    printf("structure test 2 ok!\n");
-
-    free (ts2_result);
-  }
-
-  /* struct tests */
-  {
-    int compare_value;
-    test_structure_3 ts3_arg;
-    test_structure_3 *ts3_result = 
-      (test_structure_3 *) malloc (sizeof(test_structure_3));
-
-    args[0] = &ts3_type;
-    values[0] = &ts3_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts3_type, args) == FFI_OK);
-
-    ts3_arg.si = -123;
-    compare_value = ts3_arg.si;
-
-    ffi_call(&cif, FFI_FN(struct3), ts3_result, values);
-
-    printf ("%d %d\n", ts3_result->si, -(compare_value*2));
-
-    if (ts3_result->si == -(ts3_arg.si*2))
-	puts ("structure test 3 ok!");
-    else
-      {
-	puts ("Structure test 3 found structure passing bug.");
-	puts ("  Current versions of GCC are not 100% compliant with the");
-	puts ("  n32 ABI.  There is a known problem related to passing");
-	puts ("  small structures.  Send a bug report to the gcc maintainers.");
-      }
-
-    free (ts3_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_4 ts4_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_4 *ts4_result = 
-      (test_structure_4 *) malloc (sizeof(test_structure_4));
-
-    args[0] = &ts4_type;
-    values[0] = &ts4_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts4_type, args) == FFI_OK);
-
-    ts4_arg.ui1 = 2;
-    ts4_arg.ui2 = 3;
-    ts4_arg.ui3 = 4;
-
-    ffi_call (&cif, FFI_FN(struct4), ts4_result, values);
-    
-    if (ts4_result->ui3 == 2U * 3U * 4U)
-      puts ("structure test 4 ok!");
-    else
-      puts ("Structure test 4 found GCC's structure passing bug.");
-
-    free (ts4_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_5 ts5_arg1, ts5_arg2;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_5 *ts5_result = 
-      (test_structure_5 *) malloc (sizeof(test_structure_5));
-
-    args[0] = &ts5_type;
-    args[1] = &ts5_type;
-    values[0] = &ts5_arg1;
-    values[1] = &ts5_arg2;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ts5_type, args) == FFI_OK);
-
-    ts5_arg1.c1 = 2;
-    ts5_arg1.c2 = 6;
-    ts5_arg2.c1 = 5;
-    ts5_arg2.c2 = 3;
-
-    ffi_call (&cif, FFI_FN(struct5), ts5_result, values);
-    
-    if (ts5_result->c1 == 7 
-	&& ts5_result->c2 == 3)
-      puts ("structure test 5 ok!");
-    else
-      puts ("Structure test 5 found GCC's structure passing bug.");
-
-    free (ts5_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_6 ts6_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_6 *ts6_result = 
-      (test_structure_6 *) malloc (sizeof(test_structure_6));
-
-    args[0] = &ts6_type;
-    values[0] = &ts6_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts6_type, args) == FFI_OK);
-
-    ts6_arg.f = 5.55f;
-    ts6_arg.d = 6.66;
-
-    printf ("%g\n", ts6_arg.f);
-    printf ("%g\n", ts6_arg.d);
-
-    ffi_call(&cif, FFI_FN(struct6), ts6_result, values);
-
-    printf ("%g\n", ts6_result->f);
-    printf ("%g\n", ts6_result->d);
-
-    CHECK(ts6_result->f == 5.55f + 1);
-    CHECK(ts6_result->d == 6.66 + 1);
-
-    printf("structure test 6 ok!\n");
-
-    free (ts6_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_7 ts7_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_7 *ts7_result = 
-      (test_structure_7 *) malloc (sizeof(test_structure_7));
-
-    args[0] = &ts7_type;
-    values[0] = &ts7_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts7_type, args) == FFI_OK);
-
-    ts7_arg.f1 = 5.55f;
-    ts7_arg.f2 = 55.5f;
-    ts7_arg.d = 6.66;
-
-    printf ("%g\n", ts7_arg.f1);
-    printf ("%g\n", ts7_arg.f2);
-    printf ("%g\n", ts7_arg.d);
-
-    ffi_call(&cif, FFI_FN(struct7), ts7_result, values);
-
-    printf ("%g\n", ts7_result->f1);
-    printf ("%g\n", ts7_result->f2);
-    printf ("%g\n", ts7_result->d);
-
-    CHECK(ts7_result->f1 == 5.55f + 1);
-    CHECK(ts7_result->f2 == 55.5f + 1);
-    CHECK(ts7_result->d == 6.66 + 1);
-
-    printf("structure test 7 ok!\n");
-
-    free (ts7_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_8 ts8_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_8 *ts8_result = 
-      (test_structure_8 *) malloc (sizeof(test_structure_8));
-
-    args[0] = &ts8_type;
-    values[0] = &ts8_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts8_type, args) == FFI_OK);
-
-    ts8_arg.f1 = 5.55f;
-    ts8_arg.f2 = 55.5f;
-    ts8_arg.f3 = -5.55f;
-    ts8_arg.f4 = -55.5f;
-
-    printf ("%g\n", ts8_arg.f1);
-    printf ("%g\n", ts8_arg.f2);
-    printf ("%g\n", ts8_arg.f3);
-    printf ("%g\n", ts8_arg.f4);
-
-    ffi_call(&cif, FFI_FN(struct8), ts8_result, values);
-
-    printf ("%g\n", ts8_result->f1);
-    printf ("%g\n", ts8_result->f2);
-    printf ("%g\n", ts8_result->f3);
-    printf ("%g\n", ts8_result->f4);
-
-    CHECK(ts8_result->f1 == 5.55f + 1);
-    CHECK(ts8_result->f2 == 55.5f + 1);
-    CHECK(ts8_result->f3 == -5.55f + 1);
-    CHECK(ts8_result->f4 == -55.5f + 1);
-
-    printf("structure test 8 ok!\n");
-
-    free (ts8_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_9 ts9_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_9 *ts9_result = 
-      (test_structure_9 *) malloc (sizeof(test_structure_9));
-
-    args[0] = &ts9_type;
-    values[0] = &ts9_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts9_type, args) == FFI_OK);
-
-    ts9_arg.f = 5.55f;
-    ts9_arg.i = 5;
-
-    printf ("%g\n", ts9_arg.f);
-    printf ("%d\n", ts9_arg.i);
-
-    ffi_call(&cif, FFI_FN(struct9), ts9_result, values);
-
-    printf ("%g\n", ts9_result->f);
-    printf ("%d\n", ts9_result->i);
-
-    CHECK(ts9_result->f == 5.55f + 1);
-    CHECK(ts9_result->i == 5 + 1);
-
-    printf("structure test 9 ok!\n");
-
-    free (ts9_result);
-  }
-
-#else
-  printf("Structure passing doesn't work on Win32.\n");
-#endif /* X86_WIN32 */
-
-#ifdef X86_WIN32
-  /* stdcall strlen tests */
-  {
-    args[0] = &ffi_type_pointer;
-    values[0] = (void*) &s;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 1,
-		       &ffi_type_sint, args) == FFI_OK);
-
-    s = "a";
-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);
-    CHECK(rint == 1);
-
-    s = "1234567";
-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);
-    CHECK(rint == 7);
-
-    s = "1234567890123456789012345";
-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);
-    CHECK(rint == 25);
-
-    printf("stdcall strlen tests passed\n");
-  }
-
-  /* stdcall many arg tests */
-  {
-    float ff;
-    float fa[13];
-
-    for (ul = 0; ul < 13; ul++)
-      {
-	args[ul] = &ffi_type_float;
-	values[ul] = &fa[ul];
-	fa[ul] = (float) ul;
-      }
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 13,
-		       &ffi_type_float, args) == FFI_OK);
-
-    /*@-usedef@*/
-    ff =  stdcall_many(fa[0], fa[1],
-	       fa[2], fa[3],
-	       fa[4], fa[5],
-	       fa[6], fa[7],
-	       fa[8], fa[9],
-	       fa[10],fa[11],fa[12]);
-    /*@=usedef@*/
-
-    ffi_call(&cif, FFI_FN(stdcall_many), &f, values);
-
-    /*@-realcompare@*/
-    if (f - ff < FLT_EPSILON)
-    /*@=realcompare@*/
-	printf("stdcall many arg tests ok!\n");
-    else
-        CHECK(0);
-  }
-#endif /* X86_WIN32 */
-
-# if FFI_CLOSURES
-#  if __GNUC__ >= 2
-   /* Hide before the compiler that pcl is &cl, since on
-      some architectures it is not possible to call a data
-      object using direct function call.  */
-   asm ("" : "=g" (pcl) : "0" (pcl));
-#  endif
-
-  /* A simple closure test */
-    {
-      (void) puts("\nEnter FFI_CLOSURES\n");
-
-      cl_arg_types[0] = &ffi_type_uint64;
-      cl_arg_types[1] = &ffi_type_uint;
-      cl_arg_types[2] = &ffi_type_uint64;
-      cl_arg_types[3] = &ffi_type_uint;
-      cl_arg_types[4] = &ffi_type_sshort;
-      cl_arg_types[5] = &ffi_type_uint64;
-      cl_arg_types[6] = &ffi_type_uint;
-      cl_arg_types[7] = &ffi_type_uint;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_uint;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_uint;
-      cl_arg_types[14] = &ffi_type_uint;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;   
-
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn,
-			     (void *) 3 /* userdata */) == FFI_OK);
-      
-      CHECK((*((closure_test_type)pcl))
-	    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, 
-	     19, 21, 1) == 680);
-    }
-
-    {
-
-      cl_arg_types[0] = &ffi_type_float;
-      cl_arg_types[1] = &ffi_type_float;
-      cl_arg_types[2] = &ffi_type_float;
-      cl_arg_types[3] = &ffi_type_float;
-      cl_arg_types[4] = &ffi_type_sshort;
-      cl_arg_types[5] = &ffi_type_float;
-      cl_arg_types[6] = &ffi_type_float;
-      cl_arg_types[7] = &ffi_type_uint;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_uint;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_uint;
-      cl_arg_types[14] = &ffi_type_uint;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;
-      
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,
-			     (void *) 3 /* userdata */)  == FFI_OK);
-      
-      CHECK((*((closure_test_type1)pcl))
-	    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,
-	     19, 21, 1) == 255);
-    }
-
-    {
-
-      cl_arg_types[0] = &ffi_type_double;
-      cl_arg_types[1] = &ffi_type_double;
-      cl_arg_types[2] = &ffi_type_double;
-      cl_arg_types[3] = &ffi_type_double;
-      cl_arg_types[4] = &ffi_type_sshort;
-      cl_arg_types[5] = &ffi_type_double;
-      cl_arg_types[6] = &ffi_type_double;
-      cl_arg_types[7] = &ffi_type_uint;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_uint;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_float;
-      cl_arg_types[14] = &ffi_type_uint;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;
-      
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn2,
-			     (void *) 3 /* userdata */) == FFI_OK);
-
-      CHECK((*((closure_test_type2)pcl))
-	    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,
-	     19.0, 21, 1) == 255);
-
-    }
-
-    {
-
-      cl_arg_types[0] = &ffi_type_float;
-      cl_arg_types[1] = &ffi_type_float;
-      cl_arg_types[2] = &ffi_type_float;
-      cl_arg_types[3] = &ffi_type_float;
-      cl_arg_types[4] = &ffi_type_float;
-      cl_arg_types[5] = &ffi_type_float;
-      cl_arg_types[6] = &ffi_type_float;
-      cl_arg_types[7] = &ffi_type_float;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_float;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_float;
-      cl_arg_types[14] = &ffi_type_float;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;
-      
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn3,
-			     (void *) 3 /* userdata */)  == FFI_OK);
-      
-      CHECK((*((closure_test_type3)pcl))
-	    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,
-	     19.19, 21.21, 1) == 135);
-    }
-
-    (void) puts("\nFinished FFI_CLOSURES\n");
-
-# endif
-
-  /* If we arrived here, all is good */
-  (void) puts("\nLooks good. No surprises.\n");
-
-  /*@-compdestroy@*/
-
-  return 0;
-}
-
diff -urN old/libffi/src/java_raw_api.c src/libffi/src/java_raw_api.c
--- old/libffi/src/java_raw_api.c	2003-10-23 20:24:20.000000000 +0000
+++ src/libffi/src/java_raw_api.c	2006-08-03 21:47:14.465142200 +0000
@@ -29,10 +29,10 @@
    ----------------------------------------------------------------------- */
 
 /* This defines a Java- and 64-bit specific variant of the raw API.	*/
-/* It assumes that "raw" argument blocks look like Java stacks on a 	*/
+/* It assumes that "raw" argument blocks look like Java stacks on a	*/
 /* 64-bit machine.  Arguments that can be stored in a single stack	*/
 /* stack slots (longs, doubles) occupy 128 bits, but only the first	*/
-/* 64 bits are actually used.  						*/
+/* 64 bits are actually used.						*/
 
 #include <ffi.h>
 #include <ffi_common.h>
@@ -77,20 +77,20 @@
 #if WORDS_BIGENDIAN
 
   for (i = 0; i < cif->nargs; i++, tp++, args++)
-    {	  
+    {
       switch ((*tp)->type)
 	{
 	case FFI_TYPE_UINT8:
 	case FFI_TYPE_SINT8:
 	  *args = (void*) ((char*)(raw++) + 3);
 	  break;
-	  
+
 	case FFI_TYPE_UINT16:
 	case FFI_TYPE_SINT16:
 	  *args = (void*) ((char*)(raw++) + 2);
 	  break;
 
-#if FFI_SIZEOF_ARG == 8	  
+#if FFI_SIZEOF_ARG == 8
 	case FFI_TYPE_UINT64:
 	case FFI_TYPE_SINT64:
 	case FFI_TYPE_DOUBLE:
@@ -102,7 +102,7 @@
 	case FFI_TYPE_POINTER:
 	  *args = (void*) &(raw++)->ptr;
 	  break;
-	  
+
 	default:
 	  *args = raw;
 	  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
@@ -147,7 +147,7 @@
   ffi_type **tp = cif->arg_types;
 
   for (i = 0; i < cif->nargs; i++, tp++, args++)
-    {	  
+    {
       switch ((*tp)->type)
 	{
 	case FFI_TYPE_UINT8:
@@ -218,7 +218,7 @@
 	default:
 #if FFI_SIZEOF_ARG == 8
 	  FFI_ASSERT(0);	/* Should have covered all cases */
-#else	
+#else
 	  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);
 	  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
 #endif
@@ -285,10 +285,7 @@
  * these following couple of functions will handle the translation forth
  * and back automatically. */
 
-void ffi_java_raw_call (/*@dependent@*/ ffi_cif *cif, 
-		   void (*fn)(), 
-		   /*@out@*/ void *rvalue, 
-		   /*@dependent@*/ ffi_raw *raw)
+void ffi_java_raw_call (ffi_cif *cif, void (*fn)(), void *rvalue, ffi_raw *raw)
 {
   void **avalue = (void**) alloca (cif->nargs * sizeof (void*));
   ffi_java_raw_to_ptrarray (cif, raw, avalue);
@@ -298,7 +295,7 @@
 
 #if FFI_CLOSURES		/* base system provides closures */
 
-static void 
+static void
 ffi_java_translate_args (ffi_cif *cif, void *rvalue,
 		    void **avalue, void *user_data)
 {
@@ -322,7 +319,7 @@
 {
   ffi_status status;
 
-  status = ffi_prep_closure ((ffi_closure*) cl, 
+  status = ffi_prep_closure ((ffi_closure*) cl,
 			     cif,
 			     &ffi_java_translate_args,
 			     (void*)cl);
diff -urN old/libffi/src/m32r/ffi.c src/libffi/src/m32r/ffi.c
--- old/libffi/src/m32r/ffi.c	2004-10-13 17:20:24.000000000 +0000
+++ src/libffi/src/m32r/ffi.c	2006-08-03 21:47:14.457143416 +0000
@@ -31,9 +31,7 @@
 /* ffi_prep_args is called by the assembly routine once stack
    space has been allocated for the function's arguments.  */
 
-/*@-exportheader@*/
 void ffi_prep_args(char *stack, extended_cif *ecif)
-/*@=exportheader@*/
 {
   unsigned int i;
   int tmp;
@@ -173,20 +171,10 @@
   return FFI_OK;
 }
 
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), 
-			  /*@out@*/ extended_cif *, 
-			  unsigned, unsigned, 
-			  /*@out@*/ unsigned *, 
-			  void (*fn)());
-/*@=declundef@*/
-/*@=exportheader@*/
-
-void ffi_call(/*@dependent@*/ ffi_cif *cif, 
-	      void (*fn)(), 
-	      /*@out@*/ void *rvalue, 
-	      /*@dependent@*/ void **avalue)
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, unsigned *, void (*fn)());
+
+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
   extended_cif ecif;
 
@@ -198,9 +186,7 @@
   if ((rvalue == NULL) && 
       (cif->rtype->type == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca (cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;    
@@ -208,7 +194,6 @@
   switch (cif->abi) 
     {
     case FFI_SYSV:
-      /*@-usedef@*/
       ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, 
 		    cif->flags, ecif.rvalue, fn);
       if (cif->rtype->type == FFI_TYPE_STRUCT)
@@ -237,7 +222,6 @@
 		}
 	    }
 	}
-      /*@=usedef@*/
       break;
 
     default:
diff -urN old/libffi/src/powerpc/ffi.c src/libffi/src/powerpc/ffi.c
--- old/libffi/src/powerpc/ffi.c	2005-09-26 19:56:22.000000000 +0000
+++ src/libffi/src/powerpc/ffi.c	2006-08-03 21:47:14.284169712 +0000
@@ -30,8 +30,8 @@
 #include <stdio.h>
 
 
-extern void ffi_closure_SYSV(void);
-extern void FFI_HIDDEN ffi_closure_LINUX64(void);
+extern void ffi_closure_SYSV (void);
+extern void FFI_HIDDEN ffi_closure_LINUX64 (void);
 
 enum {
   /* The assembly depends on these exact flags.  */
@@ -80,79 +80,103 @@
 
 */
 
-/*@-exportheader@*/
-void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)
-/*@=exportheader@*/
+void
+ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)
 {
   const unsigned bytes = ecif->cif->bytes;
   const unsigned flags = ecif->cif->flags;
 
+  typedef union {
+    char *c;
+    unsigned *u;
+    long long *ll;
+    float *f;
+    double *d;
+  } valp;
+
   /* 'stacktop' points at the previous backchain pointer.  */
-  unsigned *const stacktop = stack + (bytes / sizeof(unsigned));
+  valp stacktop;
 
   /* 'gpr_base' points at the space for gpr3, and grows upwards as
      we use GPR registers.  */
-  unsigned *gpr_base = stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;
-  int intarg_count = 0;
+  valp gpr_base;
+  int intarg_count;
 
   /* 'fpr_base' points at the space for fpr1, and grows upwards as
      we use FPR registers.  */
-  double *fpr_base = (double *)gpr_base - NUM_FPR_ARG_REGISTERS;
-  int fparg_count = 0;
+  valp fpr_base;
+  int fparg_count;
 
   /* 'copy_space' grows down as we put structures in it.  It should
      stay 16-byte aligned.  */
-  char *copy_space = ((flags & FLAG_FP_ARGUMENTS)
-		      ? (char *)fpr_base
-		      : (char *)gpr_base);
+  valp copy_space;
 
   /* 'next_arg' grows up as we put parameters in it.  */
-  unsigned *next_arg = stack + 2;
+  valp next_arg;
 
   int i;
   ffi_type **ptr;
   double double_tmp;
-  void **p_argv;
+  union {
+    void **v;
+    char **c;
+    signed char **sc;
+    unsigned char **uc;
+    signed short **ss;
+    unsigned short **us;
+    unsigned int **ui;
+    long long **ll;
+    float **f;
+    double **d;
+  } p_argv;
   size_t struct_copy_size;
   unsigned gprvalue;
 
+  stacktop.c = (char *) stack + bytes;
+  gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;
+  intarg_count = 0;
+  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS;
+  fparg_count = 0;
+  copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);
+  next_arg.u = stack + 2;
+
   /* Check that everything starts aligned properly.  */
-  FFI_ASSERT(((unsigned)(char *)stack & 0xF) == 0);
-  FFI_ASSERT(((unsigned)(char *)copy_space & 0xF) == 0);
-  FFI_ASSERT(((unsigned)(char *)stacktop & 0xF) == 0);
-  FFI_ASSERT((bytes & 0xF) == 0);
-  FFI_ASSERT(copy_space >= (char *)next_arg);
+  FFI_ASSERT (((unsigned) (char *) stack & 0xF) == 0);
+  FFI_ASSERT (((unsigned) copy_space.c & 0xF) == 0);
+  FFI_ASSERT (((unsigned) stacktop.c & 0xF) == 0);
+  FFI_ASSERT ((bytes & 0xF) == 0);
+  FFI_ASSERT (copy_space.c >= next_arg.c);
 
   /* Deal with return values that are actually pass-by-reference.  */
   if (flags & FLAG_RETVAL_REFERENCE)
     {
-      *gpr_base++ = (unsigned long)(char *)ecif->rvalue;
+      *gpr_base.u++ = (unsigned long) (char *) ecif->rvalue;
       intarg_count++;
     }
 
   /* Now for the arguments.  */
-  p_argv = ecif->avalue;
+  p_argv.v = ecif->avalue;
   for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;
        i > 0;
-       i--, ptr++, p_argv++)
+       i--, ptr++, p_argv.v++)
     {
       switch ((*ptr)->type)
 	{
 	case FFI_TYPE_FLOAT:
-	  double_tmp = *(float *)*p_argv;
+	  double_tmp = **p_argv.f;
 	  if (fparg_count >= NUM_FPR_ARG_REGISTERS)
 	    {
-	      *(float *)next_arg = (float)double_tmp;
-	      next_arg += 1;
+	      *next_arg.f = (float) double_tmp;
+	      next_arg.u += 1;
 	    }
 	  else
-	    *fpr_base++ = double_tmp;
+	    *fpr_base.d++ = double_tmp;
 	  fparg_count++;
-	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
 	  break;
 
 	case FFI_TYPE_DOUBLE:
-	  double_tmp = *(double *)*p_argv;
+	  double_tmp = **p_argv.d;
 
 	  if (fparg_count >= NUM_FPR_ARG_REGISTERS)
 	    {
@@ -160,16 +184,48 @@
 		  && intarg_count % 2 != 0)
 		{
 		  intarg_count++;
-		  next_arg++;
+		  next_arg.u++;
 		}
-	      *(double *)next_arg = double_tmp;
-	      next_arg += 2;
+	      *next_arg.d = double_tmp;
+	      next_arg.u += 2;
 	    }
 	  else
-	    *fpr_base++ = double_tmp;
+	    *fpr_base.d++ = double_tmp;
 	  fparg_count++;
-	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+	  break;
+
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  if (ecif->cif->abi != FFI_LINUX)
+	    goto do_struct;
+	  double_tmp = (*p_argv.d)[0];
+
+	  if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)
+	    {
+	      if (intarg_count >= NUM_GPR_ARG_REGISTERS
+		  && intarg_count % 2 != 0)
+		{
+		  intarg_count++;
+		  next_arg.u++;
+		}
+	      *next_arg.d = double_tmp;
+	      next_arg.u += 2;
+	      double_tmp = (*p_argv.d)[1];
+	      *next_arg.d = double_tmp;
+	      next_arg.u += 2;
+	    }
+	  else
+	    {
+	      *fpr_base.d++ = double_tmp;
+	      double_tmp = (*p_argv.d)[1];
+	      *fpr_base.d++ = double_tmp;
+	    }
+
+	  fparg_count += 2;
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
 	  break;
+#endif
 
 	case FFI_TYPE_UINT64:
 	case FFI_TYPE_SINT64:
@@ -177,13 +233,13 @@
 	    intarg_count++;
 	  if (intarg_count >= NUM_GPR_ARG_REGISTERS)
 	    {
-	      if (intarg_count%2 != 0)
+	      if (intarg_count % 2 != 0)
 		{
 		  intarg_count++;
-		  next_arg++;
+		  next_arg.u++;
 		}
-	      *(long long *)next_arg = *(long long *)*p_argv;
-	      next_arg += 2;
+	      *next_arg.ll = **p_argv.ll;
+	      next_arg.u += 2;
 	    }
 	  else
 	    {
@@ -194,65 +250,65 @@
 	       * not correct starting register of pair then skip
 	       * until the proper starting register
 	       */
-	      if (intarg_count%2 != 0)
+	      if (intarg_count % 2 != 0)
 		{
 		  intarg_count ++;
-		  gpr_base++;
+		  gpr_base.u++;
 		}
-	      *(long long *)gpr_base = *(long long *)*p_argv;
-	      gpr_base += 2;
+	      *gpr_base.ll++ = **p_argv.ll;
 	    }
 	  intarg_count += 2;
 	  break;
 
 	case FFI_TYPE_STRUCT:
 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
-	case FFI_TYPE_LONGDOUBLE:
+	do_struct:
 #endif
 	  struct_copy_size = ((*ptr)->size + 15) & ~0xF;
-	  copy_space -= struct_copy_size;
-	  memcpy(copy_space, (char *)*p_argv, (*ptr)->size);
+	  copy_space.c -= struct_copy_size;
+	  memcpy (copy_space.c, *p_argv.c, (*ptr)->size);
 
-	  gprvalue = (unsigned long)copy_space;
+	  gprvalue = (unsigned long) copy_space.c;
 
-	  FFI_ASSERT(copy_space > (char *)next_arg);
-	  FFI_ASSERT(flags & FLAG_ARG_NEEDS_COPY);
+	  FFI_ASSERT (copy_space.c > next_arg.c);
+	  FFI_ASSERT (flags & FLAG_ARG_NEEDS_COPY);
 	  goto putgpr;
 
 	case FFI_TYPE_UINT8:
-	  gprvalue = *(unsigned char *)*p_argv;
+	  gprvalue = **p_argv.uc;
 	  goto putgpr;
 	case FFI_TYPE_SINT8:
-	  gprvalue = *(signed char *)*p_argv;
+	  gprvalue = **p_argv.sc;
 	  goto putgpr;
 	case FFI_TYPE_UINT16:
-	  gprvalue = *(unsigned short *)*p_argv;
+	  gprvalue = **p_argv.us;
 	  goto putgpr;
 	case FFI_TYPE_SINT16:
-	  gprvalue = *(signed short *)*p_argv;
+	  gprvalue = **p_argv.ss;
 	  goto putgpr;
 
 	case FFI_TYPE_INT:
 	case FFI_TYPE_UINT32:
 	case FFI_TYPE_SINT32:
 	case FFI_TYPE_POINTER:
-	  gprvalue = *(unsigned *)*p_argv;
+	  gprvalue = **p_argv.ui;
+
 	putgpr:
 	  if (intarg_count >= NUM_GPR_ARG_REGISTERS)
-	    *next_arg++ = gprvalue;
+	    *next_arg.u++ = gprvalue;
 	  else
-	    *gpr_base++ = gprvalue;
+	    *gpr_base.u++ = gprvalue;
 	  intarg_count++;
 	  break;
 	}
     }
 
   /* Check that we didn't overrun the stack...  */
-  FFI_ASSERT(copy_space >= (char *)next_arg);
-  FFI_ASSERT(gpr_base <= stacktop - ASM_NEEDS_REGISTERS);
-  FFI_ASSERT((unsigned *)fpr_base
-	     <= stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);
-  FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);
+  FFI_ASSERT (copy_space.c >= next_arg.c);
+  FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);
+  FFI_ASSERT (fpr_base.u
+	      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);
+  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);
 }
 
 /* About the LINUX64 ABI.  */
@@ -296,160 +352,187 @@
 
 */
 
-/*@-exportheader@*/
-void FFI_HIDDEN ffi_prep_args64(extended_cif *ecif, unsigned long *const stack)
-/*@=exportheader@*/
+void FFI_HIDDEN
+ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)
 {
   const unsigned long bytes = ecif->cif->bytes;
   const unsigned long flags = ecif->cif->flags;
 
+  typedef union {
+    char *c;
+    unsigned long *ul;
+    float *f;
+    double *d;
+  } valp;
+
   /* 'stacktop' points at the previous backchain pointer.  */
-  unsigned long *const stacktop = stack + (bytes / sizeof(unsigned long));
+  valp stacktop;
 
   /* 'next_arg' points at the space for gpr3, and grows upwards as
      we use GPR registers, then continues at rest.  */
-  unsigned long *const gpr_base = stacktop - ASM_NEEDS_REGISTERS64
-    - NUM_GPR_ARG_REGISTERS64;
-  unsigned long *const gpr_end = gpr_base + NUM_GPR_ARG_REGISTERS64;
-  unsigned long *const rest = stack + 6 + NUM_GPR_ARG_REGISTERS64;
-  unsigned long *next_arg = gpr_base;
+  valp gpr_base;
+  valp gpr_end;
+  valp rest;
+  valp next_arg;
 
   /* 'fpr_base' points at the space for fpr3, and grows upwards as
      we use FPR registers.  */
-  double *fpr_base = (double *)gpr_base - NUM_FPR_ARG_REGISTERS64;
-  int fparg_count = 0;
+  valp fpr_base;
+  int fparg_count;
 
   int i, words;
   ffi_type **ptr;
   double double_tmp;
-  void **p_argv;
+  union {
+    void **v;
+    char **c;
+    signed char **sc;
+    unsigned char **uc;
+    signed short **ss;
+    unsigned short **us;
+    signed int **si;
+    unsigned int **ui;
+    unsigned long **ul;
+    float **f;
+    double **d;
+  } p_argv;
   unsigned long gprvalue;
 
+  stacktop.c = (char *) stack + bytes;
+  gpr_base.ul = stacktop.ul - ASM_NEEDS_REGISTERS64 - NUM_GPR_ARG_REGISTERS64;
+  gpr_end.ul = gpr_base.ul + NUM_GPR_ARG_REGISTERS64;
+  rest.ul = stack + 6 + NUM_GPR_ARG_REGISTERS64;
+  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS64;
+  fparg_count = 0;
+  next_arg.ul = gpr_base.ul;
+
   /* Check that everything starts aligned properly.  */
-  FFI_ASSERT(((unsigned long)(char *)stack & 0xF) == 0);
-  FFI_ASSERT(((unsigned long)(char *)stacktop & 0xF) == 0);
-  FFI_ASSERT((bytes & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);
+  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);
+  FFI_ASSERT ((bytes & 0xF) == 0);
 
   /* Deal with return values that are actually pass-by-reference.  */
   if (flags & FLAG_RETVAL_REFERENCE)
-    *next_arg++ = (unsigned long)(char *)ecif->rvalue;
+    *next_arg.ul++ = (unsigned long) (char *) ecif->rvalue;
 
   /* Now for the arguments.  */
-  p_argv = ecif->avalue;
+  p_argv.v = ecif->avalue;
   for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;
        i > 0;
-       i--, ptr++, p_argv++)
+       i--, ptr++, p_argv.v++)
     {
       switch ((*ptr)->type)
 	{
 	case FFI_TYPE_FLOAT:
-	  double_tmp = *(float *)*p_argv;
-	  *(float *)next_arg = (float)double_tmp;
-	  if (++next_arg == gpr_end)
-	    next_arg = rest;
+	  double_tmp = **p_argv.f;
+	  *next_arg.f = (float) double_tmp;
+	  if (++next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
 	  if (fparg_count < NUM_FPR_ARG_REGISTERS64)
-	    *fpr_base++ = double_tmp;
+	    *fpr_base.d++ = double_tmp;
 	  fparg_count++;
-	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
 	  break;
 
 	case FFI_TYPE_DOUBLE:
-	  double_tmp = *(double *)*p_argv;
-	  *(double *)next_arg = double_tmp;
-	  if (++next_arg == gpr_end)
-	    next_arg = rest;
+	  double_tmp = **p_argv.d;
+	  *next_arg.d = double_tmp;
+	  if (++next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
 	  if (fparg_count < NUM_FPR_ARG_REGISTERS64)
-	    *fpr_base++ = double_tmp;
+	    *fpr_base.d++ = double_tmp;
 	  fparg_count++;
-	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
 	  break;
 
 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
 	case FFI_TYPE_LONGDOUBLE:
-	  double_tmp = ((double *) *p_argv)[0];
-	  *(double *) next_arg = double_tmp;
-	  if (++next_arg == gpr_end)
-	    next_arg = rest;
+	  double_tmp = (*p_argv.d)[0];
+	  *next_arg.d = double_tmp;
+	  if (++next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
 	  if (fparg_count < NUM_FPR_ARG_REGISTERS64)
-	    *fpr_base++ = double_tmp;
+	    *fpr_base.d++ = double_tmp;
 	  fparg_count++;
-	  double_tmp = ((double *) *p_argv)[1];
-	  *(double *) next_arg = double_tmp;
-	  if (++next_arg == gpr_end)
-	    next_arg = rest;
+	  double_tmp = (*p_argv.d)[1];
+	  *next_arg.d = double_tmp;
+	  if (++next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
 	  if (fparg_count < NUM_FPR_ARG_REGISTERS64)
-	    *fpr_base++ = double_tmp;
+	    *fpr_base.d++ = double_tmp;
 	  fparg_count++;
-	  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);
+	  FFI_ASSERT (__LDBL_MANT_DIG__ == 106);
+	  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
 	  break;
 #endif
 
 	case FFI_TYPE_STRUCT:
 	  words = ((*ptr)->size + 7) / 8;
-	  if (next_arg >= gpr_base && next_arg + words > gpr_end)
+	  if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)
 	    {
-	      size_t first = (char *) gpr_end - (char *) next_arg;
-	      memcpy((char *) next_arg, (char *) *p_argv, first);
-	      memcpy((char *) rest, (char *) *p_argv + first,
-		     (*ptr)->size - first);
-	      next_arg = (unsigned long *) ((char *) rest + words * 8 - first);
+	      size_t first = gpr_end.c - next_arg.c;
+	      memcpy (next_arg.c, *p_argv.c, first);
+	      memcpy (rest.c, *p_argv.c + first, (*ptr)->size - first);
+	      next_arg.c = rest.c + words * 8 - first;
 	    }
 	  else
 	    {
-	      char *where = (char *) next_arg;
+	      char *where = next_arg.c;
 
 	      /* Structures with size less than eight bytes are passed
 		 left-padded.  */
 	      if ((*ptr)->size < 8)
 		where += 8 - (*ptr)->size;
 
-	      memcpy (where, (char *) *p_argv, (*ptr)->size);
-	      next_arg += words;
-	      if (next_arg == gpr_end)
-		next_arg = rest;
+	      memcpy (where, *p_argv.c, (*ptr)->size);
+	      next_arg.ul += words;
+	      if (next_arg.ul == gpr_end.ul)
+		next_arg.ul = rest.ul;
 	    }
 	  break;
 
 	case FFI_TYPE_UINT8:
-	  gprvalue = *(unsigned char *)*p_argv;
+	  gprvalue = **p_argv.uc;
 	  goto putgpr;
 	case FFI_TYPE_SINT8:
-	  gprvalue = *(signed char *)*p_argv;
+	  gprvalue = **p_argv.sc;
 	  goto putgpr;
 	case FFI_TYPE_UINT16:
-	  gprvalue = *(unsigned short *)*p_argv;
+	  gprvalue = **p_argv.us;
 	  goto putgpr;
 	case FFI_TYPE_SINT16:
-	  gprvalue = *(signed short *)*p_argv;
+	  gprvalue = **p_argv.ss;
 	  goto putgpr;
 	case FFI_TYPE_UINT32:
-	  gprvalue = *(unsigned int *)*p_argv;
+	  gprvalue = **p_argv.ui;
 	  goto putgpr;
 	case FFI_TYPE_INT:
 	case FFI_TYPE_SINT32:
-	  gprvalue = *(signed int *)*p_argv;
+	  gprvalue = **p_argv.si;
 	  goto putgpr;
 
 	case FFI_TYPE_UINT64:
 	case FFI_TYPE_SINT64:
 	case FFI_TYPE_POINTER:
-	  gprvalue = *(unsigned long *)*p_argv;
+	  gprvalue = **p_argv.ul;
 	putgpr:
-	  *next_arg++ = gprvalue;
-	  if (next_arg == gpr_end)
-	    next_arg = rest;
+	  *next_arg.ul++ = gprvalue;
+	  if (next_arg.ul == gpr_end.ul)
+	    next_arg.ul = rest.ul;
 	  break;
 	}
     }
 
-  FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS
-	     || (next_arg >= gpr_base && next_arg <= gpr_base + 4));
+  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS
+	      || (next_arg.ul >= gpr_base.ul
+		  && next_arg.ul <= gpr_base.ul + 4));
 }
 
 
 
 /* Perform machine dependent cif processing */
-ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
 {
   /* All this is for the SYSV and LINUX64 ABI.  */
   int i;
@@ -467,10 +550,10 @@
 	 Redo the calculation for SYSV.  */
 
       /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */
-      bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof(int);
+      bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof (int);
 
       /* Space for the GPR registers.  */
-      bytes += NUM_GPR_ARG_REGISTERS * sizeof(int);
+      bytes += NUM_GPR_ARG_REGISTERS * sizeof (int);
     }
   else
     {
@@ -478,15 +561,10 @@
 
       /* Space for backchain, CR, LR, cc/ld doubleword, TOC and the asm's temp
 	 regs.  */
-      bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof(long);
+      bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof (long);
 
       /* Space for the mandatory parm save area and general registers.  */
-      bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof(long);
-
-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
-      if (type == FFI_TYPE_LONGDOUBLE)
-	type = FFI_TYPE_DOUBLE;
-#endif
+      bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof (long);
     }
 
   /* Return value handling.  The rules for SYSV are as follows:
@@ -495,14 +573,24 @@
      - 64-bit integer values and structures between 5 and 8 bytes are returned
      in gpr3 and gpr4;
      - Single/double FP values are returned in fpr1;
-     - Larger structures and long double (if not equivalent to double) values
-     are allocated space and a pointer is passed as the first argument.
+     - Larger structures are allocated space and a pointer is passed as
+     the first argument.
+     - long doubles (if not equivalent to double) are returned in
+     fpr1,fpr2 for Linux and as for large structs for SysV.
      For LINUX64:
      - integer values in gpr3;
      - Structures/Unions by reference;
      - Single/double FP values in fpr1, long double in fpr1,fpr2.  */
   switch (type)
     {
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64)
+	goto byref;
+
+      flags |= FLAG_RETURNS_128BITS;
+      /* Fall through.  */
+#endif
     case FFI_TYPE_DOUBLE:
       flags |= FLAG_RETURNS_64BITS;
       /* Fall through.  */
@@ -523,33 +611,29 @@
 	     in memory.  */
 
 	  /* Treat structs with size <= 8 bytes.  */
-	  if (size <= 8) {
-	    flags |= FLAG_RETURNS_SMST;
-	    /* These structs are returned in r3. We pack the type and the
-	       precalculated shift value (needed in the sysv.S) into flags.
-	       The same applies for the structs returned in r3/r4.  */
-	    if (size <= 4) {
-	      flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 1 )
-		| (8 * (4 - size) << 4);
-	      break;
-	    }
-	    /* These structs are returned in r3 and r4. See above.   */
-	    if  (size <= 8) {
-	      flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 2 )
-		| (8 * (8 - size) << 4);
-	    break;
+	  if (size <= 8)
+	    {
+	      flags |= FLAG_RETURNS_SMST;
+	      /* These structs are returned in r3. We pack the type and the
+		 precalculated shift value (needed in the sysv.S) into flags.
+		 The same applies for the structs returned in r3/r4.  */
+	      if (size <= 4)
+		{
+		  flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 1);
+		  flags |= 8 * (4 - size) << 4;
+		  break;
+		}
+	      /* These structs are returned in r3 and r4. See above.   */
+	      if  (size <= 8)
+		{
+		  flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 2);
+		  flags |= 8 * (8 - size) << 4;
+		  break;
+		}
 	    }
-	  }
 	}
-      /* else fall through.  */
 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
-    case FFI_TYPE_LONGDOUBLE:
-      if (type == FFI_TYPE_LONGDOUBLE && cif->abi == FFI_LINUX64)
-	{
-	  flags |= FLAG_RETURNS_128BITS;
-	  flags |= FLAG_RETURNS_FP;
-	  break;
-	}
+    byref:
 #endif
       intarg_count++;
       flags |= FLAG_RETVAL_REFERENCE;
@@ -578,6 +662,13 @@
 	    /* floating singles are not 8-aligned on stack */
 	    break;
 
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	  case FFI_TYPE_LONGDOUBLE:
+	    if (cif->abi != FFI_LINUX)
+	      goto do_struct;
+	    fparg_count++;
+	    /* Fall thru */
+#endif
 	  case FFI_TYPE_DOUBLE:
 	    fparg_count++;
 	    /* If this FP arg is going on the stack, it must be
@@ -600,14 +691,14 @@
 	       (r7,r8), (r9,r10).
 	    */
 	    if (intarg_count == NUM_GPR_ARG_REGISTERS-1
-		|| intarg_count%2 != 0)
+		|| intarg_count % 2 != 0)
 	      intarg_count++;
 	    intarg_count += 2;
 	    break;
 
 	  case FFI_TYPE_STRUCT:
 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
-	  case FFI_TYPE_LONGDOUBLE:
+	  do_struct:
 #endif
 	    /* We must allocate space for a copy of these to enforce
 	       pass-by-value.  Pad the space up to a multiple of 16
@@ -663,23 +754,23 @@
     {
       /* Space for the FPR registers, if needed.  */
       if (fparg_count != 0)
-	bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);
+	bytes += NUM_FPR_ARG_REGISTERS * sizeof (double);
 
       /* Stack space.  */
       if (intarg_count > NUM_GPR_ARG_REGISTERS)
-	bytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof(int);
+	bytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof (int);
       if (fparg_count > NUM_FPR_ARG_REGISTERS)
-	bytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof(double);
+	bytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof (double);
     }
   else
     {
       /* Space for the FPR registers, if needed.  */
       if (fparg_count != 0)
-	bytes += NUM_FPR_ARG_REGISTERS64 * sizeof(double);
+	bytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);
 
       /* Stack space.  */
       if (intarg_count > NUM_GPR_ARG_REGISTERS64)
-	bytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof(long);
+	bytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof (long);
     }
 
   /* The stack space allocated needs to be a multiple of 16 bytes.  */
@@ -694,23 +785,14 @@
   return FFI_OK;
 }
 
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_SYSV(/*@out@*/ extended_cif *,
-			  unsigned, unsigned,
-			  /*@out@*/ unsigned *,
+extern void ffi_call_SYSV(extended_cif *, unsigned, unsigned, unsigned *,
 			  void (*fn)());
-extern void FFI_HIDDEN ffi_call_LINUX64(/*@out@*/ extended_cif *,
-					unsigned long, unsigned long,
-					/*@out@*/ unsigned long *,
+extern void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, unsigned long,
+					unsigned long, unsigned long *,
 					void (*fn)());
-/*@=declundef@*/
-/*@=exportheader@*/
 
-void ffi_call(/*@dependent@*/ ffi_cif *cif,
-	      void (*fn)(),
-	      /*@out@*/ void *rvalue,
-	      /*@dependent@*/ void **avalue)
+void
+ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
   extended_cif ecif;
 
@@ -720,12 +802,9 @@
   /* If the return value is a struct and we don't have a return	*/
   /* value address then we need to make one		        */
 
-  if ((rvalue == NULL) &&
-      (cif->rtype->type == FFI_TYPE_STRUCT))
+  if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca(cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;
@@ -736,48 +815,45 @@
 #ifndef POWERPC64
     case FFI_SYSV:
     case FFI_GCC_SYSV:
-      /*@-usedef@*/
-      ffi_call_SYSV(&ecif, -cif->bytes,
-		    cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+    case FFI_LINUX:
+      ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);
       break;
 #else
     case FFI_LINUX64:
-      /*@-usedef@*/
-      ffi_call_LINUX64(&ecif, -(long) cif->bytes,
-		       cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_LINUX64 (&ecif, -(long) cif->bytes, cif->flags, ecif.rvalue, fn);
       break;
 #endif
     default:
-      FFI_ASSERT(0);
+      FFI_ASSERT (0);
       break;
     }
 }
 
 
 #ifndef POWERPC64
-static void flush_icache(char *, int);
-
 #define MIN_CACHE_LINE_SIZE 8
 
-static void flush_icache(char * addr1, int size)
+static void
+flush_icache (char *addr1, int size)
 {
   int i;
   char * addr;
-  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE) {
-    addr = addr1 + i;
-    __asm__ volatile ("icbi 0,%0;" "dcbf 0,%0;" : : "r"(addr) : "memory");
-  }
+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)
+    {
+      addr = addr1 + i;
+      __asm__ volatile ("icbi 0,%0;" "dcbf 0,%0;"
+			: : "r" (addr) : "memory");
+    }
   addr = addr1 + size - 1;
-  __asm__ volatile ("icbi 0,%0;" "dcbf 0,%0;" "sync;" "isync;" : : "r"(addr) : "memory");
+  __asm__ volatile ("icbi 0,%0;" "dcbf 0,%0;" "sync;" "isync;"
+		    : : "r"(addr) : "memory");
 }
 #endif
 
 ffi_status
-ffi_prep_closure (ffi_closure* closure,
-		  ffi_cif* cif,
-		  void (*fun)(ffi_cif*, void*, void**, void*),
+ffi_prep_closure (ffi_closure *closure,
+		  ffi_cif *cif,
+		  void (*fun) (ffi_cif *, void *, void **, void *),
 		  void *user_data)
 {
 #ifdef POWERPC64
@@ -801,11 +877,11 @@
   tramp[7] = 0x816b0004;  /*   lwz     r11,4(r11) */
   tramp[8] = 0x7c0903a6;  /*   mtctr   r0 */
   tramp[9] = 0x4e800420;  /*   bctr */
-  *(void **) &tramp[2] = (void *)ffi_closure_SYSV; /* function */
-  *(void **) &tramp[3] = (void *)closure;          /* context */
+  *(void **) &tramp[2] = (void *) ffi_closure_SYSV; /* function */
+  *(void **) &tramp[3] = (void *) closure;          /* context */
 
   /* Flush the icache.  */
-  flush_icache(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);
+  flush_icache (&closure->tramp[0],FFI_TRAMPOLINE_SIZE);
 #endif
 
   closure->cif = cif;
@@ -821,8 +897,8 @@
   double d;
 } ffi_dblfl;
 
-int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*,
-			     ffi_dblfl*, unsigned long*);
+int ffi_closure_helper_SYSV (ffi_closure *, void *, unsigned long *,
+			     ffi_dblfl *, unsigned long *);
 
 /* Basically the trampoline invokes ffi_closure_SYSV, and on
  * entry, r11 holds the address of the closure.
@@ -833,9 +909,9 @@
  */
 
 int
-ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,
-			 unsigned long * pgr, ffi_dblfl * pfr,
-			 unsigned long * pst)
+ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,
+			 unsigned long *pgr, ffi_dblfl *pfr,
+			 unsigned long *pst)
 {
   /* rvalue is the pointer to space for return value in closure assembly */
   /* pgr is the pointer to where r3-r10 are stored in ffi_closure_SYSV */
@@ -852,7 +928,7 @@
   unsigned         size;
 
   cif = closure->cif;
-  avalue = alloca(cif->nargs * sizeof(void *));
+  avalue = alloca (cif->nargs * sizeof (void *));
   size = cif->rtype->size;
 
   nf = 0;
@@ -863,13 +939,17 @@
      For FFI_SYSV the result is passed in r3/r4 if the struct size is less
      or equal 8 bytes.  */
 
-  if (cif->rtype->type == FFI_TYPE_STRUCT)
+  if ((cif->rtype->type == FFI_TYPE_STRUCT
+       && !((cif->abi == FFI_SYSV) && (size <= 8)))
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+      || (cif->rtype->type == FFI_TYPE_LONGDOUBLE
+	  && cif->abi != FFI_LINUX)
+#endif
+      )
     {
-      if (!((cif->abi == FFI_SYSV) && (size <= 8))) {
-	rvalue = (void *) *pgr;
-	ng++;
-	pgr++;
-      }
+      rvalue = (void *) *pgr;
+      ng++;
+      pgr++;
     }
 
   i = 0;
@@ -884,54 +964,69 @@
 	case FFI_TYPE_SINT8:
 	case FFI_TYPE_UINT8:
 	  /* there are 8 gpr registers used to pass values */
-	  if (ng < 8) {
-	    avalue[i] = (((char *)pgr)+3);
-	    ng++;
-	    pgr++;
-	  } else {
-	    avalue[i] = (((char *)pst)+3);
-	    pst++;
-	  }
+	  if (ng < 8)
+	    {
+	      avalue[i] = (char *) pgr + 3;
+	      ng++;
+	      pgr++;
+	    }
+	  else
+	    {
+	      avalue[i] = (char *) pst + 3;
+	      pst++;
+	    }
 	  break;
 
 	case FFI_TYPE_SINT16:
 	case FFI_TYPE_UINT16:
 	  /* there are 8 gpr registers used to pass values */
-	  if (ng < 8) {
-	    avalue[i] = (((char *)pgr)+2);
-	    ng++;
-	    pgr++;
-	  } else {
-	    avalue[i] = (((char *)pst)+2);
-	    pst++;
-	  }
+	  if (ng < 8)
+	    {
+	      avalue[i] = (char *) pgr + 2;
+	      ng++;
+	      pgr++;
+	    }
+	  else
+	    {
+	      avalue[i] = (char *) pst + 2;
+	      pst++;
+	    }
 	  break;
 
 	case FFI_TYPE_SINT32:
 	case FFI_TYPE_UINT32:
 	case FFI_TYPE_POINTER:
 	  /* there are 8 gpr registers used to pass values */
-	  if (ng < 8) {
-	    avalue[i] = pgr;
-	    ng++;
-	    pgr++;
-	  } else {
-	    avalue[i] = pst;
-	    pst++;
-	  }
+	  if (ng < 8)
+	    {
+	      avalue[i] = pgr;
+	      ng++;
+	      pgr++;
+	    }
+	  else
+	    {
+	      avalue[i] = pst;
+	      pst++;
+	    }
 	  break;
 
 	case FFI_TYPE_STRUCT:
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	do_struct:
+#endif
 	  /* Structs are passed by reference. The address will appear in a
 	     gpr if it is one of the first 8 arguments.  */
-	  if (ng < 8) {
-	    avalue[i] = (void *) *pgr;
-	    ng++;
-	    pgr++;
-	  } else {
-	    avalue[i] = (void *) *pst;
-	    pst++;
-	  }
+	  if (ng < 8)
+	    {
+	      avalue[i] = (void *) *pgr;
+	      ng++;
+	      pgr++;
+	    }
+	  else
+	    {
+	      avalue[i] = (void *) *pst;
+	      pst++;
+	    }
 	  break;
 
 	case FFI_TYPE_SINT64:
@@ -945,20 +1040,25 @@
 	   * or pst to find the correct address for this type
 	   * of parameter.
 	   */
-	  if (ng < 7) {
-	    if (ng & 0x01) {
-	      /* skip r4, r6, r8 as starting points */
-	      ng++;
-	      pgr++;
+	  if (ng < 7)
+	    {
+	      if (ng & 0x01)
+		{
+		  /* skip r4, r6, r8 as starting points */
+		  ng++;
+		  pgr++;
+		}
+	      avalue[i] = pgr;
+	      ng += 2;
+	      pgr += 2;
+	    }
+	  else
+	    {
+	      if (((long) pst) & 4)
+		pst++;
+	      avalue[i] = pst;
+	      pst += 2;
 	    }
-	    avalue[i] = pgr;
-	    ng+=2;
-	    pgr+=2;
-	  } else {
-	    if (((long)pst) & 4) pst++;
-	    avalue[i] = pst;
-	    pst+=2;
-	  }
 	  break;
 
 	case FFI_TYPE_FLOAT:
@@ -969,42 +1069,69 @@
 
 	  /* there are 8 64bit floating point registers */
 
-	  if (nf < 8) {
-	    temp = pfr->d;
-	    pfr->f = (float)temp;
-	    avalue[i] = pfr;
-	    nf++;
-	    pfr++;
-	  } else {
-	    /* FIXME? here we are really changing the values
-	     * stored in the original calling routines outgoing
-	     * parameter stack.  This is probably a really
-	     * naughty thing to do but...
-	     */
-	    avalue[i] = pst;
-	    nf++;
-	    pst+=1;
-	  }
+	  if (nf < 8)
+	    {
+	      temp = pfr->d;
+	      pfr->f = (float) temp;
+	      avalue[i] = pfr;
+	      nf++;
+	      pfr++;
+	    }
+	  else
+	    {
+	      /* FIXME? here we are really changing the values
+	       * stored in the original calling routines outgoing
+	       * parameter stack.  This is probably a really
+	       * naughty thing to do but...
+	       */
+	      avalue[i] = pst;
+	      pst += 1;
+	    }
 	  break;
 
 	case FFI_TYPE_DOUBLE:
 	  /* On the outgoing stack all values are aligned to 8 */
 	  /* there are 8 64bit floating point registers */
 
-	  if (nf < 8) {
-	    avalue[i] = pfr;
-	    nf++;
-	    pfr++;
-	  } else {
-	    if (((long)pst) & 4) pst++;
-	    avalue[i] = pst;
-	    nf++;
-	    pst+=2;
-	  }
+	  if (nf < 8)
+	    {
+	      avalue[i] = pfr;
+	      nf++;
+	      pfr++;
+	    }
+	  else
+	    {
+	      if (((long) pst) & 4)
+		pst++;
+	      avalue[i] = pst;
+	      pst += 2;
+	    }
 	  break;
 
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  if (cif->abi != FFI_LINUX)
+	    goto do_struct;
+
+	  if (nf < 7)
+	    {
+	      avalue[i] = pfr;
+	      pfr += 2;
+	      nf += 2;
+	    }
+	  else
+	    {
+	      if (((long) pst) & 4)
+		pst++;
+	      avalue[i] = pst;
+	      pst += 4;
+	      nf = 8;
+	    }
+	  break;
+#endif
+
 	default:
-	  FFI_ASSERT(0);
+	  FFI_ASSERT (0);
 	}
 
       i++;
@@ -1019,12 +1146,16 @@
   if (cif->abi == FFI_SYSV && cif->rtype->type == FFI_TYPE_STRUCT
       && size <= 8)
     return FFI_SYSV_TYPE_SMALL_STRUCT + size;
+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+  else if (cif->rtype->type == FFI_TYPE_LONGDOUBLE
+	   && cif->abi != FFI_LINUX)
+    return FFI_TYPE_STRUCT;
+#endif
   return cif->rtype->type;
-
 }
 
-int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure*, void*, unsigned long*,
-					   ffi_dblfl*);
+int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,
+					   unsigned long *, ffi_dblfl *);
 
 int FFI_HIDDEN
 ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,
@@ -1153,7 +1284,7 @@
 #endif
 
 	default:
-	  FFI_ASSERT(0);
+	  FFI_ASSERT (0);
 	}
 
       i++;
diff -urN old/libffi/src/powerpc/ffi_darwin.c src/libffi/src/powerpc/ffi_darwin.c
--- old/libffi/src/powerpc/ffi_darwin.c	2004-09-02 21:14:45.000000000 +0000
+++ src/libffi/src/powerpc/ffi_darwin.c	2006-08-03 21:47:14.287169256 +0000
@@ -79,9 +79,7 @@
 
    */
 
-/*@-exportheader@*/
 void ffi_prep_args(extended_cif *ecif, unsigned *const stack)
-/*@=exportheader@*/
 {
   const unsigned bytes = ecif->cif->bytes;
   const unsigned flags = ecif->cif->flags;
@@ -375,25 +373,12 @@
   return FFI_OK;
 }
 
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_AIX(/*@out@*/ extended_cif *,
-			 unsigned, unsigned,
-			 /*@out@*/ unsigned *,
-			 void (*fn)(),
-			 void (*fn2)());
-extern void ffi_call_DARWIN(/*@out@*/ extended_cif *,
-			    unsigned, unsigned,
-			    /*@out@*/ unsigned *,
-			    void (*fn)(),
-			    void (*fn2)());
-/*@=declundef@*/
-/*@=exportheader@*/
-
-void ffi_call(/*@dependent@*/ ffi_cif *cif,
-	      void (*fn)(),
-	      /*@out@*/ void *rvalue,
-	      /*@dependent@*/ void **avalue)
+extern void ffi_call_AIX(extended_cif *, unsigned, unsigned, unsigned *,
+			 void (*fn)(), void (*fn2)());
+extern void ffi_call_DARWIN(extended_cif *, unsigned, unsigned, unsigned *,
+			    void (*fn)(), void (*fn2)());
+
+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
   extended_cif ecif;
 
@@ -406,9 +391,7 @@
   if ((rvalue == NULL) &&
       (cif->rtype->type == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca(cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;
@@ -416,16 +399,12 @@
   switch (cif->abi)
     {
     case FFI_AIX:
-      /*@-usedef@*/
-      ffi_call_AIX(&ecif, -cif->bytes,
-		   cif->flags, ecif.rvalue, fn, ffi_prep_args);
-      /*@=usedef@*/
+      ffi_call_AIX(&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn,
+		   ffi_prep_args);
       break;
     case FFI_DARWIN:
-      /*@-usedef@*/
-      ffi_call_DARWIN(&ecif, -cif->bytes,
-		      cif->flags, ecif.rvalue, fn, ffi_prep_args);
-      /*@=usedef@*/
+      ffi_call_DARWIN(&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn,
+		      ffi_prep_args);
       break;
     default:
       FFI_ASSERT(0);
diff -urN old/libffi/src/powerpc/ffitarget.h src/libffi/src/powerpc/ffitarget.h
--- old/libffi/src/powerpc/ffitarget.h	2005-07-19 21:15:36.000000000 +0000
+++ src/libffi/src/powerpc/ffitarget.h	2006-08-03 21:47:14.282170016 +0000
@@ -43,10 +43,15 @@
   FFI_SYSV,
   FFI_GCC_SYSV,
   FFI_LINUX64,
+  FFI_LINUX,
 # ifdef POWERPC64
   FFI_DEFAULT_ABI = FFI_LINUX64,
 # else
+#  if __LDBL_MANT_DIG__ == 106
+  FFI_DEFAULT_ABI = FFI_LINUX,
+#  else
   FFI_DEFAULT_ABI = FFI_GCC_SYSV,
+#  endif
 # endif
 #endif
 
@@ -69,7 +74,7 @@
   FFI_DEFAULT_ABI = FFI_SYSV,
 #endif
 
-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1
+  FFI_LAST_ABI
 } ffi_abi;
 #endif
 
diff -urN old/libffi/src/powerpc/linux64.S src/libffi/src/powerpc/linux64.S
--- old/libffi/src/powerpc/linux64.S	2005-09-26 19:56:22.000000000 +0000
+++ src/libffi/src/powerpc/linux64.S	2006-08-03 21:47:14.290168800 +0000
@@ -120,12 +120,9 @@
 	blr
 
 .Lfp_return_value:
-	bt	27, .Lfd_return_value
 	bf	28, .Lfloat_return_value
 	stfd	%f1, 0(%r30)
-	b	.Ldone_return_value
-.Lfd_return_value:
-	stfd	%f1, 0(%r30)
+	bf	27, .Ldone_return_value
 	stfd	%f2, 8(%r30)
 	b	.Ldone_return_value
 .Lfloat_return_value:
diff -urN old/libffi/src/powerpc/ppc_closure.S src/libffi/src/powerpc/ppc_closure.S
--- old/libffi/src/powerpc/ppc_closure.S	2006-01-18 08:06:25.000000000 +0000
+++ src/libffi/src/powerpc/ppc_closure.S	2006-08-03 21:47:14.280170320 +0000
@@ -58,218 +58,178 @@
 
 	# make the call
 	bl ffi_closure_helper_SYSV@local
-
+.Lret:
 	# now r3 contains the return type
 	# so use it to look up in a table
 	# so we know how to deal with each type
 
 	# look up the proper starting point in table
 	# by using return type as offset
-	addi %r6,%r1,112   # get pointer to results area
-	bl .Lget_ret_type0_addr # get pointer to .Lret_type0 into LR
-	mflr %r4           # move to r4
-	slwi %r3,%r3,4     # now multiply return type by 16
-	add %r3,%r3,%r4    # add contents of table to table address
+
+	mflr %r4		# move address of .Lret to r4
+	slwi %r3,%r3,4		# now multiply return type by 16
+	addi %r4, %r4, .Lret_type0 - .Lret
+	lwz %r0,148(%r1)
+	add %r3,%r3,%r4		# add contents of table to table address
 	mtctr %r3
-	bctr               # jump to it
+	bctr			# jump to it
 .LFE1:
 
 # Each of the ret_typeX code fragments has to be exactly 16 bytes long
 # (4 instructions). For cache effectiveness we align to a 16 byte boundary
 # first.
 	.align 4
-
-	nop
-	nop
-	nop
-.Lget_ret_type0_addr:
-	blrl
-
 # case FFI_TYPE_VOID
 .Lret_type0:
-	b .Lfinish
-	nop
-	nop
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 	nop
 
 # case FFI_TYPE_INT
-.Lret_type1:
-	lwz %r3,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+.Lfinish:
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_FLOAT
-.Lret_type2:
-	lfs %f1,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lfs %f1,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_DOUBLE
-.Lret_type3:
-	lfd %f1,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lfd %f1,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_LONGDOUBLE
-.Lret_type4:
-	lfd %f1,0(%r6)
+	lfd %f1,112+0(%r1)
+	lfd %f2,112+8(%r1)
+	mtlr %r0
 	b .Lfinish
-	nop
-	nop
 
 # case FFI_TYPE_UINT8
-.Lret_type5:
-	lbz %r3,3(%r6)
-	b .Lfinish
-	nop
-	nop
+	lbz %r3,112+3(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_SINT8
-.Lret_type6:
-	lbz %r3,3(%r6)
+	lbz %r3,112+3(%r1)
 	extsb %r3,%r3
+	mtlr %r0
 	b .Lfinish
-	nop
 
 # case FFI_TYPE_UINT16
-.Lret_type7:
-	lhz %r3,2(%r6)
-	b .Lfinish
-	nop
-	nop
+	lhz %r3,112+2(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_SINT16
-.Lret_type8:
-	lha %r3,2(%r6)
-	b .Lfinish
-	nop
-	nop
+	lha %r3,112+2(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_UINT32
-.Lret_type9:
-	lwz %r3,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_SINT32
-.Lret_type10:
-	lwz %r3,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_TYPE_UINT64
-.Lret_type11:
-	lwz %r3,0(%r6)
-	lwz %r4,4(%r6)
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+	mtlr %r0
 	b .Lfinish
-	nop
 
 # case FFI_TYPE_SINT64
-.Lret_type12:
-	lwz %r3,0(%r6)
-	lwz %r4,4(%r6)
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+	mtlr %r0
 	b .Lfinish
-	nop
 
 # case FFI_TYPE_STRUCT
-.Lret_type13:
-	b .Lfinish
-	nop
-	nop
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 	nop
 
 # case FFI_TYPE_POINTER
-.Lret_type14:
-	lwz %r3,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # The return types below are only used when the ABI type is FFI_SYSV.
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 1. One byte struct.
-.Lret_type15:
-# fall through.
-	lbz %r3,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lbz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 2. Two byte struct.
-.Lret_type16:
-# fall through.
-	lhz %r3,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lhz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 3. Three byte struct.
-.Lret_type17:
-# fall through.
-	lwz %r3,0(%r6)
+	lwz %r3,112+0(%r1)
 	srwi %r3,%r3,8
+	mtlr %r0
 	b .Lfinish
-	nop
 
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 4. Four byte struct.
-.Lret_type18:
-# this one handles the structs from above too.
-	lwz %r3,0(%r6)
-	b .Lfinish
-	nop
-	nop
+	lwz %r3,112+0(%r1)
+	mtlr %r0
+	addi %r1,%r1,144
+	blr
 
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 5. Five byte struct.
-.Lret_type19:
-# fall through.
-	lwz %r3,0(%r6)
-	lwz %r4,4(%r6)
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
 	li %r5,24
 	b .Lstruct567
 
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 6. Six byte struct.
-.Lret_type20:
-# fall through.
-	lwz %r3,0(%r6)
-	lwz %r4,4(%r6)
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
 	li %r5,16
 	b .Lstruct567
 
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 7. Seven byte struct.
-.Lret_type21:
-# fall through.
-	lwz %r3,0(%r6)
-	lwz %r4,4(%r6)
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
 	li %r5,8
 	b .Lstruct567
 
 # case FFI_SYSV_TYPE_SMALL_STRUCT + 8. Eight byte struct.
-.Lret_type22:
-# this one handles the above unhandled structs.
-	lwz %r3,0(%r6)
-	lwz %r4,4(%r6)
+	lwz %r3,112+0(%r1)
+	lwz %r4,112+4(%r1)
+	mtlr %r0
 	b .Lfinish
-	nop
 
-# case done
-.Lfinish:
-
-	lwz %r0,148(%r1)
+.Lstruct567:
+	subfic %r6,%r5,32
+	srw %r4,%r4,%r5
+	slw %r6,%r3,%r6
+	srw %r3,%r3,%r5
+	or %r4,%r6,%r4
 	mtlr %r0
 	addi %r1,%r1,144
 	blr
 
-.Lstruct567:
-	subfic %r0,%r5,32
-	srw %r4,%r4,%r5
-	slw %r0,%r3,%r0
-	srw %r3,%r3,%r5
-	or %r4,%r0,%r4
-	b .Lfinish
 END(ffi_closure_SYSV)
 
 	.section	".eh_frame",EH_FRAME_FLAGS,@progbits
diff -urN old/libffi/src/powerpc/sysv.S src/libffi/src/powerpc/sysv.S
--- old/libffi/src/powerpc/sysv.S	2006-01-18 08:06:25.000000000 +0000
+++ src/libffi/src/powerpc/sysv.S	2006-08-03 21:47:14.285169560 +0000
@@ -121,6 +121,8 @@
 L(fp_return_value):
 	bf	28,L(float_return_value)
 	stfd	%f1,0(%r30)
+	bf	27,L(done_return_value)
+	stfd	%f2,8(%r30)
 	b	L(done_return_value)
 L(float_return_value):
 	stfs	%f1,0(%r30)
diff -urN old/libffi/src/prep_cif.c src/libffi/src/prep_cif.c
--- old/libffi/src/prep_cif.c	2005-04-18 17:08:58.000000000 +0000
+++ src/libffi/src/prep_cif.c	2006-08-03 21:47:14.467141896 +0000
@@ -25,7 +25,6 @@
 #include <ffi_common.h>
 #include <stdlib.h>
 
-
 /* Round up to FFI_SIZEOF_ARG. */
 
 #define STACK_ARG_SIZE(x) ALIGN(x, FFI_SIZEOF_ARG)
@@ -33,14 +32,12 @@
 /* Perform machine independent initialization of aggregate type
    specifications. */
 
-static ffi_status initialize_aggregate(/*@out@*/ ffi_type *arg)
+static ffi_status initialize_aggregate(ffi_type *arg)
 {
-  ffi_type **ptr; 
+  ffi_type **ptr;
 
   FFI_ASSERT(arg != NULL);
 
-  /*@-usedef@*/
-
   FFI_ASSERT(arg->elements != NULL);
   FFI_ASSERT(arg->size == 0);
   FFI_ASSERT(arg->alignment == 0);
@@ -51,14 +48,14 @@
     {
       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))
 	return FFI_BAD_TYPEDEF;
-      
+
       /* Perform a sanity check on the argument type */
       FFI_ASSERT_VALID_TYPE(*ptr);
 
       arg->size = ALIGN(arg->size, (*ptr)->alignment);
       arg->size += (*ptr)->size;
 
-      arg->alignment = (arg->alignment > (*ptr)->alignment) ? 
+      arg->alignment = (arg->alignment > (*ptr)->alignment) ?
 	arg->alignment : (*ptr)->alignment;
 
       ptr++;
@@ -77,8 +74,6 @@
     return FFI_BAD_TYPEDEF;
   else
     return FFI_OK;
-
-  /*@=usedef@*/
 }
 
 #ifndef __CRIS__
@@ -89,10 +84,8 @@
 /* Perform machine independent ffi_cif preparation, then call
    machine dependent routine. */
 
-ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif, 
-			ffi_abi abi, unsigned int nargs, 
-			/*@dependent@*/ /*@out@*/ /*@partial@*/ ffi_type *rtype, 
-			/*@dependent@*/ ffi_type **atypes)
+ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,
+			ffi_type *rtype, ffi_type **atypes)
 {
   unsigned bytes = 0;
   unsigned int i;
@@ -109,10 +102,8 @@
   cif->flags = 0;
 
   /* Initialize the return type if necessary */
-  /*@-usedef@*/
   if ((cif->rtype->size == 0) && (initialize_aggregate(cif->rtype) != FFI_OK))
     return FFI_BAD_TYPEDEF;
-  /*@=usedef@*/
 
   /* Perform a sanity check on the return type */
   FFI_ASSERT_VALID_TYPE(cif->rtype);
@@ -135,7 +126,7 @@
       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))
 	return FFI_BAD_TYPEDEF;
 
-      /* Perform a sanity check on the argument type, do this 
+      /* Perform a sanity check on the argument type, do this
 	 check after the initialization.  */
       FFI_ASSERT_VALID_TYPE(*ptr);
 
@@ -152,7 +143,7 @@
 	  /* Add any padding if necessary */
 	  if (((*ptr)->alignment - 1) & bytes)
 	    bytes = ALIGN(bytes, (*ptr)->alignment);
-	  
+
 	  bytes += STACK_ARG_SIZE((*ptr)->size);
 	}
 #endif
diff -urN old/libffi/src/raw_api.c src/libffi/src/raw_api.c
--- old/libffi/src/raw_api.c	2003-10-21 19:01:58.000000000 +0000
+++ src/libffi/src/raw_api.c	2006-08-03 21:47:14.461142808 +0000
@@ -189,10 +189,7 @@
  * these following couple of functions will handle the translation forth
  * and back automatically. */
 
-void ffi_raw_call (/*@dependent@*/ ffi_cif *cif, 
-		   void (*fn)(), 
-		   /*@out@*/ void *rvalue, 
-		   /*@dependent@*/ ffi_raw *raw)
+void ffi_raw_call (ffi_cif *cif, void (*fn)(), void *rvalue, ffi_raw *raw)
 {
   void **avalue = (void**) alloca (cif->nargs * sizeof (void*));
   ffi_raw_to_ptrarray (cif, raw, avalue);
@@ -201,7 +198,7 @@
 
 #if FFI_CLOSURES		/* base system provides closures */
 
-static void 
+static void
 ffi_translate_args (ffi_cif *cif, void *rvalue,
 		    void **avalue, void *user_data)
 {
@@ -224,7 +221,7 @@
 {
   ffi_status status;
 
-  status = ffi_prep_closure ((ffi_closure*) cl, 
+  status = ffi_prep_closure ((ffi_closure*) cl,
 			     cif,
 			     &ffi_translate_args,
 			     (void*)cl);
diff -urN old/libffi/src/sh/ffi.c src/libffi/src/sh/ffi.c
--- old/libffi/src/sh/ffi.c	2005-07-22 22:56:27.000000000 +0000
+++ src/libffi/src/sh/ffi.c	2006-08-03 21:47:14.468141744 +0000
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   ffi.c - Copyright (c) 2002, 2003, 2004, 2005 Kaz Kojima
+   ffi.c - Copyright (c) 2002, 2003, 2004, 2005, 2006 Kaz Kojima
    
    SuperH Foreign Function Interface 
 
@@ -106,9 +106,7 @@
 /* ffi_prep_args is called by the assembly routine once stack space
    has been allocated for the function's arguments */
 
-/*@-exportheader@*/
 void ffi_prep_args(char *stack, extended_cif *ecif)
-/*@=exportheader@*/
 {
   register unsigned int i;
   register int tmp;
@@ -406,20 +404,10 @@
   return FFI_OK;
 }
 
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), 
-			  /*@out@*/ extended_cif *, 
-			  unsigned, unsigned, 
-			  /*@out@*/ unsigned *, 
-			  void (*fn)());
-/*@=declundef@*/
-/*@=exportheader@*/
-
-void ffi_call(/*@dependent@*/ ffi_cif *cif, 
-	      void (*fn)(), 
-	      /*@out@*/ void *rvalue, 
-	      /*@dependent@*/ void **avalue)
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, unsigned *, void (*fn)());
+
+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
   extended_cif ecif;
   UINT64 trvalue;
@@ -436,9 +424,7 @@
   else if ((rvalue == NULL) && 
       (cif->rtype->type == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca(cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;
@@ -446,10 +432,8 @@
   switch (cif->abi) 
     {
     case FFI_SYSV:
-      /*@-usedef@*/
-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, 
-		    cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
+		    fn);
       break;
     default:
       FFI_ASSERT(0);
@@ -535,7 +519,6 @@
   int freg = 0;
 #endif
   ffi_cif *cif; 
-  double temp; 
 
   cif = closure->cif;
   avalue = alloca(cif->nargs * sizeof(void *));
@@ -544,7 +527,7 @@
      returns the data directly to the caller.  */
   if (cif->rtype->type == FFI_TYPE_STRUCT && STRUCT_VALUE_ADDRESS_WITH_ARG)
     {
-      rvalue = *pgr++;
+      rvalue = (void *) *pgr++;
       ireg = 1;
     }
   else
@@ -611,6 +594,8 @@
 	{
 	  if (freg + 1 >= NFREGARG)
 	    continue;
+	  if (freg & 1)
+	    pfr++;
 	  freg = (freg + 1) & ~1;
 	  freg += 2;
 	  avalue[i] = pfr;
diff -urN old/libffi/src/sh/sysv.S src/libffi/src/sh/sysv.S
--- old/libffi/src/sh/sysv.S	2005-07-22 22:56:27.000000000 +0000
+++ src/libffi/src/sh/sysv.S	2006-08-03 21:47:14.470141440 +0000
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   sysv.S - Copyright (c) 2002, 2003, 2004 Kaz Kojima
+   sysv.S - Copyright (c) 2002, 2003, 2004, 2006 Kaz Kojima
    
    SuperH Foreign Function Interface 
 
@@ -829,13 +829,13 @@
 	.byte	0x6	/* uleb128 0x6 */
 	.byte	0x8e	/* DW_CFA_offset, column 0xe */
 	.byte	0x5	/* uleb128 0x5 */
-	.byte	0x8b	/* DW_CFA_offset, column 0xb */
+	.byte	0x84	/* DW_CFA_offset, column 0x4 */
 	.byte	0x4	/* uleb128 0x4 */
-	.byte	0x8a	/* DW_CFA_offset, column 0xa */
+	.byte	0x85	/* DW_CFA_offset, column 0x5 */
 	.byte	0x3	/* uleb128 0x3 */
-	.byte	0x89	/* DW_CFA_offset, column 0x9 */
+	.byte	0x86	/* DW_CFA_offset, column 0x6 */
 	.byte	0x2	/* uleb128 0x2 */
-	.byte	0x88	/* DW_CFA_offset, column 0x8 */
+	.byte	0x87	/* DW_CFA_offset, column 0x7 */
 	.byte	0x1	/* uleb128 0x1 */
 	.byte	0x4	/* DW_CFA_advance_loc4 */
 	.4byte	.LCFIE-.LCFID
diff -urN old/libffi/src/sh64/ffi.c src/libffi/src/sh64/ffi.c
--- old/libffi/src/sh64/ffi.c	2005-07-20 23:32:01.000000000 +0000
+++ src/libffi/src/sh64/ffi.c	2006-08-03 21:47:14.458143264 +0000
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   ffi.c - Copyright (c) 2003, 2004 Kaz Kojima
+   ffi.c - Copyright (c) 2003, 2004, 2006 Kaz Kojima
    
    SuperH SHmedia Foreign Function Interface 
 
@@ -54,9 +54,7 @@
 /* ffi_prep_args is called by the assembly routine once stack space
    has been allocated for the function's arguments */
 
-/*@-exportheader@*/
 void ffi_prep_args(char *stack, extended_cif *ecif)
-/*@=exportheader@*/
 {
   register unsigned int i;
   register unsigned int avn;
@@ -160,6 +158,7 @@
   int n, m;
   int greg;
   int freg;
+  int fpair = -1;
 
   greg = (return_type (cif->rtype) == FFI_TYPE_STRUCT ? 1 : 0);
   freg = 0;
@@ -175,7 +174,13 @@
 	  cif->bytes += sizeof (UINT64) - sizeof (float);
 	  if (freg >= NFREGARG - 1)
 	    continue;
-	  freg++;
+	  if (fpair < 0)
+	    {
+	      fpair = freg;
+	      freg += 2;
+	    }
+	  else
+	    fpair = -1;
 	  cif->flags2 += ((cif->arg_types)[i]->type) << (2 * j++);
 	  break;
 
@@ -184,7 +189,6 @@
 	    continue;
 	  if ((freg + 1) < NFREGARG)
 	    {
-	      freg = (freg + 1) & ~1;
 	      freg += 2;
 	      cif->flags2 += ((cif->arg_types)[i]->type) << (2 * j++);
 	    }
@@ -232,20 +236,11 @@
   return FFI_OK;
 }
 
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), 
-			  /*@out@*/ extended_cif *, 
-			  unsigned, unsigned, long long,
-			  /*@out@*/ unsigned *, 
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, long long, unsigned *,
 			  void (*fn)());
-/*@=declundef@*/
-/*@=exportheader@*/
 
-void ffi_call(/*@dependent@*/ ffi_cif *cif, 
-	      void (*fn)(), 
-	      /*@out@*/ void *rvalue, 
-	      /*@dependent@*/ void **avalue)
+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
   extended_cif ecif;
   UINT64 trvalue;
@@ -262,9 +257,7 @@
   else if ((rvalue == NULL) && 
       (cif->rtype->type == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca(cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;
@@ -272,10 +265,8 @@
   switch (cif->abi) 
     {
     case FFI_SYSV:
-      /*@-usedef@*/
-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, 
-		    cif->flags, cif->flags2, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, cif->flags2,
+		    ecif.rvalue, fn);
       break;
     default:
       FFI_ASSERT(0);
@@ -350,6 +341,7 @@
   int i, avn;
   int greg, freg;
   ffi_cif *cif;
+  int fpair = -1;
 
   cif = closure->cif;
   avalue = alloca (cif->nargs * sizeof (void *));
@@ -358,7 +350,7 @@
      returns the data directly to the caller.  */
   if (return_type (cif->rtype) == FFI_TYPE_STRUCT)
     {
-      rvalue = *pgr;
+      rvalue = (UINT64 *) *pgr;
       greg = 1;
     }
   else
@@ -402,11 +394,24 @@
 	  if ((*p_arg)->type == FFI_TYPE_FLOAT)
 	    {
 	      if (freg < NFREGARG - 1)
+		{
+		  if (fpair >= 0)
+		    {
+		      avalue[i] = (UINT32 *) pfr + fpair;
+		      fpair = -1;
+		    }
+		  else
+		    {
 #ifdef __LITTLE_ENDIAN__
-		avalue[i] = (UINT32 *) pfr + (1 ^ freg++);
+		      fpair = freg;
+		      avalue[i] = (UINT32 *) pfr + (1 ^ freg);
 #else
-		avalue[i] = (UINT32 *) pfr + freg++;
+		      fpair = 1 ^ freg;
+		      avalue[i] = (UINT32 *) pfr + freg;
 #endif
+		      freg += 2;
+		    }
+		}
 	      else
 #ifdef __LITTLE_ENDIAN__
 		avalue[i] = pgr + greg;
@@ -428,7 +433,6 @@
 	    avalue[i] = pgr + greg;
 	  else
 	    {
-	      freg = (freg + 1) & ~1;
 	      avalue[i] = pfr + (freg >> 1);
 	      freg += 2;
 	    }
diff -urN old/libffi/src/sh64/sysv.S src/libffi/src/sh64/sysv.S
--- old/libffi/src/sh64/sysv.S	2005-07-20 23:32:01.000000000 +0000
+++ src/libffi/src/sh64/sysv.S	2006-08-03 21:47:14.459143112 +0000
@@ -1,5 +1,5 @@
 /* -----------------------------------------------------------------------
-   sysv.S - Copyright (c) 2003, 2004 Kaz Kojima
+   sysv.S - Copyright (c) 2003, 2004, 2006 Kaz Kojima
    
    SuperH SHmedia Foreign Function Interface 
 
@@ -84,6 +84,7 @@
 	addi	r15, 64, r22
 	movi	0, r0
 	movi	0, r1
+	movi	-1, r23
 
 	pt/l	1f, tr1
 	bnei/l	r29, FFI_TYPE_STRUCT, tr1
@@ -106,9 +107,6 @@
 
 .L_pass_d:
 	addi	r0, 1, r0
-	addi	r1, 1, r1
-	andi	r1, ~1, r1
-
 	pt/l	3f, tr0
 	movi	12, r20
 	bge/l	r1, r20, tr0
@@ -158,13 +156,23 @@
 	addi.l	r15, 8, r15
 3:
 	pt/l	.L_pass, tr0
-	addi	r1, 1, r1
 	blink	tr0, r63
 
 .L_pop_f:
 	pt/l	.L_pop_f_tbl, tr1
+	pt/l	5f, tr2
 	gettr	tr1, r20
+	bge/l	r23, r63, tr2
+	add	r1, r63, r23 
 	shlli	r1, 3, r21
+	addi	r1, 2, r1
+	add	r20, r21, r20
+	ptabs/l	r20, tr1
+	blink	tr1, r63
+5:
+	addi	r23, 1, r21
+	movi	-1, r23
+	shlli	r21, 3, r21
 	add	r20, r21, r20
 	ptabs/l	r20, tr1
 	blink	tr1, r63
diff -urN old/libffi/src/x86/ffi.c src/libffi/src/x86/ffi.c
--- old/libffi/src/x86/ffi.c	2005-08-11 21:18:24.000000000 +0000
+++ src/libffi/src/x86/ffi.c	2006-08-03 21:47:14.460142960 +0000
@@ -36,9 +36,7 @@
 /* ffi_prep_args is called by the assembly routine once stack space
    has been allocated for the function's arguments */
 
-/*@-exportheader@*/
 void ffi_prep_args(char *stack, extended_cif *ecif)
-/*@=exportheader@*/
 {
   register unsigned int i;
   register void **p_argv;
@@ -168,32 +166,16 @@
   return FFI_OK;
 }
 
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), 
-			  /*@out@*/ extended_cif *, 
-			  unsigned, unsigned, 
-			  /*@out@*/ unsigned *, 
-			  void (*fn)());
-/*@=declundef@*/
-/*@=exportheader@*/
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, unsigned *, void (*fn)());
 
 #ifdef X86_WIN32
-/*@-declundef@*/
-/*@-exportheader@*/
-extern void ffi_call_STDCALL(void (*)(char *, extended_cif *),
-			  /*@out@*/ extended_cif *,
-			  unsigned, unsigned,
-			  /*@out@*/ unsigned *,
-			  void (*fn)());
-/*@=declundef@*/
-/*@=exportheader@*/
+extern void ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *,
+			  unsigned, unsigned, unsigned *, void (*fn)());
+
 #endif /* X86_WIN32 */
 
-void ffi_call(/*@dependent@*/ ffi_cif *cif, 
-	      void (*fn)(), 
-	      /*@out@*/ void *rvalue, 
-	      /*@dependent@*/ void **avalue)
+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
   extended_cif ecif;
 
@@ -206,9 +188,7 @@
   if ((rvalue == NULL) && 
       (cif->flags == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca(cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;
@@ -217,17 +197,13 @@
   switch (cif->abi) 
     {
     case FFI_SYSV:
-      /*@-usedef@*/
-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, 
-		    cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
+		    fn);
       break;
 #ifdef X86_WIN32
     case FFI_STDCALL:
-      /*@-usedef@*/
-      ffi_call_STDCALL(ffi_prep_args, &ecif, cif->bytes,
-		    cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_STDCALL(ffi_prep_args, &ecif, cif->bytes, cif->flags,
+		       ecif.rvalue, fn);
       break;
 #endif /* X86_WIN32 */
     default:
@@ -276,11 +252,9 @@
   return cif->flags;
 }
 
-/*@-exportheader@*/
-static void 
-ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,
-			    void **avalue, ffi_cif *cif)
-/*@=exportheader@*/
+static void
+ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,
+			    ffi_cif *cif)
 {
   register unsigned int i;
   register void **p_argv;
@@ -400,27 +374,18 @@
  * libffi-1.20, this is not the case.)
  */
 
-extern void 
-ffi_call_SYSV(void (*)(char *, extended_cif *), 
-	      /*@out@*/ extended_cif *, 
-	      unsigned, unsigned, 
-	      /*@out@*/ unsigned *, 
-	      void (*fn)());
+extern void
+ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *, unsigned, 
+	      unsigned, unsigned *, void (*fn)());
 
 #ifdef X86_WIN32
 extern void
-ffi_call_STDCALL(void (*)(char *, extended_cif *),
-	      /*@out@*/ extended_cif *,
-	      unsigned, unsigned,
-	      /*@out@*/ unsigned *,
-	      void (*fn)());
+ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *, unsigned,
+		 unsigned, unsigned *, void (*fn)());
 #endif /* X86_WIN32 */
 
 void
-ffi_raw_call(/*@dependent@*/ ffi_cif *cif, 
-	     void (*fn)(), 
-	     /*@out@*/ void *rvalue, 
-	     /*@dependent@*/ ffi_raw *fake_avalue)
+ffi_raw_call(ffi_cif *cif, void (*fn)(), void *rvalue, ffi_raw *fake_avalue)
 {
   extended_cif ecif;
   void **avalue = (void **)fake_avalue;
@@ -434,9 +399,7 @@
   if ((rvalue == NULL) && 
       (cif->rtype->type == FFI_TYPE_STRUCT))
     {
-      /*@-sysunrecog@*/
       ecif.rvalue = alloca(cif->rtype->size);
-      /*@=sysunrecog@*/
     }
   else
     ecif.rvalue = rvalue;
@@ -445,17 +408,13 @@
   switch (cif->abi) 
     {
     case FFI_SYSV:
-      /*@-usedef@*/
-      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, 
-		    cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,
+		    ecif.rvalue, fn);
       break;
 #ifdef X86_WIN32
     case FFI_STDCALL:
-      /*@-usedef@*/
-      ffi_call_STDCALL(ffi_prep_args_raw, &ecif, cif->bytes,
-		    cif->flags, ecif.rvalue, fn);
-      /*@=usedef@*/
+      ffi_call_STDCALL(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,
+		       ecif.rvalue, fn);
       break;
 #endif /* X86_WIN32 */
     default:
diff -urN old/libffi/testsuite/Makefile.in src/libffi/testsuite/Makefile.in
--- old/libffi/testsuite/Makefile.in	2005-07-19 21:15:36.000000000 +0000
+++ src/libffi/testsuite/Makefile.in	2006-08-03 21:47:14.470141440 +0000
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.5 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -109,6 +109,8 @@
 MIPS_LINUX_FALSE = @MIPS_LINUX_FALSE@
 MIPS_LINUX_TRUE = @MIPS_LINUX_TRUE@
 OBJEXT = @OBJEXT@
+PA64_HPUX_FALSE = @PA64_HPUX_FALSE@
+PA64_HPUX_TRUE = @PA64_HPUX_TRUE@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
@@ -116,8 +118,10 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
-PA_FALSE = @PA_FALSE@
-PA_TRUE = @PA_TRUE@
+PA_HPUX_FALSE = @PA_HPUX_FALSE@
+PA_HPUX_TRUE = @PA_HPUX_TRUE@
+PA_LINUX_FALSE = @PA_LINUX_FALSE@
+PA_LINUX_TRUE = @PA_LINUX_TRUE@
 POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@
 POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@
 POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@
diff -urN old/libffi/testsuite/libffi.call/call.exp src/libffi/testsuite/libffi.call/call.exp
--- old/libffi/testsuite/libffi.call/call.exp	2003-09-04 14:49:22.000000000 +0000
+++ src/libffi/testsuite/libffi.call/call.exp	2006-08-03 21:47:15.152037776 +0000
@@ -1,18 +1,18 @@
-#   Copyright (C) 2003 Free Software Foundation, Inc.
+# Copyright (C) 2003, 2006 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
-# 
+#
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 
 # libffi testsuite that uses the 'dg.exp' driver.
 
@@ -23,7 +23,10 @@
 
 global srcdir subdir
 
-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] "" "" 
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] "-O0 -W -Wall" ""
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] "-O2" ""
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] "-O3" ""
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] "-Os" ""
 
 dg-finish
 
diff -urN old/libffi/testsuite/libffi.call/closure_fn0.c src/libffi/testsuite/libffi.call/closure_fn0.c
--- old/libffi/testsuite/libffi.call/closure_fn0.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/closure_fn0.c	2006-08-03 21:47:15.148038384 +0000
@@ -10,7 +10,8 @@
 #include "ffitest.h"
 
 static void
-closure_test_fn0(ffi_cif* cif,void* resp,void** args, void* userdata)
+closure_test_fn0(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
 {
   *(ffi_arg*)resp =
     (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +
diff -urN old/libffi/testsuite/libffi.call/closure_fn1.c src/libffi/testsuite/libffi.call/closure_fn1.c
--- old/libffi/testsuite/libffi.call/closure_fn1.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/closure_fn1.c	2006-08-03 21:47:14.749099032 +0000
@@ -10,7 +10,7 @@
 #include "ffitest.h"
 
 
-static void closure_test_fn1(ffi_cif* cif,void* resp,void** args,
+static void closure_test_fn1(ffi_cif* cif __UNUSED__, void* resp, void** args,
 			     void* userdata)
 {
   *(ffi_arg*)resp =
diff -urN old/libffi/testsuite/libffi.call/closure_fn2.c src/libffi/testsuite/libffi.call/closure_fn2.c
--- old/libffi/testsuite/libffi.call/closure_fn2.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/closure_fn2.c	2006-08-03 21:47:15.149038232 +0000
@@ -9,7 +9,7 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void closure_test_fn2(ffi_cif* cif,void* resp,void** args,
+static void closure_test_fn2(ffi_cif* cif __UNUSED__, void* resp, void** args,
 			     void* userdata)
 {
   *(ffi_arg*)resp =
diff -urN old/libffi/testsuite/libffi.call/closure_fn3.c src/libffi/testsuite/libffi.call/closure_fn3.c
--- old/libffi/testsuite/libffi.call/closure_fn3.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/closure_fn3.c	2006-08-03 21:47:14.752098576 +0000
@@ -9,7 +9,7 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void closure_test_fn3(ffi_cif* cif,void* resp,void** args,
+static void closure_test_fn3(ffi_cif* cif __UNUSED__, void* resp, void** args,
 			     void* userdata)
  {
    *(ffi_arg*)resp =
diff -urN old/libffi/testsuite/libffi.call/closure_fn4.c src/libffi/testsuite/libffi.call/closure_fn4.c
--- old/libffi/testsuite/libffi.call/closure_fn4.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/closure_fn4.c	2006-08-03 21:47:15.150038080 +0000
@@ -11,7 +11,8 @@
 #include "ffitest.h"
 
 static void
-closure_test_fn0(ffi_cif* cif,void* resp,void** args, void* userdata)
+closure_test_fn0(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
 {
   *(ffi_arg*)resp =
     (int)*(unsigned long long *)args[0] + (int)*(unsigned long long *)args[1] +
diff -urN old/libffi/testsuite/libffi.call/closure_fn5.c src/libffi/testsuite/libffi.call/closure_fn5.c
--- old/libffi/testsuite/libffi.call/closure_fn5.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/closure_fn5.c	2006-08-03 21:47:14.753098424 +0000
@@ -7,11 +7,11 @@
    Originator:	<andreast@gcc.gnu.org> 20031026	 */
 
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
-
 #include "ffitest.h"
 
 static void
-closure_test_fn5(ffi_cif* cif,void* resp,void** args, void* userdata)
+closure_test_fn5(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
 {
   *(ffi_arg*)resp =
     (int)*(unsigned long long *)args[0] + (int)*(unsigned long long *)args[1] +
diff -urN old/libffi/testsuite/libffi.call/cls_12byte.c src/libffi/testsuite/libffi.call/cls_12byte.c
--- old/libffi/testsuite/libffi.call/cls_12byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_12byte.c	2006-08-03 21:47:15.138039904 +0000
@@ -28,7 +28,8 @@
   return result;
 }
 
-static void cls_struct_12byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+static void cls_struct_12byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				 void** args , void* userdata __UNUSED__)
 {
   struct cls_struct_12byte b1, b2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_16byte.c src/libffi/testsuite/libffi.call/cls_16byte.c
--- old/libffi/testsuite/libffi.call/cls_16byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_16byte.c	2006-08-03 21:47:15.145038840 +0000
@@ -29,7 +29,8 @@
   return result;
 }
 
-static void cls_struct_16byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+static void cls_struct_16byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				 void** args, void* userdata __UNUSED__)
 {
   struct cls_struct_16byte b1, b2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_18byte.c src/libffi/testsuite/libffi.call/cls_18byte.c
--- old/libffi/testsuite/libffi.call/cls_18byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_18byte.c	2006-08-03 21:47:15.146038688 +0000
@@ -33,7 +33,8 @@
 }
 
 static void
-cls_struct_18byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_18byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
 {
   struct cls_struct_18byte a1, a2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_19byte.c src/libffi/testsuite/libffi.call/cls_19byte.c
--- old/libffi/testsuite/libffi.call/cls_19byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_19byte.c	2006-08-03 21:47:14.744099792 +0000
@@ -36,7 +36,8 @@
 }
 
 static void
-cls_struct_19byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_19byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
 {
   struct cls_struct_19byte a1, a2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_1_1byte.c src/libffi/testsuite/libffi.call/cls_1_1byte.c
--- old/libffi/testsuite/libffi.call/cls_1_1byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_1_1byte.c	2006-08-03 21:47:15.138039904 +0000
@@ -26,7 +26,8 @@
 }
 
 static void
-cls_struct_1_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_1_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		      void* userdata __UNUSED__)
 {
 
   struct cls_struct_1_1byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_20byte.c src/libffi/testsuite/libffi.call/cls_20byte.c
--- old/libffi/testsuite/libffi.call/cls_20byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_20byte.c	2006-08-03 21:47:14.954067872 +0000
@@ -29,7 +29,8 @@
 }
 
 static void
-cls_struct_20byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_20byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
 {
   struct cls_struct_20byte a1, a2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_20byte1.c src/libffi/testsuite/libffi.call/cls_20byte1.c
--- old/libffi/testsuite/libffi.call/cls_20byte1.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_20byte1.c	2006-08-03 21:47:14.654113472 +0000
@@ -29,7 +29,8 @@
 }
 
 static void
-cls_struct_20byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_20byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
 {
   struct cls_struct_20byte a1, a2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_24byte.c src/libffi/testsuite/libffi.call/cls_24byte.c
--- old/libffi/testsuite/libffi.call/cls_24byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_24byte.c	2006-08-03 21:47:14.957067416 +0000
@@ -38,7 +38,8 @@
 }
 
 static void
-cls_struct_24byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_24byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
 {
   struct cls_struct_24byte b0, b1, b2, b3;
 
diff -urN old/libffi/testsuite/libffi.call/cls_2byte.c src/libffi/testsuite/libffi.call/cls_2byte.c
--- old/libffi/testsuite/libffi.call/cls_2byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_2byte.c	2006-08-03 21:47:14.754098272 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_2byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_2byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_2byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_3_1byte.c src/libffi/testsuite/libffi.call/cls_3_1byte.c
--- old/libffi/testsuite/libffi.call/cls_3_1byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_3_1byte.c	2006-08-03 21:47:15.139039752 +0000
@@ -32,7 +32,8 @@
 }
 
 static void
-cls_struct_3_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_3_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		      void* userdata __UNUSED__)
 {
 
   struct cls_struct_3_1byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_3byte1.c src/libffi/testsuite/libffi.call/cls_3byte1.c
--- old/libffi/testsuite/libffi.call/cls_3byte1.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_3byte1.c	2006-08-03 21:47:15.140039600 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_3byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_3byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_3byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_3byte2.c src/libffi/testsuite/libffi.call/cls_3byte2.c
--- old/libffi/testsuite/libffi.call/cls_3byte2.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_3byte2.c	2006-08-03 21:47:14.742100096 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_3byte_gn1(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_3byte_gn1(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
 {
 
   struct cls_struct_3byte_1 a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_4_1byte.c src/libffi/testsuite/libffi.call/cls_4_1byte.c
--- old/libffi/testsuite/libffi.call/cls_4_1byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_4_1byte.c	2006-08-03 21:47:15.141039448 +0000
@@ -34,7 +34,8 @@
 }
 
 static void
-cls_struct_4_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_4_1byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		      void* userdata __UNUSED__)
 {
 
   struct cls_struct_4_1byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_4byte.c src/libffi/testsuite/libffi.call/cls_4byte.c
--- old/libffi/testsuite/libffi.call/cls_4byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_4byte.c	2006-08-03 21:47:14.760097360 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_4byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_4byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_4byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_5_1_byte.c src/libffi/testsuite/libffi.call/cls_5_1_byte.c
--- old/libffi/testsuite/libffi.call/cls_5_1_byte.c	2005-07-10 20:14:37.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_5_1_byte.c	2006-08-03 21:47:14.955067720 +0000
@@ -36,7 +36,8 @@
 }
 
 static void
-cls_struct_5byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_5byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_5byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_5byte.c src/libffi/testsuite/libffi.call/cls_5byte.c
--- old/libffi/testsuite/libffi.call/cls_5byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_5byte.c	2006-08-03 21:47:15.156037168 +0000
@@ -31,7 +31,8 @@
 }
 
 static void
-cls_struct_5byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_5byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_5byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_64byte.c src/libffi/testsuite/libffi.call/cls_64byte.c
--- old/libffi/testsuite/libffi.call/cls_64byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_64byte.c	2006-08-03 21:47:14.958067264 +0000
@@ -43,7 +43,8 @@
 }
 
 static void
-cls_struct_64byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_64byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		     void* userdata __UNUSED__)
 {
   struct cls_struct_64byte b0, b1, b2, b3;
 
diff -urN old/libffi/testsuite/libffi.call/cls_6_1_byte.c src/libffi/testsuite/libffi.call/cls_6_1_byte.c
--- old/libffi/testsuite/libffi.call/cls_6_1_byte.c	2005-07-10 20:14:37.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_6_1_byte.c	2006-08-03 21:47:15.142039296 +0000
@@ -38,7 +38,8 @@
 }
 
 static void
-cls_struct_6byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_6byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_6byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_6byte.c src/libffi/testsuite/libffi.call/cls_6byte.c
--- old/libffi/testsuite/libffi.call/cls_6byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_6byte.c	2006-08-03 21:47:14.946069088 +0000
@@ -33,7 +33,8 @@
 }
 
 static void
-cls_struct_6byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_6byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_6byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_7_1_byte.c src/libffi/testsuite/libffi.call/cls_7_1_byte.c
--- old/libffi/testsuite/libffi.call/cls_7_1_byte.c	2005-07-10 20:14:37.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_7_1_byte.c	2006-08-03 21:47:14.649114232 +0000
@@ -40,7 +40,8 @@
 }
 
 static void
-cls_struct_7byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_7byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_7byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_7byte.c src/libffi/testsuite/libffi.call/cls_7byte.c
--- old/libffi/testsuite/libffi.call/cls_7byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_7byte.c	2006-08-03 21:47:15.331010568 +0000
@@ -33,7 +33,8 @@
 }
 
 static void
-cls_struct_7byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_7byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_7byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_8byte.c src/libffi/testsuite/libffi.call/cls_8byte.c
--- old/libffi/testsuite/libffi.call/cls_8byte.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_8byte.c	2006-08-03 21:47:14.947068936 +0000
@@ -27,7 +27,8 @@
 }
 
 static void
-cls_struct_8byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_8byte_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_8byte a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_9byte1.c src/libffi/testsuite/libffi.call/cls_9byte1.c
--- old/libffi/testsuite/libffi.call/cls_9byte1.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_9byte1.c	2006-08-03 21:47:14.745099640 +0000
@@ -29,8 +29,8 @@
   return result;
 }
 
-static void cls_struct_9byte_gn(ffi_cif* cif, void* resp, void** args,
-				void* userdata)
+static void cls_struct_9byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				void** args, void* userdata __UNUSED__)
 {
   struct cls_struct_9byte b1, b2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_9byte2.c src/libffi/testsuite/libffi.call/cls_9byte2.c
--- old/libffi/testsuite/libffi.call/cls_9byte2.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_9byte2.c	2006-08-03 21:47:15.149038232 +0000
@@ -29,8 +29,8 @@
   return result;
 }
 
-static void cls_struct_9byte_gn(ffi_cif* cif, void* resp, void** args,
-				void* userdata)
+static void cls_struct_9byte_gn(ffi_cif* cif __UNUSED__, void* resp,
+				void** args, void* userdata __UNUSED__)
 {
   struct cls_struct_9byte b1, b2;
 
diff -urN old/libffi/testsuite/libffi.call/cls_align_double.c src/libffi/testsuite/libffi.call/cls_align_double.c
--- old/libffi/testsuite/libffi.call/cls_align_double.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_double.c	2006-08-03 21:47:14.754098272 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_float.c src/libffi/testsuite/libffi.call/cls_align_float.c
--- old/libffi/testsuite/libffi.call/cls_align_float.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_float.c	2006-08-03 21:47:14.749099032 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_longdouble.c src/libffi/testsuite/libffi.call/cls_align_longdouble.c
--- old/libffi/testsuite/libffi.call/cls_align_longdouble.c	2005-02-11 22:33:16.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_longdouble.c	2006-08-03 21:47:15.137040056 +0000
@@ -29,7 +29,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_pointer.c src/libffi/testsuite/libffi.call/cls_align_pointer.c
--- old/libffi/testsuite/libffi.call/cls_align_pointer.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_pointer.c	2006-08-03 21:47:15.330010720 +0000
@@ -19,16 +19,19 @@
   struct cls_struct_align result;
 
   result.a = a1.a + a2.a;
-  result.b = (void *)((size_t)a1.b + (size_t)a2.b);
+  result.b = (void *)((unsigned long)a1.b + (unsigned long)a2.b);
   result.c = a1.c + a2.c;
 
-  printf("%d %d %d %d %d %d: %d %d %d\n", a1.a, (size_t)a1.b, a1.c, a2.a, (size_t)a2.b, a2.c, result.a, (size_t)result.b, result.c);
+  printf("%d %lu %d %d %lu %d: %d %lu %d\n", a1.a, (unsigned long)a1.b, a1.c,
+	 a2.a, (unsigned long)a2.b, a2.c, result.a, (unsigned long)result.b,
+	 result.c);
 
-  return  result;
+  return result;
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
@@ -84,14 +87,14 @@
 
   ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_dbl, args_dbl);
   /* { dg-output "12 4951 127 1 9320 13: 13 14271 140" } */
-  printf("res: %d %d %d\n", res_dbl.a, (size_t)res_dbl.b, res_dbl.c);
+  printf("res: %d %lu %d\n", res_dbl.a, (unsigned long)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
   CHECK(ffi_prep_closure(pcl, &cif, cls_struct_align_gn, NULL) == FFI_OK);
 
   res_dbl = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(pcl))(g_dbl, f_dbl);
   /* { dg-output "\n12 4951 127 1 9320 13: 13 14271 140" } */
-  printf("res: %d %d %d\n", res_dbl.a, (size_t)res_dbl.b, res_dbl.c);
+  printf("res: %d %lu %d\n", res_dbl.a, (unsigned long)res_dbl.b, res_dbl.c);
   /* { dg-output "\nres: 13 14271 140" } */
 
   exit(0);
diff -urN old/libffi/testsuite/libffi.call/cls_align_sint16.c src/libffi/testsuite/libffi.call/cls_align_sint16.c
--- old/libffi/testsuite/libffi.call/cls_align_sint16.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_sint16.c	2006-08-03 21:47:14.949068632 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_sint32.c src/libffi/testsuite/libffi.call/cls_align_sint32.c
--- old/libffi/testsuite/libffi.call/cls_align_sint32.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_sint32.c	2006-08-03 21:47:15.332010416 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_sint64.c src/libffi/testsuite/libffi.call/cls_align_sint64.c
--- old/libffi/testsuite/libffi.call/cls_align_sint64.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_sint64.c	2006-08-03 21:47:14.741100248 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_uint16.c src/libffi/testsuite/libffi.call/cls_align_uint16.c
--- old/libffi/testsuite/libffi.call/cls_align_uint16.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_uint16.c	2006-08-03 21:47:14.472141136 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_uint32.c src/libffi/testsuite/libffi.call/cls_align_uint32.c
--- old/libffi/testsuite/libffi.call/cls_align_uint32.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_uint32.c	2006-08-03 21:47:14.949068632 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_align_uint64.c src/libffi/testsuite/libffi.call/cls_align_uint64.c
--- old/libffi/testsuite/libffi.call/cls_align_uint64.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_align_uint64.c	2006-08-03 21:47:14.965066200 +0000
@@ -28,7 +28,8 @@
 }
 
 static void
-cls_struct_align_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		    void* userdata __UNUSED__)
 {
 
   struct cls_struct_align a1, a2;
diff -urN old/libffi/testsuite/libffi.call/cls_double.c src/libffi/testsuite/libffi.call/cls_double.c
--- old/libffi/testsuite/libffi.call/cls_double.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_double.c	2006-08-03 21:47:14.650114080 +0000
@@ -7,8 +7,8 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_double_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
+static void cls_ret_double_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
  {
    *(double *)resp = *(double *)args[0];
 
diff -urN old/libffi/testsuite/libffi.call/cls_float.c src/libffi/testsuite/libffi.call/cls_float.c
--- old/libffi/testsuite/libffi.call/cls_float.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_float.c	2006-08-03 21:47:14.954067872 +0000
@@ -7,8 +7,8 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_float_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
+static void cls_ret_float_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata __UNUSED__)
  {
    *(float *)resp = *(float *)args[0];
 
diff -urN old/libffi/testsuite/libffi.call/cls_multi_schar.c src/libffi/testsuite/libffi.call/cls_multi_schar.c
--- old/libffi/testsuite/libffi.call/cls_multi_schar.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_multi_schar.c	2006-08-03 21:47:14.743099944 +0000
@@ -19,7 +19,8 @@
 
 }
 
-static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
 {
   signed char a1, a2;
 
@@ -67,7 +68,7 @@
 
   ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
   /* { dg-output "2 125: 127" } */
-  printf("res: %d\n", res_call);
+  printf("res: %d\n", (signed char)res_call);
   /* { dg-output "\nres: 127" } */
 
   CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
diff -urN old/libffi/testsuite/libffi.call/cls_multi_sshort.c src/libffi/testsuite/libffi.call/cls_multi_sshort.c
--- old/libffi/testsuite/libffi.call/cls_multi_sshort.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_multi_sshort.c	2006-08-03 21:47:14.948068784 +0000
@@ -19,7 +19,8 @@
 
 }
 
-static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
 {
   signed short a1, a2;
 
@@ -67,7 +68,7 @@
 
   ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
   /* { dg-output "2 32765: 32767" } */
-  printf("res: %d\n", res_call);
+  printf("res: %d\n", (unsigned short)res_call);
   /* { dg-output "\nres: 32767" } */
 
   CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
diff -urN old/libffi/testsuite/libffi.call/cls_multi_sshortchar.c src/libffi/testsuite/libffi.call/cls_multi_sshortchar.c
--- old/libffi/testsuite/libffi.call/cls_multi_sshortchar.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_multi_sshortchar.c	2006-08-03 21:47:14.740100400 +0000
@@ -20,7 +20,8 @@
 
 }
 
-static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
 {
   signed char a1, a3;
   signed short a2, a4;
@@ -79,7 +80,7 @@
 
   ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
   /* { dg-output "1 32765 127 -128: 32765" } */
-  printf("res: %d\n", res_call);
+  printf("res: %d\n", (signed short)res_call);
   /* { dg-output "\nres: 32765" } */
 
   CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
diff -urN old/libffi/testsuite/libffi.call/cls_multi_uchar.c src/libffi/testsuite/libffi.call/cls_multi_uchar.c
--- old/libffi/testsuite/libffi.call/cls_multi_uchar.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_multi_uchar.c	2006-08-03 21:47:14.743099944 +0000
@@ -20,7 +20,8 @@
 
 }
 
-static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
 {
   unsigned char a1, a2, a3, a4;
 
@@ -35,7 +36,9 @@
 
 typedef unsigned char (*test_type)(unsigned char, unsigned char,
 				   unsigned char, unsigned char);
-void test_func(ffi_cif *cif, void *rval, void **avals, void *data)
+
+void test_func(ffi_cif *cif __UNUSED__, void *rval __UNUSED__, void **avals,
+	       void *data __UNUSED__)
 {
   printf("%d %d %d %d\n", *(unsigned char *)avals[0],
 	 *(unsigned char *)avals[1], *(unsigned char *)avals[2],
@@ -82,7 +85,7 @@
 
   ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
   /* { dg-output "1 2 127 125: 255" } */
-  printf("res: %d\n", res_call);
+  printf("res: %d\n", (unsigned char)res_call);
   /* { dg-output "\nres: 255" } */
 
   CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
diff -urN old/libffi/testsuite/libffi.call/cls_multi_ushort.c src/libffi/testsuite/libffi.call/cls_multi_ushort.c
--- old/libffi/testsuite/libffi.call/cls_multi_ushort.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_multi_ushort.c	2006-08-03 21:47:14.471141288 +0000
@@ -19,7 +19,8 @@
 
 }
 
-static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
 {
   unsigned short a1, a2;
 
@@ -67,7 +68,7 @@
 
   ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
   /* { dg-output "2 32765: 32767" } */
-  printf("res: %d\n", res_call);
+  printf("res: %d\n", (unsigned short)res_call);
   /* { dg-output "\nres: 32767" } */
 
   CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
diff -urN old/libffi/testsuite/libffi.call/cls_multi_ushortchar.c src/libffi/testsuite/libffi.call/cls_multi_ushortchar.c
--- old/libffi/testsuite/libffi.call/cls_multi_ushortchar.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_multi_ushortchar.c	2006-08-03 21:47:14.960066960 +0000
@@ -20,7 +20,8 @@
 
 }
 
-static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)
+static void test_func_gn(ffi_cif *cif __UNUSED__, void *rval, void **avals,
+			 void *data __UNUSED__)
 {
   unsigned char a1, a3;
   unsigned short a2, a4;
@@ -79,7 +80,7 @@
 
   ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);
   /* { dg-output "1 2 127 128: 258" } */
-  printf("res: %d\n", res_call);
+  printf("res: %d\n", (unsigned short)res_call);
   /* { dg-output "\nres: 258" } */
 
   CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);
diff -urN old/libffi/testsuite/libffi.call/cls_schar.c src/libffi/testsuite/libffi.call/cls_schar.c
--- old/libffi/testsuite/libffi.call/cls_schar.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_schar.c	2006-08-03 21:47:14.964066352 +0000
@@ -7,12 +7,12 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_schar_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
+static void cls_ret_schar_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata __UNUSED__)
 {
   *(ffi_arg*)resp = *(signed char *)args[0];
   printf("%d: %d\n",*(signed char *)args[0],
-	 *(ffi_arg*)resp);
+	 (int)*(ffi_arg *)(resp));
 }
 typedef signed char (*cls_ret_schar)(signed char);
 
diff -urN old/libffi/testsuite/libffi.call/cls_sint.c src/libffi/testsuite/libffi.call/cls_sint.c
--- old/libffi/testsuite/libffi.call/cls_sint.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_sint.c	2006-08-03 21:47:14.651113928 +0000
@@ -7,12 +7,12 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_sint_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
+static void cls_ret_sint_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			    void* userdata __UNUSED__)
 {
   *(ffi_arg*)resp = *(signed int *)args[0];
   printf("%d: %d\n",*(signed int *)args[0],
-	 *(ffi_arg*)resp);
+	 (int)*(ffi_arg *)(resp));
 }
 typedef signed int (*cls_ret_sint)(signed int);
 
diff -urN old/libffi/testsuite/libffi.call/cls_sshort.c src/libffi/testsuite/libffi.call/cls_sshort.c
--- old/libffi/testsuite/libffi.call/cls_sshort.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_sshort.c	2006-08-03 21:47:14.752098576 +0000
@@ -7,12 +7,12 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_sshort_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
+static void cls_ret_sshort_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
 {
   *(ffi_arg*)resp = *(signed short *)args[0];
   printf("%d: %d\n",*(signed short *)args[0],
-	 *(ffi_arg*)resp);
+	 (int)*(ffi_arg *)(resp));
 }
 typedef signed short (*cls_ret_sshort)(signed short);
 
diff -urN old/libffi/testsuite/libffi.call/cls_uchar.c src/libffi/testsuite/libffi.call/cls_uchar.c
--- old/libffi/testsuite/libffi.call/cls_uchar.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_uchar.c	2006-08-03 21:47:14.964066352 +0000
@@ -7,12 +7,12 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_uchar_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
+static void cls_ret_uchar_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			     void* userdata __UNUSED__)
 {
   *(ffi_arg*)resp = *(unsigned char *)args[0];
   printf("%d: %d\n",*(unsigned char *)args[0],
-	 *(ffi_arg*)resp);
+	 (int)*(ffi_arg *)(resp));
 }
 typedef unsigned char (*cls_ret_uchar)(unsigned char);
 
diff -urN old/libffi/testsuite/libffi.call/cls_uint.c src/libffi/testsuite/libffi.call/cls_uint.c
--- old/libffi/testsuite/libffi.call/cls_uint.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_uint.c	2006-08-03 21:47:14.959067112 +0000
@@ -7,14 +7,14 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_uint_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
- {
-   *(ffi_arg *)resp = *(unsigned int *)args[0];
-
-   printf("%d: %d\n",*(unsigned int *)args[0],
-	  *(ffi_arg *)resp);
- }
+static void cls_ret_uint_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			    void* userdata __UNUSED__)
+{
+  *(ffi_arg *)resp = *(unsigned int *)args[0];
+
+  printf("%d: %d\n",*(unsigned int *)args[0],
+	 (int)*(ffi_arg *)(resp));
+}
 typedef unsigned int (*cls_ret_uint)(unsigned int);
 
 int main (void)
diff -urN old/libffi/testsuite/libffi.call/cls_ulonglong.c src/libffi/testsuite/libffi.call/cls_ulonglong.c
--- old/libffi/testsuite/libffi.call/cls_ulonglong.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_ulonglong.c	2006-08-03 21:47:14.966066048 +0000
@@ -7,14 +7,14 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_ulonglong_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
- {
-   *(unsigned long long *)resp=  *(unsigned long long *)args[0];
-
-   printf("%llu: %llu\n",*(unsigned long long *)args[0],
-	  *(unsigned long long *)resp);
- }
+static void cls_ret_ulonglong_fn(ffi_cif* cif __UNUSED__, void* resp,
+				 void** args, void* userdata __UNUSED__)
+{
+  *(unsigned long long *)resp=  *(unsigned long long *)args[0];
+
+  printf("%llu: %llu\n",*(unsigned long long *)args[0],
+	 *(unsigned long long *)(resp));
+}
 typedef unsigned long long (*cls_ret_ulonglong)(unsigned long long);
 
 int main (void)
diff -urN old/libffi/testsuite/libffi.call/cls_ushort.c src/libffi/testsuite/libffi.call/cls_ushort.c
--- old/libffi/testsuite/libffi.call/cls_ushort.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/cls_ushort.c	2006-08-03 21:47:15.151037928 +0000
@@ -7,14 +7,14 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-static void cls_ret_ushort_fn(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
- {
-   *(ffi_arg*)resp = *(unsigned short *)args[0];
-
-   printf("%d: %d\n",*(unsigned short *)args[0],
-	  *(ffi_arg*)resp);
- }
+static void cls_ret_ushort_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+			      void* userdata __UNUSED__)
+{
+  *(ffi_arg*)resp = *(unsigned short *)args[0];
+
+  printf("%d: %d\n",*(unsigned short *)args[0],
+	 (int)*(ffi_arg *)(resp));
+}
 typedef unsigned short (*cls_ret_ushort)(unsigned short);
 
 int main (void)
diff -urN old/libffi/testsuite/libffi.call/ffitest.h src/libffi/testsuite/libffi.call/ffitest.h
--- old/libffi/testsuite/libffi.call/ffitest.h	2004-01-08 12:15:17.000000000 +0000
+++ src/libffi/testsuite/libffi.call/ffitest.h	2006-08-03 21:47:15.141039448 +0000
@@ -9,6 +9,24 @@
 
 #define CHECK(x) !(x) ? abort() : 0
 
+/* Define our own long for easier handling on multilib targets.  */
+#if LONG_MAX == 2147483647
+#define ffi_type_mylong ffi_type_uint32
+#else
+#if LONG_MAX == 9223372036854775807
+#define ffi_type_mylong ffi_type_uint64
+#else
+#error "Error, size LONG not defined as expected"
+#endif
+#endif
+
+/* Define __UNUSED__ that also other compilers than gcc can run the tests.  */
+#undef __UNUSED__
+#if defined(__GNUC__)
+#define __UNUSED__ __attribute__((__unused__))
+#else
+#define __UNUSED__
+#endif
 
 /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a
    file open.  */
diff -urN old/libffi/testsuite/libffi.call/float.c src/libffi/testsuite/libffi.call/float.c
--- old/libffi/testsuite/libffi.call/float.c	2005-02-11 22:33:16.000000000 +0000
+++ src/libffi/testsuite/libffi.call/float.c	2006-08-03 21:47:14.950068480 +0000
@@ -8,7 +8,7 @@
 
 #include "ffitest.h"
 
-static int floating(int a, float b, double c, long double d, int e)
+static int floating(int a, float b, double c, long double d)
 {
   int i;
 
@@ -28,7 +28,6 @@
   signed int si1;
   double d;
   long double ld;
-  signed int si2;
 
   args[0] = &ffi_type_sint;
   values[0] = &si1;
@@ -38,26 +37,23 @@
   values[2] = &d;
   args[3] = &ffi_type_longdouble;
   values[3] = &ld;
-  args[4] = &ffi_type_sint;
-  values[4] = &si2;
 
   /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
 		     &ffi_type_sint, args) == FFI_OK);
 
   si1 = 6;
   f = 3.14159;
   d = (double)1.0/(double)3.0;
   ld = 2.71828182846L;
-  si2 = 10;
 
-  floating (si1, f, d, ld, si2);
+  floating (si1, f, d, ld);
 
   ffi_call(&cif, FFI_FN(floating), &rint, values);
 
-  printf ("%d vs %d\n", (int)rint, floating (si1, f, d, ld, si2));
+  printf ("%d vs %d\n", (int)rint, floating (si1, f, d, ld));
 
-  CHECK(rint == floating(si1, f, d, ld, si2));
+  CHECK((int)rint == floating(si1, f, d, ld));
 
   exit (0);
 }
diff -urN old/libffi/testsuite/libffi.call/float1.c src/libffi/testsuite/libffi.call/float1.c
--- old/libffi/testsuite/libffi.call/float1.c	2005-09-26 19:56:22.000000000 +0000
+++ src/libffi/testsuite/libffi.call/float1.c	2006-08-03 21:47:15.156037168 +0000
@@ -28,25 +28,25 @@
   void *values[MAX_ARGS];
   float f;
   value_type result[2];
-  int i;
+  unsigned int i;
 
   args[0] = &ffi_type_float;
   values[0] = &f;
-  
+
   /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
 		     &ffi_type_double, args) == FFI_OK);
-  
+
   f = 3.14159;
-  
+
   /* Put a canary in the return array.  This is a regression test for
      a buffer overrun.  */
   memset(result[1].c, CANARY, sizeof (double));
 
   ffi_call(&cif, FFI_FN(dblit), &result[0].d, values);
-  
+
   /* These are not always the same!! Check for a reasonable delta */
- 
+
   CHECK(result[0].d - dblit(f) < DBL_EPSILON);
 
   /* Check the canary.  */
diff -urN old/libffi/testsuite/libffi.call/float2.c src/libffi/testsuite/libffi.call/float2.c
--- old/libffi/testsuite/libffi.call/float2.c	2005-02-11 22:33:16.000000000 +0000
+++ src/libffi/testsuite/libffi.call/float2.c	2006-08-03 21:47:14.759097512 +0000
@@ -48,9 +48,7 @@
 #endif
 
   /* These are not always the same!! Check for a reasonable delta */
-  /*@-realcompare@*/
   if (ld - ldblit(f) < LDBL_EPSILON)
-    /*@=realcompare@*/
     puts("long double return value tests ok!");
   else
     CHECK(0);
diff -urN old/libffi/testsuite/libffi.call/negint.c src/libffi/testsuite/libffi.call/negint.c
--- old/libffi/testsuite/libffi.call/negint.c	2004-10-02 07:02:41.000000000 +0000
+++ src/libffi/testsuite/libffi.call/negint.c	2006-08-03 21:47:15.151037928 +0000
@@ -11,7 +11,6 @@
 
 static int checking(int a, short b, signed char c)
 {
-  int i;
 
   return (a < 0 && b < 0 && c < 0);
 }
diff -urN old/libffi/testsuite/libffi.call/nested_struct.c src/libffi/testsuite/libffi.call/nested_struct.c
--- old/libffi/testsuite/libffi.call/nested_struct.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/nested_struct.c	2006-08-03 21:47:14.755098120 +0000
@@ -50,7 +50,8 @@
 }
 
 static void
-cls_struct_combined_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_combined_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		       void* userdata __UNUSED__)
 {
   struct cls_struct_16byte1 b0;
   struct cls_struct_16byte2 b1;
diff -urN old/libffi/testsuite/libffi.call/nested_struct1.c src/libffi/testsuite/libffi.call/nested_struct1.c
--- old/libffi/testsuite/libffi.call/nested_struct1.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/nested_struct1.c	2006-08-03 21:47:14.648114384 +0000
@@ -52,7 +52,8 @@
 }
 
 static void
-cls_struct_combined_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+cls_struct_combined_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		       void* userdata __UNUSED__)
 {
   struct cls_struct_16byte1 b0;
   struct cls_struct_16byte2 b1;
diff -urN old/libffi/testsuite/libffi.call/nested_struct2.c src/libffi/testsuite/libffi.call/nested_struct2.c
--- old/libffi/testsuite/libffi.call/nested_struct2.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/nested_struct2.c	2006-08-03 21:47:14.956067568 +0000
@@ -9,16 +9,6 @@
 /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
 #include "ffitest.h"
 
-#if LONG_MAX == 2147483647
-#define ffi_type_mylong ffi_type_uint32
-#else
-#if LONG_MAX == 9223372036854775807
-#define ffi_type_mylong ffi_type_uint64
-#else
-#error "Error, size LONG not defined as expected"
-#endif
-#endif
-
 typedef struct A {
   unsigned long a;
   unsigned char b;
@@ -37,14 +27,15 @@
   result.x.b = b0.b + b1.x.b + b1.y;
   result.y = b0.b + b1.x.b;
 
-  printf("%d %d %d %d %d: %d %d %d\n", b0.a, b0.b, b1.x.a, b1.x.b, b1.y,
+  printf("%lu %d %lu %d %d: %lu %d %d\n", b0.a, b0.b, b1.x.a, b1.x.b, b1.y,
 	 result.x.a, result.x.b, result.y);
 
   return result;
 }
 
 static void
-B_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
 {
   struct A b0;
   struct B b1;
@@ -115,7 +106,6 @@
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
 
-
   CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
 
   res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
@@ -123,5 +113,6 @@
   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
   exit(0);
 }
diff -urN old/libffi/testsuite/libffi.call/nested_struct3.c src/libffi/testsuite/libffi.call/nested_struct3.c
--- old/libffi/testsuite/libffi.call/nested_struct3.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/nested_struct3.c	2006-08-03 21:47:14.649114232 +0000
@@ -35,7 +35,8 @@
 }
 
 static void
-B_gn(ffi_cif* cif, void* resp, void** args, void* userdata)
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
 {
   struct A b0;
   struct B b1;
diff -urN old/libffi/testsuite/libffi.call/problem1.c src/libffi/testsuite/libffi.call/problem1.c
--- old/libffi/testsuite/libffi.call/problem1.c	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.call/problem1.c	2006-08-03 21:47:14.750098880 +0000
@@ -27,7 +27,8 @@
   return result;
 }
 
-void stub(ffi_cif* cif, void* resp, void** args, void* userdata)
+void stub(ffi_cif* cif __UNUSED__, void* resp, void** args,
+	  void* userdata __UNUSED__)
 {
   struct my_ffi_struct a1;
   struct my_ffi_struct a2;
diff -urN old/libffi/testsuite/libffi.call/promotion.c src/libffi/testsuite/libffi.call/promotion.c
--- old/libffi/testsuite/libffi.call/promotion.c	2004-09-04 22:41:53.000000000 +0000
+++ src/libffi/testsuite/libffi.call/promotion.c	2006-08-03 21:47:14.759097512 +0000
@@ -43,10 +43,10 @@
   ul = 0;
 
   for (sc = (signed char) -127;
-       sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)
+       sc <= (signed char) 120; sc += 1)
     for (ss = -30000; ss <= 30000; ss += 10000)
       for (uc = (unsigned char) 0;
-	   uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)
+	   uc <= (unsigned char) 200; uc += 20)
 	for (us = 0; us <= 60000; us += 10000)
 	  {
 	    ul++;
diff -urN old/libffi/testsuite/libffi.call/pyobjc-tc.c src/libffi/testsuite/libffi.call/pyobjc-tc.c
--- old/libffi/testsuite/libffi.call/pyobjc-tc.c	2004-01-24 16:13:48.000000000 +0000
+++ src/libffi/testsuite/libffi.call/pyobjc-tc.c	2006-08-03 21:47:14.960066960 +0000
@@ -107,7 +107,7 @@
 
 	ffi_call(&cif, FFI_FN(doit), &result, values);
 
-	printf ("The result is %d\n", result);
+	printf ("The result is %d\n", (int)result);
 
 	}
 	exit(0);
diff -urN old/libffi/testsuite/libffi.call/struct1.c src/libffi/testsuite/libffi.call/struct1.c
--- old/libffi/testsuite/libffi.call/struct1.c	2003-09-04 14:49:22.000000000 +0000
+++ src/libffi/testsuite/libffi.call/struct1.c	2006-08-03 21:47:14.475140680 +0000
@@ -16,9 +16,7 @@
 
 static test_structure_1 struct1(test_structure_1 ts)
 {
-  /*@-type@*/
   ts.uc++;
-  /*@=type@*/
   ts.d--;
   ts.ui++;
 
diff -urN old/libffi/testsuite/libffi.special/ffitestcxx.h src/libffi/testsuite/libffi.special/ffitestcxx.h
--- old/libffi/testsuite/libffi.special/ffitestcxx.h	2003-11-26 13:46:10.000000000 +0000
+++ src/libffi/testsuite/libffi.special/ffitestcxx.h	2006-08-03 21:47:15.334010112 +0000
@@ -6,6 +6,15 @@
 
 #define MAX_ARGS 256
 
+
+/* Define __UNUSED__ that also other compilers than gcc can run the tests.  */
+#undef __UNUSED__
+#if defined(__GNUC__)
+#define __UNUSED__ __attribute__((__unused__))
+#else
+#define __UNUSED__
+#endif
+
 #define CHECK(x) (!(x) ? abort() : (void)0)
 
 /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a
diff -urN old/libffi/testsuite/libffi.special/special.exp src/libffi/testsuite/libffi.special/special.exp
--- old/libffi/testsuite/libffi.special/special.exp	2005-01-12 09:06:52.000000000 +0000
+++ src/libffi/testsuite/libffi.special/special.exp	2006-08-03 21:47:15.333010264 +0000
@@ -1,19 +1,18 @@
-#   Copyright (C) 2003 Free Software Foundation, Inc.
+# Copyright (C) 2003, 2006 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
-# 
+#
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
-
+# Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 # libffi testsuite that uses the 'dg.exp' driver.
 
 load_lib libffi-dg.exp
@@ -27,7 +26,10 @@
 
 set cxx_options " -shared-libgcc -lstdc++"
 
-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.cc]] $cxx_options ""
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.cc]] $cxx_options "-O0 -W -Wall"
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.cc]] $cxx_options "-O2"
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.cc]] $cxx_options "-O3"
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.cc]] $cxx_options "-Os"
 
 dg-finish
 
diff -urN old/libffi/testsuite/libffi.special/unwindtest.cc src/libffi/testsuite/libffi.special/unwindtest.cc
--- old/libffi/testsuite/libffi.special/unwindtest.cc	2004-08-25 05:06:55.000000000 +0000
+++ src/libffi/testsuite/libffi.special/unwindtest.cc	2006-08-03 21:47:15.333010264 +0000
@@ -8,15 +8,16 @@
 #include "ffitestcxx.h"
 
 void
-closure_test_fn(ffi_cif* cif, void* resp, void** args, void* userdata)
+closure_test_fn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,
+		void** args __UNUSED__, void* userdata __UNUSED__)
 {
   throw 9;
 }
 
 typedef void (*closure_test_type)();
 
-void closure_test_fn1(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
+void closure_test_fn1(ffi_cif* cif __UNUSED__, void* resp,
+		      void** args, void* userdata __UNUSED__)
  {
     *(ffi_arg*)resp =
       (int)*(float *)args[0] +(int)(*(float *)args[1]) +
@@ -54,7 +55,6 @@
 #endif
   ffi_closure *pcl;
   ffi_type * cl_arg_types[17];
-  int res;
 #ifdef USING_MMAP
   pcl = (ffi_closure *) allocate_mmap (sizeof(ffi_closure));
 #else
