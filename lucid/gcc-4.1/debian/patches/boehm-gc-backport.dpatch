#! /bin/sh -e

# DP: gcc/java / libjava backport / classpath-0.92

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p1 < $0
        #cd ${dir}gcc && autoconf2.59
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p1 < $0
        #rm ${dir}gcc/configure
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0


diff -urN old/boehm-gc/aclocal.m4 src/boehm-gc/aclocal.m4
--- old/boehm-gc/aclocal.m4	2006-05-25 01:46:15.000000000 +0200
+++ src/boehm-gc/aclocal.m4	2006-08-28 19:14:18.110718000 +0200
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.9.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.6 -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
-# Free Software Foundation, Inc.
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -11,23 +11,11 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
-#                                                        -*- Autoconf -*-
-# Copyright (C) 2002, 2003  Free Software Foundation, Inc.
-# Generated from amversion.in; do not edit by hand.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
@@ -40,26 +28,15 @@
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.9.3])])
-
-# AM_AUX_DIR_EXPAND
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+	 [AM_AUTOMAKE_VERSION([1.9.6])])
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
 # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
@@ -106,26 +83,16 @@
 am_aux_dir=`cd $ac_aux_dir && pwd`
 ])
 
-# AM_CONDITIONAL                                              -*- Autoconf -*-
-
-# Copyright (C) 1997, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 6
+# serial 7
 
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
@@ -149,26 +116,15 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# serial 7						-*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
+# serial 8
 
 # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
@@ -177,7 +133,6 @@
 # CC etc. in the Makefile, will ask for an AC_PROG_CC use...
 
 
-
 # _AM_DEPENDENCIES(NAME)
 # ----------------------
 # See how the compiler implements dependency checking.
@@ -317,27 +272,16 @@
 AC_SUBST([AMDEPBACKSLASH])
 ])
 
-# Generate code to set up dependency tracking.   -*- Autoconf -*-
-
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
-#   Free Software Foundation, Inc.
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-#serial 2
+#serial 3
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
@@ -396,30 +340,19 @@
      [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
 ])
 
-# Do all the work for Automake.                            -*- Autoconf -*-
+# Do all the work for Automake.                             -*- Autoconf -*-
 
-# This macro actually does too much some checks are only needed if
-# your package does certain things.  But this isn't really a big deal.
-
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# serial 12
 
-# serial 11
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
 
 # AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
 # AM_INIT_AUTOMAKE([OPTIONS])
@@ -521,87 +454,31 @@
 done
 echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
 
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
 AC_DEFUN([AM_PROG_INSTALL_SH],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
 install_sh=${install_sh-"$am_aux_dir/install-sh"}
 AC_SUBST(install_sh)])
 
-#                                                          -*- Autoconf -*-
-# Copyright (C) 2003  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 1
-
-# Check whether the underlying file-system supports filenames
-# with a leading dot.  For instance MS-DOS doesn't.
-AC_DEFUN([AM_SET_LEADING_DOT],
-[rm -rf .tst 2>/dev/null
-mkdir .tst 2>/dev/null
-if test -d .tst; then
-  am__leading_dot=.
-else
-  am__leading_dot=_
-fi
-rmdir .tst 2>/dev/null
-AC_SUBST([am__leading_dot])])
-
-# Add --enable-maintainer-mode option to configure.
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 3
+# serial 4
 
 AC_DEFUN([AM_MAINTAINER_MODE],
 [AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
@@ -620,26 +497,15 @@
 
 AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
 
-# Check to see how 'make' treats includes.	-*- Autoconf -*-
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # AM_MAKE_INCLUDE()
 # -----------------
@@ -683,29 +549,17 @@
 rm -f confinc confmf
 ])
 
-# serial 2
+# Copyright (C) 1999, 2000, 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
 
 # AM_PROG_CC_C_O
 # --------------
 # Like AC_PROG_CC_C_O, but changed for automake.
-
-# Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
 AC_DEFUN([AM_PROG_CC_C_O],
 [AC_REQUIRE([AC_PROG_CC_C_O])dnl
 AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
@@ -723,27 +577,16 @@
 fi
 ])
 
-#  -*- Autoconf -*-
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# Copyright (C) 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 3
+# serial 4
 
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
@@ -769,27 +612,16 @@
 fi
 ])
 
+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
 # AM_PROG_MKDIR_P
 # ---------------
 # Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.
-
-# Copyright (C) 2003, 2004 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
+#
 # Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories
 # created by `make install' are always world readable, even if the
 # installer happens to have an overly restrictive umask (e.g. 077).
@@ -843,25 +675,14 @@
 fi
 AC_SUBST([mkdir_p])])
 
-# Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004
+# Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2005
 # Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 4
+# serial 5
 
 # AM_ENABLE_MULTILIB([MAKEFILE], [REL-TO-TOP-SRCDIR])
 # ---------------------------------------------------
@@ -912,26 +733,15 @@
 CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
 CC="$CC"])])dnl
 
-# Helper functions for option handling.                    -*- Autoconf -*-
+# Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -956,28 +766,16 @@
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
-#
-# Check to make sure that the build environment is sane.
-#
-
-# Copyright (C) 1996, 1997, 2000, 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
-# serial 3
+# serial 4
 
 # AM_SANITY_CHECK
 # ---------------
@@ -1020,25 +818,14 @@
 fi
 AC_MSG_RESULT(yes)])
 
-# AM_PROG_INSTALL_STRIP
-
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
+# AM_PROG_INSTALL_STRIP
+# ---------------------
 # One issue with vendor `install' (even GNU) is that you can't
 # specify the program used to strip binaries.  This is especially
 # annoying in cross-compiling environments, where the build's strip
@@ -1061,25 +848,13 @@
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004  Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
-
-# serial 1
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
+# serial 2
 
 # _AM_PROG_TAR(FORMAT)
 # --------------------
@@ -1168,5 +943,7 @@
 ]) # _AM_PROG_TAR
 
 m4_include([../config/acx.m4])
+m4_include([../config/depstand.m4])
+m4_include([../config/lead-dot.m4])
 m4_include([../config/no-executables.m4])
 m4_include([../libtool.m4])
diff -urN old/boehm-gc/aix_irix_threads.c src/boehm-gc/aix_irix_threads.c
--- old/boehm-gc/aix_irix_threads.c	2004-08-23 23:40:17.000000000 +0200
+++ src/boehm-gc/aix_irix_threads.c	2006-08-28 19:14:18.110718000 +0200
@@ -1,689 +0,0 @@
-/* 
- * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.
- * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.
- * Copyright (c) 1999-2003 by Hewlett-Packard Company. All rights reserved.
- *
- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
- *
- * Permission is hereby granted to use or copy this program
- * for any purpose,  provided the above notices are retained on all copies.
- * Permission to modify the code and to distribute modified code is granted,
- * provided the above notices are retained, and a notice that the code was
- * modified is included with the above copyright notice.
- */
-/*
- * Support code for Irix (>=6.2) Pthreads and for AIX pthreads.
- * This relies on properties
- * not guaranteed by the Pthread standard.  It may or may not be portable
- * to other implementations.
- *
- * Note that there is a lot of code duplication between this file and
- * (pthread_support.c, pthread_stop_world.c).  They should be merged.
- * Pthread_support.c should be directly usable.
- *
- * Please avoid adding new ports here; use the generic pthread support
- * as a base instead.
- */
-
-# include "private/gc_priv.h"
-
-# if defined(GC_IRIX_THREADS) || defined(GC_AIX_THREADS)
-
-# include <pthread.h>
-# include <assert.h>
-# include <semaphore.h>
-# include <time.h>
-# include <errno.h>
-# include <unistd.h>
-# include <sys/mman.h>
-# include <sys/time.h>
-
-#undef pthread_create
-#undef pthread_sigmask
-#undef pthread_join
-
-#if defined(GC_IRIX_THREADS) && !defined(MUTEX_RECURSIVE_NP)
-#define MUTEX_RECURSIVE_NP PTHREAD_MUTEX_RECURSIVE
-#endif
-
-void GC_thr_init();
-
-#if 0
-void GC_print_sig_mask()
-{
-    sigset_t blocked;
-    int i;
-
-    if (pthread_sigmask(SIG_BLOCK, NULL, &blocked) != 0)
-    	ABORT("pthread_sigmask");
-    GC_printf0("Blocked: ");
-    for (i = 1; i <= MAXSIG; i++) {
-        if (sigismember(&blocked, i)) { GC_printf1("%ld ",(long) i); }
-    }
-    GC_printf0("\n");
-}
-#endif
-
-/* We use the allocation lock to protect thread-related data structures. */
-
-/* The set of all known threads.  We intercept thread creation and 	*/
-/* joins.  We never actually create detached threads.  We allocate all 	*/
-/* new thread stacks ourselves.  These allow us to maintain this	*/
-/* data structure.							*/
-/* Protected by GC_thr_lock.						*/
-/* Some of this should be declared volatile, but that's incosnsistent	*/
-/* with some library routine declarations.  		 		*/
-typedef struct GC_Thread_Rep {
-    struct GC_Thread_Rep * next;  /* More recently allocated threads	*/
-				  /* with a given pthread id come 	*/
-				  /* first.  (All but the first are	*/
-				  /* guaranteed to be dead, but we may  */
-				  /* not yet have registered the join.) */
-    pthread_t id;
-    word stop;
-#	define NOT_STOPPED 0
-#	define PLEASE_STOP 1
-#	define STOPPED 2
-    word flags;
-#	define FINISHED 1   	/* Thread has exited.	*/
-#	define DETACHED 2	/* Thread is intended to be detached.	*/
-    ptr_t stack_cold;		/* cold end of the stack		*/
-    ptr_t stack_hot;  		/* Valid only when stopped. */
-				/* But must be within stack region at	*/
-				/* all times.				*/
-    void * status;		/* Used only to avoid premature 	*/
-				/* reclamation of any data it might 	*/
-				/* reference.				*/
-} * GC_thread;
-
-GC_thread GC_lookup_thread(pthread_t id);
-
-/*
- * The only way to suspend threads given the pthread interface is to send
- * signals.  Unfortunately, this means we have to reserve
- * a signal, and intercept client calls to change the signal mask.
- */
-#if 0 /* DOB: 6.1 */
-# if defined(GC_AIX_THREADS)
-#   define SIG_SUSPEND SIGUSR1
-# else
-#   define SIG_SUSPEND (SIGRTMIN + 6)
-# endif
-#endif
-
-pthread_mutex_t GC_suspend_lock = PTHREAD_MUTEX_INITIALIZER;
-				/* Number of threads stopped so far	*/
-pthread_cond_t GC_suspend_ack_cv = PTHREAD_COND_INITIALIZER;
-pthread_cond_t GC_continue_cv = PTHREAD_COND_INITIALIZER;
-
-void GC_suspend_handler(int sig)
-{
-    int dummy;
-    GC_thread me;
-    sigset_t all_sigs;
-    sigset_t old_sigs;
-    int i;
-
-    if (sig != SIG_SUSPEND) ABORT("Bad signal in suspend_handler");
-    me = GC_lookup_thread(pthread_self());
-    /* The lookup here is safe, since I'm doing this on behalf  */
-    /* of a thread which holds the allocation lock in order	*/
-    /* to stop the world.  Thus concurrent modification of the	*/
-    /* data structure is impossible.				*/
-    if (PLEASE_STOP != me -> stop) {
-	/* Misdirected signal.	*/
-	pthread_mutex_unlock(&GC_suspend_lock);
-	return;
-    }
-    pthread_mutex_lock(&GC_suspend_lock);
-    me -> stack_hot = (ptr_t)(&dummy);
-    me -> stop = STOPPED;
-    pthread_cond_signal(&GC_suspend_ack_cv);
-    pthread_cond_wait(&GC_continue_cv, &GC_suspend_lock);
-    pthread_mutex_unlock(&GC_suspend_lock);
-    /* GC_printf1("Continuing 0x%x\n", pthread_self()); */
-}
-
-
-GC_bool GC_thr_initialized = FALSE;
-
-
-# define THREAD_TABLE_SZ 128	/* Must be power of 2	*/
-volatile GC_thread GC_threads[THREAD_TABLE_SZ];
-
-void GC_push_thread_structures GC_PROTO((void))
-{
-    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));
-}
-
-/* Add a thread to GC_threads.  We assume it wasn't already there.	*/
-/* Caller holds allocation lock.					*/
-GC_thread GC_new_thread(pthread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    GC_thread result;
-    static struct GC_Thread_Rep first_thread;
-    static GC_bool first_thread_used = FALSE;
-    
-    GC_ASSERT(I_HOLD_LOCK());
-    if (!first_thread_used) {
-    	result = &first_thread;
-    	first_thread_used = TRUE;
-    	/* Dont acquire allocation lock, since we may already hold it. */
-    } else {
-        result = (struct GC_Thread_Rep *)
-        	 GC_generic_malloc_inner(sizeof(struct GC_Thread_Rep), NORMAL);
-    }
-    if (result == 0) return(0);
-    result -> id = id;
-    result -> next = GC_threads[hv];
-    GC_threads[hv] = result;
-    /* result -> flags = 0;     */
-    /* result -> stop = 0;	*/
-    return(result);
-}
-
-/* Delete a thread from GC_threads.  We assume it is there.	*/
-/* (The code intentionally traps if it wasn't.)			*/
-/* Caller holds allocation lock.				*/
-/* We explicitly pass in the GC_thread we're looking for, since */
-/* if a thread has been joined, but we have not yet		*/
-/* been notified, then there may be more than one thread 	*/
-/* in the table with the same pthread id.			*/
-/* This is OK, but we need a way to delete a specific one.	*/
-void GC_delete_gc_thread(pthread_t id, GC_thread gc_id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    register GC_thread p = GC_threads[hv];
-    register GC_thread prev = 0;
-
-    GC_ASSERT(I_HOLD_LOCK());
-    while (p != gc_id) {
-        prev = p;
-        p = p -> next;
-    }
-    if (prev == 0) {
-        GC_threads[hv] = p -> next;
-    } else {
-        prev -> next = p -> next;
-    }
-}
-
-/* Return a GC_thread corresponding to a given thread_t.	*/
-/* Returns 0 if it's not there.					*/
-/* Caller holds  allocation lock or otherwise inhibits 		*/
-/* updates.							*/
-/* If there is more than one thread with the given id we 	*/
-/* return the most recent one.					*/
-GC_thread GC_lookup_thread(pthread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    register GC_thread p = GC_threads[hv];
-    
-    /* I either hold the lock, or i'm being called from the stop-the-world
-     * handler. */
-#if defined(GC_AIX_THREADS)
-    GC_ASSERT(I_HOLD_LOCK()); /* no stop-the-world handler needed on AIX */
-#endif
-    while (p != 0 && !pthread_equal(p -> id, id)) p = p -> next;
-    return(p);
-}
-
-#if defined(GC_AIX_THREADS)
-void GC_stop_world()
-{
-    pthread_t my_thread = pthread_self();
-    register int i;
-    register GC_thread p;
-    register int result;
-    struct timespec timeout;
-
-    GC_ASSERT(I_HOLD_LOCK());
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> id != my_thread) {
-          pthread_suspend_np(p->id);
-        }
-      }
-    }
-    /* GC_printf1("World stopped 0x%x\n", pthread_self()); */
-}
-
-void GC_start_world()
-{
-    GC_thread p;
-    unsigned i;
-    pthread_t my_thread = pthread_self();
-
-    /* GC_printf0("World starting\n"); */
-    GC_ASSERT(I_HOLD_LOCK());
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> id != my_thread) {
-          pthread_continue_np(p->id);
-        }
-      }
-    }
-}
-
-#else /* GC_AIX_THREADS */
-
-/* Caller holds allocation lock.	*/
-void GC_stop_world()
-{
-    pthread_t my_thread = pthread_self();
-    register int i;
-    register GC_thread p;
-    register int result;
-    struct timespec timeout;
-    
-    GC_ASSERT(I_HOLD_LOCK());
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> id != my_thread) {
-            if (p -> flags & FINISHED) {
-		p -> stop = STOPPED;
-		continue;
-	    }
-	    p -> stop = PLEASE_STOP;
-            result = pthread_kill(p -> id, SIG_SUSPEND);
-	    /* GC_printf1("Sent signal to 0x%x\n", p -> id); */
-	    switch(result) {
-                case ESRCH:
-                    /* Not really there anymore.  Possible? */
-                    p -> stop = STOPPED;
-                    break;
-                case 0:
-                    break;
-                default:
-                    ABORT("pthread_kill failed");
-            }
-        }
-      }
-    }
-    pthread_mutex_lock(&GC_suspend_lock);
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        while (p -> id != my_thread && p -> stop != STOPPED) {
-	    clock_gettime(CLOCK_REALTIME, &timeout);
-            timeout.tv_nsec += 50000000; /* 50 msecs */
-            if (timeout.tv_nsec >= 1000000000) {
-                timeout.tv_nsec -= 1000000000;
-                ++timeout.tv_sec;
-            }
-            result = pthread_cond_timedwait(&GC_suspend_ack_cv,
-					    &GC_suspend_lock,
-                                            &timeout);
-            if (result == ETIMEDOUT) {
-                /* Signal was lost or misdirected.  Try again.      */
-                /* Duplicate signals should be benign.              */
-                result = pthread_kill(p -> id, SIG_SUSPEND);
-	    }
-	}
-      }
-    }
-    pthread_mutex_unlock(&GC_suspend_lock);
-    /* GC_printf1("World stopped 0x%x\n", pthread_self()); */
-}
-
-/* Caller holds allocation lock.	*/
-void GC_start_world()
-{
-    GC_thread p;
-    unsigned i;
-
-    /* GC_printf0("World starting\n"); */
-    GC_ASSERT(I_HOLD_LOCK());
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-	p -> stop = NOT_STOPPED;
-      }
-    }
-    pthread_mutex_lock(&GC_suspend_lock);
-    /* All other threads are at pthread_cond_wait in signal handler.	*/
-    /* Otherwise we couldn't have acquired the lock.			*/
-    pthread_mutex_unlock(&GC_suspend_lock);
-    pthread_cond_broadcast(&GC_continue_cv);
-}
-
-#endif /* GC_AIX_THREADS */
-
-
-/* We hold allocation lock.  Should do exactly the right thing if the	*/
-/* world is stopped.  Should not fail if it isn't.			*/
-void GC_push_all_stacks()
-{
-    register int i;
-    register GC_thread p;
-    register ptr_t hot, cold;
-    pthread_t me = pthread_self();
-    
-    /* GC_init() should have been called before GC_push_all_stacks is
-     * invoked, and GC_init calls GC_thr_init(), which sets
-     * GC_thr_initialized. */
-    GC_ASSERT(GC_thr_initialized);
-
-    /* GC_printf1("Pushing stacks from thread 0x%x\n", me); */
-    GC_ASSERT(I_HOLD_LOCK());
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> flags & FINISHED) continue;
-	cold = p->stack_cold;
-	if (!cold) cold=GC_stackbottom; /* 0 indicates 'original stack' */
-        if (pthread_equal(p -> id, me)) {
-	    hot = GC_approx_sp();
-	} else {
-#        ifdef GC_AIX_THREADS
-          /* AIX doesn't use signals to suspend, so we need to get an */
-	  /* accurate hot stack pointer.			      */
-	  /* See http://publib16.boulder.ibm.com/pseries/en_US/libs/basetrf1/pthread_getthrds_np.htm */
-          pthread_t id = p -> id;
-          struct __pthrdsinfo pinfo;
-          int regbuf[64];
-          int val = sizeof(regbuf);
-          int retval = pthread_getthrds_np(&id, PTHRDSINFO_QUERY_ALL, &pinfo,
-			  		   sizeof(pinfo), regbuf, &val);
-          if (retval != 0) {
-	    printf("ERROR: pthread_getthrds_np() failed in GC\n");
-	    abort();
-	  }
-	  /* according to the AIX ABI, 
-	     "the lowest possible valid stack address is 288 bytes (144 + 144)
-	     less than the current value of the stack pointer.  Functions may
-	     use this stack space as volatile storage which is not preserved
-	     across function calls."
-	     ftp://ftp.penguinppc64.org/pub/people/amodra/PPC-elf64abi.txt.gz
-	  */
-          hot = (ptr_t)(unsigned long)pinfo.__pi_ustk-288;
-	  cold = (ptr_t)pinfo.__pi_stackend; /* more precise */
-          /* push the registers too, because they won't be on stack */
-          GC_push_all_eager((ptr_t)&pinfo.__pi_context,
-			    (ptr_t)((&pinfo.__pi_context)+1));
-          GC_push_all_eager((ptr_t)regbuf, ((ptr_t)regbuf)+val);
-#	 else
-              hot = p -> stack_hot;
-#	 endif
-	}
-#	ifdef STACK_GROWS_UP
-          GC_push_all_stack(cold, hot);
-#	else
- /* printf("thread 0x%x: hot=0x%08x cold=0x%08x\n", p -> id, hot, cold); */
-          GC_push_all_stack(hot, cold);
-#	endif
-      }
-    }
-}
-
-
-/* We hold the allocation lock.	*/
-void GC_thr_init()
-{
-    GC_thread t;
-    struct sigaction act;
-
-    if (GC_thr_initialized) return;
-    GC_ASSERT(I_HOLD_LOCK());
-    GC_thr_initialized = TRUE;
-#ifndef GC_AIX_THREADS
-    (void) sigaction(SIG_SUSPEND, 0, &act);
-    if (act.sa_handler != SIG_DFL)
-    	ABORT("Previously installed SIG_SUSPEND handler");
-    /* Install handler.	*/
-	act.sa_handler = GC_suspend_handler;
-	act.sa_flags = SA_RESTART;
-	(void) sigemptyset(&act.sa_mask);
-        if (0 != sigaction(SIG_SUSPEND, &act, 0))
-	    ABORT("Failed to install SIG_SUSPEND handler");
-#endif
-    /* Add the initial thread, so we can stop it.	*/
-      t = GC_new_thread(pthread_self());
-      /* use '0' to indicate GC_stackbottom, since GC_init() has not
-       * completed by the time we are called (from GC_init_inner()) */
-      t -> stack_cold = 0; /* the original stack. */
-      t -> stack_hot = (ptr_t)(&t);
-      t -> flags = DETACHED;
-}
-
-int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)
-{
-    sigset_t fudged_set;
-    
-#ifdef GC_AIX_THREADS
-    return(pthread_sigmask(how, set, oset));
-#endif
-
-    if (set != NULL && (how == SIG_BLOCK || how == SIG_SETMASK)) {
-        fudged_set = *set;
-        sigdelset(&fudged_set, SIG_SUSPEND);
-        set = &fudged_set;
-    }
-    return(pthread_sigmask(how, set, oset));
-}
-
-struct start_info {
-    void *(*start_routine)(void *);
-    void *arg;
-    word flags;
-    pthread_mutex_t registeredlock;
-    pthread_cond_t registered;     
-    int volatile registereddone;
-};
-
-void GC_thread_exit_proc(void *arg)
-{
-    GC_thread me;
-
-    LOCK();
-    me = GC_lookup_thread(pthread_self());
-    me -> flags |= FINISHED;
-    /* reclaim DETACHED thread right away; otherwise wait until join() */
-    if (me -> flags & DETACHED) {
-	GC_delete_gc_thread(pthread_self(), me);
-    }
-    UNLOCK();
-}
-
-int GC_pthread_join(pthread_t thread, void **retval)
-{
-    int result;
-    GC_thread thread_gc_id;
-    
-    LOCK();
-    thread_gc_id = GC_lookup_thread(thread);
-    /* This is guaranteed to be the intended one, since the thread id	*/
-    /* cant have been recycled by pthreads.				*/
-    UNLOCK();
-    GC_ASSERT(!(thread_gc_id->flags & DETACHED));
-    result = pthread_join(thread, retval);
-    /* Some versions of the Irix pthreads library can erroneously 	*/
-    /* return EINTR when the call succeeds.				*/
-	if (EINTR == result) result = 0;
-    GC_ASSERT(thread_gc_id->flags & FINISHED);
-    LOCK();
-    /* Here the pthread thread id may have been recycled. */
-    GC_delete_gc_thread(thread, thread_gc_id);
-    UNLOCK();
-    return result;
-}
-
-void * GC_start_routine(void * arg)
-{
-    int dummy;
-    struct start_info * si = arg;
-    void * result;
-    GC_thread me;
-    pthread_t my_pthread;
-    void *(*start)(void *);
-    void *start_arg;
-
-    my_pthread = pthread_self();
-    /* If a GC occurs before the thread is registered, that GC will	*/
-    /* ignore this thread.  That's fine, since it will block trying to  */
-    /* acquire the allocation lock, and won't yet hold interesting 	*/
-    /* pointers.							*/
-    LOCK();
-    /* We register the thread here instead of in the parent, so that	*/
-    /* we don't need to hold the allocation lock during pthread_create. */
-    /* Holding the allocation lock there would make REDIRECT_MALLOC	*/
-    /* impossible.  It probably still doesn't work, but we're a little  */
-    /* closer ...							*/
-    /* This unfortunately means that we have to be careful the parent	*/
-    /* doesn't try to do a pthread_join before we're registered.	*/
-    me = GC_new_thread(my_pthread);
-    me -> flags = si -> flags;
-    me -> stack_cold = (ptr_t) &dummy; /* this now the 'start of stack' */
-    me -> stack_hot = me->stack_cold;/* this field should always be sensible */
-    UNLOCK();
-    start = si -> start_routine;
-    start_arg = si -> arg;
-
-    pthread_mutex_lock(&(si->registeredlock));
-    si->registereddone = 1;
-    pthread_cond_signal(&(si->registered));
-    pthread_mutex_unlock(&(si->registeredlock));
-    /* si went away as soon as we did this unlock */
-
-    pthread_cleanup_push(GC_thread_exit_proc, 0);
-    result = (*start)(start_arg);
-    me -> status = result;
-    pthread_cleanup_pop(1);
-	/* This involves acquiring the lock, ensuring that we can't exit */
-	/* while a collection that thinks we're alive is trying to stop  */
-	/* us.								 */
-    return(result);
-}
-
-int
-GC_pthread_create(pthread_t *new_thread,
-		  const pthread_attr_t *attr,
-                  void *(*start_routine)(void *), void *arg)
-{
-    int result;
-    GC_thread t;
-    int detachstate;
-    word my_flags = 0;
-    struct start_info * si;
-    	/* This is otherwise saved only in an area mmapped by the thread */
-    	/* library, which isn't visible to the collector.		 */
-
-    LOCK();
-    /* GC_INTERNAL_MALLOC implicitly calls GC_init() if required */
-    si = (struct start_info *)GC_INTERNAL_MALLOC(sizeof(struct start_info),
-						 NORMAL);
-    GC_ASSERT(GC_thr_initialized); /* initialized by GC_init() */
-    UNLOCK();
-    if (0 == si) return(ENOMEM);
-    pthread_mutex_init(&(si->registeredlock), NULL);
-    pthread_cond_init(&(si->registered),NULL);
-    pthread_mutex_lock(&(si->registeredlock));
-    si -> start_routine = start_routine;
-    si -> arg = arg;
-
-    pthread_attr_getdetachstate(attr, &detachstate);
-    if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;
-    si -> flags = my_flags;
-    result = pthread_create(new_thread, attr, GC_start_routine, si); 
-
-    /* Wait until child has been added to the thread table.		*/
-    /* This also ensures that we hold onto si until the child is done	*/
-    /* with it.  Thus it doesn't matter whether it is otherwise		*/
-    /* visible to the collector.					*/
-
-    if (0 == result) {
-      si->registereddone = 0;
-      while (!si->registereddone) 
-        pthread_cond_wait(&(si->registered), &(si->registeredlock));
-    }
-    pthread_mutex_unlock(&(si->registeredlock));
-
-    pthread_cond_destroy(&(si->registered));
-    pthread_mutex_destroy(&(si->registeredlock));
-    LOCK();
-    GC_INTERNAL_FREE(si);
-    UNLOCK();
-
-    return(result);
-}
-
-/* For now we use the pthreads locking primitives on HP/UX */
-
-VOLATILE GC_bool GC_collecting = 0; /* A hint that we're in the collector and       */
-                        /* holding the allocation lock for an           */
-                        /* extended period.                             */
-
-/* Reasonably fast spin locks.  Basically the same implementation */
-/* as STL alloc.h.						  */
-
-#define SLEEP_THRESHOLD 3
-
-volatile unsigned int GC_allocate_lock = 0;
-#define GC_TRY_LOCK() !GC_test_and_set(&GC_allocate_lock)
-#define GC_LOCK_TAKEN GC_allocate_lock
-
-void GC_lock()
-{
-#   define low_spin_max 30  /* spin cycles if we suspect uniprocessor */
-#   define high_spin_max 1000 /* spin cycles for multiprocessor */
-    static unsigned spin_max = low_spin_max;
-    unsigned my_spin_max;
-    static unsigned last_spins = 0;
-    unsigned my_last_spins;
-    volatile unsigned junk;
-#   define PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk
-    int i;
-
-    if (GC_TRY_LOCK()) {
-        return;
-    }
-    junk = 0;
-    my_spin_max = spin_max;
-    my_last_spins = last_spins;
-    for (i = 0; i < my_spin_max; i++) {
-        if (GC_collecting) goto yield;
-        if (i < my_last_spins/2 || GC_LOCK_TAKEN) {
-            PAUSE; 
-            continue;
-        }
-        if (GC_TRY_LOCK()) {
-	    /*
-             * got it!
-             * Spinning worked.  Thus we're probably not being scheduled
-             * against the other process with which we were contending.
-             * Thus it makes sense to spin longer the next time.
-	     */
-            last_spins = i;
-            spin_max = high_spin_max;
-            return;
-        }
-    }
-    /* We are probably being scheduled against the other process.  Sleep. */
-    spin_max = low_spin_max;
-yield:
-    for (i = 0;; ++i) {
-        if (GC_TRY_LOCK()) {
-            return;
-        }
-        if (i < SLEEP_THRESHOLD) {
-            sched_yield();
-	} else {
-	    struct timespec ts;
-	
-	    if (i > 26) i = 26;
-			/* Don't wait for more than about 60msecs, even	*/
-			/* under extreme contention.			*/
-	    ts.tv_sec = 0;
-	    ts.tv_nsec = 1 << i;
-	    nanosleep(&ts, 0);
-	}
-    }
-}
-
-# else  /* !GC_IRIX_THREADS && !GC_AIX_THREADS */
-
-#ifndef LINT
-  int GC_no_Irix_threads;
-#endif
-
-# endif /* IRIX_THREADS */
-
diff -urN old/boehm-gc/allchblk.c src/boehm-gc/allchblk.c
--- old/boehm-gc/allchblk.c	2005-02-09 22:33:02.000000000 +0100
+++ src/boehm-gc/allchblk.c	2006-08-28 19:14:18.110718000 +0200
@@ -285,8 +285,8 @@
 	GET_HDR(hhdr -> hb_prev, phdr);
 	phdr -> hb_next = hhdr -> hb_next;
     }
+    FREE_ASSERT(GC_free_bytes[index] >= hhdr -> hb_sz);
     INCR_FREE_BYTES(index, - (signed_word)(hhdr -> hb_sz));
-    FREE_ASSERT(GC_free_bytes[index] >= 0);
     if (0 != hhdr -> hb_next) {
 	hdr * nhdr;
 	GC_ASSERT(!IS_FORWARDING_ADDR_OR_NIL(NHDR(hhdr)));
diff -urN old/boehm-gc/alloc.c src/boehm-gc/alloc.c
--- old/boehm-gc/alloc.c	2004-08-28 02:41:41.000000000 +0200
+++ src/boehm-gc/alloc.c	2006-08-28 19:14:18.110718000 +0200
@@ -92,6 +92,16 @@
 
 # include "version.h"
 
+#if defined(SAVE_CALL_CHAIN) && \
+	!(defined(REDIRECT_MALLOC) && defined(GC_HAVE_BUILTIN_BACKTRACE))
+#   define SAVE_CALL_CHAIN_IN_GC
+    /* This is only safe if the call chain save mechanism won't end up	*/
+    /* calling GC_malloc.  The GNU C library documentation suggests 	*/
+    /* that backtrace doesn't use malloc, but at least the initial	*/
+    /* call in some versions does seem to invoke the dynamic linker,	*/
+    /* which uses malloc.						*/
+#endif
+
 /* some more variables */
 
 extern signed_word GC_mem_found;  /* Number of reclaimed longwords	*/
@@ -196,7 +206,8 @@
     	/* had been reallocated this round. Finalization is user	*/
     	/* visible progress.  And if we don't count this, we have	*/
     	/* stability problems for programs that finalize all objects.	*/
-    result += GC_words_wasted;
+    if ((GC_words_wasted >> 3) < result)
+        result += GC_words_wasted;
      	/* This doesn't reflect useful work.  But if there is lots of	*/
      	/* new fragmentation, the same is probably true of the heap,	*/
      	/* and the collection will be correspondingly cheaper.		*/
@@ -221,6 +232,8 @@
 {
 #   define NWORDS 64
     word frames[NWORDS];
+    /* Some compilers will warn that frames was set but never used.	*/
+    /* That's the whole idea ...					*/
     register int i;
     
     for (i = 0; i < NWORDS; i++) frames[i] = 0;
@@ -293,7 +306,7 @@
 #	endif
         if (GC_stopped_mark(GC_time_limit == GC_TIME_UNLIMITED? 
 			    GC_never_stop_func : GC_timeout_stop_func)) {
-#           ifdef SAVE_CALL_CHAIN
+#           ifdef SAVE_CALL_CHAIN_IN_GC
                 GC_save_callers(GC_last_stack);
 #           endif
             GC_finish_collection();
@@ -358,7 +371,7 @@
 	}
     GC_invalidate_mark_state();  /* Flush mark stack.	*/
     GC_clear_marks();
-#   ifdef SAVE_CALL_CHAIN
+#   ifdef SAVE_CALL_CHAIN_IN_GC
         GC_save_callers(GC_last_stack);
 #   endif
     GC_is_full_gc = TRUE;
@@ -413,7 +426,7 @@
     	for (i = GC_deficit; i < GC_RATE*n; i++) {
     	    if (GC_mark_some((ptr_t)0)) {
     	        /* Need to finish a collection */
-#     		ifdef SAVE_CALL_CHAIN
+#     		ifdef SAVE_CALL_CHAIN_IN_GC
         	    GC_save_callers(GC_last_stack);
 #     		endif
 #		ifdef PARALLEL_MARK
@@ -929,7 +942,7 @@
 #   endif
     expansion_slop = WORDS_TO_BYTES(min_words_allocd()) + 4*MAXHINCR*HBLKSIZE;
     if (GC_last_heap_addr == 0 && !((word)space & SIGNB)
-        || GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space) {
+        || (GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space)) {
         /* Assume the heap is growing up */
         GC_greatest_plausible_heap_addr =
             (GC_PTR)GC_max((ptr_t)GC_greatest_plausible_heap_addr,
@@ -992,7 +1005,7 @@
 GC_bool ignore_off_page;
 {
     if (!GC_incremental && !GC_dont_gc &&
-	(GC_dont_expand && GC_words_allocd > 0 || GC_should_collect())) {
+	((GC_dont_expand && GC_words_allocd > 0) || GC_should_collect())) {
       GC_gcollect_inner();
     } else {
       word blocks_to_get = GC_heapsize/(HBLKSIZE*GC_free_space_divisor)
@@ -1001,6 +1014,9 @@
       if (blocks_to_get > MAXHINCR) {
           word slop;
           
+	  /* Get the minimum required to make it likely that we		*/
+	  /* can satisfy the current request in the presence of black-	*/
+	  /* listing.  This will probably be more than MAXHINCR.	*/
           if (ignore_off_page) {
               slop = 4;
           } else {
diff -urN old/boehm-gc/alpha_mach_dep.S src/boehm-gc/alpha_mach_dep.S
--- old/boehm-gc/alpha_mach_dep.S	2003-07-28 05:46:07.000000000 +0200
+++ src/boehm-gc/alpha_mach_dep.S	2006-08-28 19:14:18.110718000 +0200
@@ -1,4 +1,3 @@
- # $Id: alpha_mach_dep.s,v 1.2 1993/01/18 22:54:51 dosser Exp $
 	.arch ev6
 
         .text
@@ -12,13 +11,13 @@
         .mask   0x04000000, 0
         .frame  $sp, 16, $26, 0
 
- # $0		integer result
- # $1-$8	temp regs - not preserved cross calls
- # $9-$15	call saved regs
- # $16-$21	argument regs - not preserved cross calls
- # $22-$28	temp regs - not preserved cross calls
- # $29		global pointer - not preserved cross calls
- # $30		stack pointer
+/* $0		integer result                                                */
+/* $1-$8	temp regs - not preserved cross calls                         */
+/* $9-$15	call saved regs                                               */
+/* $16-$21	argument regs - not preserved cross calls                     */
+/* $22-$28	temp regs - not preserved cross calls                         */
+/* $29		global pointer - not preserved cross calls                    */
+/* $30		stack pointer                                                 */
 
 # define call_push(x)			\
 	mov   x, $16;			\
@@ -33,12 +32,12 @@
         call_push($14)
         call_push($15)
 
- # $f0-$f1	floating point results
- # $f2-$f9	call saved regs
- # $f10-$f30	temp regs - not preserved cross calls
+/* $f0-$f1	floating point results                                        */
+/* $f2-$f9	call saved regs                                               */
+/* $f10-$f30	temp regs - not preserved cross calls                         */
 
-	# Use the most efficient transfer method for this hardware.
-	# Bit 1 detects the FIX extension, which includes ftoit.
+	/* Use the most efficient transfer method for this hardware. */
+	/* Bit 1 detects the FIX extension, which includes ftoit. */
 	amask	2, $0
 	bne	$0, $use_stack
 
diff -urN old/boehm-gc/ChangeLog src/boehm-gc/ChangeLog
--- old/boehm-gc/ChangeLog	2007-02-14 06:12:26.000000000 +0100
+++ src/boehm-gc/ChangeLog	2007-02-14 23:10:06.000000000 +0100
@@ -1,3 +1,85 @@
+2006-08-21  Bryce McKinlay  <mckinlay@redhat.com>
+	
+	PR libgcj/13212:
+	* configure.ac: Check for pthread_getattr_np(). Remove
+	GC_PTHREAD_SYM_VERSION detection.
+	* include/gc.h (GC_register_my_thread, GC_unregister_my_thread,
+	GC_get_thread_stack_base): New declarations.
+	* pthread_support.c (GC_register_my_thread, GC_unregister_my_thread,
+	GC_get_thread_stack_base): New functions.
+	(GC_delete_thread): Don't try to free the first_thread.
+	* misc.c (GC_init_inner): Use GC_get_thread_stack_base() if possible.
+	(pthread_create_, constr): Removed.
+	(pthread_create): Don't rename.
+	* include/gc_ext_config.h.in: Rebuilt.
+	* include/gc_pthread_redirects.h (pthread_create): Define 
+	unconditionally.
+	* include/gc_config.h.in: Rebuilt.
+	* configure: Rebuilt.
+
+2006-06-21  Keith Seitz  <keiths@redhat.com>
+
+	* pthread_stop_world.c (GC_suspend_handler): Redirect to suspension
+	routine if signal is received and thread is flagged SUSPENDED.
+	(suspend_self): New function.
+	(GC_suspend_thread): New function.
+	(GC_resume_thread): New function.
+	* include/gc.h (GC_suspend_thread): Declare.
+	(GC_resumet_thread): Declare.
+	* include/private/pthread_support.h (SUSPENDED): New GC_thread
+	flag.
+
+2006-06-20  Ranjit Mathew  <rmathew@gcc.gnu.org>
+	
+	Backport Windows 9x/ME VirtualQuery() fix from GC 6.7.
+	* os_dep.c (GC_wnt): Define.
+	(GC_init_win32): Set GC_wnt.
+	* dyn_load.c (GC_register_dynamic_libraries): Consider MEM_PRIVATE
+	sections also on Windows 9x/ME.
+
+2006-06-02  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.ac: Define HAS_PPC_THREAD_STATE_R0,
+	HAS_PPC_THREAD_STATE___R0, HAS_PPC_THREAD_STATE64_R0,
+	HAS_PPC_THREAD_STATE64___R0, HAS_I386_THREAD_STATE_EAX,
+	HAS_I386_THREAD_STATE___EAX.
+	* configure: Regenerate.
+	* include/gc_config.h.in: Regenerate.
+	* darwin_stop_world.c (PPC_RED_ZONE_SIZE): Use standard Darwin
+	macro names to determine value.
+	(THREAD_STATE): New.
+	(THREAD_FLD): New.
+	(GC_push_all_stacks): Use THREAD_STATE and THREAD_FLD in both versions.
+
+ 2006-05-24  Release Manager
+ 
+ 	* GCC 4.1.1 released.
+ 
+2006-05-24  Carlos O'Donell  <carlos@codesourcery.com>
+
+	* Makefile.am: Add install-html target. 
+	* Makefile.in: Regenerate.
+	* aclocal.m4: Regenerate.
+	* include/Makefile.in: Regenerate.
+
+2006-03-07  Andrew Haley  <aph@redhat.com>
+
+	* dyn_load.c (GC_has_static_roots): Declare.
+	(GC_register_dynlib_callback): Call GC_has_static_roots.
+
+ 2006-04-11  Bryce McKinlay  <mckinlay@redhat.com>
+ 
+ 	* darwin_stop_world.c (GC_push_all_stacks, GC_stop_world,
+ 	GC_start_world): Call vm_deallocate to free act_list. Fix from
+ 	Bruce Mitchener.
+ 
+2006-03-24  Andreas Tobler  <a.tobler@schweiz.ch>
+	John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* configure.ac (THREADS): Add REENTRANT for *-*-hpux11*.
+	Warn about POSIX threads not being supported for *-*-hpux10*.
+	* configure: Regenerate.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
@@ -20,6 +102,12 @@
 
 	* pthread_support.c: Conditionally include dlfcn.h.
 
+2006-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* ia64_save_regs_in_stack.s: Moved to...
+	* ia64_save_regs_in_stack.S: ... this.  Add .note.GNU-stack
+	on Linux.
+
 2006-02-06  Jakub Jelinek  <jakub@redhat.com>
 	    Anthony Green  <green@redhat.com>
 	    Tom Tromey  <tromey@redhat.com>
diff -urN old/boehm-gc/configure src/boehm-gc/configure
--- old/boehm-gc/configure	2006-05-25 01:46:15.000000000 +0200
+++ src/boehm-gc/configure	2006-08-28 19:17:32.350718000 +0200
@@ -1767,7 +1767,7 @@
 
 # Define the identity of the package.
  PACKAGE=gc
- VERSION=6.3
+ VERSION=6.6
 
 
 # Some tools Automake needs.
@@ -5409,9 +5409,9 @@
 _ACEOF
 
 	;;
-     *-*-hpux*)
-	{ echo "$as_me:$LINENO: WARNING: \"Only HP/UX 11 threads are supported.\"" >&5
-echo "$as_me: WARNING: \"Only HP/UX 11 threads are supported.\"" >&2;}
+     *-*-hpux11*)
+	{ echo "$as_me:$LINENO: WARNING: \"Only HP-UX 11 POSIX threads are supported.\"" >&5
+echo "$as_me: WARNING: \"Only HP-UX 11 POSIX threads are supported.\"" >&2;}
 
 cat >>confdefs.h <<\_ACEOF
 #define GC_HPUX_THREADS 1
@@ -5433,6 +5433,16 @@
 _ACEOF
 
 	THREADLIBS="-lpthread -lrt"
+	# HPUX needs REENTRANT for the _r calls.
+
+cat >>confdefs.h <<\_ACEOF
+#define _REENTRANT 1
+_ACEOF
+
+	;;
+     *-*-hpux10*)
+	{ echo "$as_me:$LINENO: WARNING: \"Only HP-UX 11 POSIX threads are supported.\"" >&5
+echo "$as_me: WARNING: \"Only HP-UX 11 POSIX threads are supported.\"" >&2;}
 	;;
      *-*-freebsd*)
 	{ echo "$as_me:$LINENO: WARNING: \"FreeBSD does not yet fully support threads with Boehm GC.\"" >&5
@@ -5486,107 +5496,783 @@
 #define PARALLEL_MARK 1
 _ACEOF
 
-	fi
-	;;
-     *-*-osf*)
+	fi
+	;;
+     *-*-osf*)
+
+cat >>confdefs.h <<\_ACEOF
+#define GC_OSF1_THREADS 1
+_ACEOF
+
+        if test "${enable_parallel_mark}" = yes; then
+	  cat >>confdefs.h <<\_ACEOF
+#define PARALLEL_MARK 1
+_ACEOF
+
+	  cat >>confdefs.h <<\_ACEOF
+#define THREAD_LOCAL_ALLOC 1
+_ACEOF
+
+	  # May want to enable it in other cases, too.
+	  # Measurements havent yet been done.
+	fi
+	AM_CPPFLAGS="$AM_CPPFLAGS -pthread"
+	THREADLIBS="-lpthread -lrt"
+	;;
+    esac
+    ;;
+ win32)
+    cat >>confdefs.h <<\_ACEOF
+#define GC_WIN32_THREADS 1
+_ACEOF
+
+            ;;
+ dgux386)
+    THREADS=dgux386
+echo "$as_me:$LINENO: result: $THREADLIBS" >&5
+echo "${ECHO_T}$THREADLIBS" >&6
+    # Use pthread GCC  switch
+    THREADLIBS=-pthread
+    if test "${enable_parallel_mark}" = yes; then
+        cat >>confdefs.h <<\_ACEOF
+#define PARALLEL_MARK 1
+_ACEOF
+
+    fi
+    cat >>confdefs.h <<\_ACEOF
+#define THREAD_LOCAL_ALLOC 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define GC_DGUX386_THREADS 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define DGUX_THREADS 1
+_ACEOF
+
+    # Enable _POSIX4A_DRAFT10_SOURCE with flag -pthread
+    AM_CPPFLAGS="-pthread $AM_CPPFLAGS"
+    ;;
+ aix)
+    THREADS=posix
+    THREADLIBS=-lpthread
+    cat >>confdefs.h <<\_ACEOF
+#define GC_AIX_THREADS 1
+_ACEOF
+
+    cat >>confdefs.h <<\_ACEOF
+#define _REENTRANT 1
+_ACEOF
+
+    ;;
+ decosf1 | irix | mach | os2 | solaris | dce | vxworks)
+    { { echo "$as_me:$LINENO: error: thread package $THREADS not yet supported" >&5
+echo "$as_me: error: thread package $THREADS not yet supported" >&2;}
+   { (exit 1); exit 1; }; }
+    ;;
+ *)
+    { { echo "$as_me:$LINENO: error: $THREADS is an unknown thread package" >&5
+echo "$as_me: error: $THREADS is an unknown thread package" >&2;}
+   { (exit 1); exit 1; }; }
+    ;;
+esac
+
+
+case "$host" in
+   powerpc-*-darwin*)
+      powerpc_darwin=true
+      ;;
+esac
+
+
+if test x$powerpc_darwin = xtrue; then
+  POWERPC_DARWIN_TRUE=
+  POWERPC_DARWIN_FALSE='#'
+else
+  POWERPC_DARWIN_TRUE='#'
+  POWERPC_DARWIN_FALSE=
+fi
+
+
+# Darwin needs a few extra special tests to deal with variation in the
+# system headers.
+case "$host" in
+  powerpc*-*-darwin*)
+    echo "$as_me:$LINENO: checking for ppc_thread_state_t.r0" >&5
+echo $ECHO_N "checking for ppc_thread_state_t.r0... $ECHO_C" >&6
+if test "${ac_cv_member_ppc_thread_state_t_r0+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state_t ac_aggr;
+if (ac_aggr.r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state_t_r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state_t ac_aggr;
+if (sizeof ac_aggr.r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state_t_r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_member_ppc_thread_state_t_r0=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_ppc_thread_state_t_r0" >&5
+echo "${ECHO_T}$ac_cv_member_ppc_thread_state_t_r0" >&6
+if test $ac_cv_member_ppc_thread_state_t_r0 = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAS_PPC_THREAD_STATE_R0
+_ACEOF
+
+fi
+
+    echo "$as_me:$LINENO: checking for ppc_thread_state_t.__r0" >&5
+echo $ECHO_N "checking for ppc_thread_state_t.__r0... $ECHO_C" >&6
+if test "${ac_cv_member_ppc_thread_state_t___r0+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state_t ac_aggr;
+if (ac_aggr.__r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state_t___r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state_t ac_aggr;
+if (sizeof ac_aggr.__r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state_t___r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_member_ppc_thread_state_t___r0=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_ppc_thread_state_t___r0" >&5
+echo "${ECHO_T}$ac_cv_member_ppc_thread_state_t___r0" >&6
+if test $ac_cv_member_ppc_thread_state_t___r0 = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAS_PPC_THREAD_STATE___R0
+_ACEOF
+
+fi
+
+    echo "$as_me:$LINENO: checking for ppc_thread_state64_t.r0" >&5
+echo $ECHO_N "checking for ppc_thread_state64_t.r0... $ECHO_C" >&6
+if test "${ac_cv_member_ppc_thread_state64_t_r0+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state64_t ac_aggr;
+if (ac_aggr.r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state64_t_r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state64_t ac_aggr;
+if (sizeof ac_aggr.r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state64_t_r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_member_ppc_thread_state64_t_r0=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_ppc_thread_state64_t_r0" >&5
+echo "${ECHO_T}$ac_cv_member_ppc_thread_state64_t_r0" >&6
+if test $ac_cv_member_ppc_thread_state64_t_r0 = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAS_PPC_THREAD_STATE64_R0
+_ACEOF
+
+fi
+
+    echo "$as_me:$LINENO: checking for ppc_thread_state64_t.__r0" >&5
+echo $ECHO_N "checking for ppc_thread_state64_t.__r0... $ECHO_C" >&6
+if test "${ac_cv_member_ppc_thread_state64_t___r0+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state64_t ac_aggr;
+if (ac_aggr.__r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state64_t___r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static ppc_thread_state64_t ac_aggr;
+if (sizeof ac_aggr.__r0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_ppc_thread_state64_t___r0=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_member_ppc_thread_state64_t___r0=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_ppc_thread_state64_t___r0" >&5
+echo "${ECHO_T}$ac_cv_member_ppc_thread_state64_t___r0" >&6
+if test $ac_cv_member_ppc_thread_state64_t___r0 = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAS_PPC_THREAD_STATE64___R0
+_ACEOF
+
+fi
+
+    ;;
+  i?86*-*-darwin*)
+    echo "$as_me:$LINENO: checking for i386_thread_state_t.eax" >&5
+echo $ECHO_N "checking for i386_thread_state_t.eax... $ECHO_C" >&6
+if test "${ac_cv_member_i386_thread_state_t_eax+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static i386_thread_state_t ac_aggr;
+if (ac_aggr.eax)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_i386_thread_state_t_eax=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
+
+int
+main ()
+{
+static i386_thread_state_t ac_aggr;
+if (sizeof ac_aggr.eax)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_i386_thread_state_t_eax=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_member_i386_thread_state_t_eax=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_i386_thread_state_t_eax" >&5
+echo "${ECHO_T}$ac_cv_member_i386_thread_state_t_eax" >&6
+if test $ac_cv_member_i386_thread_state_t_eax = yes; then
 
 cat >>confdefs.h <<\_ACEOF
-#define GC_OSF1_THREADS 1
-_ACEOF
-
-        if test "${enable_parallel_mark}" = yes; then
-	  cat >>confdefs.h <<\_ACEOF
-#define PARALLEL_MARK 1
+#define HAS_I386_THREAD_STATE_EAX
 _ACEOF
 
-	  cat >>confdefs.h <<\_ACEOF
-#define THREAD_LOCAL_ALLOC 1
-_ACEOF
+fi
 
-	  # May want to enable it in other cases, too.
-	  # Measurements havent yet been done.
-	fi
-	AM_CPPFLAGS="$AM_CPPFLAGS -pthread"
-	THREADLIBS="-lpthread -lrt"
-	;;
-    esac
-    ;;
- win32)
-    cat >>confdefs.h <<\_ACEOF
-#define GC_WIN32_THREADS 1
+    echo "$as_me:$LINENO: checking for i386_thread_state_t.__eax" >&5
+echo $ECHO_N "checking for i386_thread_state_t.__eax... $ECHO_C" >&6
+if test "${ac_cv_member_i386_thread_state_t___eax+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
 _ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
 
-            ;;
- dgux386)
-    THREADS=dgux386
-echo "$as_me:$LINENO: result: $THREADLIBS" >&5
-echo "${ECHO_T}$THREADLIBS" >&6
-    # Use pthread GCC  switch
-    THREADLIBS=-pthread
-    if test "${enable_parallel_mark}" = yes; then
-        cat >>confdefs.h <<\_ACEOF
-#define PARALLEL_MARK 1
+int
+main ()
+{
+static i386_thread_state_t ac_aggr;
+if (ac_aggr.__eax)
+return 0;
+  ;
+  return 0;
+}
 _ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_i386_thread_state_t___eax=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-    fi
-    cat >>confdefs.h <<\_ACEOF
-#define THREAD_LOCAL_ALLOC 1
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
 _ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <mach/thread_status.h>
 
-
-cat >>confdefs.h <<\_ACEOF
-#define GC_DGUX386_THREADS 1
+int
+main ()
+{
+static i386_thread_state_t ac_aggr;
+if (sizeof ac_aggr.__eax)
+return 0;
+  ;
+  return 0;
+}
 _ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_i386_thread_state_t___eax=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+ac_cv_member_i386_thread_state_t___eax=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_i386_thread_state_t___eax" >&5
+echo "${ECHO_T}$ac_cv_member_i386_thread_state_t___eax" >&6
+if test $ac_cv_member_i386_thread_state_t___eax = yes; then
 
 cat >>confdefs.h <<\_ACEOF
-#define DGUX_THREADS 1
-_ACEOF
-
-    # Enable _POSIX4A_DRAFT10_SOURCE with flag -pthread
-    AM_CPPFLAGS="-pthread $AM_CPPFLAGS"
-    ;;
- aix)
-    THREADS=posix
-    THREADLIBS=-lpthread
-    cat >>confdefs.h <<\_ACEOF
-#define GC_AIX_THREADS 1
+#define HAS_I386_THREAD_STATE___EAX
 _ACEOF
 
-    cat >>confdefs.h <<\_ACEOF
-#define _REENTRANT 1
-_ACEOF
+fi
 
     ;;
- decosf1 | irix | mach | os2 | solaris | dce | vxworks)
-    { { echo "$as_me:$LINENO: error: thread package $THREADS not yet supported" >&5
-echo "$as_me: error: thread package $THREADS not yet supported" >&2;}
-   { (exit 1); exit 1; }; }
-    ;;
- *)
-    { { echo "$as_me:$LINENO: error: $THREADS is an unknown thread package" >&5
-echo "$as_me: error: $THREADS is an unknown thread package" >&2;}
-   { (exit 1); exit 1; }; }
-    ;;
-esac
-
-
-case "$host" in
-   powerpc-*-darwin*)
-      powerpc_darwin=true
-      ;;
+  *) ;;
 esac
 
-
-if test x$powerpc_darwin = xtrue; then
-  POWERPC_DARWIN_TRUE=
-  POWERPC_DARWIN_FALSE='#'
-else
-  POWERPC_DARWIN_TRUE='#'
-  POWERPC_DARWIN_FALSE=
-fi
-
-
 # We never want libdl on darwin. It is a fake libdl that just ends up making
 # dyld calls anyway
 case "$host" in
@@ -5759,6 +6445,119 @@
      ;;
 esac
 
+# Checks for pthreads functions
+#
+oldLIBS="$LIBS"
+LIBS="$LIBS $THREADLIBS"
+
+for ac_func in pthread_getattr_np
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+LIBS="$oldLIBS"
+
 # Configuration of machine-dependent code
 #
 # We don't set NO_EXECUTE_PERMISSION by default because gcj (and
@@ -6627,29 +7426,6 @@
 
 fi
 
-symver=
-case "$target" in
-  *-*-linux* )
-    cat > conftest.c <<EOF
-#include <pthread.h>
-void *tf (void *arg) { (void) arg; return NULL; }
-int main (void) { pthread_t th; pthread_create (&th, NULL, tf, NULL); return 0; }
-EOF
-    if $CC $CFLAGS -pthread -o conftest conftest.c > /dev/null 2>&1; then
-      symver=`readelf -s conftest 2> /dev/null | sed -n '/UND pthread_create@/{s/^.*@//;s/ .*$//;p;q}'`
-    fi
-    rm -f conftest conftest.c
-    ;;
-esac
-if test -n "$symver"; then
-
-cat >>confdefs.h <<_ACEOF
-#define GC_PTHREAD_SYM_VERSION "$symver"
-_ACEOF
-
-fi
-
-
 if test -n "$with_cross_host" &&
    test x"$with_cross_host" != x"no"; then
   toolexecdir='$(exec_prefix)/$(target_noncanonical)'
diff -urN old/boehm-gc/configure.ac src/boehm-gc/configure.ac
--- old/boehm-gc/configure.ac	2006-02-07 02:05:55.000000000 +0100
+++ src/boehm-gc/configure.ac	2006-08-28 19:17:32.340718000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 1999, 2000, 2001, 2002, 2003 by Red Hat, Inc. All rights reserved.
+# Copyright (c) 1999, 2000, 2001, 2002, 2003, 2006 by Red Hat, Inc. All rights reserved.
 # Copyright 2004 Nathanael Nerode
 # 
 # THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
@@ -36,7 +36,7 @@
 mkinstalldirs="`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs"
 AC_SUBST(mkinstalldirs)
 
-AM_INIT_AUTOMAKE(gc, 6.3, no-define)
+AM_INIT_AUTOMAKE(gc, 6.6, no-define)
 
 # The autoconf 2.5x version of the no-executables hack.
 GCC_NO_EXECUTABLES
@@ -140,8 +140,8 @@
 	AC_DEFINE(GC_AIX_THREADS,1,[support AIX threads])
 	AC_DEFINE(_REENTRANT,1)
 	;;
-     *-*-hpux*)
-	AC_MSG_WARN("Only HP/UX 11 threads are supported.")
+     *-*-hpux11*)
+	AC_MSG_WARN("Only HP-UX 11 POSIX threads are supported.")
 	AC_DEFINE(GC_HPUX_THREADS,1,[enables support for HP/UX 11 pthreads])
 	AC_DEFINE(_POSIX_C_SOURCE,199506L,[POSIX version of C Source])
 	if test "${enable_parallel_mark}" = yes; then
@@ -149,6 +149,11 @@
 	fi
 	AC_DEFINE(THREAD_LOCAL_ALLOC,1)
 	THREADLIBS="-lpthread -lrt"
+	# HPUX needs REENTRANT for the _r calls.
+	AC_DEFINE(_REENTRANT, 1, [Required define if using POSIX threads])
+	;;
+     *-*-hpux10*)
+	AC_MSG_WARN("Only HP-UX 11 POSIX threads are supported.")
 	;;
      *-*-freebsd*)
 	AC_MSG_WARN("FreeBSD does not yet fully support threads with Boehm GC.")
@@ -227,6 +232,39 @@
 esac
 AM_CONDITIONAL(POWERPC_DARWIN,test x$powerpc_darwin = xtrue)
 
+# Darwin needs a few extra special tests to deal with variation in the
+# system headers.
+case "$host" in
+  powerpc*-*-darwin*)
+    AC_CHECK_MEMBER(ppc_thread_state_t.r0,
+      AC_DEFINE(HAS_PPC_THREAD_STATE_R0,,[ppc_thread_state_t has field r0]),,
+      [#include <mach/thread_status.h>])
+    AC_CHECK_MEMBER(ppc_thread_state_t.__r0,
+      AC_DEFINE(HAS_PPC_THREAD_STATE___R0,,dnl
+        [ppc_thread_state_t has field __r0]),,
+      [#include <mach/thread_status.h>])
+    AC_CHECK_MEMBER(ppc_thread_state64_t.r0,
+      AC_DEFINE(HAS_PPC_THREAD_STATE64_R0,,dnl
+        [ppc_thread_state64_t has field r0]),,
+      [#include <mach/thread_status.h>])
+    AC_CHECK_MEMBER(ppc_thread_state64_t.__r0,
+      AC_DEFINE(HAS_PPC_THREAD_STATE64___R0,,dnl
+        [ppc_thread_state64_t has field __r0]),,
+      [#include <mach/thread_status.h>])
+    ;;
+  i?86*-*-darwin*)
+    AC_CHECK_MEMBER(i386_thread_state_t.eax,
+      AC_DEFINE(HAS_I386_THREAD_STATE_EAX,,dnl
+        [i386_thread_state_t has field eax]),,
+      [#include <mach/thread_status.h>])
+    AC_CHECK_MEMBER(i386_thread_state_t.__eax,
+      AC_DEFINE(HAS_I386_THREAD_STATE___EAX,,dnl
+        [i386_thread_state_t has field __eax]),,
+      [#include <mach/thread_status.h>])
+    ;;
+  *) ;;
+esac
+
 # We never want libdl on darwin. It is a fake libdl that just ends up making
 # dyld calls anyway
 case "$host" in
@@ -291,6 +329,13 @@
      ;;
 esac
 
+# Checks for pthreads functions
+#
+oldLIBS="$LIBS"
+LIBS="$LIBS $THREADLIBS"
+AC_CHECK_FUNCS([pthread_getattr_np])
+LIBS="$oldLIBS"
+
 # Configuration of machine-dependent code
 #
 # We don't set NO_EXECUTE_PERMISSION by default because gcj (and
@@ -450,25 +495,6 @@
   AC_DEFINE(USE_MMAP, 1, [use MMAP instead of sbrk to get new memory])
 fi
 
-symver=
-case "$target" in
-  *-*-linux* )
-    cat > conftest.c <<EOF
-#include <pthread.h>
-void *tf (void *arg) { (void) arg; return NULL; }
-int main (void) { pthread_t th; pthread_create (&th, NULL, tf, NULL); return 0; }
-EOF
-    if $CC $CFLAGS -pthread -o conftest conftest.c > /dev/null 2>&1; then
-      symver=`readelf -s conftest 2> /dev/null | sed -n '/UND pthread_create@/{s/^.*@//;s/ .*$//;p;q}'`
-    fi
-    rm -f conftest conftest.c
-    ;;
-esac
-if test -n "$symver"; then
-  AC_DEFINE_UNQUOTED(GC_PTHREAD_SYM_VERSION, "$symver", [symbol version of pthread_create])
-fi
-
-
 if test -n "$with_cross_host" &&
    test x"$with_cross_host" != x"no"; then
   toolexecdir='$(exec_prefix)/$(target_noncanonical)'
diff -urN old/boehm-gc/cord/cordprnt.c src/boehm-gc/cord/cordprnt.c
--- old/boehm-gc/cord/cordprnt.c	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/cord/cordprnt.c	2006-08-28 19:14:18.110718000 +0200
@@ -59,7 +59,7 @@
     register int result = 0;
     register int current_number = 0;
     register int saw_period = 0;
-    register int saw_number;
+    register int saw_number = 0;
     register int chars_so_far = 0;
     register char current;
     
@@ -243,7 +243,7 @@
 			    char * str = va_arg(args, char *);
 			    register char c;
 
-			    while (c = *str++) {
+			    while ((c = *str++)) {
 			        CORD_ec_append(result, c);
 			    }
 			    goto done;
@@ -320,7 +320,7 @@
             	    if (buf != result[0].ec_bufptr) {
             	        register char c;
 
-			while (c = *buf++) {
+			while ((c = *buf++)) {
 			    CORD_ec_append(result, c);
 		        }
 		    } else {
diff -urN old/boehm-gc/cord/cordtest.c src/boehm-gc/cord/cordtest.c
--- old/boehm-gc/cord/cordtest.c	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/cord/cordtest.c	2006-08-28 19:14:18.120718000 +0200
@@ -221,7 +221,7 @@
     if (CORD_cmp(result, result2) != 0)ABORT("CORD_sprintf goofed 5");
 }
 
-main()
+int main()
 {
 #   ifdef THINK_C
         printf("cordtest:\n");
diff -urN old/boehm-gc/darwin_stop_world.c src/boehm-gc/darwin_stop_world.c
--- old/boehm-gc/darwin_stop_world.c	2006-04-11 23:55:41.000000000 +0200
+++ src/boehm-gc/darwin_stop_world.c	2006-08-28 19:14:18.120718000 +0200
@@ -14,7 +14,44 @@
    Page 50: "If a leaf procedure's red zone usage would exceed 224 bytes, then
    it must set up a stack frame just like routines that call other routines."
 */
-#define PPC_RED_ZONE_SIZE 224
+#if defined(__ppc__)
+# define PPC_RED_ZONE_SIZE 224
+#elif defined(__ppc64__)
+# define PPC_RED_ZONE_SIZE 320
+#endif
+
+/* Try to work out the right way to access thread state structure members.
+   The structure has changed its definition in different Darwin versions.  */
+#if defined(__ppc__)
+# define THREAD_STATE ppc_thread_state_t
+# if defined (HAS_PPC_THREAD_STATE_R0)
+#  define THREAD_FLD(x) x
+# elif defined (HAS_PPC_THREAD_STATE___R0)
+#  define THREAD_FLD(x) __ ## x
+# else
+#  error can not work out how to access fields of ppc_thread_state_t
+# endif
+#elif defined(__ppc64__)
+# define THREAD_STATE ppc_thread_state64_t
+# if defined (HAS_PPC_THREAD_STATE64_R0)
+#  define THREAD_FLD(x) x
+# elif defined (HAS_PPC_THREAD_STATE64___R0)
+#  define THREAD_FLD(x) __ ## x
+# else
+#  error can not work out how to access fields of ppc_thread_state64_t
+# endif
+#elif defined(__i386__)
+# define THREAD_STATE i386_thread_state_t
+# if defined (HAS_I386_THREAD_STATE_EAX)
+#  define THREAD_FLD(x) x
+# elif defined (HAS_I386_THREAD_STATE___EAX)
+#  define THREAD_FLD(x) __ ## x
+# else
+#  error can not work out how to access fields of i386_thread_state_t
+# endif
+#else
+# error unknown architecture
+#endif
 
 typedef struct StackFrame {
   unsigned long	savedSP;
@@ -24,12 +61,17 @@
   unsigned long	savedRTOC;
 } StackFrame;
 
-
-unsigned int FindTopOfStack(unsigned int stack_start) {
+unsigned long FindTopOfStack(unsigned int stack_start) {
   StackFrame	*frame;
   
   if (stack_start == 0) {
-    __asm__ volatile("lwz	%0,0(r1)" : "=r" (frame));
+# ifdef POWERPC
+#   if CPP_WORDSZ == 32
+      __asm__ volatile("lwz	%0,0(r1)" : "=r" (frame));
+#   else
+      __asm__ volatile("ld	%0,0(r1)" : "=r" (frame));
+#   endif
+# endif
   } else {
     frame = (StackFrame *)stack_start;
   }
@@ -38,7 +80,7 @@
     /* GC_printf1("FindTopOfStack start at sp = %p\n", frame); */
 # endif
   do {
-    if (frame->savedSP == NULL) break;
+    if (frame->savedSP == 0) break;
     		/* if there are no more stack frames, stop */
 
     frame = (StackFrame*)frame->savedSP;
@@ -54,9 +96,88 @@
     /* GC_printf1("FindTopOfStack finish at sp = %p\n", frame); */
 # endif
 
-  return (unsigned int)frame;
+  return (unsigned long)frame;
 }	
 
+#ifdef DARWIN_DONT_PARSE_STACK
+void GC_push_all_stacks() {
+  int i;
+  kern_return_t r;
+  GC_thread p;
+  pthread_t me;
+  ptr_t lo, hi;
+  THREAD_STATE state;
+  mach_msg_type_number_t thread_state_count = MACHINE_THREAD_STATE_COUNT;
+  
+  me = pthread_self();
+  if (!GC_thr_initialized) GC_thr_init();
+  
+  for(i=0;i<THREAD_TABLE_SZ;i++) {
+    for(p=GC_threads[i];p!=0;p=p->next) {
+      if(p -> flags & FINISHED) continue;
+      if(pthread_equal(p->id,me)) {
+	lo = GC_approx_sp();
+      } else {
+	/* Get the thread state (registers, etc) */
+	r = thread_get_state(
+			     p->stop_info.mach_thread,
+			     MACHINE_THREAD_STATE,
+			     (natural_t*)&state,
+			     &thread_state_count);
+	if(r != KERN_SUCCESS) ABORT("thread_get_state failed");
+	
+	lo = (void*)(state . THREAD_FLD (r1) - PPC_RED_ZONE_SIZE);
+        
+	GC_push_one(state . THREAD_FLD (r0)); 
+	GC_push_one(state . THREAD_FLD (r2)); 
+	GC_push_one(state . THREAD_FLD (r3)); 
+	GC_push_one(state . THREAD_FLD (r4)); 
+	GC_push_one(state . THREAD_FLD (r5)); 
+	GC_push_one(state . THREAD_FLD (r6)); 
+	GC_push_one(state . THREAD_FLD (r7)); 
+	GC_push_one(state . THREAD_FLD (r8)); 
+	GC_push_one(state . THREAD_FLD (r9)); 
+	GC_push_one(state . THREAD_FLD (r10)); 
+	GC_push_one(state . THREAD_FLD (r11)); 
+	GC_push_one(state . THREAD_FLD (r12)); 
+	GC_push_one(state . THREAD_FLD (r13)); 
+	GC_push_one(state . THREAD_FLD (r14)); 
+	GC_push_one(state . THREAD_FLD (r15)); 
+	GC_push_one(state . THREAD_FLD (r16)); 
+	GC_push_one(state . THREAD_FLD (r17)); 
+	GC_push_one(state . THREAD_FLD (r18)); 
+	GC_push_one(state . THREAD_FLD (r19)); 
+	GC_push_one(state . THREAD_FLD (r20)); 
+	GC_push_one(state . THREAD_FLD (r21)); 
+	GC_push_one(state . THREAD_FLD (r22)); 
+	GC_push_one(state . THREAD_FLD (r23)); 
+	GC_push_one(state . THREAD_FLD (r24)); 
+	GC_push_one(state . THREAD_FLD (r25)); 
+	GC_push_one(state . THREAD_FLD (r26)); 
+	GC_push_one(state . THREAD_FLD (r27)); 
+	GC_push_one(state . THREAD_FLD (r28)); 
+	GC_push_one(state . THREAD_FLD (r29)); 
+	GC_push_one(state . THREAD_FLD (r30)); 
+	GC_push_one(state . THREAD_FLD (r31));
+      } /* p != me */
+      if(p->flags & MAIN_THREAD)
+	hi = GC_stackbottom;
+      else
+	hi = p->stack_end;
+#if DEBUG_THREADS
+      GC_printf3("Darwin: Stack for thread 0x%lx = [%lx,%lx)\n",
+		 (unsigned long) p -> id,
+		 (unsigned long) lo,
+		 (unsigned long) hi
+		 );
+#endif
+      GC_push_all_stack(lo,hi);
+    } /* for(p=GC_threads[i]...) */
+  } /* for(i=0;i<THREAD_TABLE_SZ...) */
+}
+
+#else /* !DARWIN_DONT_PARSE_STACK; Use FindTopOfStack() */
+
 void GC_push_all_stacks() {
     int i;
     kern_return_t r;
@@ -76,74 +197,74 @@
 	lo = GC_approx_sp();
 	hi = (ptr_t)FindTopOfStack(0);
       } else {
-#      ifdef POWERPC
-	ppc_thread_state_t info;
+#     if defined(__ppc__) || defined(__ppc64__)
+	THREAD_STATE info;
 	mach_msg_type_number_t outCount = THREAD_STATE_MAX;
 	r = thread_get_state(thread, MACHINE_THREAD_STATE,
 			     (natural_t *)&info, &outCount);
 	if(r != KERN_SUCCESS) ABORT("task_get_state failed");
 
-	lo = (void*)(info.r1 - PPC_RED_ZONE_SIZE);
-	hi = (ptr_t)FindTopOfStack(info.r1);
+	lo = (void*)(info . THREAD_FLD (r1) - PPC_RED_ZONE_SIZE);
+	hi = (ptr_t)FindTopOfStack(info . THREAD_FLD (r1));
 
-	GC_push_one(info.r0); 
-	GC_push_one(info.r2); 
-	GC_push_one(info.r3); 
-	GC_push_one(info.r4); 
-	GC_push_one(info.r5); 
-	GC_push_one(info.r6); 
-	GC_push_one(info.r7); 
-	GC_push_one(info.r8); 
-	GC_push_one(info.r9); 
-	GC_push_one(info.r10); 
-	GC_push_one(info.r11); 
-	GC_push_one(info.r12); 
-	GC_push_one(info.r13); 
-	GC_push_one(info.r14); 
-	GC_push_one(info.r15); 
-	GC_push_one(info.r16); 
-	GC_push_one(info.r17); 
-	GC_push_one(info.r18); 
-	GC_push_one(info.r19); 
-	GC_push_one(info.r20); 
-	GC_push_one(info.r21); 
-	GC_push_one(info.r22); 
-	GC_push_one(info.r23); 
-	GC_push_one(info.r24); 
-	GC_push_one(info.r25); 
-	GC_push_one(info.r26); 
-	GC_push_one(info.r27); 
-	GC_push_one(info.r28); 
-	GC_push_one(info.r29); 
-	GC_push_one(info.r30); 
-	GC_push_one(info.r31);
+	GC_push_one(info . THREAD_FLD (r0)); 
+	GC_push_one(info . THREAD_FLD (r2)); 
+	GC_push_one(info . THREAD_FLD (r3)); 
+	GC_push_one(info . THREAD_FLD (r4)); 
+	GC_push_one(info . THREAD_FLD (r5)); 
+	GC_push_one(info . THREAD_FLD (r6)); 
+	GC_push_one(info . THREAD_FLD (r7)); 
+	GC_push_one(info . THREAD_FLD (r8)); 
+	GC_push_one(info . THREAD_FLD (r9)); 
+	GC_push_one(info . THREAD_FLD (r10)); 
+	GC_push_one(info . THREAD_FLD (r11)); 
+	GC_push_one(info . THREAD_FLD (r12)); 
+	GC_push_one(info . THREAD_FLD (r13)); 
+	GC_push_one(info . THREAD_FLD (r14)); 
+	GC_push_one(info . THREAD_FLD (r15)); 
+	GC_push_one(info . THREAD_FLD (r16)); 
+	GC_push_one(info . THREAD_FLD (r17)); 
+	GC_push_one(info . THREAD_FLD (r18)); 
+	GC_push_one(info . THREAD_FLD (r19)); 
+	GC_push_one(info . THREAD_FLD (r20)); 
+	GC_push_one(info . THREAD_FLD (r21)); 
+	GC_push_one(info . THREAD_FLD (r22)); 
+	GC_push_one(info . THREAD_FLD (r23)); 
+	GC_push_one(info . THREAD_FLD (r24)); 
+	GC_push_one(info . THREAD_FLD (r25)); 
+	GC_push_one(info . THREAD_FLD (r26)); 
+	GC_push_one(info . THREAD_FLD (r27)); 
+	GC_push_one(info . THREAD_FLD (r28)); 
+	GC_push_one(info . THREAD_FLD (r29)); 
+	GC_push_one(info . THREAD_FLD (r30)); 
+	GC_push_one(info . THREAD_FLD (r31));
 #      else
 	/* FIXME: Remove after testing:	*/
 	WARN("This is completely untested and likely will not work\n", 0);
-	i386_thread_state_t info;
+	THREAD_STATE info;
 	mach_msg_type_number_t outCount = THREAD_STATE_MAX;
 	r = thread_get_state(thread, MACHINE_THREAD_STATE,
 			     (natural_t *)&info, &outCount);
 	if(r != KERN_SUCCESS) ABORT("task_get_state failed");
 
-	lo = (void*)info.esp;
-	hi = (ptr_t)FindTopOfStack(info.esp);
+	lo = (void*)info . THREAD_FLD (esp);
+	hi = (ptr_t)FindTopOfStack(info . THREAD_FLD (esp));
 
-	GC_push_one(info.eax); 
-	GC_push_one(info.ebx); 
-	GC_push_one(info.ecx); 
-	GC_push_one(info.edx); 
-	GC_push_one(info.edi); 
-	GC_push_one(info.esi); 
-	/* GC_push_one(info.ebp);  */
-	/* GC_push_one(info.esp);  */
-	GC_push_one(info.ss); 
-	GC_push_one(info.eip); 
-	GC_push_one(info.cs); 
-	GC_push_one(info.ds); 
-	GC_push_one(info.es); 
-	GC_push_one(info.fs); 
-	GC_push_one(info.gs); 
+	GC_push_one(info . THREAD_FLD (eax)); 
+	GC_push_one(info . THREAD_FLD (ebx)); 
+	GC_push_one(info . THREAD_FLD (ecx)); 
+	GC_push_one(info . THREAD_FLD (edx)); 
+	GC_push_one(info . THREAD_FLD (edi)); 
+	GC_push_one(info . THREAD_FLD (esi)); 
+	/* GC_push_one(info . THREAD_FLD (ebp));  */
+	/* GC_push_one(info . THREAD_FLD (esp));  */
+	GC_push_one(info . THREAD_FLD (ss)); 
+	GC_push_one(info . THREAD_FLD (eip)); 
+	GC_push_one(info . THREAD_FLD (cs)); 
+	GC_push_one(info . THREAD_FLD (ds)); 
+	GC_push_one(info . THREAD_FLD (es)); 
+	GC_push_one(info . THREAD_FLD (fs)); 
+	GC_push_one(info . THREAD_FLD (gs)); 
 #      endif /* !POWERPC */
       }
 #     if DEBUG_THREADS
@@ -157,6 +278,7 @@
     } /* for(p=GC_threads[i]...) */
     vm_deallocate(current_task(), (vm_address_t)act_list, sizeof(thread_t) * listcount);
 }
+#endif /* !DARWIN_DONT_PARSE_STACK */
 
 static mach_port_t GC_mach_handler_thread;
 static int GC_use_mach_handler_thread = 0;
@@ -327,6 +449,8 @@
   kern_return_t kern_result;
   thread_act_array_t act_list;
   mach_msg_type_number_t listcount;
+  struct thread_basic_info info;
+  mach_msg_type_number_t outCount = THREAD_INFO_MAX;
   
 #   if DEBUG_THREADS
       GC_printf0("World starting\n");
@@ -353,8 +477,6 @@
 #             endif
 	      continue;
 	    }
-	    struct thread_basic_info info;
-	    mach_msg_type_number_t outCount = THREAD_INFO_MAX;
 	    kern_result = thread_info(thread, THREAD_BASIC_INFO,
 				      (thread_info_t)&info, &outCount);
 	    if(kern_result != KERN_SUCCESS) ABORT("thread_info failed");
diff -urN old/boehm-gc/doc/README src/boehm-gc/doc/README
--- old/boehm-gc/doc/README	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/doc/README	2006-08-28 19:14:18.120718000 +0200
@@ -28,7 +28,7 @@
 collector.  (If you are concerned about such things, I recommend you look
 at the notice in config.guess or ltmain.sh.)
 
-This is version 6.3 of a conservative garbage collector for C and C++.
+This is version 6.6 of a conservative garbage collector for C and C++.
 
 You might find a more recent version of this at
 
diff -urN old/boehm-gc/doc/README.changes src/boehm-gc/doc/README.changes
--- old/boehm-gc/doc/README.changes	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/doc/README.changes	2006-08-28 19:14:18.120718000 +0200
@@ -2100,7 +2100,151 @@
    to Andrew Begel.)
  - Fix GC_task_self declaration in os_dep.c.  (Thanks to Andrew Pinski.)
  - Increase INITIAL_BUF_SZ in os_dep.c for Solaris /proc reads.
+
+Since 6.3:
+ - Merge gcconfig.h changes from gcc tree.
+ - Unconditionally include gc_priv.h in solaris_pthreads.c, win32_threads.h,
+   aix_irix_threads.c, and solaris_threads.c to get thread definitions.
+ - Start marker threads in GC_thr_init, so that they get started even
+   if no other threads are ever started.  (Oddly enough, the parallel
+   collector worked correctly, though not well, with no helper threads.)
+ - Go ahead and split large blocks in GC_allochblk_nth if GC_dont_gc
+   is set.  (Thanks to Alexander Petrossian.)
+ - GC_PRINT_BACK_HEIGHT would deadlock with thread support.
+ - Let in_progress_space in backgraph.s grow dynamically.
+ - Fix README.solaris2.  The GC_thr_init() hack doesn't work anymore.
+ - Convert GC_finalizer_mem_freed to bytes in allchblk.c.
+ - Add missing declaration for GC_generic_malloc_words_small_inner.
+   Without it, s390x breaks.  (Thanks to Ulrich Weigand.)
+ - Applied several MacOSX patches to support older tool chains.
+   (Thanks to Stefan Ring.)
+ - Bug fix for NetBSD/amd64.  (Thanks to Marc Recht.)  Add NetBSD/sh3
+   support.  (Thanks to Uchiyama Yasushi.)
+ - Fixed an uninitialized variable in cordprnt.c.  (Thanks to gcc for
+   providing the warning.)
+ - Eliminated some, but not all, gcc -Wall warnings.
+ - Changed some old style casts to reinterpret_cast in new_gc_alloc.h.
+   (Thanks to Dan Grayson.)
+ - GC_extend_size_map shouldn't adjust for GC_all_interior_pointers if
+   GC_DONT_ADD_BYTE_AT_END is set.
+ - Changed some (long) casts to (word) in preparation for win64.
+   (Thanks to Peter Colson.)
+ - Changed "int stack_size" declaration in pthread_support.c to use
+   size_t.  (Only mattered with GC_ASSERTIONS enabled.)
+ - Added CRIS (etrax) support.  (Thanks to Simon Posnjak and
+   Hans-Peter Nilsson.)
+ - Removed GC_IGNORE_FB frame buffer recognition, and replaced
+   it with a check that the mapping type is MEM_IMAGE.
+   In theory, this should work much better, but it is a high
+   risk change for win32.  (Thanks to Ashley Bone for the crucial
+   experimental data behind this, and to Rutger Ovidus for
+   some further experiments.)
+ - Fixed print_block_list to print the correct kind number for
+   STUBBORN.  (Thanks to Rutger Ovidus.)
+ - GC_allochblk_nth incremented GC_words_wasted by bytes rather than
+   words.
+ - Consider GC_words_wasted in GC_adj_words_allocd only if it is within
+   reason.  (A hack to avoid some extremely unlikely scenarios in which
+   we manage to allocate only "wasted" space.  7.0 has a better fix.)
+ - Changed PowerPC GC_clear implementation to use lwsync instead of
+   eieio, since the documentation recommends against eieio, and
+   it seems to be incorrect if the preceding memory op is a load.
+ - Fixed print_block_list to print the correct kind number for
+   STUBBORN.  (Thanks to Rutger Ovidus.)
+ - Have configure.in generate an error if it is asked to support
+   pthreads, but doesn't know how to.
+ - Added Kazuhiro Inaoka's patch for Renesas M32R support.
+ - Have the GNU build mechanism link with -ldl.  Rename THREADLIBS
+   to THREADDLLIBS to reflect this.  (Thanks to Sven Verdoolaege.)
+ - Added Hannes Mehnert's patch for FreeBSD/SPARC support.
+ - Merged some FreeBSD specific patches to threadlibs.c and dyn_load.c.
+   (Thanks tp John Merryweather Cooper.)
+ - Define MPROTECT_VDB on MACOSX only if threads are being used, since the
+   dirty page tracking mechanism uses threads.  (This avoids an undefined
+   reference to _GC_darwin_register_mach_handler_thread.)
+ - By popular demand, use __libc symbols only if we are built with
+   USE_LIBC_PRIVATES, which is off by default, and not otherwise documented.
+ - Ignore GC_enable_incremental() requests when KEEP_BACK_PTRS is set.
+   The GC itself will dirty lots of pages in this cases, probably making
+   it counterproductive on all platforms.  And the DARWIN port crashes.
+
+Since GC6.4:
+ - Integrated Paolo Molaro's patch to deal with EINTR in sem_wait.
+ - Make GC_approx_sp() write to dummy location to ensure that stack
+   is grown here, when sp looks reasonable, rather than later, when
+   it might look like a bad memory reference.  (Problem was never
+   observed that I know of.  But on rereading the code it seemed
+   dubious.)
+ - Separate out GC_with_callee_saves_pushed and sometimes call
+   it from GC_suspend_handler in pthread_stop_world.c.  Callee-save
+   register values sometimes failed to get traced under HP/UX on
+   PA-RISC.  Linux/IA64 had the same problem, though non-stacked
+   callee-save registers seem to be so rarely used there that nobody
+   ever noticed.
+ - Integrated an ancient Darwin powerpc_darwin_machine_dep.s patch
+   from Andreas Tobler, which I had lost.
+ - Fix compare_and_exchange implementation for gcc/IA64 to deal with
+   pickier compiler versions.
+ - Fixed Itanium 32-bit ABI support (HP/UX).  In particular, the
+   compare_and_exchange implementation didn't consider that possibility.
+ - Undefine GC_pthread_detach in win32_threads.c.  (Thanks to
+   Tagliapietra Tommaso.)
+ - Fixed inclusion of frame.h for NETBSD in os_dep.c.
+ - Applied Dan Bonachea's patch to use mmap on AIX.
+ - Several fixes to resurrect the Irix port on recent OS versions.
+ - Change ALPHA to use LINUX_STACKBOTTOM.
+ - Change SPARC64/LINUX to also use LINUX_STACKBOTTOM.  Deal with potential
+   bad values of __libc_stack_end on that platform.  (Thanks to David Miller.)
+ - Relax gctest to allow larger heap if ALIGN_DOUBLE isn't set.
+   (Unnecessary in 7.0)
+ - Force a define of __STDC__=0 for the IBM compiler on AIX, so that
+   we get prototypes.  (Unnecessary in 7.0)
+ - GC_INIT definition for AIX and CYGWIN referred to DATASTART and DATAEND
+   which are only defined in private include files.
+ - Integrated some small gcconfig.h patches from Dan Bonachea.  Also
+   relaxed assertion about FreeBSD stack size in pthread_support.c.
+ - Integrated Andrew Begel's darwin_stop_world.c patch for 64-bit
+   support.  This may need additional work.
+ - Avoided potentially infinite recursion in GC_save_callers if
+   the system backtrace calls malloc.  The workaround currently requires
+   __thread support if this code is used with threads.
+ - Avoided another similar infinite recursion by conditionally
+   invoking GC_save_callers in alloc.c.  (Thanks to Matthias Andree
+   for helping to track down both of these.)
+ - Removed all traces of aix_irix_threads.c.  AIX and Irix now use
+   pthread_support.c and pthread_stop_world.c.  The old code appeared
+   to be unreliable for AIX, and was not regularly maintained.
+ - On Irix, ignore segments with MA_FETCHOP or MA_NOTCACHED attributed;
+   they're not always safe to read.
+ - Fixed a previously vacuous assertion (diagnosed by the SGI compiler)
+   in GC_remove_from_fl.
+ - Fix stack_size assertion in GC_pthread_create.
+ - Fix assertion in GC_steal_mark_stack.
   
+Since 6.5
+ - Fix CPU count detection for Irix and FreeBSD. (Thanks to Dan Bonachea.)
+ - Integrate Dan Bonachea's patch for the IBM XLC compiler on Darwin.
+ - Integrated Andreas Tobler's FreeBSD/PowerPC patch.
+ - Don't access the GC thread structure from the restart handler.  It's
+   unsafe, since the handler may run too late.  (Thanks to Ben Maurer for
+   tracking this down.)
+ - Applied Christian Thalinger's patch to change comment syntax in
+   alpha_mach_dep.S.
+ - Added test for GC_no_dls in GC_dyld_image_add for DARWIN. (Thanks to
+   Juan Jose Garcia Ripoli).
+ - Use LINUX_STACKBOTTOM for Linux/SH and LINUX/ARM. (Thanks to Sugioka
+   Toshinobu and Christian Thalinger.)
+ - Rewrote GC_parse_map_entry.  This assumed a fixed column layout of
+   /proc/self/maps on Linux.  This ceased to be true about 2 years ago.
+   The old code is probably quite problemetic with -DREDIRECT_MALLOC.  It
+   is also used by default for IA64, though I haven't seen actual failures
+   there.
+ - More consistently define HBLKSIZE to 4096 on 64 bit architectures with
+   4K pages.  (Thanks to Andrew Haley.)
+ - With win32 threads, GC_stop_world needs to acquire GC_write_cs.  (Thanks
+   to Ben Hutchings for the observation and patch.)
+ - Move up struct callinfo declaration to make gcc 4.0.2. happy.
+
 To do:
  - The USE_MUNMAP code should really use a separate data structure
    indexed by physical page to keep track of time since last use of
diff -urN old/boehm-gc/doc/README.darwin src/boehm-gc/doc/README.darwin
--- old/boehm-gc/doc/README.darwin	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/doc/README.darwin	2006-08-28 19:14:18.120718000 +0200
@@ -1,3 +1,16 @@
+6.5 update:
+I disabled incremental GC on Darwin in this version, since I couldn't
+get gctest to pass when the GC was built as a dynamic library.  Building
+with -DMPROTECT_VDB (and threads) on the command line should get you
+back to the old state.			- HB
+
+./configure --enable-cplusplus results in a "make check" failure, probably
+because the ::delete override ends up in a separate dl, and Darwin dynamic
+loader semantics appear to be such that this is not really visible to the
+main program, unlike on ELF systems.  Someone who understands dynamic
+loading needs to lookat this.  For now, gc_cpp.o needs to be linked
+statically, if needed.			- HB
+
 Darwin/MacOSX Support - December 16, 2003
 =========================================
 
diff -urN old/boehm-gc/doc/README.environment src/boehm-gc/doc/README.environment
--- old/boehm-gc/doc/README.environment	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/doc/README.environment	2006-08-28 19:14:18.130718000 +0200
@@ -115,6 +115,7 @@
 		are never honored, eliminating this risk for most,
 		but not all, applications.  This feature is likely to disappear
 		if/when we find a less disgusting "solution".
+		IN VERSION 6.4 AND LATER, THIS SHOULD BE UNNECESSARY.
 
 The following turn on runtime flags that are also program settable.  Checked
 only during initialization.  We expect that they will usually be set through
diff -urN old/boehm-gc/doc/README.linux src/boehm-gc/doc/README.linux
--- old/boehm-gc/doc/README.linux	2003-07-28 06:18:23.000000000 +0200
+++ src/boehm-gc/doc/README.linux	2006-08-28 19:14:18.130718000 +0200
@@ -19,10 +19,10 @@
 
 To use threads, you need to abide by the following requirements:
 
-1) You need to use LinuxThreads (which are included in libc6).
+1) You need to use LinuxThreads or NPTL (which are included in libc6).
 
    The collector relies on some implementation details of the LinuxThreads
-   package.  It is unlikely that this code will work on other
+   package.  This code may not work on other
    pthread implementations (in particular it will *not* work with
    MIT pthreads).
 
diff -urN old/boehm-gc/doc/README.solaris2 src/boehm-gc/doc/README.solaris2
--- old/boehm-gc/doc/README.solaris2	2001-08-17 20:30:51.000000000 +0200
+++ src/boehm-gc/doc/README.solaris2	2006-08-28 19:14:18.130718000 +0200
@@ -43,9 +43,7 @@
 race/deadlock issues we had before.
 
 If solaris_threads are used on an X86 processor with malloc redirected to
-GC_malloc, it is necessary to call GC_thr_init explicitly before forking the
-first thread.  (This avoids a deadlock arising from calling GC_thr_init
-with the allocation lock held.)
+GC_malloc a deadlock is likely to result.
 
 It appears that there is a problem in using gc_cpp.h in conjunction with
 Solaris threads and Sun's C++ runtime.  Apparently the overloaded new operator
diff -urN old/boehm-gc/dyn_load.c src/boehm-gc/dyn_load.c
--- old/boehm-gc/dyn_load.c	2005-02-26 16:40:07.000000000 +0100
+++ src/boehm-gc/dyn_load.c	2006-08-28 19:17:32.350718000 +0200
@@ -96,21 +96,40 @@
 /* Newer versions of GNU/Linux define this macro.  We
  * define it similarly for any ELF systems that don't.  */
 #  ifndef ElfW
-#    ifdef __NetBSD__
-#      if ELFSIZE == 32
+#    if defined(FREEBSD)
+#      if __ELF_WORD_SIZE == 32
 #        define ElfW(type) Elf32_##type
 #      else
 #        define ElfW(type) Elf64_##type
 #      endif
 #    else
-#      if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32
-#        define ElfW(type) Elf32_##type
+#      ifdef NETBSD
+#        if ELFSIZE == 32
+#          define ElfW(type) Elf32_##type
+#        else
+#          define ElfW(type) Elf64_##type
+#        endif
 #      else
-#        define ElfW(type) Elf64_##type
+#        if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32
+#          define ElfW(type) Elf32_##type
+#        else
+#          define ElfW(type) Elf64_##type
+#	 endif
 #      endif
 #    endif
 #  endif
 
+/* An user-supplied routine that is called to dtermine if a DSO must
+   be scanned by the gc.  */
+static int (*GC_has_static_roots)(const char *, void *, size_t);
+/* Register the routine.  */
+void
+GC_register_has_static_roots_callback 
+  (int (*callback)(const char *, void *, size_t))
+{
+  GC_has_static_roots = callback;
+}
+
 #if defined(SUNOS5DL) && !defined(USE_PROC_FOR_LIBRARIES)
 
 #ifdef LINT
@@ -363,7 +382,7 @@
 {
   return FALSE;
 }
-  
+
 # define HAVE_REGISTER_MAIN_STATIC_DATA
 
 #endif /* USE_PROC_FOR_LIBRARIES */
@@ -403,6 +422,11 @@
 	{
 	  if( !(p->p_flags & PF_W) ) break;
 	  start = ((char *)(p->p_vaddr)) + info->dlpi_addr;
+
+	  if (GC_has_static_roots 
+	      && !GC_has_static_roots(info->dlpi_name, start, p->p_memsz))
+	    break;
+
 	  GC_add_roots_inner(start, start + p->p_memsz, TRUE);
 	}
       break;
@@ -485,7 +509,6 @@
 GC_FirstDLOpenedLinkMap()
 {
     ElfW(Dyn) *dp;
-    struct r_debug *r;
     static struct link_map *cachedResult = 0;
 
     if( _DYNAMIC == 0) {
@@ -494,6 +517,12 @@
     if( cachedResult == 0 ) {
         int tag;
         for( dp = _DYNAMIC; (tag = dp->d_tag) != 0; dp++ ) {
+	    /* FIXME: The DT_DEBUG header is not mandated by the	*/
+	    /* ELF spec.  This code appears to be dependent on		*/
+	    /* idiosynchracies of older GNU tool chains.  If this code	*/
+	    /* fails for you, the real problem is probably that it is	*/
+	    /* being used at all.  You should be getting the 		*/
+	    /* dl_iterate_phdr version.					*/
             if( tag == DT_DEBUG ) {
                 struct link_map *lm
                         = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;
@@ -618,7 +647,8 @@
     }
     for (i = 0; i < needed_sz; i++) {
         flags = addr_map[i].pr_mflags;
-        if ((flags & (MA_BREAK | MA_STACK | MA_PHYS)) != 0) goto irrelevant;
+        if ((flags & (MA_BREAK | MA_STACK | MA_PHYS
+		      | MA_FETCHOP | MA_NOTCACHED)) != 0) goto irrelevant;
         if ((flags & (MA_READ | MA_WRITE)) != (MA_READ | MA_WRITE))
             goto irrelevant;
           /* The latter test is empirically useless in very old Irix	*/
@@ -758,25 +788,27 @@
  
   /* Should [start, start+len) be treated as a frame buffer	*/
   /* and ignored?						*/
-  /* Unfortunately, we currently have no real way to tell	*/
-  /* automatically, and rely largely on user input.		*/
-  /* FIXME: If we had more data on this phenomenon (e.g.	*/
-  /* is start aligned to a MB multiple?) we should be able to	*/
-  /* do better.							*/
+  /* Unfortunately, we currently are not quite sure how to tell	*/
+  /* this automatically, and rely largely on user input.	*/
+  /* We expect that any mapping with type MEM_MAPPED (which 	*/
+  /* apparently excludes library data sections) can be safely	*/
+  /* ignored.  But we're too chicken to do that in this 	*/
+  /* version.							*/
   /* Based on a very limited sample, it appears that:		*/
-  /* 	- Frame buffer mappings appear as mappings of length	*/
-  /* 	  2**n MB - 192K.  (We guess the 192K can vary a bit.)	*/
-  /*	- Have a stating address at best 64K aligned.		*/
-  /* I'd love more information about the mapping, since I	*/
-  /* can't reproduce the problem.				*/
-  static GC_bool is_frame_buffer(ptr_t start, size_t len)
+  /* 	- Frame buffer mappings appear as mappings of large	*/
+  /*	  length, usually a bit less than a power of two.	*/
+  /*	- The definition of "a bit less" in the above cannot	*/
+  /*	  be made more precise.					*/
+  /*	- Have a starting address at best 64K aligned.		*/
+  /*	- Have type == MEM_MAPPED.				*/
+  static GC_bool is_frame_buffer(ptr_t start, size_t len, DWORD tp)
   {
     static GC_bool initialized = FALSE;
 #   define MB (1024*1024)
 #   define DEFAULT_FB_MB 15
 #   define MIN_FB_MB 3
 
-    if (GC_disallow_ignore_fb) return FALSE;
+    if (GC_disallow_ignore_fb || tp != MEM_MAPPED) return FALSE;
     if (!initialized) {
       char * ignore_fb_string =  GETENV("GC_IGNORE_FB");
 
@@ -828,6 +860,9 @@
   }
 # endif /* DEBUG_VIRTUALQUERY */
 
+  extern GC_bool GC_wnt;  /* Is Windows NT derivative.		*/
+  			  /* Defined and set in os_dep.c.	*/
+
   void GC_register_dynamic_libraries()
   {
     MEMORY_BASIC_INFORMATION buf;
@@ -869,7 +904,12 @@
 		 * !is_frame_buffer(p, buf.RegionSize, buf.Type)
 		 * instead of just checking for MEM_IMAGE.
 		 * If something breaks, change it back. */
-		&& buf.Type == MEM_IMAGE) {
+		/* There is some evidence that we cannot always
+		 * ignore MEM_PRIVATE sections under Windows ME
+		 * and predecessors.  Hence we now also check for
+		 * that case.	*/
+		&& (buf.Type == MEM_IMAGE ||
+		    !GC_wnt && buf.Type == MEM_PRIVATE)) {  
 #	        ifdef DEBUG_VIRTUALQUERY
 	          GC_dump_meminfo(&buf);
 #	        endif
@@ -1125,21 +1165,22 @@
 static void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide) {
     unsigned long start,end,i;
     const struct section *sec;
+    if (GC_no_dls) return;
     for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {
         sec = getsectbynamefromheader(
             hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);
-            if(sec == NULL || sec->size == 0) continue;
-            start = slide + sec->addr;
-            end = start + sec->size;
-#		ifdef DARWIN_DEBUG
-                GC_printf4("Adding section at %p-%p (%lu bytes) from image %s\n",
+        if(sec == NULL || sec->size == 0) continue;
+        start = slide + sec->addr;
+        end = start + sec->size;
+#	ifdef DARWIN_DEBUG
+            GC_printf4("Adding section at %p-%p (%lu bytes) from image %s\n",
                 start,end,sec->size,GC_dyld_name_for_hdr(hdr));
-#			endif
+#       endif
         GC_add_roots((char*)start,(char*)end);
-        }
-#	ifdef DARWIN_DEBUG
-    GC_print_static_roots();
-#	endif
+    }
+#   ifdef DARWIN_DEBUG
+        GC_print_static_roots();
+#   endif
 }
 
 /* This should never be called by a thread holding the lock */
@@ -1152,15 +1193,15 @@
         if(sec == NULL || sec->size == 0) continue;
         start = slide + sec->addr;
         end = start + sec->size;
-#		ifdef DARWIN_DEBUG
+#	ifdef DARWIN_DEBUG
             GC_printf4("Removing section at %p-%p (%lu bytes) from image %s\n",
                 start,end,sec->size,GC_dyld_name_for_hdr(hdr));
 #		endif
         GC_remove_roots((char*)start,(char*)end);
     }
-#	ifdef DARWIN_DEBUG
-    GC_print_static_roots();
-#	endif
+#   ifdef DARWIN_DEBUG
+        GC_print_static_roots();
+#   endif
 }
 
 void GC_register_dynamic_libraries() {
diff -urN old/boehm-gc/include/gc_config.h.in src/boehm-gc/include/gc_config.h.in
--- old/boehm-gc/include/gc_config.h.in	2006-02-07 02:05:55.000000000 +0100
+++ src/boehm-gc/include/gc_config.h.in	2006-08-28 19:17:32.350718000 +0200
@@ -45,9 +45,6 @@
 /* support for Tru64 pthreads */
 #undef GC_OSF1_THREADS
 
-/* symbol version of pthread_create */
-#undef GC_PTHREAD_SYM_VERSION
-
 /* support for Solaris pthreads */
 #undef GC_SOLARIS_PTHREADS
 
@@ -57,12 +54,33 @@
 /* support for win32 threads */
 #undef GC_WIN32_THREADS
 
+/* i386_thread_state_t has field eax */
+#undef HAS_I386_THREAD_STATE_EAX
+
+/* i386_thread_state_t has field __eax */
+#undef HAS_I386_THREAD_STATE___EAX
+
+/* ppc_thread_state64_t has field r0 */
+#undef HAS_PPC_THREAD_STATE64_R0
+
+/* ppc_thread_state64_t has field __r0 */
+#undef HAS_PPC_THREAD_STATE64___R0
+
+/* ppc_thread_state_t has field r0 */
+#undef HAS_PPC_THREAD_STATE_R0
+
+/* ppc_thread_state_t has field __r0 */
+#undef HAS_PPC_THREAD_STATE___R0
+
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
+/* Define to 1 if you have the `pthread_getattr_np' function. */
+#undef HAVE_PTHREAD_GETATTR_NP
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
@@ -154,5 +172,5 @@
 /* POSIX version of C Source */
 #undef _POSIX_C_SOURCE
 
-/* Use reentrant code */
+/* Required define if using POSIX threads */
 #undef _REENTRANT
diff -urN old/boehm-gc/include/gc_config_macros.h src/boehm-gc/include/gc_config_macros.h
--- old/boehm-gc/include/gc_config_macros.h	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/include/gc_config_macros.h	2006-08-28 19:14:18.130718000 +0200
@@ -59,6 +59,10 @@
 #   define GC_DGUX386_THREADS
 #   define GC_PTHREADS
 # endif
+# if defined(_AIX)
+#   define GC_AIX_THREADS
+#   define GC_PTHREADS
+# endif
 #endif /* GC_THREADS */
 
 #if defined(GC_THREADS) && !defined(GC_PTHREADS) && \
diff -urN old/boehm-gc/include/gc_cpp.h src/boehm-gc/include/gc_cpp.h
--- old/boehm-gc/include/gc_cpp.h	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/include/gc_cpp.h	2006-08-28 19:14:18.130718000 +0200
@@ -74,7 +74,7 @@
 collectable.  See the interface gc.h for low-level facilities for
 handling such cycles of objects with clean-up.
 
-The collector cannot guarrantee that it will find all inaccessible
+The collector cannot guarantee that it will find all inaccessible
 objects.  In practice, it finds almost all of them.
 
 
diff -urN old/boehm-gc/include/gc_ext_config.h.in src/boehm-gc/include/gc_ext_config.h.in
--- old/boehm-gc/include/gc_ext_config.h.in	2006-02-07 02:05:55.000000000 +0100
+++ src/boehm-gc/include/gc_ext_config.h.in	2006-08-28 19:17:32.350718000 +0200
@@ -4,4 +4,4 @@
 
 #undef THREAD_LOCAL_ALLOC
 
-#undef GC_PTHREAD_SYM_VERSION
+#undef HAVE_PTHREAD_GETATTR_NP
diff -urN old/boehm-gc/include/gc.h src/boehm-gc/include/gc.h
--- old/boehm-gc/include/gc.h	2005-01-02 04:35:57.000000000 +0100
+++ src/boehm-gc/include/gc.h	2006-08-28 19:17:32.340718000 +0200
@@ -55,7 +55,7 @@
 # include <gc_config.h>
 # include "gc_config_macros.h"
 
-# if defined(__STDC__) || defined(__cplusplus)
+# if defined(__STDC__) || defined(__cplusplus) || defined(_AIX)
 #   define GC_PROTO(args) args
     typedef void * GC_PTR;
 #   define GC_CONST const
@@ -69,7 +69,6 @@
     extern "C" {
 # endif
 
-
 /* Define word and signed_word to be unsigned and signed types of the 	*/
 /* size as char * or void *.  There seems to be no way to do this	*/
 /* even semi-portably.  The following is probably no better/worse 	*/
@@ -152,7 +151,7 @@
 			/* ordered finalization.  Default value is	*/
 			/* determined by JAVA_FINALIZATION macro.	*/
 
-GC_API void (* GC_finalizer_notifier)();
+GC_API void (* GC_finalizer_notifier) GC_PROTO((void));
 			/* Invoked by the collector when there are 	*/
 			/* objects to be finalized.  Invoked at most	*/
 			/* once per GC cycle.  Never invoked unless 	*/
@@ -214,7 +213,7 @@
 			/* least N/GC_free_space_divisor bytes between	*/
 			/* collections, where N is the heap size plus	*/
 			/* a rough estimate of the root set size.	*/
-			/* Initially, GC_free_space_divisor = 4.	*/
+			/* Initially, GC_free_space_divisor = 3.	*/
 			/* Increasing its value will use less space	*/
 			/* but more collection time.  Decreasing it	*/
 			/* will appreciably decrease collection time	*/
@@ -340,6 +339,9 @@
 /* the base of the user object.						*/
 /* Return 0 if displaced_pointer doesn't point to within a valid	*/
 /* object.								*/
+/* Note that a deallocated object in the garbage collected heap		*/
+/* may be considered valid, even if it has been deallocated with	*/
+/* GC_free.  								*/
 GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));
 
 /* Given a pointer to the base of an object, return its size in bytes.	*/
@@ -877,7 +879,7 @@
 
 /* Safer assignment of a pointer to a nonstack location.	*/
 #ifdef GC_DEBUG
-# ifdef __STDC__
+# if defined(__STDC__) || defined(_AIX)
 #   define GC_PTR_STORE(p, q) \
 	(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))
 # else
@@ -909,6 +911,25 @@
 # if defined(PCR) || defined(GC_SOLARIS_THREADS) || \
      defined(GC_PTHREADS) || defined(GC_WIN32_THREADS)
    	/* Any flavor of threads except SRC_M3.	*/
+
+/* Register the current thread as a new thread whose stack(s) should    */
+/* be traced by the GC.  						*/
+/* If a platform does not implicitly do so, this must be called before  */
+/* a thread can allocate garbage collected memory, or assign pointers	*/
+/* to the garbage collected heap.  Once registered, a thread will be	*/
+/* stopped during garbage collections.					*/
+GC_API void GC_register_my_thread GC_PROTO((void));
+
+/* Register the current thread, with the indicated stack base, as	*/
+/* a new thread whose stack(s) should be traced by the GC.  If a 	*/
+/* platform does not implicitly do so, this must be called before a	*/
+/* thread can allocate garbage collected memory, or assign pointers	*/
+/* to the garbage collected heap.  Once registered, a thread will be	*/
+/* stopped during garbage collections.					*/
+GC_API void GC_unregister_my_thread GC_PROTO((void));
+
+GC_API GC_PTR GC_get_thread_stack_base GC_PROTO((void));
+
 /* This returns a list of objects, linked through their first		*/
 /* word.  Its use can greatly reduce lock contention problems, since	*/
 /* the allocation lock can be acquired and released many fewer times.	*/
@@ -918,10 +939,19 @@
 GC_PTR GC_malloc_many(size_t lb);
 #define GC_NEXT(p) (*(GC_PTR *)(p)) 	/* Retrieve the next element	*/
 					/* in returned list.		*/
-extern void GC_thr_init();	/* Needed for Solaris/X86	*/
+extern void GC_thr_init GC_PROTO((void));/* Needed for Solaris/X86	*/
 
 #endif /* THREADS && !SRC_M3 */
 
+/* Register a callback to control the scanning of dynamic libraries.
+   When the GC scans the static data of a dynamic library, it will
+   first call a user-supplied routine with filename of the library and
+   the address and length of the memory region.  This routine should
+   return nonzero if that region should be scanned.  */
+GC_API void GC_register_has_static_roots_callback 
+  (int (*callback)(const char *, void *, size_t));
+
+
 #if defined(GC_WIN32_THREADS) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)
 # include <windows.h>
 
@@ -972,12 +1002,32 @@
 #   define GC_INIT() { extern end, etext; \
 		       GC_noop(&end, &etext); }
 #else
-# if defined(__CYGWIN32__) && defined(GC_DLL) || defined (_AIX)
+# if defined(__CYGWIN32__) || defined (_AIX)
     /*
      * Similarly gnu-win32 DLLs need explicit initialization from
      * the main program, as does AIX.
      */
-#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }
+#   ifdef __CYGWIN32__
+      extern int _data_start__[];
+      extern int _data_end__[];
+      extern int _bss_start__[];
+      extern int _bss_end__[];
+#     define GC_MAX(x,y) ((x) > (y) ? (x) : (y))
+#     define GC_MIN(x,y) ((x) < (y) ? (x) : (y))
+#     define GC_DATASTART ((GC_PTR) GC_MIN(_data_start__, _bss_start__))
+#     define GC_DATAEND	 ((GC_PTR) GC_MAX(_data_end__, _bss_end__))
+#     ifdef GC_DLL
+#       define GC_INIT() { GC_add_roots(GC_DATASTART, GC_DATAEND); }
+#     else
+#       define GC_INIT()
+#     endif
+#   endif
+#   if defined(_AIX)
+      extern int _data[], _end[];
+#     define GC_DATASTART ((GC_PTR)((ulong)_data))
+#     define GC_DATAEND ((GC_PTR)((ulong)_end))
+#     define GC_INIT() { GC_add_roots(GC_DATASTART, GC_DATAEND); }
+#   endif
 # else
 #  if defined(__APPLE__) && defined(__MACH__) || defined(GC_WIN32_THREADS)
 #   define GC_INIT() { GC_init(); }
@@ -1008,4 +1058,14 @@
     }  /* end of extern "C" */
 #endif
 
+/* External thread suspension support. These functions do not implement
+ * suspension counts or any other higher-level abstraction. Threads which
+ * have been suspended numerous times will resume with the very first call
+ * to GC_resume_thread.
+ */
+#if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \
+  && !defined(GC_WIN32_THREADS) && !defined(GC_DARWIN_THREADS)
+GC_API void GC_suspend_thread GC_PROTO((pthread_t));
+GC_API void GC_resume_thread GC_PROTO((pthread_t));
+#endif
 #endif /* _GC_H */
diff -urN old/boehm-gc/include/gc_pthread_redirects.h src/boehm-gc/include/gc_pthread_redirects.h
--- old/boehm-gc/include/gc_pthread_redirects.h	2006-02-07 02:05:55.000000000 +0100
+++ src/boehm-gc/include/gc_pthread_redirects.h	2006-08-28 19:17:32.350718000 +0200
@@ -68,9 +68,7 @@
 # undef pthread_detach
 #endif
 
-#ifndef GC_PTHREAD_SYM_VERSION
 # define pthread_create GC_pthread_create
-#endif
 # define pthread_join GC_pthread_join
 # define pthread_detach GC_pthread_detach
 
diff -urN old/boehm-gc/include/Makefile.in src/boehm-gc/include/Makefile.in
--- old/boehm-gc/include/Makefile.in	2005-03-02 00:25:50.000000000 +0100
+++ src/boehm-gc/include/Makefile.in	2006-08-28 19:14:18.130718000 +0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -43,6 +43,8 @@
 	$(srcdir)/gc_ext_config.h.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/depstand.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
 	$(top_srcdir)/../config/no-executables.m4 \
 	$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
diff -urN old/boehm-gc/include/new_gc_alloc.h src/boehm-gc/include/new_gc_alloc.h
--- old/boehm-gc/include/new_gc_alloc.h	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/include/new_gc_alloc.h	2006-08-28 19:14:18.130718000 +0200
@@ -109,7 +109,7 @@
 enum { GC_word_alignment = GC_byte_alignment/GC_bytes_per_word };
 
 inline void * &GC_obj_link(void * p)
-{   return *(void **)p;  }
+{   return *reinterpret_cast<void **>(p);  }
 
 // Compute a number of words >= n+1 bytes.
 // The +1 allows for pointers one past the end.
@@ -228,7 +228,7 @@
 	    } else {
 	        flh = GC_objfreelist_ptr + nwords;
 	        GC_obj_link(p) = *flh;
-		memset((char *)p + GC_bytes_per_word, 0,
+		memset(reinterpret_cast<char *>(p) + GC_bytes_per_word, 0,
 		       GC_bytes_per_word * (nwords - 1));
 	        *flh = p;
 	        GC_aux::GC_mem_recently_freed += nwords;
@@ -352,9 +352,9 @@
 public: \
     static T *allocate(size_t n) \
 	{ return 0 == n? 0 : \
-			 (T*) alloc::ptr_free_allocate(n * sizeof (T)); } \
+			 reinterpret_cast<T*>(alloc::ptr_free_allocate(n * sizeof (T))); } \
     static T *allocate(void) \
-	{ return (T*) alloc::ptr_free_allocate(sizeof (T)); } \
+	{ return reinterpret_cast<T*>(alloc::ptr_free_allocate(sizeof (T))); } \
     static void deallocate(T *p, size_t n) \
 	{ if (0 != n) alloc::ptr_free_deallocate(p, n * sizeof (T)); } \
     static void deallocate(T *p) \
diff -urN old/boehm-gc/include/private/gcconfig.h src/boehm-gc/include/private/gcconfig.h
--- old/boehm-gc/include/private/gcconfig.h	2005-09-06 16:22:01.000000000 +0200
+++ src/boehm-gc/include/private/gcconfig.h	2006-08-28 19:14:18.130718000 +0200
@@ -55,7 +55,7 @@
 # endif
 
 /* And one for FreeBSD: */
-# if defined(__FreeBSD__)
+# if defined(__FreeBSD__) && !defined(FREEBSD)
 #    define FREEBSD
 # endif
 
@@ -97,6 +97,10 @@
 #    define ARM32
 #    define mach_type_known
 # endif
+# if defined(NETBSD) && defined(__sh__)
+#    define SH
+#    define mach_type_known
+# endif
 # if defined(vax)
 #    define VAX
 #    ifdef ultrix
@@ -127,6 +131,9 @@
 #	 endif
 #      endif
 #    endif /* !LINUX */
+#    if defined(__NetBSD__) && defined(__MIPSEL__)
+#      undef ULTRIX
+#    endif
 #    define mach_type_known
 # endif
 # if defined(DGUX) && (defined(i386) || defined(__i386__))
@@ -167,7 +174,7 @@
 #   define mach_type_known
 # endif
 # if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \
-     && !defined(__OpenBSD__) && !(__NetBSD__)
+     && !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__)
 #   define SPARC
 #   define DRSNX
 #   define mach_type_known
@@ -198,14 +205,16 @@
 # if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) || defined(_PA_RISC2_0) \
      || defined(hppa) || defined(__hppa__)
 #   define HP_PA
-#   ifndef LINUX
+#   if !defined(LINUX) && !defined(HPUX)
 #     define HPUX
 #   endif
 #   define mach_type_known
 # endif
 # if defined(__ia64) && defined(_HPUX_SOURCE)
 #   define IA64
-#   define HPUX
+#   ifndef HPUX
+#     define HPUX
+#   endif
 #   define mach_type_known
 # endif
 # if defined(__BEOS__) && defined(_X86_)
@@ -235,7 +244,8 @@
 #    endif
 #    define mach_type_known
 # endif
-# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__) || defined(powerpc64) || defined(__powerpc64__))
+# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__) || \
+		        defined(powerpc64) || defined(__powerpc64__))
 #    define POWERPC
 #    define mach_type_known
 # endif
@@ -287,17 +297,15 @@
 #   define MACOS
 #   define mach_type_known
 # endif
-# if defined(macosx) \
-     || defined(__APPLE__) && defined(__MACH__) && defined(__ppc__) \
-     || defined(__APPLE__) && defined(__MACH__) && defined(__ppc64__)
-#    define DARWIN
+# if defined(macosx) || (defined(__APPLE__) && defined(__MACH__))
+#   define DARWIN
+#   if defined(__ppc__)  || defined(__ppc64__)
 #    define POWERPC
 #    define mach_type_known
-# endif
-# if defined(__APPLE__) && defined(__MACH__) && defined(__i386__)
-#    define DARWIN
+#   elif defined(__i386__)
 #    define I386
      --> Not really supported, but at least we recognize it.
+#   endif
 # endif
 # if defined(NeXT) && defined(mc68000)
 #   define M68K
@@ -326,6 +334,10 @@
 #    define X86_64
 #    define mach_type_known
 # endif
+# if defined(FREEBSD) && defined(__sparc__)
+#    define SPARC
+#    define mach_type_known
+#endif
 # if defined(bsdi) && (defined(i386) || defined(__i386__))
 #    define I386
 #    define BSDI
@@ -486,6 +498,9 @@
 		    /*		   POWERPC    ==> IBM/Apple PowerPC	*/
 		    /*			(MACOS(<=9),DARWIN(incl.MACOSX),*/
 		    /*			 LINUX, NETBSD, NOSYS variants)	*/
+		    /*			Handles 32 and 64-bit variants.	*/
+		    /* 			AIX should be handled here, but	*/
+		    /*			that's called an RS6000.	*/
 		    /*		   CRIS       ==> Axis Etrax		*/
 		    /*		   M32R	      ==> Renesas M32R		*/
 
@@ -493,12 +508,12 @@
 /*
  * For each architecture and OS, the following need to be defined:
  *
- * CPP_WORD_SZ is a simple integer constant representing the word size.
+ * CPP_WORDSZ is a simple integer constant representing the word size.
  * in bits.  We assume byte addressibility, where a byte has 8 bits.
- * We also assume CPP_WORD_SZ is either 32 or 64.
+ * We also assume CPP_WORDSZ is either 32 or 64.
  * (We care about the length of pointers, not hardware
  * bus widths.  Thus a 64 bit processor with a C compiler that uses
- * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)
+ * 32 bit pointers should use CPP_WORDSZ of 32, not 64. Default is 32.)
  *
  * MACH_TYPE is a string representation of the machine type.
  * OS_TYPE is analogous for the OS.
@@ -615,7 +630,8 @@
  */
 # if defined(__GNUC__) && ((__GNUC__ >= 3) || \
 			   (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)) \
-		       && !defined(__INTEL_COMPILER)
+		       && !defined(__INTEL_COMPILER) \
+ 		       && !defined(__PATHCC__)
 #   define HAVE_BUILTIN_UNWIND_INIT
 # endif
 
@@ -651,8 +667,7 @@
 #       define OS_TYPE "LINUX"
 #       define STACKBOTTOM ((ptr_t)0xf0000000)
 #       define USE_GENERIC_PUSH_REGS
-#	     define USE_MMAP
-	      /* We never got around to the assembly version. */
+		/* We never got around to the assembly version. */
 /* #       define MPROTECT_VDB - Reported to not work  9/17/01 */
 #       ifdef __ELF__
 #            define DYNAMIC_LOADING
@@ -740,7 +755,7 @@
 #   endif
 # endif
 
-# ifdef POWERPC
+# if defined(POWERPC)
 #   define MACH_TYPE "POWERPC"
 #   ifdef MACOS
 #     define ALIGNMENT 2  /* Still necessary?  Could it be 4?	*/
@@ -753,10 +768,12 @@
 #     define DATAEND  /* not needed */
 #   endif
 #   ifdef LINUX
-#     if (defined (powerpc64) || defined(__powerpc64__))
+#     if defined(__powerpc64__)
 #       define ALIGNMENT 8
 #       define CPP_WORDSZ 64
-#       define HBLKSIZE 4096
+#       ifndef HBLKSIZE
+#         define HBLKSIZE 4096
+#       endif
 #     else
 #       define ALIGNMENT 4
 #     endif
@@ -770,7 +787,7 @@
 #     define DATAEND (_end)
 #   endif
 #   ifdef DARWIN
-#     if (defined (__ppc64__))
+#     ifdef __ppc64__
 #       define ALIGNMENT 8
 #       define CPP_WORDSZ 64
 #     else
@@ -787,8 +804,10 @@
 #     define USE_MMAP_ANON
 #     define USE_ASM_PUSH_REGS
       /* This is potentially buggy. It needs more testing. See the comments in
-         os_dep.c */
-#     define MPROTECT_VDB
+         os_dep.c.  It relies on threads to track writes. */
+#     ifdef GC_DARWIN_THREADS
+/* #       define MPROTECT_VDB -- diabled for now.  May work for some apps. */
+#     endif
 #     include <unistd.h>
 #     define GETPAGESIZE() getpagesize()
 #     if defined(USE_PPC_PREFETCH) && defined(__GNUC__)
@@ -975,6 +994,23 @@
 #	define DATASTART ((ptr_t)(etext))
 #     endif
 #   endif
+#   ifdef FREEBSD
+#	define OS_TYPE "FREEBSD"
+#	define SIG_SUSPEND SIGUSR1
+#	define SIG_THR_RESTART SIGUSR2
+#	define FREEBSD_STACKBOTTOM
+#	ifdef __ELF__
+#	    define DYNAMIC_LOADING
+#	endif
+	extern char etext[];
+	extern char edata[];
+	extern char end[];
+#	define NEED_FIND_LIMIT
+#	define DATASTART ((ptr_t)(&etext))
+#	define DATAEND (GC_find_limit (DATASTART, TRUE))
+#	define DATASTART2 ((ptr_t)(&edata))
+#	define DATAEND2 ((ptr_t)(&end))
+#   endif
 # endif
 
 # ifdef I386
@@ -1158,26 +1194,8 @@
 #   endif
 #   ifdef CYGWIN32
 #       define OS_TYPE "CYGWIN32"
-          extern int _data_start__[];
-          extern int _data_end__[];
-          extern int _bss_start__[];
-          extern int _bss_end__[];
-  	/* For binutils 2.9.1, we have			*/
-  	/*	DATASTART   = _data_start__		*/
-  	/*	DATAEND	    = _bss_end__		*/
-  	/* whereas for some earlier versions it was	*/
-  	/*	DATASTART   = _bss_start__		*/
-  	/*	DATAEND	    = _data_end__		*/
-  	/* To get it right for both, we take the	*/
-  	/* minumum/maximum of the two.			*/
-#     ifndef MAX
-#   	define MAX(x,y) ((x) > (y) ? (x) : (y))
-#     endif
-#     ifndef MIN
-#   	define MIN(x,y) ((x) < (y) ? (x) : (y))
-#     endif
-#       define DATASTART ((ptr_t) MIN(_data_start__, _bss_start__))
-#       define DATAEND	 ((ptr_t) MAX(_data_end__, _bss_end__))
+#       define DATASTART ((ptr_t)GC_DATASTART)  /* From gc.h */
+#       define DATAEND	 ((ptr_t)GC_DATAEND)
 #	undef STACK_GRAN
 #       define STACK_GRAN 0x10000
 #       define HEURISTIC1
@@ -1388,8 +1406,8 @@
 #       define DATAEND /* not needed */
 #   endif
 #   if defined(NETBSD)
-#     define OS_TYPE "NETBSD"
 #     define ALIGNMENT 4
+#     define OS_TYPE "NETBSD"
 #     define HEURISTIC2
 #     define USE_GENERIC_PUSH_REGS
 #     ifdef __ELF__
@@ -1421,6 +1439,8 @@
 #     define CPP_WORDSZ 32
 #     define STACKBOTTOM ((ptr_t)((ulong)&errno))
 #   endif
+#   define USE_MMAP
+#   define USE_MMAP_ANON
  /* From AIX linker man page:
  _text Specifies the first location of the program.
  _etext Specifies the first location after the program.
@@ -1567,7 +1587,7 @@
 	/* the text segment immediately follows the stack.		*/
 	/* Hence we give an upper pound.				*/
 	/* This is currently unused, since we disabled HEURISTIC2	*/
-   	extern int __start[];
+    	extern int __start[];
 #   	define HEURISTIC2_LIMIT ((ptr_t)((word)(__start) & ~(getpagesize()-1)))
 #	ifndef GC_OSF1_THREADS
 	  /* Unresolved signal issues with threads.	*/
@@ -1728,7 +1748,7 @@
 #   define USE_GENERIC_PUSH_REGS
 #   ifdef UTS4
 #       define OS_TYPE "UTS4"
-       extern int etext[];
+	extern int etext[];
 	extern int _etext[];
 	extern int _end[];
 	extern ptr_t GC_SysVGetDataStart();
@@ -1742,18 +1762,20 @@
 #   define MACH_TYPE "S390"
 #   define USE_GENERIC_PUSH_REGS
 #   ifndef __s390x__
-#   define ALIGNMENT 4
-#   define CPP_WORDSZ 32
+#     define ALIGNMENT 4
+#     define CPP_WORDSZ 32
 #   else
-#   define ALIGNMENT 8
-#   define CPP_WORDSZ 64
-#   define HBLKSIZE 4096
+#     define ALIGNMENT 8
+#     define CPP_WORDSZ 64
+#   endif
+#   ifndef HBLKSIZE
+#     define HBLKSIZE 4096
 #   endif
 #   ifdef LINUX
 #       define OS_TYPE "LINUX"
 #       define LINUX_STACKBOTTOM
 #       define DYNAMIC_LOADING
-       extern int __data_start[];
+	extern int __data_start[];
 #       define DATASTART ((ptr_t)(__data_start))
     extern int _end[];
 #   define DATAEND (_end)
@@ -1859,6 +1881,13 @@
       extern int _end[];
 #     define DATAEND (_end)
 #   endif
+#   ifdef NETBSD
+#      define OS_TYPE "NETBSD"
+#      define HEURISTIC2
+#      define DATASTART GC_data_start
+#       define USE_GENERIC_PUSH_REGS
+#      define DYNAMIC_LOADING
+#   endif
 # endif
  
 # ifdef SH4
@@ -2107,7 +2136,8 @@
 #   define THREADS
 # endif
 
-# if defined(HP_PA) || defined(M88K) || defined(POWERPC) && !defined(DARWIN) \
+# if defined(HP_PA) || defined(M88K) \
+             || defined(POWERPC) && !defined(DARWIN) \
 	     || defined(LINT) || defined(MSWINCE) || defined(ARM32) || defined(CRIS) \
 	     || (defined(I386) && defined(__LCC__))
 	/* Use setjmp based hack to mark from callee-save registers.    */
@@ -2249,7 +2279,7 @@
 #	    else
 #	      if defined(AMIGA) && defined(GC_AMIGA_FASTALLOC)
 			extern void *GC_amiga_get_mem(size_t size);
-#			define GET_MEM(bytes) HBLKPTR((size_t) \
+#		define GET_MEM(bytes) HBLKPTR((size_t) \
 			  GC_amiga_get_mem((size_t)bytes + GC_page_size) \
 			  + GC_page_size-1)
 #	      else
@@ -2265,4 +2295,10 @@
 
 #endif /* GC_PRIVATE_H */
 
+#if defined(_AIX) && !defined(__GNUC__) && !defined(__STDC__)
+  /* IBMs xlc compiler doesn't appear to follow the convention of	*/
+  /* defining  __STDC__ to be zero in extended mode.			*/
+#   define __STDC__ 0
+#endif
+
 # endif /* GCCONFIG_H */
diff -urN old/boehm-gc/include/private/gc_hdrs.h src/boehm-gc/include/private/gc_hdrs.h
--- old/boehm-gc/include/private/gc_hdrs.h	2003-07-28 06:18:23.000000000 +0200
+++ src/boehm-gc/include/private/gc_hdrs.h	2006-08-28 19:14:18.130718000 +0200
@@ -108,7 +108,7 @@
 
 /* Analogous to GET_HDR, except that in the case of large objects, it	*/
 /* Returns the header for the object beginning, and updates p.		*/
-/* Returns &GC_bad_header instead of 0.  All of this saves a branch	*/
+/* Returns GC_invalid_header instead of 0.  All of this saves a branch	*/
 /* in the fast path.							*/
 # define HC_GET_HDR(p, hhdr, source) \
 	{ \
diff -urN old/boehm-gc/include/private/gc_locks.h src/boehm-gc/include/private/gc_locks.h
--- old/boehm-gc/include/private/gc_locks.h	2005-09-16 00:35:52.000000000 +0200
+++ src/boehm-gc/include/private/gc_locks.h	2006-08-28 19:14:18.130718000 +0200
@@ -139,6 +139,25 @@
 #      define GC_TEST_AND_SET_DEFINED
 #    endif
 #    if defined(POWERPC)
+#     if 0 /* CPP_WORDSZ == 64  totally broken to use int locks with ldarx */
+        inline static int GC_test_and_set(volatile unsigned int *addr) {
+          unsigned long oldval;
+          unsigned long temp = 1; /* locked value */
+
+          __asm__ __volatile__(
+               "1:\tldarx %0,0,%3\n"   /* load and reserve               */
+               "\tcmpdi %0, 0\n"       /* if load is                     */
+               "\tbne 2f\n"            /*   non-zero, return already set */
+               "\tstdcx. %2,0,%1\n"    /* else store conditional         */
+               "\tbne- 1b\n"           /* retry if lost reservation      */
+               "\tsync\n"              /* import barrier                 */
+               "2:\t\n"                /* oldval is zero if we set       */
+              : "=&r"(oldval), "=p"(addr)
+              : "r"(temp), "1"(addr)
+              : "cr0","memory");
+          return (int)oldval;
+        }
+#     else
         inline static int GC_test_and_set(volatile unsigned int *addr) {
           int oldval;
           int temp = 1; /* locked value */
@@ -156,12 +175,13 @@
               : "cr0","memory");
           return oldval;
         }
-#       define GC_TEST_AND_SET_DEFINED
-        inline static void GC_clear(volatile unsigned int *addr) {
-	  __asm__ __volatile__("eieio" : : : "memory");
-          *(addr) = 0;
-        }
-#       define GC_CLEAR_DEFINED
+#     endif
+#     define GC_TEST_AND_SET_DEFINED
+      inline static void GC_clear(volatile unsigned int *addr) {
+	__asm__ __volatile__("lwsync" : : : "memory");
+        *(addr) = 0;
+      }
+#     define GC_CLEAR_DEFINED
 #    endif
 #    if defined(ALPHA) 
         inline static int GC_test_and_set(volatile unsigned int * addr)
@@ -282,6 +302,8 @@
 #          define GC_test_and_set(addr) test_and_set((void *)addr,1)
 #	 endif
 #    else
+#	 include <sgidefs.h>
+#	 include <mutex.h>
 #	 define GC_test_and_set(addr) __test_and_set32((void *)addr,1)
 #	 define GC_clear(addr) __lock_release(addr);
 #	 define GC_CLEAR_DEFINED
@@ -354,7 +376,7 @@
 #  endif
 
 #  if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \
-      && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS)
+      && !defined(GC_WIN32_THREADS)
 #    define NO_THREAD (pthread_t)(-1)
 #    include <pthread.h>
 #    if defined(PARALLEL_MARK) 
@@ -401,6 +423,29 @@
 
 #     if defined(POWERPC)
 #      if !defined(GENERIC_COMPARE_AND_SWAP)
+#       if CPP_WORDSZ == 64
+        /* Returns TRUE if the comparison succeeded. */
+        inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,
+            GC_word old, GC_word new_val) 
+        {
+            unsigned long result, dummy;
+            __asm__ __volatile__(
+                "1:\tldarx %0,0,%5\n"
+                  "\tcmpd %0,%4\n"
+                  "\tbne  2f\n"
+                  "\tstdcx. %3,0,%2\n"
+                  "\tbne- 1b\n"
+                  "\tsync\n"
+                  "\tli %1, 1\n"
+                  "\tb 3f\n"
+                "2:\tli %1, 0\n"
+                "3:\t\n"
+                :  "=&r" (dummy), "=r" (result), "=p" (addr)
+                :  "r" (new_val), "r" (old), "2"(addr)
+                : "cr0","memory");
+            return (GC_bool) result;
+        }
+#       else
         /* Returns TRUE if the comparison succeeded. */
         inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,
             GC_word old, GC_word new_val) 
@@ -422,6 +467,7 @@
                 : "cr0","memory");
             return (GC_bool) result;
         }
+#       endif
 #      endif /* !GENERIC_COMPARE_AND_SWAP */
         inline static void GC_memory_barrier()
         {
@@ -598,33 +644,6 @@
       extern pthread_t GC_mark_lock_holder;
 #   endif
 #  endif /* GC_PTHREADS with linux_threads.c implementation */
-#  if defined(GC_IRIX_THREADS)
-#    include <pthread.h>
-     /* This probably should never be included, but I can't test	*/
-     /* on Irix anymore.						*/
-#    include <mutex.h>
-
-     extern volatile unsigned int GC_allocate_lock;
-	/* This is not a mutex because mutexes that obey the (optional) 	*/
-	/* POSIX scheduling rules are subject to convoys in high contention	*/
-	/* applications.  This is basically a spin lock.			*/
-     extern pthread_t GC_lock_holder;
-     extern void GC_lock(void);
-	/* Allocation lock holder.  Only set if acquired by client through */
-	/* GC_call_with_alloc_lock.					   */
-#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()
-#    define NO_THREAD (pthread_t)(-1)
-#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD
-#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))
-#    define LOCK() { if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }
-#    define UNLOCK() GC_clear(&GC_allocate_lock);
-     extern VOLATILE GC_bool GC_collecting;
-#    define ENTER_GC() \
-		{ \
-		    GC_collecting = 1; \
-		}
-#    define EXIT_GC() GC_collecting = 0;
-#  endif /* GC_IRIX_THREADS */
 #  if defined(GC_WIN32_THREADS)
 #    if defined(GC_PTHREADS)
 #      include <pthread.h>
diff -urN old/boehm-gc/include/private/gc_priv.h src/boehm-gc/include/private/gc_priv.h
--- old/boehm-gc/include/private/gc_priv.h	2005-11-02 01:06:30.000000000 +0100
+++ src/boehm-gc/include/private/gc_priv.h	2006-08-28 19:14:18.130718000 +0200
@@ -262,17 +262,6 @@
 /*                               */
 /*********************************/
 
-#ifdef SAVE_CALL_CHAIN
-
-/* Fill in the pc and argument information for up to NFRAMES of my	*/
-/* callers.  Ignore my frame and my callers frame.			*/
-struct callinfo;
-void GC_save_callers GC_PROTO((struct callinfo info[NFRAMES]));
-  
-void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));
-
-#endif
-
 #ifdef NEED_CALLINFO
     struct callinfo {
 	word ci_pc;  	/* Caller, not callee, pc	*/
@@ -286,6 +275,16 @@
     };
 #endif
 
+#ifdef SAVE_CALL_CHAIN
+
+/* Fill in the pc and argument information for up to NFRAMES of my	*/
+/* callers.  Ignore my frame and my callers frame.			*/
+void GC_save_callers GC_PROTO((struct callinfo info[NFRAMES]));
+  
+void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));
+
+#endif
+
 
 /*********************************/
 /*                               */
diff -urN old/boehm-gc/include/private/pthread_stop_world.h src/boehm-gc/include/private/pthread_stop_world.h
--- old/boehm-gc/include/private/pthread_stop_world.h	2003-07-28 05:46:07.000000000 +0200
+++ src/boehm-gc/include/private/pthread_stop_world.h	2006-08-28 19:14:18.140718000 +0200
@@ -2,7 +2,6 @@
 #define GC_PTHREAD_STOP_WORLD_H
 
 struct thread_stop_info {
-    int	signal;
     word last_stop_count;	/* GC_last_stop_count value when thread	*/
     				/* last successfully handled a suspend	*/
     				/* signal.				*/
diff -urN old/boehm-gc/include/private/pthread_support.h src/boehm-gc/include/private/pthread_support.h
--- old/boehm-gc/include/private/pthread_support.h	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/include/private/pthread_support.h	2006-08-28 19:14:18.140718000 +0200
@@ -4,7 +4,7 @@
 # include "private/gc_priv.h"
 
 # if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \
-     && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS)
+     && !defined(GC_WIN32_THREADS)
      
 #if defined(GC_DARWIN_THREADS)
 # include "private/darwin_stop_world.h"
@@ -33,6 +33,7 @@
 #	define FINISHED 1   	/* Thread has exited.	*/
 #	define DETACHED 2	/* Thread is intended to be detached.	*/
 #	define MAIN_THREAD 4	/* True for the original thread only.	*/
+#       define SUSPENDED 8      /* True if thread was suspended externally */
     short thread_blocked;	/* Protected by GC lock.		*/
     				/* Treated as a boolean value.  If set,	*/
     				/* thread will acquire GC lock before	*/
diff -urN old/boehm-gc/mach_dep.c src/boehm-gc/mach_dep.c
--- old/boehm-gc/mach_dep.c	2005-02-09 22:33:02.000000000 +0100
+++ src/boehm-gc/mach_dep.c	2006-08-28 19:14:18.140718000 +0200
@@ -27,6 +27,10 @@
 #   endif
 # endif
 
+#if defined(RS6000) || defined(POWERPC)
+# include <ucontext.h>
+#endif
+
 #if defined(__MWERKS__) && !defined(POWERPC)
 
 asm static void PushMacRegisters()
@@ -413,6 +417,13 @@
         /* the stack.						*/
         __builtin_unwind_init();
 #     else /* !HAVE_BUILTIN_UNWIND_INIT */
+#      if defined(RS6000) || defined(POWERPC)
+	/* FIXME: RS6000 means AIX.				*/
+        /* This should probably be used in all Posix/non-gcc	*/
+        /* settings.  We defer that change to minimize risk.	*/
+        ucontext_t ctxt;
+        getcontext(&ctxt);
+#      else
         /* Generic code                          */
         /* The idea is due to Parag Patel at HP. */
         /* We're not sure whether he would like  */
@@ -426,7 +437,7 @@
   	for (; (char *)i < lim; i++) {
   	    *i = 0;
   	}
-#       if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \
+#       if defined(MSWIN32) || defined(MSWINCE) \
                   || defined(UTS4) || defined(LINUX) || defined(EWS4800)
   	  (void) setjmp(regs);
 #       else
@@ -435,15 +446,16 @@
   	  /* SUSV3, setjmp() may or may not save signal mask.	*/
   	  /* _setjmp won't, but is less portable.		*/
 #       endif
+#      endif /* !AIX ... */
 #     endif /* !HAVE_BUILTIN_UNWIND_INIT */
-#   elif defined(PTHREADS) && !defined(MSWIN32) /* !USE_GENERIC_PUSH_REGS */
-      /* We may still need this to save thread contexts.	*/
-      /* This should probably be used in all Posix/non-gcc	*/
-      /* settings.  We defer that change to minimize risk.	*/
-      ucontext_t ctxt;
-      getcontext(&ctxt);
-#   else  /* Shouldn't be needed */
-      ABORT("Unexpected call to GC_with_callee_saves_pushed");
+#   else
+#     if defined(PTHREADS) && !defined(MSWIN32) /* !USE_GENERIC_PUSH_REGS */
+        /* We may still need this to save thread contexts.	*/
+        ucontext_t ctxt;
+        getcontext(&ctxt);
+#     else  /* Shouldn't be needed */
+        ABORT("Unexpected call to GC_with_callee_saves_pushed");
+#     endif
 #   endif
 #   if (defined(SPARC) && !defined(HAVE_BUILTIN_UNWIND_INIT)) \
 	|| defined(IA64)
@@ -480,7 +492,7 @@
 /* the stack.	Return sp.						*/
 # ifdef SPARC
     asm("	.seg 	\"text\"");
-#   if defined(SVR4) || defined(NETBSD)
+#   if defined(SVR4) || defined(NETBSD) || defined(FREEBSD)
       asm("	.globl	GC_save_regs_in_stack");
       asm("GC_save_regs_in_stack:");
       asm("	.type GC_save_regs_in_stack,#function");
diff -urN old/boehm-gc/Makefile.am src/boehm-gc/Makefile.am
--- old/boehm-gc/Makefile.am	2004-11-05 02:51:50.000000000 +0100
+++ src/boehm-gc/Makefile.am	2006-08-28 19:14:18.100718000 +0200
@@ -12,33 +12,32 @@
 noinst_LTLIBRARIES = libgcjgc.la libgcjgc_convenience.la
 
 if POWERPC_DARWIN
-asm_libgc_sources = powerpc_darwin_mach_dep.s
+asm_libgcjgc_sources = powerpc_darwin_mach_dep.s
 else
-asm_libgc_sources = 
+asm_libgcjgc_sources = 
 endif
 
-GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \
-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \
+libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \
+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \
 malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \
 obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \
 solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \
 backgraph.c win32_threads.c \
 pthread_support.c pthread_stop_world.c darwin_stop_world.c \
-$(asm_libgc_sources)
+$(asm_libgcjgc_sources)
+
+libgcjgc_convenience_la_SOURCES = $(libgcjgc_la_SOURCES)
 
 EXTRA_DIST = alpha_mach_dep.S \
 mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \
 rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \
 sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s
 
-libgcjgc_la_SOURCES = $(GC_SOURCES)
-libgcjgc_convenience_la_SOURCES = $(GC_SOURCES)
-
 # Include THREADLIBS here to ensure that the correct versions of
 # linuxthread semaphore functions get linked:
-libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)
+libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS) $(UNWINDLIBS)
 libgcjgc_la_DEPENDENCIES = @addobjs@
-libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)
+libgcjgc_la_LDFLAGS = -version-info 1:2:0 -rpath $(toolexeclibdir)
 
 libgcjgc_convenience_la_LIBADD = @addobjs@
 libgcjgc_convenience_la_DEPENDENCIES = @addobjs@
@@ -48,7 +47,7 @@
 
 check_PROGRAMS = gctest
 gctest_SOURCES = tests/test.c
-gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(EXTRA_TEST_LIBS)
+gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)
 gctest_LDFLAGS = -shared-libgcc
 TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc
 TESTS = gctest
@@ -111,3 +110,8 @@
 CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host
 
 MAKEOVERRIDES=
+
+# No install-html support yet
+.PHONY: install-html
+install-html:
+
diff -urN old/boehm-gc/Makefile.direct src/boehm-gc/Makefile.direct
--- old/boehm-gc/Makefile.direct	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/Makefile.direct	2006-08-28 19:14:18.100718000 +0200
@@ -36,7 +36,7 @@
 # -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC
 # To build the parallel collector in a static library on HP/UX,
 # add to the above:
-# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L
+# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L -mt
 # To build the thread-safe collector on Tru64, add to the above:
 # -pthread -DGC_OSF1_THREADS
 
@@ -70,10 +70,11 @@
 #   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.
 # -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.
 #   see README.linux.  -D_REENTRANT may also be required.
-# -DGC_OSF1_THREADS enables support for Tru64 pthreads.  Untested.
-# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.  Untested.
+# -DGC_OSF1_THREADS enables support for Tru64 pthreads.
+# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.
 #   Appeared to run into some underlying thread problems.
-# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.  Untested.
+# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.
+# -DGC_AIX_THREADS enables support for IBM AIX threads.
 # -DGC_DGUX386_THREADS enables support for DB/UX on I386 threads.
 #   See README.DGUX386.
 # -DGC_WIN32_THREADS enables support for win32 threads.  That makes sense
@@ -233,8 +234,8 @@
 # -DTHREAD_LOCAL_ALLOC defines GC_local_malloc(), GC_local_malloc_atomic()
 #   and GC_local_gcj_malloc().  Needed for gc_gcj.h interface.  These allocate
 #   in a way that usually does not involve acquisition of a global lock.
-#   Currently requires -DGC_LINUX_THREADS, but should be easy to port to
-#   other pthreads environments.  Recommended for multiprocessors.
+#   Currently works only on platforms such as Linux which use pthread_support.c.
+#   Recommended for multiprocessors.
 # -DUSE_COMPILER_TLS causes thread local allocation to use compiler-supported
 #   "__thread" thread-local variables.  This is the default in HP/UX.  It
 #   may help performance on recent Linux installations.  (It failed for
@@ -276,6 +277,10 @@
 # -DPOINTER_SHIFT=n causes the collector to left shift candidate pointers
 #   by the indicated amount before trying to interpret them.  Applied
 #   after POINTER_MASK. EXPERIMENTAL.  See also the preceding macro.
+# -DDARWIN_DONT_PARSE_STACK Causes the Darwin port to discover thread
+#   stack bounds in the same way as other pthread ports, without trying to
+#   walk the frames onthe stack.  This is recommended only as a fallback
+#   for applications that don't support proper stack unwinding.
 #
 
 CXXFLAGS= $(CFLAGS) 
@@ -283,9 +288,9 @@
 RANLIB= ranlib
 
 
-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o aix_irix_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o
+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o
 
-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c aix_irix_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c
+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c
 
 CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC
 
diff -urN old/boehm-gc/Makefile.in src/boehm-gc/Makefile.in
--- old/boehm-gc/Makefile.in	2006-05-25 01:46:15.000000000 +0200
+++ src/boehm-gc/Makefile.in	2006-08-28 19:14:18.100718000 +0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,8 +14,6 @@
 
 @SET_MAKE@
 
-SOURCES = $(libgcjgc_la_SOURCES) $(libgcjgc_convenience_la_SOURCES) $(gctest_SOURCES)
-
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
@@ -65,12 +63,13 @@
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
-	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
-	$(srcdir)/../ltmain.sh $(srcdir)/../config.guess \
-	$(srcdir)/../config.sub
+	$(srcdir)/../compile $(srcdir)/../ltmain.sh \
+	$(srcdir)/../config.guess $(srcdir)/../config.sub
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/depstand.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
 	$(top_srcdir)/../config/no-executables.m4 \
 	$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
@@ -83,24 +82,30 @@
 LTLIBRARIES = $(noinst_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 @POWERPC_DARWIN_TRUE@am__objects_1 = powerpc_darwin_mach_dep.lo
-am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \
+am_libgcjgc_la_OBJECTS = allchblk.lo alloc.lo blacklst.lo checksums.lo \
 	dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \
-	headers.lo aix_irix_threads.lo malloc.lo mallocx.lo mark.lo \
-	mark_rts.lo misc.lo new_hblk.lo obj_map.lo os_dep.lo \
-	pcr_interface.lo ptr_chck.lo real_malloc.lo reclaim.lo \
-	solaris_pthreads.lo solaris_threads.lo specific.lo stubborn.lo \
-	typd_mlc.lo backgraph.lo win32_threads.lo pthread_support.lo \
+	headers.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \
+	new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \
+	real_malloc.lo reclaim.lo solaris_pthreads.lo \
+	solaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \
+	backgraph.lo win32_threads.lo pthread_support.lo \
 	pthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)
-am_libgcjgc_la_OBJECTS = $(am__objects_2)
 libgcjgc_la_OBJECTS = $(am_libgcjgc_la_OBJECTS)
+am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \
+	dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \
+	headers.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \
+	new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \
+	real_malloc.lo reclaim.lo solaris_pthreads.lo \
+	solaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \
+	backgraph.lo win32_threads.lo pthread_support.lo \
+	pthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)
 am_libgcjgc_convenience_la_OBJECTS = $(am__objects_2)
 libgcjgc_convenience_la_OBJECTS =  \
 	$(am_libgcjgc_convenience_la_OBJECTS)
 am__dirstamp = $(am__leading_dot)dirstamp
 am_gctest_OBJECTS = tests/test.$(OBJEXT)
 gctest_OBJECTS = $(am_gctest_OBJECTS)
-gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
+gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include -I$(top_builddir)/include
 depcomp =
 am__depfiles_maybe =
@@ -252,36 +257,35 @@
 ACLOCAL_AMFLAGS = -I .. -I ../config
 SUBDIRS = include
 noinst_LTLIBRARIES = libgcjgc.la libgcjgc_convenience.la
-@POWERPC_DARWIN_FALSE@asm_libgc_sources = 
-@POWERPC_DARWIN_TRUE@asm_libgc_sources = powerpc_darwin_mach_dep.s
-GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \
-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \
+@POWERPC_DARWIN_FALSE@asm_libgcjgc_sources = 
+@POWERPC_DARWIN_TRUE@asm_libgcjgc_sources = powerpc_darwin_mach_dep.s
+libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \
+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \
 malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \
 obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \
 solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \
 backgraph.c win32_threads.c \
 pthread_support.c pthread_stop_world.c darwin_stop_world.c \
-$(asm_libgc_sources)
+$(asm_libgcjgc_sources)
 
+libgcjgc_convenience_la_SOURCES = $(libgcjgc_la_SOURCES)
 EXTRA_DIST = alpha_mach_dep.S \
 mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \
 rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \
 sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s
 
-libgcjgc_la_SOURCES = $(GC_SOURCES)
-libgcjgc_convenience_la_SOURCES = $(GC_SOURCES)
 
 # Include THREADLIBS here to ensure that the correct versions of
 # linuxthread semaphore functions get linked:
-libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)
+libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS) $(UNWINDLIBS)
 libgcjgc_la_DEPENDENCIES = @addobjs@
-libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)
+libgcjgc_la_LDFLAGS = -version-info 1:2:0 -rpath $(toolexeclibdir)
 libgcjgc_convenience_la_LIBADD = @addobjs@
 libgcjgc_convenience_la_DEPENDENCIES = @addobjs@
 AM_CXXFLAGS = @GC_CFLAGS@
 AM_CFLAGS = @GC_CFLAGS@
 gctest_SOURCES = tests/test.c
-gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(EXTRA_TEST_LIBS)
+gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)
 gctest_LDFLAGS = -shared-libgcc
 TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc
 TESTS = gctest
@@ -454,7 +458,13 @@
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -466,7 +476,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done; \
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
@@ -474,7 +484,13 @@
 
 mostlyclean-recursive clean-recursive distclean-recursive \
 maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	case "$@" in \
 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
@@ -495,7 +511,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -746,6 +762,10 @@
 	$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<
 .S.lo:
 	$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<
+
+# No install-html support yet
+.PHONY: install-html
+install-html:
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -urN old/boehm-gc/mallocx.c src/boehm-gc/mallocx.c
--- old/boehm-gc/mallocx.c	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/mallocx.c	2006-08-28 19:14:18.140718000 +0200
@@ -172,7 +172,8 @@
 # endif /* REDIRECT_REALLOC */
 
 
-/* The same thing, except caller does not hold allocation lock.	*/
+/* Allocate memory such that only pointers to near the 		*/
+/* beginning of the object are considered.			*/
 /* We avoid holding allocation lock while we clear memory.	*/
 ptr_t GC_generic_malloc_ignore_off_page(lb, k)
 register size_t lb;
diff -urN old/boehm-gc/mark.c src/boehm-gc/mark.c
--- old/boehm-gc/mark.c	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/mark.c	2006-08-28 19:14:18.140718000 +0200
@@ -858,9 +858,9 @@
 	    ++top;
 	    top -> mse_descr = descr;
 	    top -> mse_start = p -> mse_start;
-	    GC_ASSERT(  top -> mse_descr & GC_DS_TAGS != GC_DS_LENGTH || 
-			top -> mse_descr < GC_greatest_plausible_heap_addr
-			                   - GC_least_plausible_heap_addr);
+	    GC_ASSERT(  (top -> mse_descr & GC_DS_TAGS) != GC_DS_LENGTH || 
+			top -> mse_descr < (ptr_t)GC_greatest_plausible_heap_addr
+			                   - (ptr_t)GC_least_plausible_heap_addr);
 	    /* If this is a big object, count it as			*/
 	    /* size/256 + 1 objects.					*/
 	    ++i;
@@ -1450,8 +1450,8 @@
 ptr_t bottom;
 ptr_t top;
 {
-    word * b = (word *)(((long) bottom + ALIGNMENT-1) & ~(ALIGNMENT-1));
-    word * t = (word *)(((long) top) & ~(ALIGNMENT-1));
+    word * b = (word *)(((word) bottom + ALIGNMENT-1) & ~(ALIGNMENT-1));
+    word * t = (word *)(((word) top) & ~(ALIGNMENT-1));
     register word *p;
     register word q;
     register word *lim;
diff -urN old/boehm-gc/misc.c src/boehm-gc/misc.c
--- old/boehm-gc/misc.c	2004-08-21 09:49:17.000000000 +0200
+++ src/boehm-gc/misc.c	2006-08-28 19:17:32.360718000 +0200
@@ -246,7 +246,7 @@
     	byte_sz = WORDS_TO_BYTES(word_sz);
 	if (GC_all_interior_pointers) {
 	    /* We need one extra byte; don't fill in GC_size_map[byte_sz] */
-	    byte_sz--;
+	    byte_sz -= EXTRA_BYTES;
 	}
 
     	for (j = low_limit; j <= byte_sz; j++) GC_size_map[j] = word_sz;  
@@ -674,7 +674,13 @@
 #   if !defined(THREADS) || defined(GC_PTHREADS) || defined(GC_WIN32_THREADS) \
 	|| defined(GC_SOLARIS_THREADS)
       if (GC_stackbottom == 0) {
-	GC_stackbottom = GC_get_stack_base();
+        # ifdef GC_PTHREADS
+	/* Use thread_stack_base if available, as GC could be initialized from
+	   a thread that is not the "main" thread.  */
+	GC_stackbottom = GC_get_thread_stack_base();
+	# endif
+	if (GC_stackbottom == 0)
+	  GC_stackbottom = GC_get_stack_base();
 #       if (defined(LINUX) || defined(HPUX)) && defined(IA64)
 	  GC_register_stackbottom = GC_get_register_stack_base();
 #       endif
@@ -805,7 +811,10 @@
 
 void GC_enable_incremental GC_PROTO(())
 {
-# if !defined(SMALL_CONFIG)
+# if !defined(SMALL_CONFIG) && !defined(KEEP_BACK_PTRS)
+  /* If we are keeping back pointers, the GC itself dirties all	*/
+  /* pages on which objects have been marked, making 		*/
+  /* incremental GC pointless.					*/
   if (!GC_find_leak) {
     DCL_LOCK_STATE;
     
diff -urN old/boehm-gc/os_dep.c src/boehm-gc/os_dep.c
--- old/boehm-gc/os_dep.c	2005-06-15 23:25:54.000000000 +0200
+++ src/boehm-gc/os_dep.c	2006-08-28 19:17:32.350718000 +0200
@@ -60,6 +60,10 @@
 #   include <signal.h>
 # endif
 
+#if defined(LINUX) || defined(LINUX_STACKBOTTOM)
+# include <ctype.h>
+#endif
+
 /* Blatantly OS dependent routines, except for those that are related 	*/
 /* to dynamic loading.							*/
 
@@ -245,30 +249,11 @@
 //  XXXXXXXX-XXXXXXXX r-xp 00000000 30:05 260537     name of mapping...\n
 //  ^^^^^^^^ ^^^^^^^^ ^^^^          ^^
 //  start    end      prot          maj_dev
-//  0        9        18            32
-//  
-//  For 64 bit ABIs:
-//  0	     17	      34	    56
 //
-//  The parser is called with a pointer to the entry and the return value
-//  is either NULL or is advanced to the next entry(the byte after the
-//  trailing '\n'.)
+//  Note that since about auguat 2003 kernels, the columns no longer have
+//  fixed offsets on 64-bit kernels.  Hence we no longer rely on fixed offsets
+//  anywhere, which is safer anyway.
 //
-#if CPP_WORDSZ == 32
-# define OFFSET_MAP_START   0
-# define OFFSET_MAP_END     9
-# define OFFSET_MAP_PROT   18
-# define OFFSET_MAP_MAJDEV 32
-# define ADDR_WIDTH 	    8
-#endif
-
-#if CPP_WORDSZ == 64
-# define OFFSET_MAP_START   0
-# define OFFSET_MAP_END    17
-# define OFFSET_MAP_PROT   34
-# define OFFSET_MAP_MAJDEV 56
-# define ADDR_WIDTH 	   16
-#endif
 
 /*
  * Assign various fields of the first line in buf_ptr to *start, *end,
@@ -277,37 +262,46 @@
 char *GC_parse_map_entry(char *buf_ptr, word *start, word *end,
                                 char *prot_buf, unsigned int *maj_dev)
 {
-    int i;
-    char *tok;
+    char *start_start, *end_start, *prot_start, *maj_dev_start;
+    char *p;
+    char *endp;
 
     if (buf_ptr == NULL || *buf_ptr == '\0') {
         return NULL;
     }
 
-    memcpy(prot_buf, buf_ptr+OFFSET_MAP_PROT, 4);
-    				/* do the protections first. */
+    p = buf_ptr;
+    while (isspace(*p)) ++p;
+    start_start = p;
+    GC_ASSERT(isxdigit(*start_start));
+    *start = strtoul(start_start, &endp, 16); p = endp;
+    GC_ASSERT(*p=='-');
+
+    ++p;
+    end_start = p;
+    GC_ASSERT(isxdigit(*end_start));
+    *end = strtoul(end_start, &endp, 16); p = endp;
+    GC_ASSERT(isspace(*p));
+
+    while (isspace(*p)) ++p;
+    prot_start = p;
+    GC_ASSERT(*prot_start == 'r' || *prot_start == '-');
+    memcpy(prot_buf, prot_start, 4);
     prot_buf[4] = '\0';
-
-    if (prot_buf[1] == 'w') {/* we can skip all of this if it's not writable. */
-
-        tok = buf_ptr;
-        buf_ptr[OFFSET_MAP_START+ADDR_WIDTH] = '\0';
-        *start = strtoul(tok, NULL, 16);
-
-        tok = buf_ptr+OFFSET_MAP_END;
-        buf_ptr[OFFSET_MAP_END+ADDR_WIDTH] = '\0';
-        *end = strtoul(tok, NULL, 16);
-
-        buf_ptr += OFFSET_MAP_MAJDEV;
-        tok = buf_ptr;
-        while (*buf_ptr != ':') buf_ptr++;
-        *buf_ptr++ = '\0';
-        *maj_dev = strtoul(tok, NULL, 16);
+    if (prot_buf[1] == 'w') {/* we can skip the rest if it's not writable. */
+	/* Skip past protection field to offset field */
+          while (!isspace(*p)) ++p; while (isspace(*p)) ++p;
+          GC_ASSERT(isxdigit(*p));
+	/* Skip past offset field, which we ignore */
+          while (!isspace(*p)) ++p; while (isspace(*p)) ++p;
+	maj_dev_start = p;
+        GC_ASSERT(isxdigit(*maj_dev_start));
+        *maj_dev = strtoul(maj_dev_start, NULL, 16);
     }
 
-    while (*buf_ptr && *buf_ptr++ != '\n');
+    while (*p && *p++ != '\n');
 
-    return buf_ptr;
+    return p;
 }
 
 #endif /* Need to parse /proc/self/maps. */	
@@ -699,7 +693,7 @@
 #   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1) \
     || defined(HURD) || defined(NETBSD)
 	static struct sigaction old_segv_act;
-#	if defined(_sigargs) /* !Irix6.x */ || defined(HPUX) \
+#	if defined(IRIX5) || defined(HPUX) \
 	|| defined(HURD) || defined(NETBSD)
 	    static struct sigaction old_bus_act;
 #	endif
@@ -732,9 +726,11 @@
 		/* and setting a handler at the same time.		*/
 	        (void) sigaction(SIGSEGV, 0, &old_segv_act);
 	        (void) sigaction(SIGSEGV, &act, 0);
+	        (void) sigaction(SIGBUS, 0, &old_bus_act);
+	        (void) sigaction(SIGBUS, &act, 0);
 #	  else
 	        (void) sigaction(SIGSEGV, &act, &old_segv_act);
-#		if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \
+#		if defined(IRIX5) \
 		   || defined(HPUX) || defined(HURD) || defined(NETBSD)
 		    /* Under Irix 5.x or HP/UX, we may get SIGBUS.	*/
 		    /* Pthreads doesn't exist under Irix 5.x, so we	*/
@@ -773,7 +769,7 @@
 #       if defined(SUNOS5SIGS) || defined(IRIX5) \
 	   || defined(OSF1) || defined(HURD) || defined(NETBSD)
 	  (void) sigaction(SIGSEGV, &old_segv_act, 0);
-#	  if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \
+#	  if defined(IRIX5) \
 	     || defined(HPUX) || defined(HURD) || defined(NETBSD)
 	      (void) sigaction(SIGBUS, &old_bus_act, 0);
 #	  endif
@@ -854,13 +850,14 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <ctype.h>
 
 # define STAT_SKIP 27   /* Number of fields preceding startstack	*/
 			/* field in /proc/self/stat			*/
 
+#ifdef USE_LIBC_PRIVATES
 # pragma weak __libc_stack_end
   extern ptr_t __libc_stack_end;
+#endif
 
 # ifdef IA64
     /* Try to read the backing store base from /proc/self/maps.	*/
@@ -890,30 +887,33 @@
         return GC_apply_to_maps(backing_store_base_from_maps);
     }
 
-#   pragma weak __libc_ia64_register_backing_store_base
-    extern ptr_t __libc_ia64_register_backing_store_base;
+#   ifdef USE_LIBC_PRIVATES
+#     pragma weak __libc_ia64_register_backing_store_base
+      extern ptr_t __libc_ia64_register_backing_store_base;
+#   endif
 
     ptr_t GC_get_register_stack_base(void)
     {
-      if (0 != &__libc_ia64_register_backing_store_base
-	  && 0 != __libc_ia64_register_backing_store_base) {
-	/* Glibc 2.2.4 has a bug such that for dynamically linked	*/
-	/* executables __libc_ia64_register_backing_store_base is 	*/
-	/* defined but uninitialized during constructor calls.  	*/
-	/* Hence we check for both nonzero address and value.		*/
-	return __libc_ia64_register_backing_store_base;
-      } else {
-	word result = backing_store_base_from_proc();
-	if (0 == result) {
+#     ifdef USE_LIBC_PRIVATES
+        if (0 != &__libc_ia64_register_backing_store_base
+	    && 0 != __libc_ia64_register_backing_store_base) {
+	  /* Glibc 2.2.4 has a bug such that for dynamically linked	*/
+	  /* executables __libc_ia64_register_backing_store_base is 	*/
+	  /* defined but uninitialized during constructor calls.  	*/
+	  /* Hence we check for both nonzero address and value.		*/
+	  return __libc_ia64_register_backing_store_base;
+        }
+#     endif
+      word result = backing_store_base_from_proc();
+      if (0 == result) {
 	  /* Use dumb heuristics.  Works only for default configuration. */
 	  result = (word)GC_stackbottom - BACKING_STORE_DISPLACEMENT;
 	  result += BACKING_STORE_ALIGNMENT - 1;
 	  result &= ~(BACKING_STORE_ALIGNMENT - 1);
 	  /* Verify that it's at least readable.  If not, we goofed. */
 	  GC_noop1(*(word *)result); 
-	}
-	return (ptr_t)result;
       }
+      return (ptr_t)result;
     }
 # endif
 
@@ -936,6 +936,7 @@
     /* since the correct value of __libc_stack_end never	*/
     /* becomes visible to us.  The second test works around 	*/
     /* this.							*/  
+#   ifdef USE_LIBC_PRIVATES
       if (0 != &__libc_stack_end && 0 != __libc_stack_end ) {
 #       ifdef IA64
 	  /* Some versions of glibc set the address 16 bytes too	*/
@@ -957,6 +958,7 @@
 #	endif
 #	endif
       }
+#   endif
     f = open("/proc/self/stat", O_RDONLY);
     if (f < 0 || STAT_READ(f, stat_buf, STAT_BUF_SIZE) < 2 * STAT_SKIP) {
 	ABORT("Couldn't read /proc/self/stat");
@@ -1179,12 +1181,15 @@
   	/* This used to be set for gcc, to avoid dealing with		*/
   	/* the structured exception handling issues.  But we now have	*/
   	/* assembly code to do that right.				*/
+  GC_bool GC_wnt = FALSE;
+        /* This is a Windows NT derivative, i.e. NT, W2K, XP or later.  */
   
   void GC_init_win32()
   {
     /* if we're running under win32s, assume that no DLLs will be loaded */
     DWORD v = GetVersion();
-    GC_no_win32_dlls |= ((v & 0x80000000) && (v & 0xff) <= 3);
+    GC_wnt = !(v & 0x80000000);
+    GC_no_win32_dlls |= ((!GC_wnt) && (v & 0xff) <= 3);
   }
 
   /* Return the smallest address a such that VirtualQuery		*/
@@ -1508,7 +1513,7 @@
 # endif
 
 
-# ifdef RS6000
+# if 0 && defined(RS6000)  /* We now use mmap */
 /* The compiler seems to generate speculative reads one past the end of	*/
 /* an allocated object.  Hence we need to make sure that the page 	*/
 /* following the last heap page is also mapped.				*/
@@ -2381,7 +2386,7 @@
 #   endif
 #   ifdef FREEBSD
 #     define SIG_OK (sig == SIGBUS)
-#     define CODE_OK (code == BUS_PAGE_FAULT)
+#     define CODE_OK TRUE
 #   endif
 # endif /* SUNOS4 || (FREEBSD && !SUNOS5SIGS) */
 
@@ -3726,7 +3731,7 @@
     exception_behavior_t behavior;
     thread_state_flavor_t flavor;
     
-    thread_state_data_t thread_state;
+    thread_state_t thread_state;
     mach_msg_type_number_t thread_state_count = THREAD_STATE_MAX;
         
     for(i=0;i<GC_old_exc_ports.count;i++)
@@ -3787,13 +3792,19 @@
     char *addr;
     struct hblk *h;
     int i;
-#ifdef POWERPC
-    thread_state_flavor_t flavor = PPC_EXCEPTION_STATE;
-    mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE_COUNT;
-    ppc_exception_state_t exc_state;
-#else
+#   if defined(POWERPC)
+#     if CPP_WORDSZ == 32
+        thread_state_flavor_t flavor = PPC_EXCEPTION_STATE;
+        mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE_COUNT;
+        ppc_exception_state_t exc_state;
+#     else
+        thread_state_flavor_t flavor = PPC_EXCEPTION_STATE64;
+        mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE64_COUNT;
+        ppc_exception_state64_t exc_state;
+#     endif
+#   else
 #	error FIXME for non-ppc darwin
-#endif
+#   endif
 
     
     if(exception != EXC_BAD_ACCESS || code[0] != KERN_PROTECTION_FAILURE) {
@@ -3953,10 +3964,14 @@
 #      if defined (DRSNX)
 #	 include <sys/sparc/frame.h>
 #      else
-#	 if defined(OPENBSD) || defined(NETBSD)
+#	 if defined(OPENBSD)
 #	   include <frame.h>
 #	 else
-#	   include <sys/frame.h>
+#	   if defined(FREEBSD) || defined(NETBSD)
+#	     include <machine/frame.h>
+#	   else
+#	     include <sys/frame.h>
+#	   endif
 #	 endif
 #      endif
 #    endif
@@ -3985,6 +4000,16 @@
 #if NARGS == 0 && NFRAMES % 2 == 0 /* No padding */ \
     && defined(GC_HAVE_BUILTIN_BACKTRACE)
 
+#ifdef REDIRECT_MALLOC
+  /* Deal with possible malloc calls in backtrace by omitting	*/
+  /* the infinitely recursing backtrace.			*/
+# ifdef THREADS
+    __thread 	/* If your compiler doesn't understand this */
+    		/* you could use something like pthread_getspecific.	*/
+# endif
+  GC_in_save_callers = FALSE;
+#endif
+
 void GC_save_callers (info) 
 struct callinfo info[NFRAMES];
 {
@@ -3994,15 +4019,26 @@
   
   /* We retrieve NFRAMES+1 pc values, but discard the first, since it	*/
   /* points to our own frame.						*/
+# ifdef REDIRECT_MALLOC
+    if (GC_in_save_callers) {
+      info[0].ci_pc = (word)(&GC_save_callers);
+      for (i = 1; i < NFRAMES; ++i) info[i].ci_pc = 0;
+      return;
+    }
+    GC_in_save_callers = TRUE;
+# endif
   GC_ASSERT(sizeof(struct callinfo) == sizeof(void *));
   npcs = backtrace((void **)tmp_info, NFRAMES + IGNORE_FRAMES);
   BCOPY(tmp_info+IGNORE_FRAMES, info, (npcs - IGNORE_FRAMES) * sizeof(void *));
   for (i = npcs - IGNORE_FRAMES; i < NFRAMES; ++i) info[i].ci_pc = 0;
+# ifdef REDIRECT_MALLOC
+    GC_in_save_callers = FALSE;
+# endif
 }
 
 #else /* No builtin backtrace; do it ourselves */
 
-#if (defined(OPENBSD) || defined(NETBSD)) && defined(SPARC)
+#if (defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD)) && defined(SPARC)
 #  define FR_SAVFP fr_fp
 #  define FR_SAVPC fr_pc
 #else
diff -urN old/boehm-gc/powerpc_darwin_mach_dep.s src/boehm-gc/powerpc_darwin_mach_dep.s
--- old/boehm-gc/powerpc_darwin_mach_dep.s	2005-03-24 01:48:39.000000000 +0100
+++ src/boehm-gc/powerpc_darwin_mach_dep.s	2006-08-28 19:14:18.140718000 +0200
@@ -12,7 +12,7 @@
 
 ; GC_push_regs function. Under some optimization levels GCC will clobber
 ; some of the non-volatile registers before we get a chance to save them
-; therefore, this can't be inline asm.
+; therefore, this cannot be inline asm.
 
 .text
 	.align LOG2_GPR_BYTES
diff -urN old/boehm-gc/pthread_stop_world.c src/boehm-gc/pthread_stop_world.c
--- old/boehm-gc/pthread_stop_world.c	2005-02-09 22:33:02.000000000 +0100
+++ src/boehm-gc/pthread_stop_world.c	2006-08-28 19:14:18.140718000 +0200
@@ -1,13 +1,19 @@
 #include "private/pthread_support.h"
 
 #if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \
-     && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS) \
-     && !defined(GC_DARWIN_THREADS) && !defined(GC_AIX_THREADS)
+     && !defined(GC_WIN32_THREADS) && !defined(GC_DARWIN_THREADS)
 
 #include <signal.h>
 #include <semaphore.h>
 #include <errno.h>
 #include <unistd.h>
+#include <sys/time.h>
+#ifndef HPUX
+# include <sys/select.h>
+  /* Doesn't exist on HP/UX 11.11. */
+#endif
+
+void suspend_self();
 
 #if DEBUG_THREADS
 
@@ -67,7 +73,22 @@
 
 static sigset_t suspend_handler_mask;
 
-word GC_stop_count;	/* Incremented at the beginning of GC_stop_world. */
+volatile sig_atomic_t GC_stop_count;
+			/* Incremented at the beginning of GC_stop_world. */
+
+volatile sig_atomic_t GC_world_is_stopped = FALSE;
+			/* FALSE ==> it is safe for threads to restart, i.e. */
+			/* they will see another suspend signal before they  */
+			/* are expected to stop (unless they have voluntarily */
+			/* stopped).					     */
+
+void GC_brief_async_signal_safe_sleep()
+{
+    struct timeval tv;
+    tv.tv_sec = 0;
+    tv.tv_usec = 1000 * TIME_LIMIT / 2;
+    select(0, 0, 0, 0, &tv);
+}
 
 #ifdef GC_OSF1_THREADS
   GC_bool GC_retry_signals = TRUE;
@@ -108,7 +129,14 @@
 
 void GC_suspend_handler(int sig)
 {
-  GC_with_callee_saves_pushed(GC_suspend_handler_inner, (ptr_t)(word)sig);
+  GC_thread me = GC_lookup_thread (pthread_self());
+  if (me -> flags & SUSPENDED)
+    suspend_self();
+  else {
+    int old_errno = errno;
+    GC_with_callee_saves_pushed(GC_suspend_handler_inner, (ptr_t)(word)sig);
+    errno = old_errno;
+  }
 }
 
 #else
@@ -116,7 +144,14 @@
 /* in the signal handler frame.						*/
 void GC_suspend_handler(int sig)
 {
-  GC_suspend_handler_inner((ptr_t)(word)sig);
+  GC_thread me = GC_lookup_thread(pthread_self());
+  if (me -> flags & SUSPENDED)
+    suspend_self();
+  else {
+    int old_errno = errno;
+    GC_suspend_handler_inner((ptr_t)(word)sig);
+    errno = old_errno;
+  }
 }
 #endif
 
@@ -172,16 +207,26 @@
     /* this thread a SIG_THR_RESTART signal.			*/
     /* SIG_THR_RESTART should be masked at this point.  Thus there	*/
     /* is no race.						*/
-    do {
-	    me->stop_info.signal = 0;
-	    sigsuspend(&suspend_handler_mask);        /* Wait for signal */
-    } while (me->stop_info.signal != SIG_THR_RESTART);
+    /* We do not continue until we receive a SIG_THR_RESTART,	*/
+    /* but we do not take that as authoritative.  (We may be	*/
+    /* accidentally restarted by one of the user signals we 	*/
+    /* don't block.)  After we receive the signal, we use a 	*/
+    /* primitive and expensive mechanism to wait until it's	*/
+    /* really safe to proceed.  Under normal circumstances,	*/
+    /* this code should not be executed.			*/
+    sigsuspend(&suspend_handler_mask);        /* Wait for signal */
+    while (GC_world_is_stopped && GC_stop_count == my_stop_count) {
+        GC_brief_async_signal_safe_sleep();
+#       if DEBUG_THREADS
+	  GC_err_printf0("Sleeping in signal handler");
+#       endif
+    }
     /* If the RESTART signal gets lost, we can still lose.  That should be  */
     /* less likely than losing the SUSPEND signal, since we don't do much   */
     /* between the sem_post and sigsuspend.	   			    */
-    /* We'd need more handshaking to work around that, since we don't want  */
-    /* to accidentally leave a RESTART signal pending, thus causing us to   */
-    /* continue prematurely in a future round.				    */ 
+    /* We'd need more handshaking to work around that.			    */
+    /* Simply dropping the sigsuspend call should be safe, but is unlikely  */
+    /* to be efficient.							    */
 
 #if DEBUG_THREADS
     GC_printf1("Continuing 0x%lx\n", my_thread);
@@ -191,20 +236,11 @@
 void GC_restart_handler(int sig)
 {
     pthread_t my_thread = pthread_self();
-    GC_thread me;
 
     if (sig != SIG_THR_RESTART) ABORT("Bad signal in suspend_handler");
 
-    /* Let the GC_suspend_handler() know that we got a SIG_THR_RESTART. */
-    /* The lookup here is safe, since I'm doing this on behalf  */
-    /* of a thread which holds the allocation lock in order	*/
-    /* to stop the world.  Thus concurrent modification of the	*/
-    /* data structure is impossible.				*/
-    me = GC_lookup_thread(my_thread);
-    me->stop_info.signal = SIG_THR_RESTART;
-
     /*
-    ** Note: even if we didn't do anything useful here,
+    ** Note: even if we don't do anything useful here,
     ** it would still be necessary to have a signal handler,
     ** rather than ignoring the signals, otherwise
     ** the signals will not be delivered at all, and
@@ -357,6 +393,7 @@
       /* We should have previously waited for it to become zero. */
 #   endif /* PARALLEL_MARK */
     ++GC_stop_count;
+    GC_world_is_stopped = TRUE;
     n_live_threads = GC_suspend_all();
 
       if (GC_retry_signals) {
@@ -390,10 +427,10 @@
       }
     for (i = 0; i < n_live_threads; i++) {
 	  while (0 != (code = sem_wait(&GC_suspend_ack_sem))) {
-	    if (errno != EINTR) {
-	      GC_err_printf1("Sem_wait returned %ld\n", (unsigned long)code);
-	      ABORT("sem_wait for handler failed");
-	    }
+	      if (errno != EINTR) {
+	         GC_err_printf1("Sem_wait returned %ld\n", (unsigned long)code);
+	         ABORT("sem_wait for handler failed");
+	      }
 	  }
     }
 #   ifdef PARALLEL_MARK
@@ -405,6 +442,47 @@
     GC_stopping_thread = 0;  /* debugging only */
 }
 
+void suspend_self() {
+  GC_thread me = GC_lookup_thread(pthread_self());
+  if (me == NULL)
+    ABORT("attempting to suspend unknown thread");
+
+  me -> flags |= SUSPENDED;
+  GC_start_blocking();
+  while (me -> flags & SUSPENDED)
+    GC_brief_async_signal_safe_sleep();
+  GC_end_blocking();
+}
+
+void GC_suspend_thread(pthread_t thread) {
+  if (thread == pthread_self())
+    suspend_self();
+  else {
+    int result;
+    GC_thread t = GC_lookup_thread(thread);
+    if (t == NULL)
+      ABORT("attempting to suspend unknown thread");
+
+    t -> flags |= SUSPENDED;
+    result = pthread_kill (t -> id, SIG_SUSPEND);
+    switch (result) {
+    case ESRCH:
+    case 0:
+      break;
+    default:
+      ABORT("pthread_kill failed");
+    }
+  }
+}
+
+void GC_resume_thread(pthread_t thread) {
+  GC_thread t = GC_lookup_thread(thread);
+  if (t == NULL)
+    ABORT("attempting to resume unknown thread");
+
+  t -> flags &= ~SUSPENDED;
+}
+
 /* Caller holds allocation lock, and has held it continuously since	*/
 /* the world stopped.							*/
 void GC_start_world()
@@ -419,6 +497,7 @@
       GC_printf0("World starting\n");
 #   endif
 
+    GC_world_is_stopped = FALSE;
     for (i = 0; i < THREAD_TABLE_SZ; i++) {
       for (p = GC_threads[i]; p != 0; p = p -> next) {
         if (p -> id != my_thread) {
@@ -428,8 +507,7 @@
 	    #if DEBUG_THREADS
 	      GC_printf1("Sending restart signal to 0x%lx\n", p -> id);
 	    #endif
-        
-        result = pthread_kill(p -> id, SIG_THR_RESTART);
+            result = pthread_kill(p -> id, SIG_THR_RESTART);
 	    switch(result) {
                 case ESRCH:
                     /* Not really there anymore.  Possible? */
diff -urN old/boehm-gc/pthread_support.c src/boehm-gc/pthread_support.c
--- old/boehm-gc/pthread_support.c	2006-02-10 02:54:34.000000000 +0100
+++ src/boehm-gc/pthread_support.c	2006-08-28 19:17:32.350718000 +0200
@@ -2,7 +2,7 @@
  * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.
  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.
  * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.
- * Copyright (c) 2000-2001 by Hewlett-Packard Company.  All rights reserved.
+ * Copyright (c) 2000-2004 by Hewlett-Packard Company.  All rights reserved.
  *
  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
@@ -58,8 +58,7 @@
 # include "private/pthread_support.h"
 
 # if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \
-     && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS) \
-     && !defined(GC_AIX_THREADS)
+     && !defined(GC_WIN32_THREADS)
 
 # if defined(GC_HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \
      && !defined(USE_COMPILER_TLS)
@@ -76,7 +75,8 @@
 # endif
 
 # if (defined(GC_DGUX386_THREADS) || defined(GC_OSF1_THREADS) || \
-      defined(GC_DARWIN_THREADS)) && !defined(USE_PTHREAD_SPECIFIC)
+      defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)) \
+      && !defined(USE_PTHREAD_SPECIFIC)
 #   define USE_PTHREAD_SPECIFIC
 # endif
 
@@ -124,7 +124,7 @@
 # include <semaphore.h>
 #endif /* !GC_DARWIN_THREADS */
 
-#if defined(GC_DARWIN_THREADS)
+#if defined(GC_DARWIN_THREADS) || defined(GC_FREEBSD_THREADS)
 # include <sys/sysctl.h>
 #endif /* GC_DARWIN_THREADS */
 
@@ -602,7 +602,9 @@
     } else {
         prev -> next = p -> next;
     }
-    GC_INTERNAL_FREE(p);
+
+    if (p != &first_thread)
+      GC_INTERNAL_FREE(p);
 }
 
 /* If a thread has been joined, but we have not yet		*/
@@ -847,9 +849,9 @@
 /* We hold the allocation lock.	*/
 void GC_thr_init()
 {
-#	ifndef GC_DARWIN_THREADS
-        int dummy;
-#	endif
+#   ifndef GC_DARWIN_THREADS
+      int dummy;
+#   endif
     GC_thread t;
 
     if (GC_thr_initialized) return;
@@ -881,14 +883,15 @@
 #       if defined(GC_HPUX_THREADS)
 	  GC_nprocs = pthread_num_processors_np();
 #       endif
-#	if defined(GC_OSF1_THREADS)
+#	if defined(GC_OSF1_THREADS) || defined(GC_AIX_THREADS)
 	  GC_nprocs = sysconf(_SC_NPROCESSORS_ONLN);
 	  if (GC_nprocs <= 0) GC_nprocs = 1;
 #	endif
-#       if defined(GC_FREEBSD_THREADS)
-          GC_nprocs = 1;
+#       if defined(GC_IRIX_THREADS)
+	  GC_nprocs = sysconf(_SC_NPROC_ONLN);
+	  if (GC_nprocs <= 0) GC_nprocs = 1;
 #       endif
-#       if defined(GC_DARWIN_THREADS)
+#       if defined(GC_DARWIN_THREADS) || defined(GC_FREEBSD_THREADS)
 	  int ncpus = 1;
 	  size_t len = sizeof(ncpus);
 	  sysctl((int[2]) {CTL_HW, HW_NCPU}, 2, &ncpus, &len, NULL, 0);
@@ -935,6 +938,8 @@
 	/* Disable true incremental collection, but generational is OK.	*/
 	GC_time_limit = GC_TIME_UNLIMITED;
       }
+      /* If we are using a parallel marker, actually start helper threads.  */
+        if (GC_parallel) start_mark_threads();
 #   endif
 }
 
@@ -951,10 +956,6 @@
 
     /* GC_init() calls us back, so set flag first.	*/
     if (!GC_is_initialized) GC_init();
-    /* If we are using a parallel marker, start the helper threads.  */
-#     ifdef PARALLEL_MARK
-        if (GC_parallel) start_mark_threads();
-#     endif
     /* Initialize thread local free lists if used.	*/
 #   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)
       LOCK();
@@ -1125,6 +1126,107 @@
 
 GC_bool GC_in_thread_creation = FALSE;
 
+GC_PTR GC_get_thread_stack_base()
+{  
+# ifdef HAVE_PTHREAD_GETATTR_NP
+  pthread_t my_pthread;
+  pthread_attr_t attr;
+  ptr_t stack_addr;
+  size_t stack_size;
+  
+  my_pthread = pthread_self();  
+  pthread_getattr_np (my_pthread, &attr);
+  pthread_attr_getstack (&attr, (void **) &stack_addr, &stack_size);
+  pthread_attr_destroy (&attr);
+  
+#   ifdef DEBUG_THREADS
+	GC_printf1("attached thread stack address: 0x%x\n", stack_addr);
+#   endif
+
+#   ifdef STACK_GROWS_DOWN
+      return stack_addr + stack_size;
+#   else
+      return stack_addr - stack_size;
+#   endif
+
+# else
+#   ifdef DEBUG_THREADS
+	GC_printf1("Can not determine stack base for attached thread");
+#   endif
+  return 0;
+# endif
+}
+
+void GC_register_my_thread()
+{
+  GC_thread me;
+  pthread_t my_pthread;
+
+  my_pthread = pthread_self();
+#   ifdef DEBUG_THREADS
+      GC_printf1("Attaching thread 0x%lx\n", my_pthread);
+      GC_printf1("pid = %ld\n", (long) getpid());
+#   endif
+  
+  /* Check to ensure this thread isn't attached already. */
+  LOCK();
+  me = GC_lookup_thread (my_pthread);
+  UNLOCK();
+  if (me != 0)
+    {
+#   ifdef DEBUG_THREADS
+      GC_printf1("Attempt to re-attach known thread 0x%lx\n", my_pthread);
+#   endif
+      return;
+    }
+
+  LOCK();
+  GC_in_thread_creation = TRUE;
+  me = GC_new_thread(my_pthread);
+  GC_in_thread_creation = FALSE;
+
+  me -> flags |= DETACHED;  
+
+#ifdef GC_DARWIN_THREADS
+    me -> stop_info.mach_thread = mach_thread_self();
+#else
+    me -> stack_end = GC_get_thread_stack_base();    
+    if (me -> stack_end == 0)
+      GC_abort("Can not determine stack base for attached thread");
+    
+#   ifdef STACK_GROWS_DOWN
+      me -> stop_info.stack_ptr = me -> stack_end - 0x10;
+#   else
+      me -> stop_info.stack_ptr = me -> stack_end + 0x10;
+#   endif
+#endif
+
+#   ifdef IA64
+      me -> backing_store_end = (ptr_t)
+			(GC_save_regs_in_stack() & ~(GC_page_size - 1));
+      /* This is also < 100% convincing.  We should also read this 	*/
+      /* from /proc, but the hook to do so isn't there yet.		*/
+#   endif /* IA64 */
+
+#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)
+        GC_init_thread_local(me);
+#   endif
+  UNLOCK();
+}
+
+void GC_unregister_my_thread()
+{
+  pthread_t my_pthread;
+
+  my_pthread = pthread_self();
+
+#   ifdef DEBUG_THREADS
+      GC_printf1("Detaching thread 0x%lx\n", my_pthread);
+#   endif
+
+  GC_thread_exit_proc (0);
+}
+
 void * GC_start_routine(void * arg)
 {
     int dummy;
@@ -1201,37 +1303,8 @@
     return(result);
 }
 
-#ifdef GC_PTHREAD_SYM_VERSION
-
-/* Force constr to execute prior to main().  */
-static void constr (void) __attribute__ ((constructor));
-
-static int
-(*pthread_create_)(pthread_t *new_thread,
-		   const pthread_attr_t *attr_in,
-		   void * (*thread_execp)(void *), void *arg);
-
-static void
-constr (void)
-{
-  /* Get a pointer to the real pthread_create.  */
-  pthread_create_ = dlvsym (RTLD_NEXT, "pthread_create",
-			    GC_PTHREAD_SYM_VERSION);
-}
-
-#define GC_PTHREAD_CREATE_NAME pthread_create
-#define GC_PTHREAD_REAL_NAME (*pthread_create_)
-
-#else
-
-#define GC_PTHREAD_CREATE_NAME WRAP_FUNC(pthread_create)
-#define GC_PTHREAD_REAL_NAME REAL_FUNC(pthread_create)
-
-#endif
-
-
 int
-GC_PTHREAD_CREATE_NAME(pthread_t *new_thread,
+WRAP_FUNC(pthread_create)(pthread_t *new_thread,
 		  const pthread_attr_t *attr,
                   void *(*start_routine)(void *), void *arg)
 {
@@ -1259,7 +1332,7 @@
     if (!GC_thr_initialized) GC_thr_init();
 #   ifdef GC_ASSERTIONS
       {
-	int stack_size;
+	size_t stack_size;
 	if (NULL == attr) {
 	   pthread_attr_t my_attr;
 	   pthread_attr_init(&my_attr);
@@ -1267,7 +1340,13 @@
 	} else {
 	   pthread_attr_getstacksize(attr, &stack_size);
 	}
-	GC_ASSERT(stack_size >= (8*HBLKSIZE*sizeof(word)));
+#       ifdef PARALLEL_MARK
+	  GC_ASSERT(stack_size >= (8*HBLKSIZE*sizeof(word)));
+#       else
+          /* FreeBSD-5.3/Alpha: default pthread stack is 64K, 	*/
+	  /* HBLKSIZE=8192, sizeof(word)=8			*/
+	  GC_ASSERT(stack_size >= 65536);
+#       endif
 	/* Our threads may need to do some work for the GC.	*/
 	/* Ridiculously small threads won't work, and they	*/
 	/* probably wouldn't work anyway.			*/
@@ -1286,7 +1365,7 @@
 		   pthread_self());
 #   endif
 
-    result = GC_PTHREAD_REAL_NAME(new_thread, attr, GC_start_routine, si);
+    result = REAL_FUNC(pthread_create)(new_thread, attr, GC_start_routine, si);
 
 #   ifdef DEBUG_THREADS
         GC_printf1("Started thread 0x%X\n", *new_thread);
diff -urN old/boehm-gc/reclaim.c src/boehm-gc/reclaim.c
--- old/boehm-gc/reclaim.c	2003-07-28 06:18:23.000000000 +0200
+++ src/boehm-gc/reclaim.c	2006-08-28 19:14:18.140718000 +0200
@@ -888,7 +888,7 @@
 {
     struct Print_stats pstats;
 
-    GC_printf0("(kind(0=ptrfree,1=normal,2=unc.,3=stubborn):size_in_bytes, #_marks_set)\n");
+    GC_printf1("(kind(0=ptrfree,1=normal,2=unc.,%lu=stubborn):size_in_bytes, #_marks_set)\n", STUBBORN);
     pstats.number_of_blocks = 0;
     pstats.total_bytes = 0;
     GC_apply_to_all_blocks(GC_print_block_descr, (word)&pstats);
diff -urN old/boehm-gc/solaris_pthreads.c src/boehm-gc/solaris_pthreads.c
--- old/boehm-gc/solaris_pthreads.c	2004-08-16 18:32:26.000000000 +0200
+++ src/boehm-gc/solaris_pthreads.c	2006-08-28 19:14:18.140718000 +0200
@@ -16,7 +16,7 @@
  * Modified by Peter C. for Solaris Posix Threads.
  */
 
-#include "private/gc_priv.h"
+# include "private/gc_priv.h"
 
 # if defined(GC_SOLARIS_PTHREADS)
 # include <pthread.h>
diff -urN old/boehm-gc/solaris_threads.c src/boehm-gc/solaris_threads.c
--- old/boehm-gc/solaris_threads.c	2004-08-16 18:32:26.000000000 +0200
+++ src/boehm-gc/solaris_threads.c	2006-08-28 19:14:18.140718000 +0200
@@ -16,7 +16,7 @@
  */
 /* Boehm, September 14, 1994 4:44 pm PDT */
 
-#include "private/gc_priv.h"
+# include "private/gc_priv.h"
 
 # if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)
 # include "private/solaris_threads.h"
@@ -248,8 +248,8 @@
     for (i = 0; i < max_lwps; i++)
 	last_ids[i] = 0;
     for (;;) {
-    if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCSTATUS, &status) < 0)
-    	ABORT("Main PIOCSTATUS failed");
+        if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCSTATUS, &status) < 0)
+    	    ABORT("Main PIOCSTATUS failed");
     	if (status.pr_nlwp < 1)
     		ABORT("Invalid number of lwps returned by PIOCSTATUS");
     	if (status.pr_nlwp >= max_lwps) {
@@ -262,7 +262,7 @@
         	for (i = 0; i < max_lwps; i++)
 			last_ids[i] = 0;
 		continue;
-    }
+    	}
         if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCLWPIDS, GC_current_ids) < 0)
             ABORT("PIOCLWPIDS failed");
         changed = FALSE;
diff -urN old/boehm-gc/tests/test.c src/boehm-gc/tests/test.c
--- old/boehm-gc/tests/test.c	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/tests/test.c	2006-08-28 19:14:18.140718000 +0200
@@ -1367,6 +1367,10 @@
     	max_heap_sz = 11000000;
     }
 #   endif
+#   ifndef ALIGN_DOUBLE
+        /* We end up needing more small object pages. */
+        max_heap_sz += 2000000;
+#   endif
 #   ifdef GC_DEBUG
 	max_heap_sz *= 2;
 #       ifdef SAVE_CALL_CHAIN
diff -urN old/boehm-gc/threadlibs.c src/boehm-gc/threadlibs.c
--- old/boehm-gc/threadlibs.c	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/threadlibs.c	2006-08-28 19:14:18.150718000 +0200
@@ -11,10 +11,17 @@
 	       "-Wl,--wrap -Wl,pthread_sigmask -Wl,--wrap -Wl,sleep\n");
 #   endif
 #   if defined(GC_LINUX_THREADS) || defined(GC_IRIX_THREADS) \
-	|| defined(GC_FREEBSD_THREADS) || defined(GC_SOLARIS_PTHREADS) \
+	|| defined(GC_SOLARIS_PTHREADS) \
 	|| defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)
         printf("-lpthread\n");
 #   endif
+#   if defined(GC_FREEBSD_THREADS)
+#       if (__FREEBSD_version >= 500000)
+          printf("-lpthread\n");
+#       else
+          printf("-pthread\n");
+#       endif
+#   endif
 #   if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)
 	printf("-lpthread -lrt\n");
 #   endif
diff -urN old/boehm-gc/version.h src/boehm-gc/version.h
--- old/boehm-gc/version.h	2004-08-14 01:05:36.000000000 +0200
+++ src/boehm-gc/version.h	2006-08-28 19:14:18.150718000 +0200
@@ -2,7 +2,7 @@
 /* Eventually this one may become unnecessary.  For now we need	*/
 /* it to keep the old-style build process working.		*/
 #define GC_TMP_VERSION_MAJOR 6
-#define GC_TMP_VERSION_MINOR 3
+#define GC_TMP_VERSION_MINOR 6
 #define GC_TMP_ALPHA_VERSION GC_NOT_ALPHA
 
 #ifndef GC_NOT_ALPHA
diff -urN old/boehm-gc/win32_threads.c src/boehm-gc/win32_threads.c
--- old/boehm-gc/win32_threads.c	2004-08-23 17:07:00.000000000 +0200
+++ src/boehm-gc/win32_threads.c	2006-08-28 19:14:18.150718000 +0200
@@ -11,6 +11,7 @@
 # undef pthread_create 
 # undef pthread_sigmask 
 # undef pthread_join 
+# undef pthread_detach
 # undef dlopen 
 
 # define DEBUG_CYGWIN_THREADS 0
@@ -185,7 +186,7 @@
        /* Must still be in_use, since nobody else can store our thread_id. */
        i++) {}
   if (i > my_max) {
-    WARN("Removing nonexisiting thread %ld\n", (GC_word)thread_id);
+    WARN("Removing nonexistent thread %ld\n", (GC_word)thread_id);
   } else {
     GC_delete_gc_thread(thread_table+i);
   }
@@ -232,6 +233,9 @@
 # endif
 }
 
+/* Defined in misc.c */
+extern CRITICAL_SECTION GC_write_cs;
+
 void GC_stop_world()
 {
   DWORD thread_id = GetCurrentThreadId();
@@ -240,6 +244,9 @@
   if (!GC_thr_initialized) ABORT("GC_stop_world() called before GC_thr_init()");
 
   GC_please_stop = TRUE;
+# ifndef CYGWIN32
+    EnterCriticalSection(&GC_write_cs);
+# endif /* !CYGWIN32 */
   for (i = 0; i <= GC_get_max_thread_index(); i++)
     if (thread_table[i].stack_base != 0
 	&& thread_table[i].id != thread_id) {
@@ -270,6 +277,9 @@
 #     endif
       thread_table[i].suspended = TRUE;
     }
+# ifndef CYGWIN32
+    LeaveCriticalSection(&GC_write_cs);
+# endif /* !CYGWIN32 */
 }
 
 void GC_start_world()
