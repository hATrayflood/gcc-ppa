#! /bin/sh -e

# DP: SVN updates from the gcc-4_1-rh-branch branch upto 20070718.

last_updated()
{
	cat > ${dir}LAST_UPDATED <<EOF
Wed Jul 18 13:21:39 CEST 2007
Wed Jul 18 11:21:39 UTC 2007 (revision 126718)
EOF
}

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch ${pdir} -f --no-backup-if-mismatch -p0 < $0
	find ${dir}libjava \( -name '*.java' -o -name '*.cc' \) -type f -size 0 | xargs -r rm -f
	#last_updated
        #cd ${dir}gcc && autoconf2.59
        ;;
    -unpatch)
        patch ${pdir} -f --no-backup-if-mismatch -R -p0 < $0
        #rm ${dir}gcc/configure
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0

# svn diff -r124389:126334 boehm-gc
# svn diff -r124389:126334 libjava

Index: boehm-gc/solaris_pthreads.c
===================================================================
--- boehm-gc/solaris_pthreads.c	(revision 124389)
+++ boehm-gc/solaris_pthreads.c	(revision 126334)
@@ -1,179 +0,0 @@
-/* 
- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.
- *
- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
- *
- * Permission is hereby granted to use or copy this program
- * for any purpose,  provided the above notices are retained on all copies.
- * Permission to modify the code and to distribute modified code is granted,
- * provided the above notices are retained, and a notice that the code was
- * modified is included with the above copyright notice.
- */
-/*
- * Support code for Solaris threads.  Provides functionality we wish Sun
- * had provided.  Relies on some information we probably shouldn't rely on.
- * Modified by Peter C. for Solaris Posix Threads.
- */
-
-# include "private/gc_priv.h"
-
-# if defined(GC_SOLARIS_PTHREADS)
-# include <pthread.h>
-# include <thread.h>
-# include <signal.h>
-# include <fcntl.h>
-# include <sys/types.h>
-# include <sys/mman.h>
-# include <sys/time.h>
-# include <sys/resource.h>
-# include <sys/stat.h>
-# include <sys/syscall.h>
-# include <sys/procfs.h>
-# include <sys/lwp.h>
-# include <sys/reg.h>
-# define _CLASSIC_XOPEN_TYPES
-# include <unistd.h>
-# include <errno.h>
-# include "private/solaris_threads.h"
-# include <stdio.h>
-
-#undef pthread_join
-#undef pthread_create
-
-pthread_cond_t GC_prom_join_cv;		/* Broadcast when any thread terminates	*/
-pthread_cond_t GC_create_cv;		/* Signalled when a new undetached	*/
-				/* thread starts.			*/
-				
-extern GC_bool GC_multithreaded;
-
-/* We use the allocation lock to protect thread-related data structures. */
-
-/* We stop the world using /proc primitives.  This makes some	*/
-/* minimal assumptions about the threads implementation.	*/
-/* We don't play by the rules, since the rules make this	*/
-/* impossible (as of Solaris 2.3).  Also note that as of	*/
-/* Solaris 2.3 the various thread and lwp suspension		*/
-/* primitives failed to stop threads by the time the request	*/
-/* is completed.						*/
-
-
-
-int GC_pthread_join(pthread_t wait_for, void **status)
-{
-	return GC_thr_join((thread_t)wait_for, NULL, status);
-}
-
-
-int
-GC_pthread_create(pthread_t *new_thread,
-          const pthread_attr_t *attr_in,
-          void * (*thread_execp)(void *), void *arg)
-{
-    int result;
-    GC_thread t;
-    pthread_t my_new_thread;
-    pthread_attr_t  attr;
-    word my_flags = 0;
-    int  flag;
-    void * stack = 0;
-    size_t stack_size = 0;
-    int    n;
-    struct sched_param schedparam;
-   
-    (void)pthread_attr_init(&attr);
-    if (attr_in != 0) {
-	(void)pthread_attr_getstacksize(attr_in, &stack_size);
-	(void)pthread_attr_getstackaddr(attr_in, &stack);
-    }
-
-    LOCK();
-    if (!GC_is_initialized) {
-	    GC_init_inner();
-    }
-    GC_multithreaded++;
-	    
-    if (stack == 0) {
-     	if (stack_size == 0)
-		stack_size = 1048576;
-			  /* ^-- 1 MB (this was GC_min_stack_sz, but that
-			   * violates the pthread_create documentation which
-			   * says the default value if none is supplied is
-			   * 1MB) */
-	else
-		stack_size += thr_min_stack();
-
-     	stack = (void *)GC_stack_alloc(&stack_size);
-     	if (stack == 0) {
-	    GC_multithreaded--;
-     	    UNLOCK();
-	    errno = ENOMEM;
-     	    return -1;
-     	}
-    } else {
-    	my_flags |= CLIENT_OWNS_STACK;
-    }
-    (void)pthread_attr_setstacksize(&attr, stack_size);
-    (void)pthread_attr_setstackaddr(&attr, stack);
-    if (attr_in != 0) {
-	(void)pthread_attr_getscope(attr_in, &n);
-	(void)pthread_attr_setscope(&attr, n);
-	(void)pthread_attr_getschedparam(attr_in, &schedparam);
-	(void)pthread_attr_setschedparam(&attr, &schedparam);
-	(void)pthread_attr_getschedpolicy(attr_in, &n);
-	(void)pthread_attr_setschedpolicy(&attr, n);
-	(void)pthread_attr_getinheritsched(attr_in, &n);
-	(void)pthread_attr_setinheritsched(&attr, n);
-
-	(void)pthread_attr_getdetachstate(attr_in, &flag);
-	if (flag == PTHREAD_CREATE_DETACHED) {
-		my_flags |= DETACHED;
-	}
-	(void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
-    }
-    /*
-     * thr_create can call malloc(), which if redirected will
-     * attempt to acquire the allocation lock.
-     * Unlock here to prevent deadlock.
-     */
-
-
-#if 0
-#ifdef I386
-    UNLOCK();
-#endif
-#endif
-    result = 
-	    pthread_create(&my_new_thread, &attr, thread_execp, arg);
-#if 0
-#ifdef I386
-    LOCK();
-#endif
-#endif
-    if (result == 0) {
-        t = GC_new_thread(my_new_thread);
-        t -> flags = my_flags;
-        if (!(my_flags & DETACHED)) cond_init(&(t->join_cv), USYNC_THREAD, 0);
-        t -> stack = stack;
-        t -> stack_size = stack_size;
-        if (new_thread != 0) *new_thread = my_new_thread;
-        pthread_cond_signal(&GC_create_cv);
-    } else {
-	    if (!(my_flags & CLIENT_OWNS_STACK)) {
-		    GC_stack_free(stack, stack_size);
-	    }        
-	    GC_multithreaded--;
-    }
-    UNLOCK();
-    pthread_attr_destroy(&attr);
-    return(result);
-}
-
-# else
-
-#ifndef LINT
-  int GC_no_sunOS_pthreads;
-#endif
-
-# endif /* GC_SOLARIS_PTHREADS */
-
Index: boehm-gc/solaris_threads.c
===================================================================
--- boehm-gc/solaris_threads.c	(revision 124389)
+++ boehm-gc/solaris_threads.c	(revision 126334)
@@ -1,959 +0,0 @@
-/* 
- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.
- *
- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
- *
- * Permission is hereby granted to use or copy this program
- * for any purpose,  provided the above notices are retained on all copies.
- * Permission to modify the code and to distribute modified code is granted,
- * provided the above notices are retained, and a notice that the code was
- * modified is included with the above copyright notice.
- */
-/*
- * Support code for Solaris threads.  Provides functionality we wish Sun
- * had provided.  Relies on some information we probably shouldn't rely on.
- */
-/* Boehm, September 14, 1994 4:44 pm PDT */
-
-# include "private/gc_priv.h"
-
-# if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)
-# include "private/solaris_threads.h"
-# include <thread.h>
-# include <synch.h>
-# include <signal.h>
-# include <fcntl.h>
-# include <sys/types.h>
-# include <sys/mman.h>
-# include <sys/time.h>
-# include <sys/resource.h>
-# include <sys/stat.h>
-# include <sys/syscall.h>
-# include <sys/procfs.h>
-# include <sys/lwp.h>
-# include <sys/reg.h>
-# define _CLASSIC_XOPEN_TYPES
-# include <unistd.h>
-# include <errno.h>
-
-#ifdef HANDLE_FORK
-  --> Not yet supported.  Try porting the code from linux_threads.c.
-#endif
-
-/*
- * This is the default size of the LWP arrays. If there are more LWPs
- * than this when a stop-the-world GC happens, set_max_lwps will be
- * called to cope.
- * This must be higher than the number of LWPs at startup time.
- * The threads library creates a thread early on, so the min. is 3
- */
-# define DEFAULT_MAX_LWPS	4
-
-#undef thr_join
-#undef thr_create
-#undef thr_suspend
-#undef thr_continue
-
-cond_t GC_prom_join_cv;		/* Broadcast when any thread terminates	*/
-cond_t GC_create_cv;		/* Signalled when a new undetached	*/
-				/* thread starts.			*/
-				
-
-#ifdef MMAP_STACKS
-static int GC_zfd;
-#endif /* MMAP_STACKS */
-
-/* We use the allocation lock to protect thread-related data structures. */
-
-/* We stop the world using /proc primitives.  This makes some	*/
-/* minimal assumptions about the threads implementation.	*/
-/* We don't play by the rules, since the rules make this	*/
-/* impossible (as of Solaris 2.3).  Also note that as of	*/
-/* Solaris 2.3 the various thread and lwp suspension		*/
-/* primitives failed to stop threads by the time the request	*/
-/* is completed.						*/
-
-
-static sigset_t old_mask;
-
-/* Sleep for n milliseconds, n < 1000	*/
-void GC_msec_sleep(int n)
-{
-    struct timespec ts;
-                            
-    ts.tv_sec = 0;
-    ts.tv_nsec = 1000000*n;
-    if (syscall(SYS_nanosleep, &ts, 0) < 0) {
-	ABORT("nanosleep failed");
-    }
-}
-/* Turn off preemption;  gross but effective.  		*/
-/* Caller has allocation lock.				*/
-/* Actually this is not needed under Solaris 2.3 and	*/
-/* 2.4, but hopefully that'll change.			*/
-void preempt_off()
-{
-    sigset_t set;
-
-    (void)sigfillset(&set);
-    sigdelset(&set, SIGABRT);
-    syscall(SYS_sigprocmask, SIG_SETMASK, &set, &old_mask);
-}
-
-void preempt_on()
-{
-    syscall(SYS_sigprocmask, SIG_SETMASK, &old_mask, NULL);
-}
-
-int GC_main_proc_fd = -1;
-
-
-struct lwp_cache_entry {
-    lwpid_t lc_id;
-    int lc_descr;	/* /proc file descriptor.	*/
-}  GC_lwp_cache_default[DEFAULT_MAX_LWPS];
-
-static int max_lwps = DEFAULT_MAX_LWPS;
-static struct lwp_cache_entry *GC_lwp_cache = GC_lwp_cache_default;
-
-static prgregset_t GC_lwp_registers_default[DEFAULT_MAX_LWPS];
-static prgregset_t *GC_lwp_registers = GC_lwp_registers_default;
-
-/* Return a file descriptor for the /proc entry corresponding	*/
-/* to the given lwp.  The file descriptor may be stale if the	*/
-/* lwp exited and a new one was forked.				*/
-static int open_lwp(lwpid_t id)
-{
-    int result;
-    static int next_victim = 0;
-    register int i;
-    
-    for (i = 0; i < max_lwps; i++) {
-    	if (GC_lwp_cache[i].lc_id == id) return(GC_lwp_cache[i].lc_descr);
-    }
-    result = syscall(SYS_ioctl, GC_main_proc_fd, PIOCOPENLWP, &id);
-    /*
-     * If PIOCOPENLWP fails, try closing fds in the cache until it succeeds.
-     */
-    if (result < 0 && errno == EMFILE) {
-	    for (i = 0; i < max_lwps; i++) {
-		if (GC_lwp_cache[i].lc_id != 0) {
-        		(void)syscall(SYS_close, GC_lwp_cache[i].lc_descr);
-			result = syscall(SYS_ioctl, GC_main_proc_fd, PIOCOPENLWP, &id);
-			if (result >= 0 || (result < 0 && errno != EMFILE))
-				break;
-		}
-	    }
-    }
-    if (result < 0) {
-	if (errno == EMFILE) {
-		ABORT("Too many open files");
-	}
-        return(-1) /* exited? */;
-    }
-    if (GC_lwp_cache[next_victim].lc_id != 0)
-        (void)syscall(SYS_close, GC_lwp_cache[next_victim].lc_descr);
-    GC_lwp_cache[next_victim].lc_id = id;
-    GC_lwp_cache[next_victim].lc_descr = result;
-    if (++next_victim >= max_lwps)
-	next_victim = 0;
-    return(result);
-}
-
-static void uncache_lwp(lwpid_t id)
-{
-    register int i;
-    
-    for (i = 0; i < max_lwps; i++) {
-    	if (GC_lwp_cache[i].lc_id == id) {
-    	    (void)syscall(SYS_close, GC_lwp_cache[id].lc_descr);
-    	    GC_lwp_cache[i].lc_id = 0;
-    	    break;
-    	}
-    }
-}
-	/* Sequence of current lwp ids	*/
-static lwpid_t GC_current_ids_default[DEFAULT_MAX_LWPS + 1];
-static lwpid_t *GC_current_ids = GC_current_ids_default;
-
-	/* Temporary used below (can be big if large number of LWPs) */
-static lwpid_t last_ids_default[DEFAULT_MAX_LWPS + 1];
-static lwpid_t *last_ids = last_ids_default;
-
-
-#define ROUNDUP(n)    WORDS_TO_BYTES(ROUNDED_UP_WORDS(n))
-
-static void set_max_lwps(GC_word n)
-{
-    char *mem;
-    char *oldmem;
-    int required_bytes = ROUNDUP(n * sizeof(struct lwp_cache_entry))
-	+ ROUNDUP(n * sizeof(prgregset_t))
-	+ ROUNDUP((n + 1) * sizeof(lwpid_t))
-	+ ROUNDUP((n + 1) * sizeof(lwpid_t));
-
-    GC_expand_hp_inner(divHBLKSZ((word)required_bytes));
-    oldmem = mem = GC_scratch_alloc(required_bytes);
-    if (0 == mem) ABORT("No space for lwp data structures");
-
-    /*
-     * We can either flush the old lwp cache or copy it over. Do the latter.
-     */
-    memcpy(mem, GC_lwp_cache, max_lwps * sizeof(struct lwp_cache_entry));
-    GC_lwp_cache = (struct lwp_cache_entry*)mem;
-    mem += ROUNDUP(n * sizeof(struct lwp_cache_entry));
-
-    BZERO(GC_lwp_registers, max_lwps * sizeof(GC_lwp_registers[0]));
-    GC_lwp_registers = (prgregset_t *)mem;
-    mem += ROUNDUP(n * sizeof(prgregset_t));
-
-
-    GC_current_ids = (lwpid_t *)mem;
-    mem += ROUNDUP((n + 1) * sizeof(lwpid_t));
-
-    last_ids = (lwpid_t *)mem;
-    mem += ROUNDUP((n + 1)* sizeof(lwpid_t));
-
-    if (mem > oldmem + required_bytes)
-	ABORT("set_max_lwps buffer overflow");
-
-    max_lwps = n;
-}
-
-
-/* Stop all lwps in process.  Assumes preemption is off.	*/
-/* Caller has allocation lock (and any other locks he may	*/
-/* need).							*/
-static void stop_all_lwps()
-{
-    int lwp_fd;
-    char buf[30];
-    prstatus_t status;
-    register int i;
-    GC_bool changed;
-    lwpid_t me = _lwp_self();
-
-    if (GC_main_proc_fd == -1) {
-    	sprintf(buf, "/proc/%d", getpid());
-    	GC_main_proc_fd = syscall(SYS_open, buf, O_RDONLY);
-        if (GC_main_proc_fd < 0) {
-		if (errno == EMFILE)
-			ABORT("/proc open failed: too many open files");
-		GC_printf1("/proc open failed: errno %d", errno);
-		abort();
-        }
-    }
-    BZERO(GC_lwp_registers, sizeof (prgregset_t) * max_lwps);
-    for (i = 0; i < max_lwps; i++)
-	last_ids[i] = 0;
-    for (;;) {
-        if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCSTATUS, &status) < 0)
-    	    ABORT("Main PIOCSTATUS failed");
-    	if (status.pr_nlwp < 1)
-    		ABORT("Invalid number of lwps returned by PIOCSTATUS");
-    	if (status.pr_nlwp >= max_lwps) {
-    		set_max_lwps(status.pr_nlwp*2 + 10);
-		/*
-		 * The data in the old GC_current_ids and
-		 * GC_lwp_registers has been trashed. Cleaning out last_ids
-		 * will make sure every LWP gets re-examined.
-		 */
-        	for (i = 0; i < max_lwps; i++)
-			last_ids[i] = 0;
-		continue;
-    	}
-        if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCLWPIDS, GC_current_ids) < 0)
-            ABORT("PIOCLWPIDS failed");
-        changed = FALSE;
-        for (i = 0; GC_current_ids[i] != 0 && i < max_lwps; i++) {
-            if (GC_current_ids[i] != last_ids[i]) {
-                changed = TRUE;
-                if (GC_current_ids[i] != me) {
-		    /* PIOCSTOP doesn't work without a writable		*/
-		    /* descriptor.  And that makes the process		*/
-		    /* undebuggable.					*/
-                    if (_lwp_suspend(GC_current_ids[i]) < 0) {
-                        /* Could happen if the lwp exited */
-                        uncache_lwp(GC_current_ids[i]);
-                        GC_current_ids[i] = me; /* ignore */
-                    }
-                }
-            }
-        }
-        /*
-         * In the unlikely event something does a fork between the
-	 * PIOCSTATUS and the PIOCLWPIDS. 
-         */
-        if (i >= max_lwps)
-		continue;
-        /* All lwps in GC_current_ids != me have been suspended.  Note	*/
-        /* that _lwp_suspend is idempotent.				*/
-        for (i = 0; GC_current_ids[i] != 0; i++) {
-            if (GC_current_ids[i] != last_ids[i]) {
-                if (GC_current_ids[i] != me) {
-                    lwp_fd = open_lwp(GC_current_ids[i]);
-		    if (lwp_fd == -1)
-		    {
-			    GC_current_ids[i] = me;
-			    continue;
-		    }
-		    /* LWP should be stopped.  Empirically it sometimes	*/
-		    /* isn't, and more frequently the PR_STOPPED flag	*/
-		    /* is not set.  Wait for PR_STOPPED.		*/
-                    if (syscall(SYS_ioctl, lwp_fd,
-                                PIOCSTATUS, &status) < 0) {
-			/* Possible if the descriptor was stale, or */
-			/* we encountered the 2.3 _lwp_suspend bug. */
-			uncache_lwp(GC_current_ids[i]);
-                        GC_current_ids[i] = me; /* handle next time. */
-                    } else {
-                        while (!(status.pr_flags & PR_STOPPED)) {
-                            GC_msec_sleep(1);
-			    if (syscall(SYS_ioctl, lwp_fd,
-				    	PIOCSTATUS, &status) < 0) {
-                            	ABORT("Repeated PIOCSTATUS failed");
-			    }
-			    if (status.pr_flags & PR_STOPPED) break;
-			    
-			    GC_msec_sleep(20);
-			    if (syscall(SYS_ioctl, lwp_fd,
-				    	PIOCSTATUS, &status) < 0) {
-                            	ABORT("Repeated PIOCSTATUS failed");
-			    }
-                        }
-                        if (status.pr_who !=  GC_current_ids[i]) {
-				/* can happen if thread was on death row */
-				uncache_lwp(GC_current_ids[i]);
-				GC_current_ids[i] = me; /* handle next time. */
-				continue;	
-                        }
-                        /* Save registers where collector can */
-			/* find them.			  */
-			    BCOPY(status.pr_reg, GC_lwp_registers[i],
-				  sizeof (prgregset_t));
-                    }
-                }
-            }
-        }
-        if (!changed) break;
-        for (i = 0; i < max_lwps; i++) last_ids[i] = GC_current_ids[i];
-    }
-}
-
-/* Restart all lwps in process.  Assumes preemption is off.	*/
-static void restart_all_lwps()
-{
-    int lwp_fd;
-    register int i;
-    GC_bool changed;
-    lwpid_t me = _lwp_self();
-#   define PARANOID
-
-    for (i = 0; GC_current_ids[i] != 0; i++) {
-#	ifdef PARANOID
-	  if (GC_current_ids[i] != me) {
-	    int lwp_fd = open_lwp(GC_current_ids[i]);
-	    prstatus_t status;
-	    
-	    if (lwp_fd < 0) ABORT("open_lwp failed");
-	    if (syscall(SYS_ioctl, lwp_fd,
-			PIOCSTATUS, &status) < 0) {
-                ABORT("PIOCSTATUS failed in restart_all_lwps");
-	    }
-	    if (memcmp(status.pr_reg, GC_lwp_registers[i],
-		       sizeof (prgregset_t)) != 0) {
-		    int j;
-
-		    for(j = 0; j < NPRGREG; j++)
-		    {
-			    GC_printf3("%i: %x -> %x\n", j,
-				       GC_lwp_registers[i][j],
-				       status.pr_reg[j]);
-		    }
-		ABORT("Register contents changed");
-	    }
-	    if (!status.pr_flags & PR_STOPPED) {
-	    	ABORT("lwp no longer stopped");
-	    }
-#ifdef SPARC
-	    {
-		    gwindows_t windows;
-	      if (syscall(SYS_ioctl, lwp_fd,
-			PIOCGWIN, &windows) < 0) {
-                ABORT("PIOCSTATUS failed in restart_all_lwps");
-	      }
-	      if (windows.wbcnt > 0) ABORT("unsaved register windows");
-	    }
-#endif
-	  }
-#	endif /* PARANOID */
-	if (GC_current_ids[i] == me) continue;
-        if (_lwp_continue(GC_current_ids[i]) < 0) {
-            ABORT("Failed to restart lwp");
-        }
-    }
-    if (i >= max_lwps) ABORT("Too many lwps");
-}
-
-GC_bool GC_multithreaded = 0;
-
-void GC_stop_world()
-{
-    preempt_off();
-    if (GC_multithreaded)
-        stop_all_lwps();
-}
-
-void GC_start_world()
-{
-    if (GC_multithreaded)
-        restart_all_lwps();
-    preempt_on();
-}
-
-void GC_thr_init(void);
-
-GC_bool GC_thr_initialized = FALSE;
-
-size_t GC_min_stack_sz;
-
-
-/*
- * stack_head is stored at the top of free stacks
- */
-struct stack_head {
-	struct stack_head	*next;
-	ptr_t			base;
-	thread_t		owner;
-};
-
-# define N_FREE_LISTS 25
-struct stack_head *GC_stack_free_lists[N_FREE_LISTS] = { 0 };
-		/* GC_stack_free_lists[i] is free list for stacks of 	*/
-		/* size GC_min_stack_sz*2**i.				*/
-		/* Free lists are linked through stack_head stored	*/			/* at top of stack.					*/
-
-/* Return a stack of size at least *stack_size.  *stack_size is	*/
-/* replaced by the actual stack size.				*/
-/* Caller holds allocation lock.				*/
-ptr_t GC_stack_alloc(size_t * stack_size)
-{
-    register size_t requested_sz = *stack_size;
-    register size_t search_sz = GC_min_stack_sz;
-    register int index = 0;	/* = log2(search_sz/GC_min_stack_sz) */
-    register ptr_t base;
-    register struct stack_head *result;
-    
-    while (search_sz < requested_sz) {
-        search_sz *= 2;
-        index++;
-    }
-    if ((result = GC_stack_free_lists[index]) == 0
-        && (result = GC_stack_free_lists[index+1]) != 0) {
-        /* Try next size up. */
-        search_sz *= 2; index++;
-    }
-    if (result != 0) {
-        base =  GC_stack_free_lists[index]->base;
-        GC_stack_free_lists[index] = GC_stack_free_lists[index]->next;
-    } else {
-#ifdef MMAP_STACKS
-        base = (ptr_t)mmap(0, search_sz + GC_page_size,
-			     PROT_READ|PROT_WRITE, MAP_PRIVATE |MAP_NORESERVE,
-			     GC_zfd, 0);
-	if (base == (ptr_t)-1)
-	{
-		*stack_size = 0;
-		return NULL;
-	}
-
-	mprotect(base, GC_page_size, PROT_NONE);
-	/* Should this use divHBLKSZ(search_sz + GC_page_size) ? -- cf */
-	GC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));
-	base += GC_page_size;
-
-#else
-        base = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_size);
-	if (base == NULL)
-	{
-		*stack_size = 0;
-		return NULL;
-	}
-
-        base = (ptr_t)(((word)base + GC_page_size) & ~(GC_page_size - 1));
-        /* Protect hottest page to detect overflow. */
-#	ifdef SOLARIS23_MPROTECT_BUG_FIXED
-            mprotect(base, GC_page_size, PROT_NONE);
-#	endif
-        GC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));
-
-        base += GC_page_size;
-#endif
-    }
-    *stack_size = search_sz;
-    return(base);
-}
-
-/* Caller holds  allocationlock.					*/
-void GC_stack_free(ptr_t stack, size_t size)
-{
-    register int index = 0;
-    register size_t search_sz = GC_min_stack_sz;
-    register struct stack_head *head;
-    
-#ifdef MMAP_STACKS
-    /* Zero pointers */
-    mmap(stack, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_FIXED,
-	 GC_zfd, 0);
-#endif
-    while (search_sz < size) {
-        search_sz *= 2;
-        index++;
-    }
-    if (search_sz != size) ABORT("Bad stack size");
-
-    head = (struct stack_head *)(stack + search_sz - sizeof(struct stack_head));
-    head->next = GC_stack_free_lists[index];
-    head->base = stack;
-    GC_stack_free_lists[index] = head;
-}
-
-void GC_my_stack_limits();
-
-/* Notify virtual dirty bit implementation that known empty parts of	*/
-/* stacks do not contain useful data.					*/ 
-/* Caller holds allocation lock.					*/
-void GC_old_stacks_are_fresh()
-{
-/* No point in doing this for MMAP stacks - and pointers are zero'd out */
-/* by the mmap in GC_stack_free */
-#ifndef MMAP_STACKS
-    register int i;
-    register struct stack_head *s;
-    register ptr_t p;
-    register size_t sz;
-    register struct hblk * h;
-    int dummy;
-    
-    for (i = 0, sz= GC_min_stack_sz; i < N_FREE_LISTS;
-         i++, sz *= 2) {
-         for (s = GC_stack_free_lists[i]; s != 0; s = s->next) {
-             p = s->base;
-             h = (struct hblk *)(((word)p + HBLKSIZE-1) & ~(HBLKSIZE-1));
-             if ((ptr_t)h == p) {
-                 GC_is_fresh((struct hblk *)p, divHBLKSZ(sz));
-             } else {
-                 GC_is_fresh((struct hblk *)p, divHBLKSZ(sz) - 1);
-                 BZERO(p, (ptr_t)h - p);
-             }
-         }
-    }
-#endif /* MMAP_STACKS */
-    GC_my_stack_limits();
-}
-
-/* The set of all known threads.  We intercept thread creation and 	*/
-/* joins.  We never actually create detached threads.  We allocate all 	*/
-/* new thread stacks ourselves.  These allow us to maintain this	*/
-/* data structure.							*/
-
-# define THREAD_TABLE_SZ 128	/* Must be power of 2	*/
-volatile GC_thread GC_threads[THREAD_TABLE_SZ];
-
-void GC_push_thread_structures GC_PROTO((void))
-{
-    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));
-}
-
-/* Add a thread to GC_threads.  We assume it wasn't already there.	*/
-/* Caller holds allocation lock.					*/
-GC_thread GC_new_thread(thread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    GC_thread result;
-    static struct GC_Thread_Rep first_thread;
-    static GC_bool first_thread_used = FALSE;
-    
-    if (!first_thread_used) {
-    	result = &first_thread;
-    	first_thread_used = TRUE;
-    	/* Dont acquire allocation lock, since we may already hold it. */
-    } else {
-        result = (struct GC_Thread_Rep *)
-        	 GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);
-    }
-    if (result == 0) return(0);
-    result -> id = id;
-    result -> next = GC_threads[hv];
-    GC_threads[hv] = result;
-    /* result -> finished = 0; */
-    (void) cond_init(&(result->join_cv), USYNC_THREAD, 0);
-    return(result);
-}
-
-/* Delete a thread from GC_threads.  We assume it is there.	*/
-/* (The code intentionally traps if it wasn't.)			*/
-/* Caller holds allocation lock.				*/
-void GC_delete_thread(thread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    register GC_thread p = GC_threads[hv];
-    register GC_thread prev = 0;
-    
-    while (p -> id != id) {
-        prev = p;
-        p = p -> next;
-    }
-    if (prev == 0) {
-        GC_threads[hv] = p -> next;
-    } else {
-        prev -> next = p -> next;
-    }
-}
-
-/* Return the GC_thread correpsonding to a given thread_t.	*/
-/* Returns 0 if it's not there.					*/
-/* Caller holds  allocation lock.				*/
-GC_thread GC_lookup_thread(thread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    register GC_thread p = GC_threads[hv];
-    
-    while (p != 0 && p -> id != id) p = p -> next;
-    return(p);
-}
-
-/* Solaris 2/Intel uses an initial stack size limit slightly bigger than the
-   SPARC default of 8 MB.  Account for this to warn only if the user has
-   raised the limit beyond the default.
-
-   This is identical to DFLSSIZ defined in <sys/vm_machparam.h>.  This file
-   is installed in /usr/platform/`uname -m`/include, which is not in the
-   default include directory list, so copy the definition here.  */
-#ifdef I386
-# define MAX_ORIG_STACK_SIZE (8 * 1024 * 1024 + ((USRSTACK) & 0x3FFFFF))
-#else
-# define MAX_ORIG_STACK_SIZE (8 * 1024 * 1024)
-#endif
-
-word GC_get_orig_stack_size() {
-    struct rlimit rl;
-    static int warned = 0;
-    int result;
-
-    if (getrlimit(RLIMIT_STACK, &rl) != 0) ABORT("getrlimit failed");
-    result = (word)rl.rlim_cur & ~(HBLKSIZE-1);
-    if (result > MAX_ORIG_STACK_SIZE) {
-	if (!warned) {
-	    WARN("Large stack limit(%ld): only scanning 8 MB\n", result);
-	    warned = 1;
-	}
-	result = MAX_ORIG_STACK_SIZE;
-    }
-    return result;
-}
-
-/* Notify dirty bit implementation of unused parts of my stack. */
-/* Caller holds allocation lock.				*/
-void GC_my_stack_limits()
-{
-    int dummy;
-    register ptr_t hottest = (ptr_t)((word)(&dummy) & ~(HBLKSIZE-1));
-    register GC_thread me = GC_lookup_thread(thr_self());
-    register size_t stack_size = me -> stack_size;
-    register ptr_t stack;
-    
-    if (stack_size == 0) {
-      /* original thread */
-        /* Empirically, what should be the stack page with lowest	*/
-        /* address is actually inaccessible.				*/
-        stack_size = GC_get_orig_stack_size() - GC_page_size;
-        stack = GC_stackbottom - stack_size + GC_page_size;
-    } else {
-        stack = me -> stack;
-    }
-    if (stack > hottest || stack + stack_size < hottest) {
-    	ABORT("sp out of bounds");
-    }
-    GC_is_fresh((struct hblk *)stack, divHBLKSZ(hottest - stack));
-}
-
-
-/* We hold allocation lock.  Should do exactly the right thing if the	*/
-/* world is stopped.  Should not fail if it isn't.			*/
-void GC_push_all_stacks()
-{
-    register int i;
-    register GC_thread p;
-    register ptr_t sp = GC_approx_sp();
-    register ptr_t bottom, top;
-    struct rlimit rl;
-    
-#   define PUSH(bottom,top) \
-      if (GC_dirty_maintained) { \
-	GC_push_selected((bottom), (top), GC_page_was_ever_dirty, \
-		      GC_push_all_stack); \
-      } else { \
-        GC_push_all_stack((bottom), (top)); \
-      }
-    GC_push_all_stack((ptr_t)GC_lwp_registers,
-		      (ptr_t)GC_lwp_registers
-		      + max_lwps * sizeof(GC_lwp_registers[0]));
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> stack_size != 0) {
-            bottom = p -> stack;
-            top = p -> stack + p -> stack_size;
-        } else {
-            /* The original stack. */
-            bottom = GC_stackbottom - GC_get_orig_stack_size() + GC_page_size;
-            top = GC_stackbottom;
-        }
-        if ((word)sp > (word)bottom && (word)sp < (word)top) bottom = sp;
-        PUSH(bottom, top);
-      }
-    }
-}
-
-
-int GC_is_thread_stack(ptr_t addr)
-{
-    register int i;
-    register GC_thread p;
-    register ptr_t bottom, top;
-    
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> stack_size != 0) {
-            if (p -> stack <= addr &&
-		addr < p -> stack + p -> stack_size)
-		    return 1;
-	}
-      }
-    }
-    return 0;
-}
-
-/* The only thread that ever really performs a thr_join.	*/
-void * GC_thr_daemon(void * dummy)
-{
-    void *status;
-    thread_t departed;
-    register GC_thread t;
-    register int i;
-    register int result;
-    
-    for(;;) {
-      start:
-        result = thr_join((thread_t)0, &departed, &status);
-    	LOCK();
-    	if (result != 0) {
-    	    /* No more threads; wait for create. */
-    	    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-    	        for (t = GC_threads[i]; t != 0; t = t -> next) {
-                    if (!(t -> flags & (DETACHED | FINISHED))) {
-                      UNLOCK();
-                      goto start; /* Thread started just before we */
-                      		  /* acquired the lock.		   */
-                    }
-                }
-            }
-            cond_wait(&GC_create_cv, &GC_allocate_ml);
-            UNLOCK();
-    	} else {
-    	    t = GC_lookup_thread(departed);
-	    GC_multithreaded--;
-    	    if (!(t -> flags & CLIENT_OWNS_STACK)) {
-    	    	GC_stack_free(t -> stack, t -> stack_size);
-    	    }
-    	    if (t -> flags & DETACHED) {
-    	    	GC_delete_thread(departed);
-    	    } else {
-    	        t -> status = status;
-    	    	t -> flags |= FINISHED;
-    	    	cond_signal(&(t -> join_cv));
-    	    	cond_broadcast(&GC_prom_join_cv);
-    	    }
-    	    UNLOCK();
-    	}
-    }
-}
-
-/* We hold the allocation lock, or caller ensures that 2 instances	*/
-/* cannot be invoked concurrently.					*/
-void GC_thr_init(void)
-{
-    GC_thread t;
-    thread_t tid;
-    int ret;
-
-    if (GC_thr_initialized)
-	    return;
-    GC_thr_initialized = TRUE;
-    GC_min_stack_sz = ((thr_min_stack() + 32*1024 + HBLKSIZE-1)
-    		       & ~(HBLKSIZE - 1));
-#ifdef MMAP_STACKS
-    GC_zfd = open("/dev/zero", O_RDONLY);
-    if (GC_zfd == -1)
-	    ABORT("Can't open /dev/zero");
-#endif /* MMAP_STACKS */
-    cond_init(&GC_prom_join_cv, USYNC_THREAD, 0);
-    cond_init(&GC_create_cv, USYNC_THREAD, 0);
-    /* Add the initial thread, so we can stop it.	*/
-      t = GC_new_thread(thr_self());
-      t -> stack_size = 0;
-      t -> flags = DETACHED | CLIENT_OWNS_STACK;
-    ret = thr_create(0 /* stack */, 0 /* stack_size */, GC_thr_daemon,
-    		     0 /* arg */, THR_DETACHED | THR_DAEMON,
-    		     &tid /* thread_id */);
-    if (ret != 0) {
-	GC_err_printf1("Thr_create returned %ld\n", ret);
-    	ABORT("Cant fork daemon");
-    }
-    thr_setprio(tid, 126);
-}
-
-/* We acquire the allocation lock to prevent races with 	*/
-/* stopping/starting world.					*/
-/* This is no more correct than the underlying Solaris 2.X	*/
-/* implementation.  Under 2.3 THIS IS BROKEN.			*/
-int GC_thr_suspend(thread_t target_thread)
-{
-    GC_thread t;
-    int result;
-    
-    LOCK();
-    result = thr_suspend(target_thread);
-    if (result == 0) {
-    	t = GC_lookup_thread(target_thread);
-    	if (t == 0) ABORT("thread unknown to GC");
-        t -> flags |= SUSPNDED;
-    }
-    UNLOCK();
-    return(result);
-}
-
-int GC_thr_continue(thread_t target_thread)
-{
-    GC_thread t;
-    int result;
-    
-    LOCK();
-    result = thr_continue(target_thread);
-    if (result == 0) {
-    	t = GC_lookup_thread(target_thread);
-    	if (t == 0) ABORT("thread unknown to GC");
-        t -> flags &= ~SUSPNDED;
-    }
-    UNLOCK();
-    return(result);
-}
-
-int GC_thr_join(thread_t wait_for, thread_t *departed, void **status)
-{
-    register GC_thread t;
-    int result = 0;
-    
-    LOCK();
-    if (wait_for == 0) {
-        register int i;
-        register GC_bool thread_exists;
-    
-    	for (;;) {
-    	  thread_exists = FALSE;
-    	  for (i = 0; i < THREAD_TABLE_SZ; i++) {
-    	    for (t = GC_threads[i]; t != 0; t = t -> next) {
-              if (!(t -> flags & DETACHED)) {
-                if (t -> flags & FINISHED) {
-                  goto found;
-                }
-                thread_exists = TRUE;
-              }
-            }
-          }
-          if (!thread_exists) {
-              result = ESRCH;
-    	      goto out;
-          }
-          cond_wait(&GC_prom_join_cv, &GC_allocate_ml);
-        }
-    } else {
-        t = GC_lookup_thread(wait_for);
-    	if (t == 0 || t -> flags & DETACHED) {
-    	    result = ESRCH;
-    	    goto out;
-    	}
-    	if (wait_for == thr_self()) {
-    	    result = EDEADLK;
-    	    goto out;
-    	}
-    	while (!(t -> flags & FINISHED)) {
-            cond_wait(&(t -> join_cv), &GC_allocate_ml);
-    	}
-    	
-    }
-  found:
-    if (status) *status = t -> status;
-    if (departed) *departed = t -> id;
-    cond_destroy(&(t -> join_cv));
-    GC_delete_thread(t -> id);
-  out:
-    UNLOCK();
-    return(result);
-}
-
-
-int
-GC_thr_create(void *stack_base, size_t stack_size,
-              void *(*start_routine)(void *), void *arg, long flags,
-              thread_t *new_thread)
-{
-    int result;
-    GC_thread t;
-    thread_t my_new_thread;
-    word my_flags = 0;
-    void * stack = stack_base;
-   
-    LOCK();
-    if (!GC_is_initialized) GC_init_inner();
-    GC_multithreaded++;
-    if (stack == 0) {
-     	if (stack_size == 0) stack_size = 1024*1024;
-     	stack = (void *)GC_stack_alloc(&stack_size);
-     	if (stack == 0) {
-	    GC_multithreaded--;
-     	    UNLOCK();
-     	    return(ENOMEM);
-     	}
-    } else {
-    	my_flags |= CLIENT_OWNS_STACK;
-    }
-    if (flags & THR_DETACHED) my_flags |= DETACHED;
-    if (flags & THR_SUSPENDED) my_flags |= SUSPNDED;
-    result = thr_create(stack, stack_size, start_routine,
-   		        arg, flags & ~THR_DETACHED, &my_new_thread);
-    if (result == 0) {
-        t = GC_new_thread(my_new_thread);
-        t -> flags = my_flags;
-        if (!(my_flags & DETACHED)) cond_init(&(t -> join_cv), USYNC_THREAD, 0);
-        t -> stack = stack;
-        t -> stack_size = stack_size;
-        if (new_thread != 0) *new_thread = my_new_thread;
-        cond_signal(&GC_create_cv);
-    } else {
-	GC_multithreaded--;
-        if (!(my_flags & CLIENT_OWNS_STACK)) {
-      	    GC_stack_free(stack, stack_size);
-	}
-    }        
-    UNLOCK();  
-    return(result);
-}
-
-# else /* !GC_SOLARIS_THREADS */
-
-#ifndef LINT
-  int GC_no_sunOS_threads;
-#endif
-#endif
Index: boehm-gc/Makefile.in
===================================================================
--- boehm-gc/Makefile.in	(revision 124389)
+++ boehm-gc/Makefile.in	(revision 126334)
@@ -62,9 +62,8 @@
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
-	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
-	$(srcdir)/../compile $(srcdir)/../ltmain.sh \
-	$(srcdir)/../config.guess $(srcdir)/../config.sub
+	$(srcdir)/../ltmain.sh $(srcdir)/../config.guess \
+	$(srcdir)/../config.sub
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
@@ -86,8 +85,7 @@
 	dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \
 	headers.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \
 	new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \
-	real_malloc.lo reclaim.lo solaris_pthreads.lo \
-	solaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \
+	real_malloc.lo reclaim.lo specific.lo stubborn.lo typd_mlc.lo \
 	backgraph.lo win32_threads.lo pthread_support.lo \
 	pthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)
 libgcjgc_la_OBJECTS = $(am_libgcjgc_la_OBJECTS)
@@ -95,8 +93,7 @@
 	dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \
 	headers.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \
 	new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \
-	real_malloc.lo reclaim.lo solaris_pthreads.lo \
-	solaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \
+	real_malloc.lo reclaim.lo specific.lo stubborn.lo typd_mlc.lo \
 	backgraph.lo win32_threads.lo pthread_support.lo \
 	pthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)
 am_libgcjgc_convenience_la_OBJECTS = $(am__objects_2)
@@ -105,7 +102,8 @@
 am__dirstamp = $(am__leading_dot)dirstamp
 am_gctest_OBJECTS = tests/test.$(OBJEXT)
 gctest_OBJECTS = $(am_gctest_OBJECTS)
-gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1)
+gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include -I$(top_builddir)/include
 depcomp =
 am__depfiles_maybe =
@@ -263,7 +261,7 @@
 dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \
 malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \
 obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \
-solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \
+specific.c stubborn.c typd_mlc.c \
 backgraph.c win32_threads.c \
 pthread_support.c pthread_stop_world.c darwin_stop_world.c \
 $(asm_libgcjgc_sources)
@@ -285,7 +283,7 @@
 AM_CXXFLAGS = @GC_CFLAGS@
 AM_CFLAGS = @GC_CFLAGS@
 gctest_SOURCES = tests/test.c
-gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)
+gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)
 gctest_LDFLAGS = -shared-libgcc
 TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc
 TESTS = gctest
Index: boehm-gc/configure.ac
===================================================================
--- boehm-gc/configure.ac	(revision 124389)
+++ boehm-gc/configure.ac	(revision 126334)
@@ -162,8 +162,12 @@
 	THREADLIBS=-pthread
       	;;
      *-*-solaris*)
-	AC_DEFINE(GC_SOLARIS_THREADS,1,[support for Solaris (thr_) threads])
 	AC_DEFINE(GC_SOLARIS_PTHREADS,1,[support for Solaris pthreads])
+	# Need to use alternate thread library, otherwise gctest hangs
+	# on Solaris 8.
+	multi_os_directory=`$CC -print-multi-os-directory`
+	THREADLIBS="-L/usr/lib/lwp/$multi_os_directory \
+		    -R/usr/lib/lwp/$multi_os_directory -lpthread -lthread -lrt"
 	;;
      *-*-irix*)
 	AC_DEFINE(GC_IRIX_THREADS,1,[support for Irix pthreads])
Index: boehm-gc/include/gc.h
===================================================================
--- boehm-gc/include/gc.h	(revision 124389)
+++ boehm-gc/include/gc.h	(revision 126334)
@@ -1085,5 +1085,6 @@
   && !defined(GC_WIN32_THREADS) && !defined(GC_DARWIN_THREADS)
 GC_API void GC_suspend_thread GC_PROTO((pthread_t));
 GC_API void GC_resume_thread GC_PROTO((pthread_t));
+GC_API int GC_is_thread_suspended GC_PROTO((pthread_t));
 #endif
 #endif /* _GC_H */
Index: boehm-gc/include/gc_config_macros.h
===================================================================
--- boehm-gc/include/gc_config_macros.h	(revision 124389)
+++ boehm-gc/include/gc_config_macros.h	(revision 126334)
@@ -72,10 +72,6 @@
 # define GC_WIN32_THREADS
 #endif
 
-#if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)
-#   define GC_SOLARIS_THREADS
-#endif
-
 # define __GC
 # ifndef _WIN32_WCE
 #   include <stddef.h>
Index: boehm-gc/include/private/solaris_threads.h
===================================================================
--- boehm-gc/include/private/solaris_threads.h	(revision 124389)
+++ boehm-gc/include/private/solaris_threads.h	(revision 126334)
@@ -1,37 +0,0 @@
-#ifdef GC_SOLARIS_THREADS
-
-/* The set of all known threads.  We intercept thread creation and     */
-/* joins.  We never actually create detached threads.  We allocate all */
-/* new thread stacks ourselves.  These allow us to maintain this       */
-/* data structure.                                                     */
-/* Protected by GC_thr_lock.                                           */
-/* Some of this should be declared volatile, but that's incosnsistent  */
-/* with some library routine declarations.  In particular, the 	       */
-/* definition of cond_t doesn't mention volatile!                      */
-  typedef struct GC_Thread_Rep {
-    struct GC_Thread_Rep * next;
-    thread_t id;
-    word flags;
-#      define FINISHED 1       /* Thread has exited.   */
-#      define DETACHED 2       /* Thread is intended to be detached.   */
-#      define CLIENT_OWNS_STACK        4
-                               /* Stack was supplied by client.        */
-#      define SUSPNDED 8       /* Currently suspended.			*/
-    			       /* SUSPENDED is used insystem header.	*/
-    ptr_t stack;
-    size_t stack_size;
-    cond_t join_cv;
-    void * status;
-  } * GC_thread;
-  extern GC_thread GC_new_thread(thread_t id);
-
-  extern GC_bool GC_thr_initialized;
-  extern volatile GC_thread GC_threads[];
-  extern size_t GC_min_stack_sz;
-  extern size_t GC_page_sz;
-  extern void GC_thr_init(void);
-  extern ptr_t GC_stack_alloc(size_t * stack_size);
-  extern void GC_stack_free(ptr_t stack, size_t size);
-
-# endif /* GC_SOLARIS_THREADS */
-
Index: boehm-gc/include/private/gcconfig.h
===================================================================
--- boehm-gc/include/private/gcconfig.h	(revision 124389)
+++ boehm-gc/include/private/gcconfig.h	(revision 126334)
@@ -153,6 +153,11 @@
 #    define SUNOS5
 #    define mach_type_known
 # endif
+# if defined(sun) && defined(__amd64)
+#    define X86_64
+#    define SUNOS5
+#    define mach_type_known
+# endif
 # if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)
 #    define I386
 #    define OS2
@@ -1961,6 +1966,36 @@
 	extern char etext[];
 #	define SEARCH_FOR_DATA_START
 #   endif
+#   ifdef SUNOS5
+#	define ELF_CLASS ELFCLASS64
+#	define OS_TYPE "SUNOS5"
+        extern int _etext[], _end[];
+  	extern ptr_t GC_SysVGetDataStart();
+#       define DATASTART GC_SysVGetDataStart(0x1000, _etext)
+#	define DATAEND (_end)
+/*	# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  	*/
+/*      but reportedly breaks under 2.8.  It appears that the stack	*/
+/* 	base is a property of the executable, so this should not break	*/
+/* 	old executables.						*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+/* #       include <sys/vm.h> */
+/* #	define STACKBOTTOM USRSTACK */
+#	define HEURISTIC2
+#	define PROC_VDB
+#	define DYNAMIC_LOADING
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#   endif
 # endif
 
 #if defined(LINUX) && defined(USE_MMAP)
@@ -2106,11 +2141,6 @@
 		((word*)x)[1] = 0;
 # endif /* CLEAR_DOUBLE */
 
-	/* Internally we use GC_SOLARIS_THREADS to test for either old or pthreads. */
-# if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)
-#   define GC_SOLARIS_THREADS
-# endif
-
 # if defined(GC_IRIX_THREADS) && !defined(IRIX5)
 	--> inconsistent configuration
 # endif
Index: boehm-gc/ChangeLog
===================================================================
--- boehm-gc/ChangeLog	(revision 124389)
+++ boehm-gc/ChangeLog	(revision 126334)
@@ -1,3 +1,37 @@
+2007-07-02  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	PR boehm-gc/21940
+	PR boehm-gc/21942
+	* configure.ac (GC_SOLARIS_THREADS): Don't define on *-*-solaris*.
+	Use alternate thread library in /usr/lib/lwp.
+	* configure: Regenerate.
+	* dyn_load.c: Use GC_SOLARIS_PTHREADS.
+	* include/gc_config_macros.h (GC_SOLARIS_THREADS): Don't define.
+	* include/private/gcconfig.h: Handle 64-bit Solaris 2/x86.
+	(GC_SOLARIS_THREADS): Don't define.
+	* include/private/solaris_threads.h: Remove.
+	* pthread_support.c (GC_thr_init) [GC_SOLARIS_PTHREADS]: Determine
+	GC_nprocs via sysconf().
+	* Makefile.am (libgcjgc_la_SOURCES): Remove solaris_pthreads.c and
+	solaris_threads.c.
+	(gctest_LDADD): Use THREADLIBS instead of THREADDLLIBS.
+	* Makefile.in: Regenerate.	 
+	* solaris_pthreads.c: Remove.
+	* solaris_threads.c: Remove.
+
+2007-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	* pthread_support.c (GC_get_thread_stack_base): Handle
+	pthread_getattr_np failures.
+
+2007-05-18  Keith Seitz  <keiths@redhat.com>
+
+	Merged from trunk:
+
+	2007-04-23  Keith Seitz  <keiths@redhat.com>
+	* include/gc.h (GC_is_thread_suspended): Declare.
+	* pthread_stop_world.c (GC_is_thread_suspended): New function.
+
 2007-04-03  Jakub Jelinek  <jakub@redhat.com>
 
 	* configure.ac (NO_EXECUTE_PERMISSION): Set by default.
Index: boehm-gc/configure
===================================================================
--- boehm-gc/configure	(revision 124389)
+++ boehm-gc/configure	(revision 126334)
@@ -5458,14 +5458,14 @@
      *-*-solaris*)
 
 cat >>confdefs.h <<\_ACEOF
-#define GC_SOLARIS_THREADS 1
-_ACEOF
-
-
-cat >>confdefs.h <<\_ACEOF
 #define GC_SOLARIS_PTHREADS 1
 _ACEOF
 
+	# Need to use alternate thread library, otherwise gctest hangs
+	# on Solaris 8.
+	multi_os_directory=`$CC -print-multi-os-directory`
+	THREADLIBS="-L/usr/lib/lwp/$multi_os_directory \
+		    -R/usr/lib/lwp/$multi_os_directory -lpthread -lthread -lrt"
 	;;
      *-*-irix*)
 
Index: boehm-gc/pthread_stop_world.c
===================================================================
--- boehm-gc/pthread_stop_world.c	(revision 124389)
+++ boehm-gc/pthread_stop_world.c	(revision 126334)
@@ -483,6 +483,14 @@
   t -> flags &= ~SUSPENDED;
 }
 
+int GC_is_thread_suspended(pthread_t thread) {
+  GC_thread t = GC_lookup_thread(thread);
+  if (t == NULL)
+    ABORT("querying suspension state of unknown thread");
+
+  return (t -> flags & SUSPENDED);
+}
+
 /* Caller holds allocation lock, and has held it continuously since	*/
 /* the world stopped.							*/
 void GC_start_world()
Index: boehm-gc/pthread_support.c
===================================================================
--- boehm-gc/pthread_support.c	(revision 124389)
+++ boehm-gc/pthread_support.c	(revision 126334)
@@ -883,7 +883,8 @@
 #       if defined(GC_HPUX_THREADS)
 	  GC_nprocs = pthread_num_processors_np();
 #       endif
-#	if defined(GC_OSF1_THREADS) || defined(GC_AIX_THREADS)
+#	if defined(GC_OSF1_THREADS) || defined(GC_AIX_THREADS) \
+	   || defined(GC_SOLARIS_PTHREADS)
 	  GC_nprocs = sysconf(_SC_NPROCESSORS_ONLN);
 	  if (GC_nprocs <= 0) GC_nprocs = 1;
 #	endif
@@ -1135,7 +1136,13 @@
   size_t stack_size;
   
   my_pthread = pthread_self();  
-  pthread_getattr_np (my_pthread, &attr);
+  if (pthread_getattr_np (my_pthread, &attr) != 0)
+    {
+#   ifdef DEBUG_THREADS
+      GC_printf1("Can not determine stack base for attached thread");
+#   endif
+      return 0;
+    }
   pthread_attr_getstack (&attr, (void **) &stack_addr, &stack_size);
   pthread_attr_destroy (&attr);
   
Index: boehm-gc/Makefile.am
===================================================================
--- boehm-gc/Makefile.am	(revision 124389)
+++ boehm-gc/Makefile.am	(revision 126334)
@@ -21,7 +21,7 @@
 dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \
 malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \
 obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \
-solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \
+specific.c stubborn.c typd_mlc.c \
 backgraph.c win32_threads.c \
 pthread_support.c pthread_stop_world.c darwin_stop_world.c \
 $(asm_libgcjgc_sources)
@@ -47,7 +47,7 @@
 
 check_PROGRAMS = gctest
 gctest_SOURCES = tests/test.c
-gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)
+gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)
 gctest_LDFLAGS = -shared-libgcc
 TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc
 TESTS = gctest
Index: boehm-gc/dyn_load.c
===================================================================
--- boehm-gc/dyn_load.c	(revision 124389)
+++ boehm-gc/dyn_load.c	(revision 126334)
@@ -225,7 +225,7 @@
 
 # if defined(SUNOS4) || defined(SUNOS5DL)
 /* Add dynamic library data sections to the root set.		*/
-# if !defined(PCR) && !defined(GC_SOLARIS_THREADS) && defined(THREADS)
+# if !defined(PCR) && !defined(GC_SOLARIS_PTHREADS) && defined(THREADS)
 #   ifndef SRC_M3
 	--> fix mutual exclusion with dlopen
 #   endif  /* We assume M3 programs don't call dlopen for now */
Index: libjava/Makefile.in
===================================================================
--- libjava/Makefile.in	(revision 125219)
+++ libjava/Makefile.in	(revision 126334)
@@ -156,9 +156,10 @@
 	gnu/classpath/jdwp/exception.lo gnu/classpath/jdwp/id.lo \
 	gnu/classpath/jdwp/processor.lo \
 	gnu/classpath/jdwp/transport.lo gnu/classpath/jdwp/util.lo \
-	gnu/gcj.lo gnu/gcj/convert.lo gnu/gcj/io.lo gnu/gcj/jvmti.lo \
-	gnu/gcj/runtime.lo gnu/gcj/util.lo gnu/java/awt.lo \
-	gnu/java/awt/color.lo gnu/java/awt/dnd.lo gnu/java/awt/font.lo \
+	gnu/classpath/jdwp/value.lo gnu/gcj.lo gnu/gcj/convert.lo \
+	gnu/gcj/io.lo gnu/gcj/jvmti.lo gnu/gcj/runtime.lo \
+	gnu/gcj/util.lo gnu/java/awt.lo gnu/java/awt/color.lo \
+	gnu/java/awt/dnd.lo gnu/java/awt/font.lo \
 	gnu/java/awt/font/autofit.lo gnu/java/awt/font/opentype.lo \
 	gnu/java/awt/font/opentype/truetype.lo gnu/java/awt/image.lo \
 	gnu/java/awt/java2d.lo gnu/java/awt/peer.lo \
@@ -1188,15 +1189,19 @@
 
 gnu_classpath_jdwp_event_filters_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_event_filters_source_files)))
 gnu_classpath_jdwp_exception_source_files = \
+classpath/gnu/classpath/jdwp/exception/AbsentInformationException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidClassException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidClassLoaderException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidCountException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidEventTypeException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidFieldException.java \
+classpath/gnu/classpath/jdwp/exception/InvalidFrameException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidLocationException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidMethodException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidObjectException.java \
+classpath/gnu/classpath/jdwp/exception/InvalidSlotException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidStringException.java \
+classpath/gnu/classpath/jdwp/exception/InvalidTagException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidThreadException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidThreadGroupException.java \
 classpath/gnu/classpath/jdwp/exception/JdwpException.java \
@@ -1204,6 +1209,7 @@
 classpath/gnu/classpath/jdwp/exception/JdwpInternalErrorException.java \
 classpath/gnu/classpath/jdwp/exception/NativeMethodException.java \
 classpath/gnu/classpath/jdwp/exception/NotImplementedException.java \
+classpath/gnu/classpath/jdwp/exception/TypeMismatchException.java \
 classpath/gnu/classpath/jdwp/exception/VmDeadException.java
 
 gnu_classpath_jdwp_exception_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_exception_source_files)))
@@ -1215,6 +1221,7 @@
 classpath/gnu/classpath/jdwp/id/ClassReferenceTypeId.java \
 classpath/gnu/classpath/jdwp/id/InterfaceReferenceTypeId.java \
 classpath/gnu/classpath/jdwp/id/JdwpId.java \
+classpath/gnu/classpath/jdwp/id/NullObjectId.java \
 classpath/gnu/classpath/jdwp/id/ObjectId.java \
 classpath/gnu/classpath/jdwp/id/ReferenceTypeId.java \
 classpath/gnu/classpath/jdwp/id/StringId.java \
@@ -1259,11 +1266,30 @@
 classpath/gnu/classpath/jdwp/util/LineTable.java \
 classpath/gnu/classpath/jdwp/util/Location.java \
 classpath/gnu/classpath/jdwp/util/MethodResult.java \
+classpath/gnu/classpath/jdwp/util/MonitorInfo.java \
+classpath/gnu/classpath/jdwp/util/NullObject.java \
 classpath/gnu/classpath/jdwp/util/Signature.java \
 classpath/gnu/classpath/jdwp/util/Value.java \
 classpath/gnu/classpath/jdwp/util/VariableTable.java
 
 gnu_classpath_jdwp_util_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_util_source_files)))
+gnu_classpath_jdwp_value_source_files = \
+classpath/gnu/classpath/jdwp/value/ArrayValue.java \
+classpath/gnu/classpath/jdwp/value/BooleanValue.java \
+classpath/gnu/classpath/jdwp/value/ByteValue.java \
+classpath/gnu/classpath/jdwp/value/CharValue.java \
+classpath/gnu/classpath/jdwp/value/DoubleValue.java \
+classpath/gnu/classpath/jdwp/value/FloatValue.java \
+classpath/gnu/classpath/jdwp/value/IntValue.java \
+classpath/gnu/classpath/jdwp/value/LongValue.java \
+classpath/gnu/classpath/jdwp/value/ObjectValue.java \
+classpath/gnu/classpath/jdwp/value/ShortValue.java \
+classpath/gnu/classpath/jdwp/value/StringValue.java \
+classpath/gnu/classpath/jdwp/value/Value.java \
+classpath/gnu/classpath/jdwp/value/ValueFactory.java \
+classpath/gnu/classpath/jdwp/value/VoidValue.java
+
+gnu_classpath_jdwp_value_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_value_source_files)))
 gnu_gcj_source_files = \
 gnu/gcj/Core.java \
 gnu/gcj/RawData.java \
@@ -7184,6 +7210,7 @@
   gnu/classpath/jdwp/processor.list \
   gnu/classpath/jdwp/transport.list \
   gnu/classpath/jdwp/util.list \
+  gnu/classpath/jdwp/value.list \
   gnu/gcj.list \
   gnu/gcj/convert.list \
   gnu/gcj/io.list \
@@ -7428,6 +7455,7 @@
   $(gnu_classpath_jdwp_processor_header_files) \
   $(gnu_classpath_jdwp_transport_header_files) \
   $(gnu_classpath_jdwp_util_header_files) \
+  $(gnu_classpath_jdwp_value_header_files) \
   $(gnu_gcj_header_files) \
   $(gnu_gcj_convert_header_files) \
   $(gnu_gcj_io_header_files) \
@@ -10004,6 +10032,12 @@
 
 -include gnu/classpath/jdwp/util.deps
 
+gnu/classpath/jdwp/value.list: $(gnu_classpath_jdwp_value_source_files)
+	@$(mkinstalldirs) $(dir $@)
+	echo $(srcdir)/classpath/lib/gnu/classpath/jdwp/value/*.class > gnu/classpath/jdwp/value.list
+
+-include gnu/classpath/jdwp/value.deps
+
 gnu/gcj.list: $(gnu_gcj_source_files)
 	@$(mkinstalldirs) $(dir $@)
 	echo $(srcdir)/classpath/lib/gnu/gcj/*.class > gnu/gcj.list
Index: libjava/interpret.cc
===================================================================
--- libjava/interpret.cc	(revision 125219)
+++ libjava/interpret.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // interpret.cc - Code for the interpreter
 
-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation
+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation
 
    This file is part of libgcj.
 
@@ -37,8 +37,12 @@
 #include <execution.h>
 #include <java/lang/reflect/Modifier.h>
 
-#include <gnu/classpath/jdwp/Jdwp.h>
+#include <jvmti.h>
+#include "jvmti-int.h"
 
+#include <gnu/gcj/jvmti/Breakpoint.h>
+#include <gnu/gcj/jvmti/BreakpointManager.h>
+
 #ifdef INTERPRETER
 
 // Execution engine for interpreted code.
@@ -60,6 +64,16 @@
 static void throw_class_format_error (const char *msg)
 	__attribute__ ((__noreturn__));
 
+static void find_catch_location (jthrowable, jthread, jmethodID *, jlong *);
+
+// A macro to facilitate JVMTI exception reporting
+#define REPORT_EXCEPTION(Jthrowable)			\
+  do {							\
+    if (JVMTI_REQUESTED_EVENT (Exception))		\
+      _Jv_ReportJVMTIExceptionThrow (Jthrowable);	\
+  }							\
+  while (0)
+
 #ifdef DIRECT_THREADED
 // Lock to ensure that methods are not compiled concurrently.
 // We could use a finer-grained lock here, however it is not safe to use
@@ -166,54 +180,81 @@
 # define LOADD(I)  LOADL(I)
 #endif
 
-#define STOREA(I) 		\
-do {					\
-DEBUG_LOCALS_INSN(I, 'o');		\
-locals[I].o = (--sp)->o;		\
-} while(0)
-#define STOREI(I) 		\
-do {					\
-DEBUG_LOCALS_INSN (I, 'i');		\
-locals[I].i = (--sp)->i;		\
-} while(0)
-#define STOREF(I)  		\
-do {					\
-DEBUG_LOCALS_INSN (I, 'f');		\
-locals[I].f = (--sp)->f;		\
-} while(0)
+#define STOREA(I)			\
+  do					\
+    {					\
+      jint __idx = (I);			\
+      DEBUG_LOCALS_INSN (__idx, 'o');	\
+      locals[__idx].o = (--sp)->o;	\
+    }					\
+  while (0)
+#define STOREI(I)		       	\
+  do					\
+    {					\
+      jint __idx = (I);			\
+      DEBUG_LOCALS_INSN (__idx, 'i');	\
+      locals[__idx].i = (--sp)->i;	\
+  } while (0)
+#define STOREF(I)			\
+  do					\
+    {					\
+      jint __idx = (I);			\
+      DEBUG_LOCALS_INSN (__idx, 'f');	\
+      locals[__idx].f = (--sp)->f;	\
+    }					\
+  while (0)
 #if SIZEOF_VOID_P == 8
-# define STOREL(I)  			\
-do {							\
-DEBUG_LOCALS_INSN (I, 'l');			\
-(sp -= 2, locals[I].l = sp->l);		\
-} while(0)
-# define STORED(I) 				\
-do {							\
-DEBUG_LOCALS_INSN (I, 'd');			\
-(sp -= 2, locals[I].d = sp->d);		\
-} while(0)
+# define STOREL(I) \
+  do						\
+    {						\
+      jint __idx = (I);				\
+      DEBUG_LOCALS_INSN (__idx, 'l');		\
+      DEBUG_LOCALS_INSN (__idx + 1, 'x');	\
+      (sp -= 2, locals[__idx].l = sp->l);	\
+    }						\
+  while (0)
+# define STORED(I)				\
+  do						\
+    {						\
+      jint __idx = (I);				\
+      DEBUG_LOCALS_INSN (__idx, 'd');		\
+      DEBUG_LOCALS_INSN (__idx + 1, 'x');	\
+      (sp -= 2, locals[__idx].d = sp->d);	\
+    }						\
+  while (0)
 
 #else
-# define STOREL(I)		\
-do { DEBUG_LOCALS_INSN(I, 'l');	\
-	 jint __idx = (I); 	\
-     locals[__idx+1].ia[0] = (--sp)->ia[0]; \
-     locals[__idx].ia[0] = (--sp)->ia[0]; 	\
-   } while (0)
-# define STORED(I)		\
-do { DEBUG_LOCALS_INSN(I, 'd');	\
-	 jint __idx = (I); 	\
-     locals[__idx+1].ia[0] = (--sp)->ia[0]; \
-     locals[__idx].ia[0] = (--sp)->ia[0]; 	\
-   } while (0)
+# define STOREL(I)				\
+  do						\
+    {						\
+      jint __idx = (I);				\
+      DEBUG_LOCALS_INSN (__idx, 'l');		\
+      DEBUG_LOCALS_INSN (__idx + 1, 'x');	\
+      locals[__idx + 1].ia[0] = (--sp)->ia[0];	\
+      locals[__idx].ia[0] = (--sp)->ia[0];	\
+    }						\
+  while (0)
+# define STORED(I)				\
+  do {						\
+    jint __idx = (I);				\
+    DEBUG_LOCALS_INSN (__idx, 'd');		\
+    DEBUG_LOCALS_INSN (__idx + 1, 'x');		\
+    locals[__idx + 1].ia[0] = (--sp)->ia[0];	\
+    locals[__idx].ia[0] = (--sp)->ia[0];	\
+  } while (0)
 #endif
 
 #define PEEKI(I)  (locals+(I))->i
 #define PEEKA(I)  (locals+(I))->o
 
-#define POKEI(I,V)  	\
-DEBUG_LOCALS_INSN(I,'i'); \
-((locals+(I))->i = (V))
+#define POKEI(I,V)			\
+  do					\
+    {					\
+      jint __idx = (I);			\
+      DEBUG_LOCALS_INSN (__idx, 'i');	\
+      ((locals + __idx)->i = (V));	\
+    }					\
+  while (0)
 
 
 #define BINOPI(OP) { \
@@ -916,18 +957,14 @@
 void
 _Jv_InterpMethod::run_debug (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)
 {
-/* Used to keep track of local variable type
- * 
- * Possible Types:
- * o object
- * i integer
- * f float
- * l long 
- * d double 
- */
 #define DEBUG
 #undef DEBUG_LOCALS_INSN
-#define DEBUG_LOCALS_INSN(s, t) do {} while(0)
+#define DEBUG_LOCALS_INSN(s, t)  \
+  do    \
+    {   \
+      frame_desc.locals_type[s] = t;  \
+    }   \
+  while (0)
 
 #include "interpret-run.cc"
 }
@@ -935,19 +972,25 @@
 static void
 throw_internal_error (const char *msg)
 {
-  throw new java::lang::InternalError (JvNewStringLatin1 (msg));
+  jthrowable t = new java::lang::InternalError (JvNewStringLatin1 (msg));
+  REPORT_EXCEPTION (t);
+  throw t;
 }
 
 static void 
 throw_incompatible_class_change_error (jstring msg)
 {
-  throw new java::lang::IncompatibleClassChangeError (msg);
+  jthrowable t = new java::lang::IncompatibleClassChangeError (msg);
+  REPORT_EXCEPTION (t);
+  throw t;
 }
 
 static void 
 throw_null_pointer_exception ()
 {
-  throw new java::lang::NullPointerException;
+  jthrowable t = new java::lang::NullPointerException;
+  REPORT_EXCEPTION (t);
+  throw t;
 }
 
 /* Look up source code line number for given bytecode (or direct threaded
@@ -1290,34 +1333,34 @@
     {
       if (staticp)
         {
-        if (::gnu::classpath::jdwp::Jdwp::isDebugging)
-		  fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class_debug;
-		else
-		  fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class;
+	  if (JVMTI::enabled)
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class_debug;
+	  else
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class;
         }
       else
         {
-	      if (::gnu::classpath::jdwp::Jdwp::isDebugging)
-		    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_object_debug;
-		  else
-		  	fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_object;
-        } 
+	  if (JVMTI::enabled)
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_object_debug;
+	  else
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_object;
+        }
     }
   else
     {
       if (staticp)
         {
-	      if (::gnu::classpath::jdwp::Jdwp::isDebugging)
-		    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_class_debug;
-		  else
-		    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_class;
+	  if (JVMTI::enabled)
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_class_debug;
+	  else
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_class;
         }
       else
         {
-	      if (::gnu::classpath::jdwp::Jdwp::isDebugging)
-		    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal_debug;
-		  else
-		    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal;
+	  if (JVMTI::enabled)
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal_debug;
+	  else
+	    fun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal;
         }
     }
 
@@ -1361,6 +1404,51 @@
   return -1;
 }
 
+// Method to check if an exception is caught at some location in a method
+// (meth).  Returns true if this method (meth) contains a catch block for the
+// exception (ex). False otherwise.  If there is a catch block, it sets the pc
+// to the location of the beginning of the catch block.
+jboolean
+_Jv_InterpMethod::check_handler (pc_t *pc, _Jv_InterpMethod *meth,
+                                java::lang::Throwable *ex)
+{
+#ifdef DIRECT_THREADED
+  void *logical_pc = (void *) ((insn_slot *) (*pc) - 1);
+#else
+  int logical_pc = (*pc) - 1 - meth->bytecode ();
+#endif
+  _Jv_InterpException *exc = meth->exceptions ();
+  jclass exc_class = ex->getClass ();
+
+  for (int i = 0; i < meth->exc_count; i++)
+    {
+      if (PCVAL (exc[i].start_pc) <= logical_pc
+          && logical_pc < PCVAL (exc[i].end_pc))
+        {
+#ifdef DIRECT_THREADED
+              jclass handler = (jclass) exc[i].handler_type.p;
+#else
+              jclass handler = NULL;
+              if (exc[i].handler_type.i != 0)
+                    handler
+                      = (_Jv_Linker::resolve_pool_entry (meth->defining_class,
+                                                                             ex$
+#endif /* DIRECT_THREADED */
+              if (handler == NULL || handler->isAssignableFrom (exc_class))
+                {
+#ifdef DIRECT_THREADED
+                  (*pc) = (insn_slot *) exc[i].handler_pc.p;
+#else
+                  (*pc) = meth->bytecode () + exc[i].handler_pc.i;
+#endif /* DIRECT_THREADED */
+                  return true;
+                }
+          }
+      }
+  return false;
+}
+
+
 void
 _Jv_InterpMethod::get_line_table (jlong& start, jlong& end,
 				  jintArray& line_numbers,
@@ -1409,6 +1497,30 @@
 #endif // !DIRECT_THREADED
 }
 
+int 
+_Jv_InterpMethod::get_local_var_table (char **name, char **sig, 
+                                       char **generic_sig, jlong *startloc,
+                                       jint *length, jint *slot, 
+                                       int table_slot)
+{  	
+  if (local_var_table == NULL)
+    return -2;
+  if (table_slot >= local_var_table_len)
+    return -1;
+  else
+    {
+      *name = local_var_table[table_slot].name;
+      *sig = local_var_table[table_slot].descriptor;
+      *generic_sig = local_var_table[table_slot].descriptor;
+
+      *startloc = static_cast<jlong> 
+                    (local_var_table[table_slot].bytecode_start_pc);
+      *length = static_cast<jint> (local_var_table[table_slot].length);
+      *slot = static_cast<jint> (local_var_table[table_slot].slot);
+    }
+  return local_var_table_len - table_slot -1;
+}
+
 pc_t
 _Jv_InterpMethod::install_break (jlong index)
 {
@@ -1455,6 +1567,23 @@
   return &code[index];
 }
 
+bool
+_Jv_InterpMethod::breakpoint_at (jlong index)
+{
+  pc_t insn = get_insn (index);
+  if (insn != NULL)
+    {
+#ifdef DIRECT_THREADED
+      return (insn->insn == breakpoint_insn->insn);
+#else
+      pc_t code = reinterpret_cast<pc_t> (bytecode ());
+      return (code[index] == breakpoint_insn);
+#endif
+    }
+
+  return false;
+}
+
 void *
 _Jv_JNIMethod::ncode (jclass klass)
 {
@@ -1523,9 +1652,11 @@
 static void
 throw_class_format_error (jstring msg)
 {
-  throw (msg
+  jthrowable t = (msg
 	 ? new java::lang::ClassFormatError (msg)
 	 : new java::lang::ClassFormatError);
+  REPORT_EXCEPTION (t);
+  throw t;
 }
 
 static void
@@ -1534,6 +1665,70 @@
   throw_class_format_error (JvNewStringLatin1 (msg));
 }
 
+/* This function finds the method and location where the exception EXC
+   is caught in the stack frame. On return, it sets CATCH_METHOD and
+   CATCH_LOCATION with the method and location where the catch will
+   occur. If the exception is not caught, these are set to 0.
+
+   This function should only be used with the DEBUG interpreter. */
+static void
+find_catch_location (::java::lang::Throwable *exc, jthread thread,
+		     jmethodID *catch_method, jlong *catch_loc)
+{
+  *catch_method = 0;
+  *catch_loc = 0;
+
+  _Jv_InterpFrame *frame
+    = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);
+  while (frame != NULL)
+    {
+      pc_t pc = frame->get_pc ();
+      _Jv_InterpMethod *imeth
+	= reinterpret_cast<_Jv_InterpMethod *> (frame->self);
+      if (imeth->check_handler (&pc, imeth, exc))
+	{
+	  // This method handles the exception.
+	  *catch_method = imeth->get_method ();
+	  *catch_loc = imeth->insn_index (pc);
+	  return;
+	}
+
+      frame = frame->next_interp;
+    }
+}
+
+/* This method handles JVMTI notifications of thrown exceptions. It
+   calls find_catch_location to figure out where the exception is
+   caught (if it is caught).
+   
+   Like find_catch_location, this should only be called with the
+   DEBUG interpreter. Since a few exceptions occur outside the
+   interpreter proper, it is important to not call this function
+   without checking JVMTI_REQUESTED_EVENT(Exception) first. */
+void
+_Jv_ReportJVMTIExceptionThrow (jthrowable ex)
+{
+  jthread thread = ::java::lang::Thread::currentThread ();
+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thread->frame);
+  jmethodID throw_meth = frame->self->get_method ();
+  jlocation throw_loc = -1;
+  if (frame->frame_type == frame_interpreter)
+    {
+      _Jv_InterpFrame * iframe
+	= reinterpret_cast<_Jv_InterpFrame *> (frame);
+      _Jv_InterpMethod *imeth
+	= reinterpret_cast<_Jv_InterpMethod *> (frame->self);
+      throw_loc = imeth->insn_index (iframe->get_pc ());
+    }
+
+  jlong catch_loc;
+  jmethodID catch_method;
+  find_catch_location (ex, thread, &catch_method, &catch_loc);
+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_EXCEPTION, thread,
+		       _Jv_GetCurrentJNIEnv (), throw_meth, throw_loc,
+		       ex, catch_method, catch_loc);
+}
+
 
 
 void
@@ -1690,7 +1885,12 @@
 _Jv_CompileMethod (_Jv_InterpMethod* method)
 {
   if (method->prepared == NULL)
-    _Jv_InterpMethod::run (NULL, NULL, method);
+    {
+      if (JVMTI::enabled)
+	_Jv_InterpMethod::run_debug (NULL, NULL, method);
+      else
+      _Jv_InterpMethod::run (NULL, NULL, method);
+    }
 }
 #endif // DIRECT_THREADED
 
Index: libjava/stacktrace.cc
===================================================================
--- libjava/stacktrace.cc	(revision 125219)
+++ libjava/stacktrace.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // stacktrace.cc - Functions for unwinding & inspecting the call stack.
 
-/* Copyright (C) 2005, 2006  Free Software Foundation
+/* Copyright (C) 2005, 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -131,9 +131,11 @@
   if (func_addr == UNWRAP_FUNCTION_DESCRIPTOR (interp_run))
     {
       state->frames[pos].type = frame_interpreter;
-      state->frames[pos].interp.meth = state->interp_frame->self;
+      _Jv_Frame *frame = static_cast<_Jv_Frame *> (state->interp_frame);
+      state->frames[pos].interp.meth 
+        = static_cast<_Jv_InterpMethod *> (frame->self);
       state->frames[pos].interp.pc = state->interp_frame->pc;
-      state->interp_frame = state->interp_frame->next;
+      state->interp_frame = state->interp_frame->next_interp;
     }
   else 
 #endif
@@ -143,7 +145,7 @@
       state->frames[pos].type = frame_proxy;
       state->frames[pos].proxyClass = state->interp_frame->proxyClass;
       state->frames[pos].proxyMethod = state->interp_frame->proxyMethod;
-      state->interp_frame = state->interp_frame->next;
+      state->interp_frame = state->interp_frame->next_interp;
     }
   else 
     {
Index: libjava/classpath/gnu/classpath/jdwp/processor/ObjectReferenceCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/ObjectReferenceCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/ObjectReferenceCommandSet.java	(revision 126334)
@@ -1,6 +1,6 @@
 /* ObjectReferenceCommandSet.java -- class to implement the ObjectReference
    Command Set
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -47,8 +47,10 @@
 import gnu.classpath.jdwp.exception.NotImplementedException;
 import gnu.classpath.jdwp.id.ObjectId;
 import gnu.classpath.jdwp.id.ReferenceTypeId;
-import gnu.classpath.jdwp.util.Value;
 import gnu.classpath.jdwp.util.MethodResult;
+import gnu.classpath.jdwp.util.MonitorInfo;
+import gnu.classpath.jdwp.value.Value;
+import gnu.classpath.jdwp.value.ValueFactory;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -137,7 +139,9 @@
           {
             field.setAccessible(true); // Might be a private field
             Object value = field.get(obj);
-            Value.writeTaggedValue(os, value);
+            Value val = ValueFactory.createFromObject(value, 
+                                                      field.getType());
+            val.writeTagged(os);
           }
         catch (IllegalArgumentException ex)
           {
@@ -163,7 +167,7 @@
     for (int i = 0; i < numFields; i++)
       {
         Field field = (Field) idMan.readObjectId(bb).getObject();
-        Object value = Value.getUntaggedObj(bb, field.getType());
+        Object value = Value.getUntaggedObject(bb, field.getType());
         try
           {
             field.setAccessible(true); // Might be a private field
@@ -183,13 +187,18 @@
   }
 
   private void executeMonitorInfo(ByteBuffer bb, DataOutputStream os)
-    throws JdwpException
+    throws JdwpException, IOException
   {
-    // This command is optional, determined by VirtualMachines CapabilitiesNew
-    // so we'll leave it till later to implement
-    throw new NotImplementedException(
-      "Command ExecuteMonitorInfo not implemented.");
+    if (!VMVirtualMachine.canGetMonitorInfo)
+      {
+	String msg = "getting monitor info not supported";
+	throw new NotImplementedException(msg);
+      }
 
+    ObjectId oid = idMan.readObjectId(bb);
+    Object obj = oid.getObject();
+    MonitorInfo info = VMVirtualMachine.getMonitorInfo(obj);
+    info.write(os);
   }
 
   private void executeInvokeMethod(ByteBuffer bb, DataOutputStream os)
@@ -212,7 +221,7 @@
 
     for (int i = 0; i < args; i++)
       {
-        values[i] = Value.getObj(bb);
+        values[i] = Value.getTaggedObject(bb);
       }
 
     int invokeOptions = bb.getInt();
@@ -232,11 +241,14 @@
     MethodResult mr = VMVirtualMachine.executeMethod(obj, thread,
 						     clazz, method,
 						     values, nonVirtual);
+    mr.setResultType (method.getReturnType());
+    
     Object value = mr.getReturnedValue();
     Exception exception = mr.getThrownException();
 
     ObjectId eId = idMan.getObjectId(exception);
-    Value.writeTaggedValue(os, value);
+    Value val = ValueFactory.createFromObject(value, mr.getResultType());
+    val.writeTagged(os);
     eId.writeTagged(os);
   }
 
Index: libjava/classpath/gnu/classpath/jdwp/processor/ThreadReferenceCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/ThreadReferenceCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/ThreadReferenceCommandSet.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* ThreadReferenceCommandSet.java -- class to implement the ThreadReference
-   Command Set Copyright (C) 2005 Free Software Foundation
+   Command Set Copyright (C) 2005, 2007 Free Software Foundation
  
 This file is part of GNU Classpath.
 
@@ -142,7 +142,7 @@
   {
     ThreadId tid = (ThreadId) idMan.readObjectId(bb);
     Thread thread = tid.getThread();
-    VMVirtualMachine.suspendThread(thread);
+    VMVirtualMachine.resumeThread(thread);
   }
 
   private void executeStatus(ByteBuffer bb, DataOutputStream os)
@@ -198,22 +198,42 @@
   }
 
   private void executeOwnedMonitors(ByteBuffer bb, DataOutputStream os)
-      throws JdwpException
+    throws JdwpException, IOException
   {
-    // This command is optional, determined by VirtualMachines CapabilitiesNew
-    // so we'll leave it till later to implement
-    throw new NotImplementedException(
-      "Command OwnedMonitors not implemented.");
+    if (!VMVirtualMachine.canGetOwnedMonitorInfo)
+      {
+	String msg = "getting owned monitors is not supported";
+	throw new NotImplementedException(msg);
+      }
+
+    ThreadId tid = (ThreadId) idMan.readObjectId(bb);
+    Thread thread = tid.getThread();
+    Object[] monitors = VMVirtualMachine.getOwnedMonitors(thread);
+
+    os.write(monitors.length);
+    for (int i = 0; i < monitors.length; ++i)
+      {
+	ObjectId id = idMan.getObjectId(monitors[i]);
+	id.writeTagged(os);
+      }
   }
 
   private void executeCurrentContendedMonitor(ByteBuffer bb,
                                               DataOutputStream os)
-      throws JdwpException
+    throws JdwpException, IOException
   {
-    // This command is optional, determined by VirtualMachines CapabilitiesNew
-    // so we'll leave it till later to implement
-    throw new NotImplementedException(
-      "Command CurrentContentedMonitors not implemented.");
+    if (!VMVirtualMachine.canGetCurrentContendedMonitor)
+      {
+	String msg = "getting current contended monitor is not supported";
+	throw new NotImplementedException(msg);
+      }
+
+    ThreadId tid = (ThreadId) idMan.readObjectId(bb);
+    Thread thread = tid.getThread();
+
+    Object monitor = VMVirtualMachine.getCurrentContendedMonitor(thread);
+    ObjectId id = idMan.getObjectId(monitor);
+    id.writeTagged(os);
   }
 
   private void executeStop(ByteBuffer bb, DataOutputStream os)
Index: libjava/classpath/gnu/classpath/jdwp/processor/EventRequestCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/EventRequestCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/EventRequestCommandSet.java	(revision 126334)
@@ -1,6 +1,6 @@
 /* EventRequestCommandSet.java -- class to implement the EventRequest Command
    Set
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
  
 This file is part of GNU Classpath.
 
@@ -40,6 +40,7 @@
 package gnu.classpath.jdwp.processor;
 
 import gnu.classpath.jdwp.JdwpConstants;
+import gnu.classpath.jdwp.VMVirtualMachine;
 import gnu.classpath.jdwp.event.EventManager;
 import gnu.classpath.jdwp.event.EventRequest;
 import gnu.classpath.jdwp.event.filters.ClassExcludeFilter;
@@ -113,6 +114,28 @@
     byte suspendPolicy = bb.get();
     int modifiers = bb.getInt();
 
+    switch (eventKind)
+      {
+	case JdwpConstants.EventKind.FIELD_ACCESS:
+	if (!VMVirtualMachine.canWatchFieldAccess)
+	  {
+	    String msg = "watching field accesses is not supported";
+	    throw new NotImplementedException(msg);
+	  }
+	break;
+
+	case JdwpConstants.EventKind.FIELD_MODIFICATION:
+	if (!VMVirtualMachine.canWatchFieldModification)
+	  {
+	    String msg = "watching field modifications is not supported";
+	    throw new NotImplementedException(msg);
+	  }
+	break;
+
+      default:
+	// okay
+      }
+
     EventRequest eventReq = new EventRequest(eventKind, suspendPolicy);
     IEventFilter filter = null;
     ReferenceTypeId refId;
Index: libjava/classpath/gnu/classpath/jdwp/processor/ArrayReferenceCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/ArrayReferenceCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/ArrayReferenceCommandSet.java	(revision 126334)
@@ -1,6 +1,6 @@
 /* ArrayReferenceCommandSet.java -- class to implement the Array
    Reference Command Set
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -46,7 +46,8 @@
 import gnu.classpath.jdwp.exception.JdwpInternalErrorException;
 import gnu.classpath.jdwp.exception.NotImplementedException;
 import gnu.classpath.jdwp.id.ObjectId;
-import gnu.classpath.jdwp.util.Value;
+import gnu.classpath.jdwp.value.Value;
+import gnu.classpath.jdwp.value.ValueFactory;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -150,11 +151,11 @@
     // tagged
     for (int i = first; i < first + length; i++)
       {
-        Object value = Array.get(array, i);
+        Value val = ValueFactory.createFromObject(Array.get(array, i), clazz);
         if (clazz.isPrimitive())
-          Value.writeUntaggedValue(os, value);
+          val.writeUntagged(os);
         else
-          Value.writeTaggedValue(os, value);
+          val.writeTagged(os);
       }
   }
 
@@ -168,7 +169,7 @@
     Class type = array.getClass().getComponentType();
     for (int i = first; i < first + length; i++)
       {
-        Object value = Value.getUntaggedObj(bb, type);
+        Object value = Value.getUntaggedObject(bb, type);
         Array.set(array, i, value);
       }
   }
Index: libjava/classpath/gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java	(revision 126334)
@@ -1,6 +1,6 @@
 /* ReferenceTypeCommandSet.java -- class to implement the ReferenceType
    Command Set
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -51,7 +51,8 @@
 import gnu.classpath.jdwp.id.ReferenceTypeId;
 import gnu.classpath.jdwp.util.JdwpString;
 import gnu.classpath.jdwp.util.Signature;
-import gnu.classpath.jdwp.util.Value;
+import gnu.classpath.jdwp.value.Value;
+import gnu.classpath.jdwp.value.ValueFactory;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -182,8 +183,7 @@
   private void executeMethods(ByteBuffer bb, DataOutputStream os)
     throws JdwpException, IOException
   {
-    ClassReferenceTypeId refId
-      = (ClassReferenceTypeId) idMan.readReferenceTypeId(bb);
+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);
     Class clazz = refId.getType();
 
     VMMethod[] methods = VMVirtualMachine.getAllClassMethods(clazz);
@@ -220,7 +220,9 @@
               {
                 field.setAccessible(true); // Might be a private field
                 Object value = field.get(null);
-                Value.writeTaggedValue(os, value);
+                Value val = ValueFactory.createFromObject(value, 
+                                                          field.getType());
+                val.writeTagged(os);
               }
             catch (IllegalArgumentException ex)
               {
@@ -303,10 +305,15 @@
   private void executeSourceDebugExtension(ByteBuffer bb, DataOutputStream os)
     throws JdwpException, IOException
   {
-    // This command is optional, determined by VirtualMachines CapabilitiesNew
-    // so we'll leave it till later to implement
-    throw new NotImplementedException(
-      "Command SourceDebugExtension not implemented.");
+    if (!VMVirtualMachine.canGetSourceDebugExtension)
+      {
+	String msg = "source debug extension is not supported";
+	throw new NotImplementedException(msg);
+      }
+
+    ReferenceTypeId id = idMan.readReferenceTypeId(bb);
+    String ext = VMVirtualMachine.getSourceDebugExtension (id.getType());
+    JdwpString.writeString(os, ext);
   }
 
   private void executeSignatureWithGeneric(ByteBuffer bb, DataOutputStream os)
@@ -314,7 +321,7 @@
   {
     // We don't have generics yet
     throw new NotImplementedException(
-      "Command SourceDebugExtension not implemented.");
+      "Command SignatureWithGeneric not implemented.");
   }
 
   private void executeFieldWithGeneric(ByteBuffer bb, DataOutputStream os)
@@ -322,7 +329,7 @@
   {
     // We don't have generics yet
     throw new NotImplementedException(
-      "Command SourceDebugExtension not implemented.");
+      "Command executeFieldWithGeneric not implemented.");
   }
 
   private void executeMethodsWithGeneric(ByteBuffer bb, DataOutputStream os)
@@ -330,6 +337,6 @@
   {
     // We don't have generics yet
     throw new NotImplementedException(
-      "Command SourceDebugExtension not implemented.");
+      "Command executeMethodsWithGeneric not implemented.");
   }
 }
Index: libjava/classpath/gnu/classpath/jdwp/processor/ClassTypeCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/ClassTypeCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/ClassTypeCommandSet.java	(revision 126334)
@@ -1,6 +1,6 @@
 /* ClassTypeCommandSet.java -- class to implement the ClassType
    Command Set
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -49,7 +49,8 @@
 import gnu.classpath.jdwp.id.ObjectId;
 import gnu.classpath.jdwp.id.ReferenceTypeId;
 import gnu.classpath.jdwp.util.MethodResult;
-import gnu.classpath.jdwp.util.Value;
+import gnu.classpath.jdwp.value.Value;
+import gnu.classpath.jdwp.value.ValueFactory;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -128,7 +129,7 @@
       {
         ObjectId fieldId = idMan.readObjectId(bb);
         Field field = (Field) (fieldId.getObject());
-        Object value = Value.getUntaggedObj(bb, field.getType());
+        Object value = Value.getUntaggedObject(bb, field.getType());
         try
           {
             field.setAccessible(true); // Might be a private field
@@ -154,7 +155,8 @@
     Exception exception = mr.getThrownException();
     ObjectId eId = idMan.getObjectId(exception);
 
-    Value.writeTaggedValue(os, value);
+    Value val = ValueFactory.createFromObject(value, mr.getResultType());
+    val.writeTagged(os);
     eId.writeTagged(os);
   }
 
@@ -192,7 +194,7 @@
 
     for (int i = 0; i < args; i++)
       {
-        values[i] = Value.getObj(bb);
+        values[i] = Value.getTaggedObject(bb);
       }
 
     int invokeOpts = bb.getInt();
@@ -207,6 +209,8 @@
         MethodResult mr = VMVirtualMachine.executeMethod(null, thread,
 							 clazz, method,
 							 values, false);
+        mr.setResultType(method.getReturnType());
+        
         if (suspend)
 	  VMVirtualMachine.resumeAllThreads ();
 
Index: libjava/classpath/gnu/classpath/jdwp/processor/VirtualMachineCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/VirtualMachineCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/VirtualMachineCommandSet.java	(revision 126334)
@@ -1,6 +1,6 @@
 /* VirtualMachineCommandSet.java -- class to implement the VirtualMachine
    Command Set
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
  
 This file is part of GNU Classpath.
 
@@ -54,6 +54,7 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.Properties;
 
@@ -179,7 +180,8 @@
     ArrayList allMatchingClasses = new ArrayList();
 
     // This will be an Iterator over all loaded Classes
-    Iterator iter = VMVirtualMachine.getAllLoadedClasses();
+    Collection classes = VMVirtualMachine.getAllLoadedClasses();
+    Iterator iter = classes.iterator ();
 
     while (iter.hasNext())
       {
@@ -203,22 +205,11 @@
   private void executeAllClasses(ByteBuffer bb, DataOutputStream os)
     throws JdwpException, IOException
   {
-    // Disable garbage collection while we're collecting the info on loaded
-    // classes so we some classes don't get collected between the time we get
-    // the count and the time we get the list
-    //VMVirtualMachine.disableGarbageCollection();
+    Collection classes = VMVirtualMachine.getAllLoadedClasses();
+    os.writeInt(classes.size ());
 
-    int classCount = VMVirtualMachine.getAllLoadedClassesCount();
-    os.writeInt(classCount);
-
-    // This will be an Iterator over all loaded Classes
-    Iterator iter = VMVirtualMachine.getAllLoadedClasses();
-    //VMVirtualMachine.enableGarbageCollection();
-    int count = 0;
-
-    // Note it's possible classes were created since out classCount so make
-    // sure we don't write more classes than we told the debugger
-    while (iter.hasNext() && count++ < classCount)
+    Iterator iter = classes.iterator ();
+    while (iter.hasNext())
       {
         Class clazz = (Class) iter.next();
         ReferenceTypeId id = idMan.getReferenceTypeId(clazz);
@@ -340,14 +331,13 @@
   private void executeCapabilities(ByteBuffer bb, DataOutputStream os)
     throws JdwpException, IOException
   {
-    // Store these somewhere?
-    os.writeBoolean(false); // canWatchFieldModification
-    os.writeBoolean(false); // canWatchFieldAccess
-    os.writeBoolean(false); // canGetBytecodes
-    os.writeBoolean(false); // canGetSyntheticAttribute
-    os.writeBoolean(false); // canGetOwnedMonitorInfo
-    os.writeBoolean(false); // canGetCurrentContendedMonitor
-    os.writeBoolean(false); // canGetMonitorInfo
+    os.writeBoolean(VMVirtualMachine.canWatchFieldModification);
+    os.writeBoolean(VMVirtualMachine.canWatchFieldAccess);
+    os.writeBoolean(VMVirtualMachine.canGetBytecodes);
+    os.writeBoolean(VMVirtualMachine.canGetSyntheticAttribute);
+    os.writeBoolean(VMVirtualMachine.canGetOwnedMonitorInfo);
+    os.writeBoolean(VMVirtualMachine.canGetCurrentContendedMonitor);
+    os.writeBoolean(VMVirtualMachine.canGetMonitorInfo);
   }
 
   private void executeClassPaths(ByteBuffer bb, DataOutputStream os)
@@ -401,43 +391,60 @@
   private void executeCapabilitiesNew(ByteBuffer bb, DataOutputStream os)
     throws JdwpException, IOException
   {
-    // Store these somewhere?
     final int CAPABILITIES_NEW_SIZE = 32;
-    os.writeBoolean(false); // canWatchFieldModification
-    os.writeBoolean(false); // canWatchFieldAccess
-    os.writeBoolean(false); // canGetBytecodes
-    os.writeBoolean(false); // canGetSyntheticAttribute
-    os.writeBoolean(false); // canGetOwnedMonitorInfo
-    os.writeBoolean(false); // canGetCurrentContendedMonitor
-    os.writeBoolean(false); // canGetMonitorInfo
-    os.writeBoolean(false); // canRedefineClasses
-    os.writeBoolean(false); // canAddMethod
-    os.writeBoolean(false); // canUnrestrictedlyRedefineClasses
-    os.writeBoolean(false); // canPopFrames
-    os.writeBoolean(false); // canUseInstanceFilters
-    os.writeBoolean(false); // canGetSourceDebugExtension
-    os.writeBoolean(false); // canRequestVMDeathEvent
-    os.writeBoolean(false); // canSetDefaultStratum
+
+    executeCapabilities(bb, os);
+    os.writeBoolean(VMVirtualMachine.canRedefineClasses);
+    os.writeBoolean(VMVirtualMachine.canAddMethod);
+    os.writeBoolean(VMVirtualMachine.canUnrestrictedlyRedefineClasses);
+    os.writeBoolean(VMVirtualMachine.canPopFrames);
+    os.writeBoolean(VMVirtualMachine.canUseInstanceFilters);
+    os.writeBoolean(VMVirtualMachine.canGetSourceDebugExtension);
+    os.writeBoolean(VMVirtualMachine.canRequestVMDeathEvent);
+    os.writeBoolean(VMVirtualMachine.canSetDefaultStratum);
     for (int i = 15; i < CAPABILITIES_NEW_SIZE; i++)
-      // Future capabilities
-      // currently unused
-      os.writeBoolean(false); // Set to false
+      {
+	// Future capabilities (currently unused)
+	os.writeBoolean(false);
+      }
   }
 
   private void executeRedefineClasses(ByteBuffer bb, DataOutputStream os)
     throws JdwpException
   {
-    // Optional command, don't implement
-    throw new NotImplementedException(
-      "Command VirtualMachine.RedefineClasses not implemented");
+    if (!VMVirtualMachine.canRedefineClasses)
+      {
+	String msg = "redefinition of classes is not supported";
+	throw new NotImplementedException(msg);
+      }
+
+    int classes = bb.getInt();
+    Class[] types = new Class[classes];
+    byte[][] bytecodes = new byte[classes][];
+    for (int i = 0; i < classes; ++i)
+      {
+	ReferenceTypeId id = idMan.readReferenceTypeId(bb);
+	int classfile = bb.getInt();
+	byte[] bytecode = new byte[classfile];
+	bb.get(bytecode);
+	types[i] = id.getType();
+	bytecodes[i] = bytecode;
+      }
+
+    VMVirtualMachine.redefineClasses (types, bytecodes);
   }
 
   private void executeSetDefaultStratum(ByteBuffer bb, DataOutputStream os)
     throws JdwpException
   {
-    // Optional command, don't implement
-    throw new NotImplementedException(
-      "Command VirtualMachine.SetDefaultStratum not implemented");
+    if (!VMVirtualMachine.canSetDefaultStratum)
+      {
+	String msg = "setting the default stratum is not supported";
+	throw new NotImplementedException(msg);
+      }
+
+    String stratum = JdwpString.readString(bb);
+    VMVirtualMachine.setDefaultStratum(stratum);
   }
 
   private void executeAllClassesWithGeneric(ByteBuffer bb, DataOutputStream os)
Index: libjava/classpath/gnu/classpath/jdwp/processor/StackFrameCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/StackFrameCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/StackFrameCommandSet.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* StackFrameCommandSet.java -- class to implement the StackFrame Command Set
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
  
 This file is part of GNU Classpath.
 
@@ -45,8 +45,10 @@
 import gnu.classpath.jdwp.exception.JdwpException;
 import gnu.classpath.jdwp.exception.JdwpInternalErrorException;
 import gnu.classpath.jdwp.exception.NotImplementedException;
-import gnu.classpath.jdwp.id.ObjectId;
-import gnu.classpath.jdwp.util.Value;
+import gnu.classpath.jdwp.id.ThreadId;
+import gnu.classpath.jdwp.value.ObjectValue;
+import gnu.classpath.jdwp.value.Value;
+import gnu.classpath.jdwp.value.ValueFactory;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -98,8 +100,8 @@
   private void executeGetValues(ByteBuffer bb, DataOutputStream os)
       throws JdwpException, IOException
   {
-    ObjectId tId = idMan.readObjectId(bb);
-    Thread thread = (Thread) tId.getObject();
+    ThreadId tId = (ThreadId) idMan.readObjectId(bb);
+    Thread thread = tId.getThread();
 
     // Although Frames look like other ids they are not. First they are not
     // ObjectIds since they don't exist in the users code. Storing them as an
@@ -107,31 +109,33 @@
     // has a reference to them. Furthermore they are not ReferenceTypeIds since
     // these are held permanently and we want these to be held only as long as
     // the Thread is suspended.
-    VMFrame frame = VMVirtualMachine.getFrame(thread, bb);
+    long frameID = bb.getLong();
+    VMFrame frame = VMVirtualMachine.getFrame(thread, frameID);
     int slots = bb.getInt();
     os.writeInt(slots); // Looks pointless but this is the protocol
     for (int i = 0; i < slots; i++)
       {
         int slot = bb.getInt();
         byte sig = bb.get();
-        Object val = frame.getValue(slot);
-        Value.writeTaggedValue(os, val);
+        Value val = frame.getValue(slot, sig);
+        val.writeTagged(os);
       }
   }
 
   private void executeSetValues(ByteBuffer bb, DataOutputStream os)
       throws JdwpException, IOException
   {
-    ObjectId tId = idMan.readObjectId(bb);
-    Thread thread = (Thread) tId.getObject();
+    ThreadId tId = (ThreadId) idMan.readObjectId(bb);
+    Thread thread = tId.getThread();
 
-    VMFrame frame = VMVirtualMachine.getFrame(thread, bb);
+    long frameID = bb.getLong();
+    VMFrame frame = VMVirtualMachine.getFrame(thread, frameID);
 
     int slots = bb.getInt();
     for (int i = 0; i < slots; i++)
       {
         int slot = bb.getInt();
-        Object value = Value.getObj(bb);
+        Value value = ValueFactory.createFromTagged(bb);
         frame.setValue(slot, value);
       }
   }
@@ -139,20 +143,28 @@
   private void executeThisObject(ByteBuffer bb, DataOutputStream os)
       throws JdwpException, IOException
   {
-    ObjectId tId = idMan.readObjectId(bb);
-    Thread thread = (Thread) tId.getObject();
+    ThreadId tId = (ThreadId) idMan.readObjectId(bb);
+    Thread thread = tId.getThread();
 
-    VMFrame frame = VMVirtualMachine.getFrame(thread, bb);
+    long frameID = bb.getLong();
+    VMFrame frame = VMVirtualMachine.getFrame(thread, frameID);
 
-    Object thisObject = frame.getObject();
-    Value.writeTaggedValue(os, thisObject);
+    ObjectValue objVal = new ObjectValue(frame.getObject());
+    objVal.writeTagged(os);
   }
 
   private void executePopFrames(ByteBuffer bb, DataOutputStream os)
-      throws JdwpException
+    throws JdwpException, IOException
   {
-    // This command is optional, determined by VirtualMachines CapabilitiesNew
-    // so we'll leave it till later to implement
-    throw new NotImplementedException("Command PopFrames not implemented.");
+    if (!VMVirtualMachine.canPopFrames)
+      {
+	String msg = "popping frames is unsupported";
+	throw new NotImplementedException(msg);
+      }
+
+    ThreadId tid = (ThreadId) idMan.readObjectId(bb);
+    Thread thread = tid.getThread();
+    long fid = bb.getLong();
+    VMVirtualMachine.popFrames(thread, fid);
   }
 }
Index: libjava/classpath/gnu/classpath/jdwp/processor/MethodCommandSet.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/processor/MethodCommandSet.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/processor/MethodCommandSet.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* MethodCommandSet.java -- class to implement the Method Command Set
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -40,10 +40,11 @@
 
 import gnu.classpath.jdwp.JdwpConstants;
 import gnu.classpath.jdwp.VMMethod;
+import gnu.classpath.jdwp.VMVirtualMachine;
 import gnu.classpath.jdwp.exception.JdwpException;
 import gnu.classpath.jdwp.exception.JdwpInternalErrorException;
 import gnu.classpath.jdwp.exception.NotImplementedException;
-import gnu.classpath.jdwp.id.ClassReferenceTypeId;
+import gnu.classpath.jdwp.id.ReferenceTypeId;
 import gnu.classpath.jdwp.util.LineTable;
 import gnu.classpath.jdwp.util.VariableTable;
 
@@ -99,8 +100,7 @@
   private void executeLineTable(ByteBuffer bb, DataOutputStream os)
       throws JdwpException, IOException
   {
-    ClassReferenceTypeId refId
-      = (ClassReferenceTypeId) idMan.readReferenceTypeId(bb);
+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);
     Class clazz = refId.getType();
 
     VMMethod method = VMMethod.readId(clazz, bb);
@@ -111,8 +111,7 @@
   private void executeVariableTable(ByteBuffer bb, DataOutputStream os)
       throws JdwpException, IOException
   {
-   ClassReferenceTypeId refId
-     = (ClassReferenceTypeId) idMan.readReferenceTypeId(bb);
+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);
     Class clazz = refId.getType();
 
     VMMethod method = VMMethod.readId(clazz, bb);
@@ -121,11 +120,20 @@
   }
 
   private void executeByteCodes(ByteBuffer bb, DataOutputStream os)
-      throws JdwpException
+    throws JdwpException, IOException
   {
-    // This command is optional, determined by VirtualMachines CapabilitiesNew
-    // so we'll leave it till later to implement
-    throw new NotImplementedException("Command ByteCodes not implemented.");
+    if (!VMVirtualMachine.canGetBytecodes)
+      {
+	String msg = "getting bytecodes is unsupported";
+	throw new NotImplementedException(msg);
+      }
+
+    ReferenceTypeId id = idMan.readReferenceTypeId(bb);
+    Class klass = id.getType();
+    VMMethod method = VMMethod.readId(klass, bb);
+    byte[] bytecode = VMVirtualMachine.getBytecodes(method);
+    os.writeInt(bytecode.length);
+    os.write(bytecode);
   }
 
   private void executeIsObsolete(ByteBuffer bb, DataOutputStream os)
@@ -143,7 +151,7 @@
   {
     // We don't have generics yet
     throw new NotImplementedException(
-      "Command SourceDebugExtension not implemented.");
+      "Command VariableTableWithGeneric not implemented.");
   }
 
 }
Index: libjava/classpath/gnu/classpath/jdwp/event/Event.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/event/Event.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/event/Event.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* Event.java -- a base class for all event types
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -135,25 +135,30 @@
   public abstract Object getParameter (int type);
 
   /**
-   * Converts this event into to a JDWP packet
+   * Converts the events into to a single JDWP Event.COMPOSITE packet
    *
    * @param dos     the stream to which to write data
-   * @param request the request the wanted this notification
+   * @param events  the events to package into the packet
+   * @param requests the corresponding event requests
+   * @param suspendPolicy the suspend policy enforced by the VM
    * @returns a <code>JdwpPacket</code> of the events
    */
-  public JdwpPacket toPacket (DataOutputStream dos, EventRequest request)
+  public static JdwpPacket toPacket (DataOutputStream dos,
+				     Event[] events,
+				     EventRequest[] requests,
+				     byte suspendPolicy)
   {
     JdwpPacket pkt;
     try
       {
-	dos.writeByte (request.getSuspendPolicy ());
-	dos.writeInt (1);
-	dos.writeByte (_eventKind);
-	dos.writeInt (request.getId ());
-	_writeData (dos);
+	dos.writeByte (suspendPolicy);
+	dos.writeInt (events.length);
+	for (int i = 0; i < events.length; ++i)
+	  _toData (dos, events[i], requests[i]);
 
-	pkt = new JdwpCommandPacket (JdwpConstants.CommandSet.Event.CS_VALUE,
-				     JdwpConstants.CommandSet.Event.COMPOSITE);
+	pkt
+	  = new JdwpCommandPacket (JdwpConstants.CommandSet.Event.CS_VALUE,
+				   JdwpConstants.CommandSet.Event.COMPOSITE);
       }
     catch (IOException ioe)
       {
@@ -162,4 +167,14 @@
 
     return pkt;
   }
+
+  // Helper function for toPacket
+  private static void _toData (DataOutputStream dos, Event event,
+			       EventRequest request)
+    throws IOException
+  {
+    dos.writeByte (event._eventKind);
+    dos.writeInt (request.getId ());
+    event._writeData (dos);
+  }
 }
Index: libjava/classpath/gnu/classpath/jdwp/event/ThreadStartEvent.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/event/ThreadStartEvent.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/event/ThreadStartEvent.java	(revision 126334)
@@ -1,6 +1,6 @@
 /* ThreadStartEvent.java -- An event specifying that a new thread
    has started in the virtual machine
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -75,7 +75,7 @@
    * @param thread  the thread ID in which event occurred
    */
   public ThreadStartEvent (Thread thread) {
-    super (JdwpConstants.EventKind.THREAD_END);
+    super (JdwpConstants.EventKind.THREAD_START);
     _thread = thread;
   }
 
Index: libjava/classpath/gnu/classpath/jdwp/event/filters/LocationOnlyFilter.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/event/filters/LocationOnlyFilter.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/event/filters/LocationOnlyFilter.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* LocationOnlyFilter.java -- filter on location
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -49,13 +49,6 @@
  * May be used with breakpoint, field access, field modification, step,
  * and exception event kinds.
  *
- * This "filter" is not really a filter. It is simply a way to communicate
- * location information for supported events in a generic way to ease 
- * the burden of special casing several things in
- * EventReqeustCommandSet.executeSet.
- * 
- * Consequently, this "filter" always matches any event.
- * 
  * @author Keith Seitz  (keiths@redhat.com)
  */
 public class LocationOnlyFilter
@@ -90,9 +83,12 @@
    *
    * @param event  the <code>Event</code> to scrutinize
    */
-  public boolean matches (Event event)
+  public boolean matches(Event event)
   {
-    // This filter always matches. See comments in class javadoc.
-    return true;
+    Location loc = (Location) event.getParameter(Event.EVENT_LOCATION);
+    if (loc != null)
+      return (getLocation().equals(loc));
+
+    return false;
   }
 }
Index: libjava/classpath/gnu/classpath/jdwp/event/filters/StepFilter.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/event/filters/StepFilter.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/event/filters/StepFilter.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* StepFilter.java -- a step filter
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -39,6 +39,7 @@
 
 package gnu.classpath.jdwp.event.filters;
 
+import gnu.classpath.jdwp.JdwpConstants;
 import gnu.classpath.jdwp.event.Event;
 import gnu.classpath.jdwp.exception.InvalidThreadException;
 import gnu.classpath.jdwp.id.ThreadId;
@@ -48,6 +49,12 @@
  * satisfy depth and size constraints. This modifier can only be used with
  * step event kinds."
  *
+ * This "filter" is not really a filter. It is simply a way to communicate
+ * stepping information in a convenient way between the JDWP backend and
+ * the virtual machine.
+ * 
+ * Consequently, this "filter" always matches.
+ * 
  * @author Keith Seitz  (keiths@redhat.com)
  */
 public class StepFilter
@@ -115,7 +122,6 @@
    */
   public boolean matches (Event event)
   {
-    // FIXME
-    throw new RuntimeException ("StepFilter.matches not implemented");
+    return true;
   }
 }
Index: libjava/classpath/gnu/classpath/jdwp/event/EventManager.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/event/EventManager.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/event/EventManager.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* EventManager.java -- event management and notification infrastructure
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -39,10 +39,12 @@
 
 package gnu.classpath.jdwp.event;
 
+import gnu.classpath.jdwp.Jdwp;
 import gnu.classpath.jdwp.VMVirtualMachine;
 import gnu.classpath.jdwp.exception.InvalidEventTypeException;
 import gnu.classpath.jdwp.exception.JdwpException;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Hashtable;
 import java.util.Iterator;
@@ -130,9 +132,10 @@
     // only two: VM_INIT, VM_DEATH
     try
       {
+	byte sp = (Jdwp.suspendOnStartup()
+		   ? EventRequest.SUSPEND_THREAD : EventRequest.SUSPEND_NONE);
 	requestEvent (new EventRequest (0,
-					EventRequest.EVENT_VM_INIT,
-					EventRequest.SUSPEND_NONE));
+					EventRequest.EVENT_VM_INIT, sp));
 	requestEvent (new EventRequest (0,
 					EventRequest.EVENT_VM_DEATH,
 					EventRequest.SUSPEND_NONE));
@@ -144,39 +147,39 @@
   }
 
   /**
-   * Returns a request for the given event. This method will only
+   * Returns all requests for the given event. This method will only
    * be used if the <code>EventManager</code> is handling event filtering.
    *
    * @param  event  the event
-   * @return request that was interested in this event
+   * @return requests that are interested in this event
    *         or <code>null</code> if none (and event should not be sent)
    * @throws IllegalArgumentException for invalid event kind
    */
-  public EventRequest getEventRequest (Event event)
+  public EventRequest[] getEventRequests(Event event)
   {
-    EventRequest interestedRequest = null;
+    ArrayList interestedEvents = new ArrayList();
     Hashtable requests;
-    Byte kind = new Byte (event.getEventKind ());
-    requests = (Hashtable) _requests.get (kind);
+    Byte kind = new Byte(event.getEventKind());
+    requests = (Hashtable) _requests.get(kind);
     if (requests == null)
       {
 	// Did not get a valid event type
-	throw new IllegalArgumentException ("invalid event kind: " + kind);
+	throw new IllegalArgumentException("invalid event kind: " + kind);
       }
-    boolean match = false;
 
     // Loop through the requests. Must look at ALL requests in order
     // to evaluate all filters (think count filter).
-    // TODO: What if multiple matches? Spec isn't so clear on this.
-    Iterator rIter = requests.values().iterator ();
-    while (rIter.hasNext ())
+    Iterator rIter = requests.values().iterator();
+    while (rIter.hasNext())
       {
-	EventRequest request = (EventRequest) rIter.next ();
-	if (request.matches (event))
-	  interestedRequest = request;
+	EventRequest request = (EventRequest) rIter.next();
+	if (request.matches(event))
+	  interestedEvents.add(request);
       }
 
-    return interestedRequest;
+    EventRequest[] r = new EventRequest[interestedEvents.size()];
+    interestedEvents.toArray(r);
+    return r;
   }
 
   /**
Index: libjava/classpath/gnu/classpath/jdwp/Jdwp.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/Jdwp.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/Jdwp.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* Jdwp.java -- Virtual machine to JDWP back-end programming interface
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -51,6 +51,7 @@
 
 import java.io.IOException;
 import java.security.AccessController;
+import java.util.ArrayList;
 import java.util.HashMap;
 
 /**
@@ -207,23 +208,21 @@
    * The event is filtered through the event manager before being
    * sent.
    *
-   * FIXME: Probably need logic to send multiple events
    * @param event the event to report
    */
-  public static void notify (Event event)
+  public static void notify(Event event)
   {
-    Jdwp jdwp = getDefault ();
+    Jdwp jdwp = getDefault();
     if (jdwp != null)
       {
-	EventManager em = EventManager.getDefault ();
-	EventRequest request = em.getEventRequest (event);
-	if (request != null)
+	EventManager em = EventManager.getDefault();
+	EventRequest[] requests = em.getEventRequests(event);
+	for (int i = 0; i < requests.length; ++i)
 	  {
 	    try
 	      {
-		System.out.println ("Jdwp.notify: sending event " + event);
-		sendEvent (request, event);
-		jdwp._enforceSuspendPolicy (request.getSuspendPolicy ());
+		sendEvent(requests[i], event);
+		jdwp._enforceSuspendPolicy(requests[i].getSuspendPolicy());
 	      }
 	    catch (Exception e)
 	      {
@@ -236,6 +235,62 @@
   }
   
   /**
+   * Notify the debugger of "co-located" events. This method should
+   * not be called if debugging is not active (but it would not
+   * cause any harm). Places where event notifications occur
+   * should check isDebugging before doing anything.
+   *
+   * The events are filtered through the event manager before being
+   * sent.
+   *
+   * @param events the events to report
+   */
+  public static void notify(Event[] events)
+  {
+    Jdwp jdwp = getDefault();
+    
+    if (jdwp != null)
+      {
+	byte suspendPolicy = JdwpConstants.SuspendPolicy.NONE;
+	EventManager em = EventManager.getDefault();
+	ArrayList allEvents = new ArrayList ();
+	ArrayList allRequests = new ArrayList ();
+	for (int i = 0; i < events.length; ++i)
+	  {
+	    EventRequest[] r = em.getEventRequests(events[i]);
+	    for (int j = 0; j < r.length; ++j)
+	      {
+		/* This is hacky, but it's not clear whether this
+		   can really happen, and if it does, what should
+		   occur. */
+		allEvents.add (events[i]);
+		allRequests.add (r[j]);
+
+		// Perhaps this is overkill?
+		if (r[j].getSuspendPolicy() > suspendPolicy)
+		  suspendPolicy = r[j].getSuspendPolicy();
+	      }
+	  }
+
+	try
+	  {
+	    Event[] e = new Event[allEvents.size()];
+	    allEvents.toArray(e);
+	    EventRequest[] r = new EventRequest[allRequests.size()];
+	    allRequests.toArray(r);
+	    sendEvents(r, e, suspendPolicy);
+	    jdwp._enforceSuspendPolicy(suspendPolicy);
+	  }
+	catch (Exception e)
+	  {
+	    /* Really not much we can do. For now, just print out
+	       a warning to the user. */
+	    System.out.println ("Jdwp.notify: caught exception: " + e);
+	  }
+      }
+  }
+
+  /**
    * Sends the event to the debugger.
    *
    * This method bypasses the event manager's filtering.
@@ -247,13 +302,30 @@
   public static void sendEvent (EventRequest request, Event event)
       throws IOException
   {
-    Jdwp jdwp = getDefault ();
+    sendEvents (new EventRequest[] { request }, new Event[] { event },
+		request.getSuspendPolicy());
+  }
+
+  /**
+   * Sends the events to the debugger.
+   *
+   * This method bypasses the event manager's filtering.
+   *
+   * @param  requests  list of debugger requests for the events
+   * @param  events    the events to send
+   * @param  suspendPolicy the suspendPolicy enforced by the VM
+   * @throws IOException if a communications failure occurs
+   */
+  public static void sendEvents (EventRequest[] requests, Event[] events,
+				 byte suspendPolicy)
+    throws IOException
+  {
+    Jdwp jdwp = getDefault();
     if (jdwp != null)
       {
-	// !! May need to implement send queue?
 	synchronized (jdwp._connection)
 	  {
-	    jdwp._connection.sendEvent (request, event);
+	    jdwp._connection.sendEvents (requests, events, suspendPolicy);
 	  }
       }
   }
Index: libjava/classpath/gnu/classpath/jdwp/id/NullObjectId.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/id/NullObjectId.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/id/NullObjectId.java	(revision 126334)
@@ -0,0 +1,79 @@
+/* NullObjectId.java -- special objectId for null values
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.id;
+
+import gnu.classpath.jdwp.exception.InvalidObjectException;
+import gnu.classpath.jdwp.util.NullObject;
+
+import java.lang.ref.SoftReference;
+
+/**
+ * This is a special case of an ObjectId.  When a varaible slot contains
+ * null as its value, this is a valid value despite the fact that it does
+ * not reference an object.  To represent this, this will always be the id
+ * of the NullObject (0).
+ *
+ * @author Kyle Galloway  <kgallowa@redhat.com>
+ */
+public class NullObjectId
+  extends ObjectId
+{
+  /**
+   * The object class that this id represents
+   */
+  public static final Class typeClass = NullObject.class;
+  
+  /**
+   * Constructs a new <code>NullObjectId</code>
+   */
+  public NullObjectId()
+  {
+    super();
+    setId((long) 0);
+    _reference = new SoftReference<NullObject>(new NullObject());
+    try
+      {
+        disableCollection();
+      }
+    catch(InvalidObjectException ex)
+      {
+        //This will not happen
+      }
+  }
+
+}
Index: libjava/classpath/gnu/classpath/jdwp/transport/JdwpConnection.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/transport/JdwpConnection.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/transport/JdwpConnection.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* JdwpConnection.java -- A JDWP-speaking connection
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -267,13 +267,17 @@
   }
 
   /**
-   * Send an event notification to the debugger
+   * Send an event notification to the debugger. Note that this
+   * method will only send out one notification: all the events
+   * are passed in a single Event.COMPOSITE packet.
    *
-   * @param request  the debugger request that wanted this event
-   * @param event    the event
+   * @param requests  debugger requests for events
+   * @param events    the events to send
+   * @param suspendPolicy  the suspend policy enforced by the VM
    * @throws IOException
    */
-  public void sendEvent (EventRequest request, Event event)
+  public void sendEvents(EventRequest[] requests, Event[] events,
+			 byte suspendPolicy)
     throws IOException
   {
     JdwpPacket pkt;
@@ -281,7 +285,7 @@
     synchronized (_bytes)
       {
 	_bytes.reset ();
-	pkt = event.toPacket (_doStream, request);
+	pkt = Event.toPacket (_doStream, events, requests, suspendPolicy);
 	pkt.setData (_bytes.toByteArray ());
       }
 
Index: libjava/classpath/gnu/classpath/jdwp/transport/SocketTransport.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/transport/SocketTransport.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/transport/SocketTransport.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* SocketTransport.java -- a socket transport
-   Copyright (C) 2005 Free Software Foundation
+   Copyright (C) 2005, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -89,27 +89,36 @@
    * @param  properties  the properties of the JDWP session
    * @throws TransportException for any configury errors
    */
-  public void configure (HashMap properties)
+  public void configure(HashMap properties)
     throws TransportException
   {
-    // Get address [form: "hostname:port"]
-    String p = (String) properties.get (_PROPERTY_ADDRESS);
+    // Get server [form: "y" or "n"]
+    String p = (String) properties.get(_PROPERTY_SERVER);
     if (p != null)
       {
-	String[] s = p.split (":");
-	if (s.length == 2)
-	  {
-	    _host = s[0];
-	    _port = Integer.parseInt (s[1]);
-	  }
+	if (p.toLowerCase().equals("y"))
+	  _server = true;
       }
 
-    // Get server [form: "y" or "n"]
-    p = (String) properties.get (_PROPERTY_SERVER);
+    // Get address [form: "hostname:port"]
+    p = (String) properties.get(_PROPERTY_ADDRESS);
     if (p != null)
       {
-	if (p.toLowerCase().equals ("y"))
-	  _server = true;
+	String[] s = p.split(":");
+	if (s.length == 1)
+	  {
+	    // Port number only. Assume "localhost"
+	    _port = Integer.parseInt(s[0]);
+	    _host = "localhost";
+	  }
+	else
+	  {
+	    if (s[0].length() == 0)
+	      _host = "localhost";
+	    else
+	      _host = s[0];
+	    _port = Integer.parseInt(s[1]);
+	  }
       }
   }
 
Index: libjava/classpath/gnu/classpath/jdwp/value/ByteValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/ByteValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/ByteValue.java	(revision 126334)
@@ -0,0 +1,99 @@
+/* ByteValue.java -- JDWP wrapper class for a byte value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an byte value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class ByteValue
+    extends Value
+{
+  // The byte wrapped by this class
+  byte _value;
+
+  /**
+   * Create a new ByteValue from an byte
+   * 
+   * @param value the byte to wrap
+   */
+  public ByteValue(byte value)
+  {
+    super(JdwpConstants.Tag.BYTE);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public byte getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Byte(_value);
+  }
+
+  /**
+   * Write the wrapped byte to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeByte(_value);
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/value/FloatValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/FloatValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/FloatValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* FloatValue.java -- JDWP wrapper class for a float value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+afloat with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an float value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class FloatValue
+    extends Value
+{
+  // The float wrapped by this class
+  float _value;
+
+  /**
+   * Create a new FloatValue from an float
+   * 
+   * @param value the float to wrap
+   */
+  public FloatValue(float value)
+  {
+    super(JdwpConstants.Tag.FLOAT);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public float getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Float(_value);
+  }
+
+  /**
+   * Write the wrapped float to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeFloat(_value);
+  }
+}
+
Index: libjava/classpath/gnu/classpath/jdwp/value/ObjectValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/ObjectValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/ObjectValue.java	(revision 126334)
@@ -0,0 +1,92 @@
+/* ObjectValue.java -- JDWP wrapper class for an Object value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+import gnu.classpath.jdwp.VMIdManager;
+import gnu.classpath.jdwp.id.ObjectId;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an Object value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class ObjectValue
+    extends Value
+{
+  // The Object wrapped by this class
+  Object _value;
+
+  /**
+   * Create a new ObjectValue from an Object
+   * 
+   * @param value the Object to wrap
+   */
+  public ObjectValue(Object value)
+  {
+    super(JdwpConstants.Tag.OBJECT);
+    _value = value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return _value;
+  }
+
+  /**
+   * Write the wrapped object to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    ObjectId oid = VMIdManager.getDefault().getObjectId(_value);
+    oid.write(os);
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/value/StringValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/StringValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/StringValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* StringValue.java -- JDWP wrapper class for an String value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+import gnu.classpath.jdwp.util.JdwpString;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an String value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class StringValue
+    extends Value
+{
+  // The String wrapped by this class
+  String _value;
+
+  /**
+   * Create a new StringValue from an String
+   * 
+   * @param value the String to wrap
+   */
+  public StringValue(String value)
+  {
+    super(JdwpConstants.Tag.OBJECT);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public String getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return _value;
+  }
+
+  /**
+   * Write the wrapped object to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    JdwpString.writeString(os, _value);
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/value/ValueFactory.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/ValueFactory.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/ValueFactory.java	(revision 126334)
@@ -0,0 +1,247 @@
+/* ValueFactory.java -- factory to create JDWP Values
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+import gnu.classpath.jdwp.VMIdManager;
+import gnu.classpath.jdwp.exception.InvalidClassException;
+import gnu.classpath.jdwp.exception.InvalidObjectException;
+import gnu.classpath.jdwp.exception.InvalidTagException;
+import gnu.classpath.jdwp.exception.JdwpInternalErrorException;
+import gnu.classpath.jdwp.id.ObjectId;
+import gnu.classpath.jdwp.util.JdwpString;
+
+import java.nio.ByteBuffer;
+
+/**
+ * A factory to create JDWP Values.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public class ValueFactory
+{
+  /**
+   * Creates a new Value of appropriate type for the value in the ByteBuffer
+   * by reading the tag byte from the front of the buffer.
+   * 
+   * @param bb contains the Object
+   * @return A new Value of appropriate type
+   * @throws JdwpInternalErrorException
+   * @throws InvalidObjectException
+   */
+  public static Value createFromTagged(ByteBuffer bb)
+    throws JdwpInternalErrorException, InvalidObjectException, InvalidTagException
+  {
+    return create(bb, bb.get());
+  }
+  
+  /**
+   * Creates a new Value of appropriate type for the value in the ByteBuffer
+   * by checking the type of the Class passed in.
+   * 
+   * @param bb contains the Object
+   * @param type a Class representing the type of the value in the ByteBuffer
+   * @return A new Value of appropriate type
+   * @throws JdwpInternalErrorException
+   * @throws InvalidObjectException
+   */
+  public static Value createFromUntagged(ByteBuffer bb, Class type)
+  throws JdwpInternalErrorException, InvalidObjectException, InvalidClassException
+  {
+    byte tag = getTagForClass(type);
+    
+    try
+      {
+        return create(bb, tag);
+      }
+    catch (InvalidTagException ite)
+      {
+        throw new InvalidClassException(ite);
+      }
+  }
+  
+  /**
+   * Creates a new Value of appropriate type for the value in the ByteBuffer.
+   * 
+   * @param bb contains the Object
+   * @param tag a byte representing the type of the object
+   * @return A new Value of appropriate type
+   * @throws JdwpInternalErrorException
+   * @throws InvalidObjectException
+   */
+  private static Value create(ByteBuffer bb, byte tag)
+    throws JdwpInternalErrorException, InvalidObjectException, InvalidTagException
+  {
+    Value val = null;
+    switch(tag)
+    {
+      case JdwpConstants.Tag.BYTE:
+        val = new ByteValue(bb.get());
+        break;
+      case JdwpConstants.Tag.BOOLEAN:
+        val = new BooleanValue((bb.get() != 0));
+        break;
+      case JdwpConstants.Tag.CHAR:
+        val = new CharValue(bb.getChar());
+        break;
+      case JdwpConstants.Tag.SHORT:
+        val = new ShortValue(bb.getShort());
+        break;
+      case JdwpConstants.Tag.INT:
+        val = new IntValue(bb.getInt());
+        break;
+      case JdwpConstants.Tag.FLOAT:
+        val = new FloatValue(bb.getFloat());
+        break;
+      case JdwpConstants.Tag.LONG:
+        val = new LongValue(bb.getLong());
+        break;
+      case JdwpConstants.Tag.DOUBLE:
+        val = new DoubleValue(bb.getDouble());
+        break;
+      case JdwpConstants.Tag.VOID:
+        val = new VoidValue();
+        break;
+      case JdwpConstants.Tag.ARRAY:
+      case JdwpConstants.Tag.THREAD:
+      case JdwpConstants.Tag.OBJECT:
+      case JdwpConstants.Tag.THREAD_GROUP:
+      case JdwpConstants.Tag.CLASS_LOADER:
+      case JdwpConstants.Tag.CLASS_OBJECT:
+        ObjectId oid = VMIdManager.getDefault().readObjectId(bb);
+        val = new ObjectValue(oid.getObject());
+        break;
+      case JdwpConstants.Tag.STRING:
+        val = new StringValue(JdwpString.readString(bb));
+        break;
+      default:
+        throw new InvalidTagException(tag);
+    }
+    
+    return val;
+  }
+  
+  /**
+   * Creates a tag for the type of the class.
+   * 
+   * @param klass the type to get a tag for
+   * @return a byte tag representing the class
+   * @throws JdwpInternalErrorException
+   * @throws InvalidObjectException
+   */
+  private static byte getTagForClass(Class klass)
+    throws JdwpInternalErrorException
+  {
+    byte tag;
+    
+    if (klass.isPrimitive())
+      {
+        if (klass == byte.class)
+          tag = JdwpConstants.Tag.BYTE;
+        else if (klass == boolean.class)
+          tag = JdwpConstants.Tag.BOOLEAN;
+        else if (klass == char.class)
+          tag = JdwpConstants.Tag.CHAR;
+        else if (klass == short.class)
+          tag = JdwpConstants.Tag.SHORT;
+        else if (klass == int.class)
+          tag = JdwpConstants.Tag.INT;
+        else if (klass == float.class)
+          tag = JdwpConstants.Tag.FLOAT;
+        else if (klass == long.class)
+          tag = JdwpConstants.Tag.LONG;
+        else if (klass == double.class)
+          tag = JdwpConstants.Tag.DOUBLE;
+        else if (klass == void.class)
+          tag = JdwpConstants.Tag.VOID;
+        else
+          throw new JdwpInternalErrorException("Invalid primitive class");
+      }
+    else
+      {
+        tag = JdwpConstants.Tag.OBJECT;
+      }
+    
+    return tag;
+  }
+  
+  /**
+   * Create a value type for an Object of type determined by a Class.  This is
+   * a special case where a value needs to be created, but the value to create
+   * it for is already in an object, not in a buffer.
+   * 
+   * @param value the Object to convert to a Value
+   * @param type the Class type of the object
+   * @return a new Value representing this object
+   */
+  public static Value createFromObject(Object value, Class type)
+  {
+    Value val = null;
+    
+    if (type.isPrimitive())
+      {
+        if (type == byte.class)
+          val = new ByteValue(((Byte) value).byteValue());
+        else if (type == boolean.class)
+          val = new BooleanValue(((Boolean) value).booleanValue());
+        else if (type == char.class)
+          val = new CharValue(((Character) value).charValue());
+        else if (type == short.class)
+          val = new ShortValue(((Short) value).shortValue());
+        else if (type == int.class)
+          val = new IntValue(((Integer) value).intValue());
+        else if (type == float.class)
+          val = new FloatValue(((Float) value).floatValue());
+        else if (type == long.class)
+          val = new LongValue(((Long) value).longValue());
+        else if (type == double.class)
+          val = new DoubleValue(((Double) value).doubleValue());
+        else if (type == void.class)
+          val = new VoidValue();
+      }
+    else
+      {
+        if (type.isAssignableFrom(String.class))
+          val = new StringValue ((String) value);
+        else
+          val = new ObjectValue(value);
+      }
+    
+    return val;
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/value/DoubleValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/DoubleValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/DoubleValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* DoubleValue.java -- JDWP wrapper class for a double value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an double value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class DoubleValue
+    extends Value
+{
+  // The double wrapped by this class
+  double _value;
+
+  /**
+   * Create a new DoubleValue from an double
+   * 
+   * @param value the double to wrap
+   */
+  public DoubleValue(double value)
+  {
+    super(JdwpConstants.Tag.DOUBLE);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public double getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Double(_value);
+  }
+
+  /**
+   * Write the wrapped double to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeDouble(_value);
+  }
+}
+
Index: libjava/classpath/gnu/classpath/jdwp/value/IntValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/IntValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/IntValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* IntValue.java -- JDWP wrapper class for an int value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an int value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class IntValue
+    extends Value
+{
+  // The int wrapped by this class
+  int _value;
+
+  /**
+   * Create a new IntValue from an int
+   * 
+   * @param value the int to wrap
+   */
+  public IntValue(int value)
+  {
+    super(JdwpConstants.Tag.INT);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public int getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Integer(_value);
+  }
+
+  /**
+   * Write the wrapped int to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeInt(_value);
+  }
+}
+
Index: libjava/classpath/gnu/classpath/jdwp/value/CharValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/CharValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/CharValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* CharValue.java -- JDWP wrapper class for a char value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an char value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class CharValue
+    extends Value
+{
+  // The char wrapped by this class
+  char _value;
+
+  /**
+   * Create a new CharValue from an char
+   * 
+   * @param value the char to wrap
+   */
+  public CharValue(char value)
+  {
+    super(JdwpConstants.Tag.CHAR);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public char getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Character(_value);
+  }
+
+  /**
+   * Write the wrapped char to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeChar(_value);
+  }
+}
+
Index: libjava/classpath/gnu/classpath/jdwp/value/ArrayValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/ArrayValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/ArrayValue.java	(revision 126334)
@@ -0,0 +1,92 @@
+/* ArrayValue.java -- JDWP wrapper class for an Object value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+import gnu.classpath.jdwp.VMIdManager;
+import gnu.classpath.jdwp.id.ObjectId;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an Array value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public class ArrayValue
+    extends Value
+{
+  // The Array wrapped by this class represented as a Object
+  Object _value;
+
+  /**
+   * Create a new ArrayValue from an Object
+   * 
+   * @param value the Object to wrap
+   */
+  public ArrayValue(Object value)
+  {
+    super(JdwpConstants.Tag.ARRAY);
+    _value = value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return _value;
+  }
+
+  /**
+   * Write the wrapped object to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    ObjectId oid = VMIdManager.getDefault().getObjectId(_value);
+    oid.write(os);
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/value/BooleanValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/BooleanValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/BooleanValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* BooleanValue.java -- JDWP wrapper class for a boolean value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an boolean value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class BooleanValue
+    extends Value
+{
+  // The boolean wrapped by this class
+  boolean _value;
+
+  /**
+   * Create a new BooleanValue from an boolean
+   * 
+   * @param value the boolean to wrap
+   */
+  public BooleanValue(boolean value)
+  {
+    super(JdwpConstants.Tag.BOOLEAN);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public boolean getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Boolean(_value);
+  }
+
+  /**
+   * Write the wrapped boolean to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeBoolean(_value);
+  }
+}
+
Index: libjava/classpath/gnu/classpath/jdwp/value/LongValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/LongValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/LongValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* LongValue.java -- JDWP wrapper class for a long value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an long value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class LongValue
+    extends Value
+{
+  // The long wrapped by this class
+  long _value;
+
+  /**
+   * Create a new LongValue from an long
+   * 
+   * @param value the long to wrap
+   */
+  public LongValue(long value)
+  {
+    super(JdwpConstants.Tag.LONG);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public long getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Long(_value);
+  }
+
+  /**
+   * Write the wrapped long to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeLong(_value);
+  }
+}
+
Index: libjava/classpath/gnu/classpath/jdwp/value/ShortValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/ShortValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/ShortValue.java	(revision 126334)
@@ -0,0 +1,100 @@
+/* ShortValue.java -- JDWP wrapper class for a short value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an short value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public final class ShortValue
+    extends Value
+{
+  // The short wrapped by this class
+  short _value;
+
+  /**
+   * Create a new ShortValue from a short
+   * 
+   * @param value the short to wrap
+   */
+  public ShortValue(short value)
+  {
+    super(JdwpConstants.Tag.SHORT);
+    _value = value;
+  }
+  
+  /**
+   * Get the value held in this Value
+   * 
+   * @return the value represented by this Value object
+   */
+  public short getValue()
+  {
+    return _value;
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return new Short(_value);
+  }
+
+  /**
+   * Write the wrapped short to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os)
+    throws IOException
+  {
+    os.writeShort(_value);
+  }
+}
+
Index: libjava/classpath/gnu/classpath/jdwp/value/Value.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/Value.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/Value.java	(revision 126334)
@@ -0,0 +1,155 @@
+/* Value.java -- base class of JDWP values
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.exception.InvalidClassException;
+import gnu.classpath.jdwp.exception.InvalidObjectException;
+import gnu.classpath.jdwp.exception.InvalidTagException;
+import gnu.classpath.jdwp.exception.JdwpInternalErrorException;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Superclass for all JDWP Values.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public abstract class Value
+{
+  // A Tag representing the type of this value
+  private byte _tag;
+  
+  /**
+   * Create a new value of type tag.
+   * 
+   * @param tag the type of the value
+   */ 
+  protected Value(byte tag)
+  {
+    _tag = tag;
+  }
+  
+  /**
+   * Get the tag for this Value
+   * 
+   * @return the byte tag of this Value
+   */
+  public byte getTag()
+  {
+    return _tag;
+  }
+  
+  /**
+   * Calls the dervied classes writeValue method to write its value to the 
+   * DataOutputStream.
+   * 
+   * @param os write the value here
+   * @throws IOException
+   */  
+  public void writeUntagged(DataOutputStream os)
+    throws IOException
+  {
+    write(os);
+  }
+  
+  /**
+   * Will write the given object as a tagged value to the DataOutputStream.
+   * 
+   * @param os write the value here
+   * @param obj the Object to write
+   * @throws IOException
+   */
+  public void writeTagged(DataOutputStream os)
+    throws IOException
+  {
+    os.write (_tag);
+    write(os);
+  }
+  
+  /**
+   * This method must write the value to the DataOutputStream in a manner
+   * appropriate for the type of the value.
+   * 
+   * @param os DataOutputStream to write to
+   * @throws IOException
+   */
+  protected abstract void write(DataOutputStream os)
+    throws IOException;
+  
+  /**
+   * Returns an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  protected abstract Object getObject();
+    
+  /**
+   * Get an untagged object from the ByteBuffer
+   * 
+   * @param bb the ByteBuffer to extract the value from
+   * @param type a Class representing the type
+   * @return an Object from the ByteBuffer of the type of the Class parameter
+   * @throws JdwpInternalErrorException
+   * @throws InvalidObjectException
+   */
+  public static Object getUntaggedObject(ByteBuffer bb, Class type)
+    throws JdwpInternalErrorException, InvalidObjectException, InvalidClassException
+  {
+    Value val = ValueFactory.createFromUntagged(bb, type);
+    return val.getObject();
+  }
+  
+  /**
+   * Get an untagged object from the ByteBuffer
+   * 
+   * @param bb the ByteBuffer to extract the value from
+   * @param tag a byte tag representing the type
+   * @return an Object from the ByteBuffer of the type of the Class parameter
+   * @throws JdwpInternalErrorException
+   * @throws InvalidObjectException
+   */
+  public static Object getTaggedObject(ByteBuffer bb)
+    throws JdwpInternalErrorException, InvalidObjectException, InvalidTagException
+  {
+    Value val = ValueFactory.createFromTagged(bb);
+    return val.getObject();
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/value/VoidValue.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/value/VoidValue.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/value/VoidValue.java	(revision 126334)
@@ -0,0 +1,82 @@
+/* VoidValue.java -- JDWP wrapper class for a void value
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.value;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Wrapper for an void value.
+ * 
+ * @author Kyle Galloway <kgallowa@redhat.com>
+ */
+public class VoidValue
+    extends Value
+{
+  /**
+   * Create a new VoidValue.
+   */
+  public VoidValue ()
+  {
+    super(JdwpConstants.Tag.VOID);
+  }
+  
+  /**
+   * Return an object representing this type
+   * 
+   * @return an Object represntation of this value
+   */
+  @Override
+  protected Object getObject()
+  {
+    return null;
+  }
+
+  /**
+   * Write the wrapped void to the given DataOutputStream.
+   * 
+   * @param os the output stream to write to
+   */
+  @Override
+  protected void write(DataOutputStream os) 
+    throws IOException
+  {
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/util/MethodResult.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/util/MethodResult.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/util/MethodResult.java	(revision 126334)
@@ -52,6 +52,9 @@
   
   // Any Exception that was thrown by the executing method
   private Exception thrownException;
+  
+  // The type of this result
+  private Class resType;
 
   public Object getReturnedValue()
   {
@@ -73,4 +76,14 @@
     this.thrownException = thrownException;
   }
   
+  public Class getResultType()
+  {
+    return resType;
+  }
+  
+  public void setResultType(Class type)
+  {
+    resType = type;
+  }
+  
 }
Index: libjava/classpath/gnu/classpath/jdwp/util/NullObject.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/util/NullObject.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/util/NullObject.java	(revision 126334)
@@ -0,0 +1,50 @@
+/* NullObject.java -- placeholder for null values
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.util;
+
+/**
+ * This is a placeholder for null.  There are several places in JDWP where null
+ * is a valid value (i.e. when geting the value of a variable slot that
+ * contains a null reference at that time).  This class distinguishes between
+ * these "meaningful" null values and invalid null pointers.
+ *
+ * @author Kyle Galloway  <kgallowa@redhat.com>
+ */
+public class NullObject
+{
+}
Index: libjava/classpath/gnu/classpath/jdwp/util/MonitorInfo.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/util/MonitorInfo.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/util/MonitorInfo.java	(revision 126334)
@@ -0,0 +1,76 @@
+/* MonitorInfo.java -- class used to return monitor information
+   for JDWP.
+
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package gnu.classpath.jdwp.util;
+
+import gnu.classpath.jdwp.VMIdManager;
+import gnu.classpath.jdwp.id.ObjectId;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * This class is used to pass monitor information between
+ * the JDWP back-end and the virtual machine.
+ *
+ * @author Keith Seitz  (keiths@redhat.com)
+ */
+public class MonitorInfo
+{
+  public int entryCount;
+  public Thread owner;
+  public Thread[] waiters;
+
+  public void write(DataOutputStream os)
+    throws IOException
+  {
+    VMIdManager idm = VMIdManager.getDefault();
+    ObjectId id = idm.getObjectId(owner);
+    id.write(os);
+    os.write(entryCount);
+    os.write(waiters.length);
+    for (int i = 0; i < waiters.length; ++i)
+      {
+	id = idm.getObjectId(waiters[i]);
+	id.write(os);
+      }
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/util/Location.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/util/Location.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/util/Location.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* Location.java -- class to read/write JDWP locations
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -153,4 +153,16 @@
   {
     return method.toString () + "." + index;
   }
+
+  public boolean equals(Object obj)
+  {
+    if (obj instanceof Location)
+      {
+	Location l = (Location) obj;
+	return (getMethod().equals(l.getMethod())
+		&& getIndex() == l.getIndex());
+      }
+
+    return false;
+  }
 }
Index: libjava/classpath/gnu/classpath/jdwp/util/Value.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/util/Value.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/util/Value.java	(revision 126334)
@@ -1,301 +0,0 @@
-/* Value.java -- class to read/write JDWP tagged and untagged values
-   Copyright (C) 2005, 2006, Free Software Foundation
-
-This file is part of GNU Classpath.
-
-GNU Classpath is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
-
-GNU Classpath is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GNU Classpath; see the file COPYING.  If not, write to the
-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
-
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
-
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version. */
-
-
-package gnu.classpath.jdwp.util;
-
-import gnu.classpath.jdwp.JdwpConstants;
-import gnu.classpath.jdwp.VMIdManager;
-import gnu.classpath.jdwp.exception.InvalidFieldException;
-import gnu.classpath.jdwp.exception.JdwpException;
-import gnu.classpath.jdwp.exception.JdwpInternalErrorException;
-import gnu.classpath.jdwp.exception.NotImplementedException;
-import gnu.classpath.jdwp.id.ObjectId;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-/**
- * A class to read/write JDWP tagged and untagged values.
- * 
- * @author Aaron Luchko <aluchko@redhat.com>
- */
-public class Value
-{
-  /**
-   * Will write the given object as an untagged value to the DataOutputStream.
-   * 
-   * @param os write the value here
-   * @param obj the Object to write
-   * @throws IOException
-   * @throws InvalidFieldException
-   */  
-  public static void writeUntaggedValue(DataOutputStream os, Object obj)
-    throws JdwpException, IOException
-  {
-    writeValue(os, obj, false);
-  }
-  
-  /**
-   * Will write the given object as a tagged value to the DataOutputStream.
-   * 
-   * @param os write the value here
-   * @param obj the Object to write
-   * @throws IOException
-   * @throws InvalidFieldException
-   */
-  public static void writeTaggedValue(DataOutputStream os, Object obj)
-    throws JdwpException, IOException
-  {
-    writeValue(os, obj, true);
-  }
-  
-  /**
-   * Will write the given object as either a value or an untagged value to the
-   * DataOutputStream.
-   * 
-   * @param os write the value here
-   * @param obj the Object to write
-   * @param tagged true if the value is tagged, false otherwise
-   * @throws IOException
-   * @throws InvalidFieldException
-   */
-  private static void writeValue(DataOutputStream os, Object obj,
-                                boolean tagged)
-    throws IOException, JdwpException
-  {
-    Class clazz = obj.getClass();
-    if (clazz.isPrimitive())
-      {
-        if (clazz == byte.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.BYTE);
-            os.writeByte(((Byte) obj).byteValue());
-          }
-        else if (clazz == char.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.CHAR);
-            os.writeChar(((Character) obj).charValue());
-          }
-        else if (clazz == float.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.FLOAT);
-            os.writeFloat(((Float) obj).floatValue());
-          }
-        else if (clazz == double.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.DOUBLE);
-            os.writeDouble(((Double) obj).doubleValue());
-          }
-        else if (clazz == int.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.BYTE);
-            os.writeInt(((Integer) obj).intValue());
-          }
-        else if (clazz == long.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.LONG);
-            os.writeLong(((Long) obj).longValue());
-          }
-        else if (clazz == short.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.SHORT);
-            os.writeInt(((Short) obj).shortValue());
-          }
-        else if (clazz == void.class)
-          { // A 'void' has no data
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.VOID);
-          }
-        else if (clazz == boolean.class)
-          {
-            if (tagged)
-              os.writeByte(JdwpConstants.Tag.BOOLEAN);
-            os.writeBoolean(((Boolean) obj).booleanValue());
-          }
-        else
-          { // This shouldn't be possible
-            throw new JdwpInternalErrorException(
-              "Field has invalid primitive!");
-          }
-      }
-    else
-      {
-        // Object is an Object, not a primitive type wrapped in an object
-        // Write the appropriate tag
-        if (tagged)
-          {
-            if (clazz.isArray())
-              os.writeByte(JdwpConstants.Tag.ARRAY);
-            else if (obj instanceof String)
-              os.writeByte(JdwpConstants.Tag.STRING);
-            else if (obj instanceof Thread)
-              os.writeByte(JdwpConstants.Tag.THREAD);
-            else if (obj instanceof ThreadGroup)
-              os.writeByte(JdwpConstants.Tag.THREAD_GROUP);
-            else if (obj instanceof ClassLoader)
-              os.writeByte(JdwpConstants.Tag.CLASS_LOADER);
-            else if (obj instanceof Class)
-              os.writeByte(JdwpConstants.Tag.CLASS_OBJECT);
-            else
-              os.writeByte(JdwpConstants.Tag.OBJECT);
-          }
-        ObjectId oid = VMIdManager.getDefault().getObjectId(obj);
-        oid.write(os);
-      }
-  }
-
-  /**
-   * Reads the appropriate object for the tagged value contained in the 
-   * ByteBuffer.
-   * 
-   * @param bb contains the Object
-   * @return The Object referenced by the value
-   * @throws JdwpException
-   * @throws IOException
-   */
-  public static Object getObj(ByteBuffer bb)
-    throws JdwpException, IOException
-  {
-    return getUntaggedObj(bb, bb.get());
-  }
-
-  /**
-   * Reads an object of the given Class from the untagged value contained
-   * in the ByteBuffer.
-   * 
-   * @param bb   contains the Object
-   * @param type corresponds to the TAG of value to be read 
-   * @return the resultant object
-   * @throws JdwpException
-   * @throws IOException
-   */
-  public static Object getUntaggedObj(ByteBuffer bb, Class type)
-    throws JdwpException, IOException
-  {
-    if (type.isPrimitive())
-      {
-        if (type == byte.class)
-          return new Byte(bb.get());
-        else if (type == char.class)
-          return new Character(bb.getChar());
-        else if (type == float.class)
-          return new Float(bb.getFloat());
-        else if (type == double.class)
-          return new Double(bb.getDouble());
-        else if (type == int.class)
-          return new Integer(bb.getInt());
-        else if (type == long.class)
-          return new Long(bb.getLong());
-        else if (type == short.class)
-          return new Short(bb.getShort());
-        else if (type == boolean.class)
-          return Boolean.valueOf(bb.get() != 0);
-        else if (type == void.class)
-          return new byte[0];
-        else
-          { // This shouldn't be possible
-            throw new JdwpInternalErrorException(
-              "Field has invalid primitive!");
-          }
-      }
-    else
-      {
-        // Field is an object
-        ObjectId oid = VMIdManager.getDefault().readObjectId(bb);
-        return oid.getObject();
-      }
-  }
-
-  /**
-   * Reads the an object of the given Class from the untagged value contained
-   * in the ByteBuffer.
-   * 
-   * @param bb contains the Object
-   * @param tag TAG of the Value to be read
-   * @return the object
-   * @throws JdwpException
-   * @throws IOException
-   */
-  public static Object getUntaggedObj(ByteBuffer bb, byte tag)
-    throws JdwpException, IOException
-  {
-    switch (tag)
-      {
-      case JdwpConstants.Tag.BYTE:
-        return new Byte(bb.get());
-      case JdwpConstants.Tag.CHAR:
-        return new Character(bb.getChar());
-      case JdwpConstants.Tag.FLOAT:
-        return new Float(bb.getFloat());
-      case JdwpConstants.Tag.DOUBLE:
-        return new Double(bb.getDouble());
-      case JdwpConstants.Tag.INT:
-        return new Integer(bb.getInt());
-      case JdwpConstants.Tag.LONG:
-        return new Long(bb.getLong());
-      case JdwpConstants.Tag.SHORT:
-        return new Short(bb.getShort());
-      case JdwpConstants.Tag.VOID:
-        return new byte[0];
-      case JdwpConstants.Tag.BOOLEAN:
-        return (bb.get() == 0) ? new Boolean(false) : new Boolean(true);
-      case JdwpConstants.Tag.STRING:
-        return JdwpString.readString(bb);
-      case JdwpConstants.Tag.ARRAY:
-      case JdwpConstants.Tag.THREAD:
-      case JdwpConstants.Tag.OBJECT:
-      case JdwpConstants.Tag.THREAD_GROUP:
-      case JdwpConstants.Tag.CLASS_LOADER:
-      case JdwpConstants.Tag.CLASS_OBJECT:
-        // All these cases are ObjectIds
-        ObjectId oid = VMIdManager.getDefault().readObjectId(bb);
-        return oid.getObject();
-      default:
-        throw new NotImplementedException("Tag " + tag
-                                          + " is not implemented.");
-      }
-  }
-}
Index: libjava/classpath/gnu/classpath/jdwp/util/VariableTable.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/util/VariableTable.java	(revision 125219)
+++ libjava/classpath/gnu/classpath/jdwp/util/VariableTable.java	(revision 126334)
@@ -50,9 +50,9 @@
 public class VariableTable
 {
 
-  private final long argCnt;
+  private final int argCnt;
 
-  private final long slots;
+  private final int slots;
 
   private final long[] lineCI;
 
@@ -95,8 +95,8 @@
    */
   public void write(DataOutputStream os) throws IOException
   {
-    os.writeLong(argCnt);
-    os.writeLong(slots);
+    os.writeInt(argCnt);
+    os.writeInt(slots);
     for (int i = 0; i < slots; i++)
       {
         os.writeLong(lineCI[i]);
Index: libjava/classpath/gnu/classpath/jdwp/exception/InvalidTagException.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/exception/InvalidTagException.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/exception/InvalidTagException.java	(revision 126334)
@@ -0,0 +1,57 @@
+/* InvalidTagException.java -- an invalid type tag exception
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package gnu.classpath.jdwp.exception;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+/**
+ * An exception thrown when an invalid tag is used by
+ * the debugger
+ *
+ * @author Kyle Galloway  (kgallowa@redhat.com)
+ */
+public class InvalidTagException
+  extends JdwpException
+{
+  public InvalidTagException (byte tag)
+  {
+    super (JdwpConstants.Error.INVALID_TAG,
+       "invalid tag (" + tag + ")");
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/exception/AbsentInformationException.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/exception/AbsentInformationException.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/exception/AbsentInformationException.java	(revision 126334)
@@ -0,0 +1,56 @@
+/* AbsentInformationException.java -- information not present exception
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package gnu.classpath.jdwp.exception;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+/**
+ * An exception thrown when the requested information is not available.
+ *
+ * @author Kyle Galloway  (kgallowa@redhat.com)
+ */
+public class AbsentInformationException
+  extends JdwpException
+{
+  public AbsentInformationException(String str)
+  {
+    super(JdwpConstants.Error.ABSENT_INFORMATION, str);
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/exception/InvalidSlotException.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/exception/InvalidSlotException.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/exception/InvalidSlotException.java	(revision 126334)
@@ -0,0 +1,62 @@
+/* InvalidSlotException.java -- an invalid variable slot exception
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package gnu.classpath.jdwp.exception;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+/**
+ * An exception thrown when an invalid Slot id is used by the debugger 
+ * (i.e. when trying to access a variable slot which doesn't exist).
+ *
+ * @author Kyle Galloway (kgallowa@redhat.com)
+ */
+public class InvalidSlotException
+  extends JdwpException
+{
+  public InvalidSlotException(int slot)
+  {
+    super(JdwpConstants.Error.INVALID_SLOT, "invalid slot: " + slot);
+  }
+
+  public InvalidSlotException(String msg)
+  {
+    super(JdwpConstants.Error.INVALID_SLOT, msg);
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/exception/InvalidFrameException.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/exception/InvalidFrameException.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/exception/InvalidFrameException.java	(revision 126334)
@@ -0,0 +1,63 @@
+/* InvalidFrameException.java -- invalid jframeid
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package gnu.classpath.jdwp.exception;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+/**
+ * An exception thrown when the debugger requests an invalid frame in the call
+ * stack.
+ *
+ * @author Kyle Galloway  (kgallowa@redhat.com)
+ */
+public class InvalidFrameException
+  extends JdwpException
+{
+  public InvalidFrameException(long id)
+  {
+    super(JdwpConstants.Error.INVALID_FRAMEID, 
+		  "invalid frame id (" + id + ")");
+  }
+
+  public InvalidFrameException(String msg)
+  {
+    super(JdwpConstants.Error.INVALID_FRAMEID, msg);
+  }
+}
Index: libjava/classpath/gnu/classpath/jdwp/exception/TypeMismatchException.java
===================================================================
--- libjava/classpath/gnu/classpath/jdwp/exception/TypeMismatchException.java	(revision 0)
+++ libjava/classpath/gnu/classpath/jdwp/exception/TypeMismatchException.java	(revision 126334)
@@ -0,0 +1,62 @@
+/* TypeMismatchException.java -- mismatched type of local variable
+   Copyright (C) 2007 Free Software Foundation
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package gnu.classpath.jdwp.exception;
+
+import gnu.classpath.jdwp.JdwpConstants;
+
+/**
+ * An exception throw when attempting to access a local variable of the wrong
+ * type.
+ *
+ * @author Kyle Galloway  (kgallowa@redhat.com)
+ */
+public class TypeMismatchException
+  extends JdwpException
+{
+  public TypeMismatchException(byte tag)
+  {
+    super(JdwpConstants.Error.TYPE_MISMATCH, "incorrect tag: " + tag);
+  }
+
+  public TypeMismatchException(String msg)
+  {
+    super(JdwpConstants.Error.TYPE_MISMATCH, msg);
+  }
+}
Index: libjava/classpath/ChangeLog
===================================================================
--- libjava/classpath/ChangeLog	(revision 125219)
+++ libjava/classpath/ChangeLog	(revision 126334)
@@ -1,3 +1,24 @@
+2007-05-18  Keith Seitz  <keiths@redhat.com>
+
+	Merged from trunk:
+
+	2007-05-07 Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/Jdwp.java (notify): Rewrite to call
+	new array-based method.
+	(notify): New function.
+	(sendEvent): Rewrite to use sendEvents.
+	(sendEvents): New method.
+	* gnu/classpath/jdwp/event/Event.java (toPacket): Make static.
+	Change parameters to use arrays for events and requests.
+	Add suspendPolicy parameter.
+	Move per-event data transformation to...
+	(_toData): ... here.
+	* gnu/classpath/jdwp/transport/JdwpConnection.java
+	(sendEvent): Renamed to ...
+	(sendEvents): ... this.
+	Change parameters to use arrays for events and requests.
+	Add suspendPolicy parameter.
+
 2007-05-03  Andrew Haley  <aph@redhat.com>
 
 	* gnu/javax/management/Server.java (Server): Record the delegate.
Index: libjava/include/jvmti_md.h
===================================================================
--- libjava/include/jvmti_md.h	(revision 125219)
+++ libjava/include/jvmti_md.h	(revision 126334)
@@ -1,5 +1,5 @@
 /* jvmti_md.h
-   Copyright (C) 2006 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -53,6 +53,14 @@
   /* One for each callback.                     */			\
   bool enabled[EVENT_SLOTS];
 
+/* Redefine the standard JVMTI types to something a little more
+   precise than "jobject". */
+#define _CLASSPATH_VM_JVMTI_TYPES_DEFINED
+typedef java::lang::Thread *jthread;
+typedef java::lang::ThreadGroup *jthreadGroup;
+typedef jlong jlocation;
+typedef struct _Jv_rawMonitorID *jrawMonitorID;
+
 #endif /* __GCJ_JNI_IMPL__ */
 
 #endif /* __GCJ_JVMTI_MD_H__ */
Index: libjava/include/java-interp.h
===================================================================
--- libjava/include/java-interp.h	(revision 125219)
+++ libjava/include/java-interp.h	(revision 126334)
@@ -1,6 +1,6 @@
 // java-interp.h - Header file for the bytecode interpreter.  -*- c++ -*-
 
-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation
+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -137,6 +137,21 @@
   int line;
 };
 
+// This structure holds local variable information.
+// The pc value is the first pc where the variable must have a value and it
+// must continue to have a value until (start_pc + length).
+// The name is the variable name, and the descriptor contains type information.
+// The slot is the index in the local variable array of this method, long and
+// double occupy slot and slot+1.
+struct _Jv_LocalVarTableEntry
+{
+  int bytecode_start_pc;
+  int length;
+  char *name;
+  char *descriptor;
+  int slot;
+};
+
 class _Jv_InterpMethod : public _Jv_MethodBase
 {
   // Breakpoint instruction
@@ -157,6 +172,10 @@
   // Length of the line_table - when this is zero then line_table is NULL.
   int line_table_len;  
   _Jv_LineTableEntry *line_table;
+  
+  // The local variable table length and the table itself
+  int local_var_table_len;
+  _Jv_LocalVarTableEntry *local_var_table;
 
   pc_t prepared;
   int number_insn_slots;
@@ -205,11 +224,16 @@
   // number info is unavailable.
   int get_source_line(pc_t mpc);
 
+   public:
+
   // Convenience function for indexing bytecode PC/insn slots in
   // line tables for JDWP
   jlong insn_index (pc_t pc);
   
-   public:
+  // Helper function used to check if there is a handler for an exception
+  // present at this code index
+  jboolean check_handler (pc_t *pc, _Jv_InterpMethod *meth,
+                     java::lang::Throwable *ex);
    
   /* Get the line table for this method.
    * start  is the lowest index in the method
@@ -219,6 +243,25 @@
    */
   void get_line_table (jlong& start, jlong& end, jintArray& line_numbers,
 		       jlongArray& code_indices);
+  
+  int get_max_locals ()
+  {
+    return static_cast<int> (max_locals);
+  }
+  
+  /* Get info for a local variable of this method.
+   * If there is no loca_var_table for this method it will return -1.
+   * table_slot  indicates which slot in the local_var_table to get, if there is
+   * no variable at this location it will return 0.
+   * Otherwise, it will return the number of table slots after the selected
+   * slot, indexed from 0.
+   * 
+   * Example: there are 5 slots in the table, you request slot 0 so it will
+   * return 4.
+   */
+  int get_local_var_table (char **name, char **sig, char **generic_sig,
+                           jlong *startloc, jint *length, jint *slot,
+                           int table_slot);
 
   /* Installs a break instruction at the given code index. Returns
      the pc_t of the breakpoint or NULL if index is invalid. */
@@ -231,6 +274,9 @@
      the insn or NULL if index is invalid. */
   pc_t set_insn (jlong index, pc_t insn);
 
+  // Is the given location in this method a breakpoint?
+  bool breakpoint_at (jlong index);
+
 #ifdef DIRECT_THREADED
   friend void _Jv_CompileMethod (_Jv_InterpMethod*);
 #endif
@@ -263,6 +309,7 @@
 #endif
 
   friend _Jv_MethodBase ** _Jv_GetFirstMethod (_Jv_InterpClass *klass);
+  friend jstring _Jv_GetInterpClassSourceFile (jclass);
 };
 
 extern inline _Jv_MethodBase **
@@ -316,38 +363,126 @@
   }
 };
 
-// The interpreted call stack, represented by a linked list of frames.
-struct _Jv_InterpFrame
+enum _Jv_FrameType
 {
+  frame_native,
+  frame_interpreter,
+  frame_proxy
+};
+
+//  The composite call stack as represented by a linked list of frames
+class _Jv_Frame
+{
+public:
+  java::lang::Thread *thread;
+
   union
   {
+    _Jv_MethodBase *self;
     void *meth;
-    _Jv_InterpMethod *self;
     _Jv_Method *proxyMethod;
   };
-  java::lang::Thread *thread;
-  _Jv_InterpFrame *next;
+  
+  //The full list of frames, JNI and interpreted
+  _Jv_Frame *next;
+  _Jv_FrameType frame_type;
+  
+  _Jv_Frame (_Jv_MethodBase *s, java::lang::Thread *thr, _Jv_FrameType type)
+  {
+    self = s;
+    frame_type = type;
+    next = (_Jv_Frame *) thr->frame;
+    thr->frame = (gnu::gcj::RawData *) this;
+    thread = thr;
+  }
+
+  ~_Jv_Frame ()
+  {
+    thread->frame = (gnu::gcj::RawData *) next;
+  }
+
+  int depth ()
+  {
+    int depth = 0;
+    struct _Jv_Frame *f;
+    for (f = this; f != NULL; f = f->next)
+      ++depth;
+
+    return depth;
+  }
+};
+
+// An interpreted frame in the call stack
+class _Jv_InterpFrame : public _Jv_Frame
+{
+public:
+  
+  // Keep the purely interpreted list around so as not to break backtraces
+  _Jv_InterpFrame *next_interp;
+  
   union
   {
     pc_t pc;
     jclass proxyClass;
   };
   
-  _Jv_InterpFrame (void *meth, java::lang::Thread *thr, jclass proxyClass = NULL)
+  // Pointer to the actual pc value.
+  pc_t *pc_ptr;
+
+  //Debug info for local variables.
+  _Jv_word *locals;
+  char *locals_type;
+
+  // Object pointer for this frame ("this")
+  jobject obj_ptr;
+
+  _Jv_InterpFrame (void *meth, java::lang::Thread *thr, jclass proxyCls = NULL,
+                   pc_t *pc = NULL)
+  : _Jv_Frame (reinterpret_cast<_Jv_MethodBase *> (meth), thr,
+	             frame_interpreter)
   {
-    this->meth = meth;
-    thread = thr;
-    next = (_Jv_InterpFrame *) thr->interp_frame;
+    next_interp = (_Jv_InterpFrame *) thr->interp_frame;
+    proxyClass = proxyCls;
     thr->interp_frame = (gnu::gcj::RawData *) this;
-    this->proxyClass = proxyClass;
+    obj_ptr = NULL;
+    pc_ptr = pc;
   }
 
   ~_Jv_InterpFrame ()
   {
-    thread->interp_frame = (gnu::gcj::RawData *) next;
+    thread->interp_frame = (gnu::gcj::RawData *) next_interp;
   }
+
+  jobject get_this_ptr ()
+  {
+    return obj_ptr;
+  }
+  
+  pc_t get_pc ()
+  {
+    pc_t pc;
+    
+    // If the PC_PTR is NULL, we are not debugging.
+    if (pc_ptr == NULL)
+      pc = 0;
+    else
+      pc = *pc_ptr;
+    
+    return pc - 1;
+  }
 };
 
+// A native frame in the call stack really just a placeholder
+class _Jv_NativeFrame : public _Jv_Frame
+{
+public:
+
+  _Jv_NativeFrame (_Jv_JNIMethod *s, java::lang::Thread *thr)
+  : _Jv_Frame (s, thr, frame_native)
+  {
+  }
+};
+
 #endif /* INTERPRETER */
 
 #endif /* __JAVA_INTERP_H__ */
Index: libjava/include/jvmti-int.h
===================================================================
--- libjava/include/jvmti-int.h	(revision 125219)
+++ libjava/include/jvmti-int.h	(revision 126334)
@@ -1,5 +1,5 @@
 /* jvmti-int.h -- Internal JVMTI definitions
-   Copyright (C) 2006 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -37,6 +37,10 @@
    False means no JVMTI environment requested that event type. */
 namespace JVMTI
 {
+  // Is JVMTI enabled? (i.e., any jvmtiEnv created?)
+  extern bool enabled;
+
+  // Event notifications
   extern bool VMInit;
   extern bool VMDeath;
   extern bool ThreadStart;
@@ -82,4 +86,9 @@
    For speed, this function should only be called after 
    JVMTI_REQUESTED_EVENT is checked. */
 extern void _Jv_JVMTI_PostEvent (jvmtiEvent type, jthread event_thread,				 ...);
+// Returns the jvmtiEnv used by the JDWP backend
+extern jvmtiEnv *_Jv_GetJDWP_JVMTIEnv (void);
+
+// Reports JVMTI excpetions
+extern void _Jv_ReportJVMTIExceptionThrow (jthrowable);
 #endif /* __GCJ_JVMTI_INT_H__ */
Index: libjava/include/win32-threads.h
===================================================================
--- libjava/include/win32-threads.h	(revision 125219)
+++ libjava/include/win32-threads.h	(revision 126334)
@@ -227,5 +227,6 @@
 #undef STRICT
 #undef VOID
 #undef TEXT
+#undef OUT
 
 #endif /* __JV_WIN32_THREADS__ */
Index: libjava/include/no-gc.h
===================================================================
--- libjava/include/no-gc.h	(revision 125219)
+++ libjava/include/no-gc.h	(revision 126334)
@@ -1,7 +1,7 @@
 // -*- c++ -*-
 // no-gc.h - Defines for no garbage collector.
 
-/* Copyright (C) 1998, 1999, 2006  Free Software Foundation
+/* Copyright (C) 1998, 1999, 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -18,4 +18,6 @@
 // Resume a suspended thread.
 extern "C" void _Jv_ResumeThread (_Jv_Thread_t *);
 
+// Is the given thread suspended?
+extern "C" int _Jv_IsThreadSuspended (_Jv_Thread_t *);
 #endif /* __JV_NO_GC__ */
Index: libjava/include/boehm-gc.h
===================================================================
--- libjava/include/boehm-gc.h	(revision 125219)
+++ libjava/include/boehm-gc.h	(revision 126334)
@@ -1,7 +1,7 @@
 // -*- c++ -*-
 // boehm-gc.h - Defines for Boehm collector.
 
-/* Copyright (C) 1998, 1999, 2002, 2004, 2006  Free Software Foundation
+/* Copyright (C) 1998, 1999, 2002, 2004, 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -93,4 +93,6 @@
 // Resume a suspended thread.
 extern "C" void _Jv_ResumeThread (_Jv_Thread_t *);
 
+// Is the given thread suspended?
+extern "C" int _Jv_IsThreadSuspended (_Jv_Thread_t *);
 #endif /* __JV_BOEHM_GC__ */
Index: libjava/include/java-stack.h
===================================================================
--- libjava/include/java-stack.h	(revision 125219)
+++ libjava/include/java-stack.h	(revision 126334)
@@ -41,13 +41,6 @@
   }
 }
 
-enum _Jv_FrameType
-{
-  frame_native,
-  frame_interpreter,
-  frame_proxy
-};
-
 #ifdef INTERPRETER
 struct _Jv_InterpFrameInfo
 {
Index: libjava/ChangeLog
===================================================================
--- libjava/ChangeLog	(revision 125219)
+++ libjava/ChangeLog	(revision 126334)
@@ -3,6 +3,350 @@
 	* java/lang/natClassLoader.cc (_Jv_NewClassFromInitializer): Clear
 	INTERPRETED access modifier.
 
+2007-05-18  Keith Seitz  <keiths@redhat.com>
+
+	Merged from trunk:
+
+	2007-05-17  Kyle Galloway  <kgallowa@redhat.com>
+	* classpath/gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java
+	(executeMethods): Remove cast to ClassReferenceTypeId.
+	* classpath/lib/gnu/classpath/jdwp/processor/
+	ReferenceTypeCommandSet.class: Rebuilt.
+
+	2007-05-17  Kyle Galloway  <kgallowa@redhat.com>
+	* gnu/classpath/jdwp/natVMMethod.cc (getModifiers): Check for native
+	classes and mark methods as native appropriately.
+
+	2007-05-17  Kyle Galloway  <kgallowa@redhat.com>
+	* gnu/classpath/jdwp/VMFrame.java (<init>): Add parameter for "this"
+	pointer.
+	* gnu/classpath/jdwp/VMFrame.h: Regenerated.
+	* classpath/lib/gnu/classpath/jdwp/VMFrame.class: Rebuilt.
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc (getFrame): Use new
+	VMFrame constructor.
+
+	2007-05-16  Keith Seitz  <keiths@redhat.com>
+	* include/java-interp.h (breakpoint_at): Declare.
+	* interpret.cc (breakpoint_at): New function.
+	* gnu/classpath/jdwp/VMVirtualMachine.java (_event_list):
+	New member.
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc (initialize):
+	Initialize _event_list.
+	(handle_single_step): If there is a breakpoint at the
+	location at which we are stopping, do not send the notification.
+	Instead add the event to a list of events that occur at this
+	location.
+	(jdwpBreakpointCB): If the event list is not empty, send
+	whatever events are in it and the breakpoint event in a single
+	notification.
+	Mark parameter jni_env as MAYBE_UNUSED.
+	* classpath/lib/gnu/classpath/jdwp/VMVirtualMachine.class:
+	Regenerated.
+	* gnu/classpath/jdwp/VMVirtualMachine.h: Regenerated.
+
+	2007-05-15  Keith Seitz  <keiths@redhat.com>
+	* interpret.cc (STOREA): Rewrite using temporary variable to
+	avoid double-macro expansion side-effects.
+	(STOREI): Likewise.
+	(STOREF): Likewise.
+	(STOREL)[SIZEOF_VOID_P == 8]: Likewise.
+	(STORED)[SIZEOF_VOID_P == 8]: Likewise.
+	(STOREL)[SIZEOF_VOID_P != 8]: Likewise.
+	(STORED)[SIZEOF_VOID_P != 8]: Likewise.
+	(POKEI): Likewise.
+
+	2007-05-07  Keith Seitz  <keiths@redhat.com>
+	* classpath/lib/gnu/classpath/jdwp/Jdwp.class: Regenerate.
+	* classpath/lib/gnu/classpath/jdwp/Jdwp$1.class: Regenerate.
+	* classpath/lib/gnu/classpath/jdwp/event/Event.class:
+	Regenerate.
+	* classpath/lib/gnu/classpath/jdwp/transport/JdwpConnection.class:
+	Regenerate.
+	* gnu/classpath/jdwp/Jdwp.h: Regenerate.
+	* gnu/classpath/jdwp/event/Event.h: Regenerate.
+	* gnu/classpath/jdwp/transport/JdwpConnection.h: Regenerate.
+
+	2007-05-04  Kyle Galloway  <kgallowa@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc (getClassMethod): Change
+	to use JVMTI.
+
+	2007-05-03  Keith Seitz  <keiths@redhat.com>
+	* interpret.cc: Don't include ExceptionEvent.h.
+	* gnu/gcj/jvmti/natExceptionEvent.cc: Remove.
+	* Makefile.am (nat_source_files): Remove natExceptionEvent.cc.
+	* Makefile.in: Regenerated.
+
+	2007-05-03  Keith Seitz  <keiths@redhat.com>
+	* include/jvmti-int.h (_Jv_ReportJVMTIExceptionThrow):
+	Declare.
+	* interpret.cc (_Jv_ReportJVMTIExceptionThrow): New function.
+	(find_catch_location): New function.
+	(REPORT_EXCEPTION): New macro.
+	(throw_internal_error): Use REPORT_EXCEPTION.
+	(throw_incompatible_class_change_error): Likewise.
+	(throw_null_pointer_exception): Likewise.
+	(throw_class_format_error): Likewise.
+	* interpret-run.cc (INTERP_REPORT_EXCEPTION)[DEBUG]: Set
+	to REPORT_EXCEPTION.
+	(INTERP_REPORT_EXCEPTION)[!DEBUG]: Make nop.
+	(insn_new): Use INTERP_REPORT_EXCEPTION.
+	(insn_athrow): Likewise.
+	Remove previous JVMTI exception notifications.
+	Add JVMTI ExceptionCatch notificatin.
+	* jni.cc (_Jv_PopSystemFrame): Notify JVMTI clients of
+	exception throw.
+	* gnu/gcj/jvmti/ExceptionEvent.java: Removed.
+	* gnu/gcj/jvmti/ExceptionEvent.h: Removed. 
+	* classpath/lib/gnu/gcj/jvmti/ExceptionEvent.class: Removed.
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(jdwpExceptionCB): New function.
+	(jdwpVMInitCB): Set Exception event handler and enable.
+	* sources.am: Regenerated.
+	* Makefile.in: Regenerated.
+
+	2007-02-15  Kyle Galloway  <kgallowa@redhat.com>
+	* defineclass.cc (_Jv_ClassReader::read_one_code_attribute):
+	Added LocalVariableTable attribute handling.
+	(_Jv_ClassReader::pool_Utf8_to_char_arr): New method.
+	* jvmti.cc (_Jv_JVMTI_GetLocalVariableTable): New method.
+	* include/java-interp.h: Added local_var_table and 
+	local_var_table_len fields to _Jv_InterpMethod.
+	(_Jv_InterpMethod::get_local_var_table): New method.
+	* testsuite/libjava.jvmti/interp/getlocalvartable.java: New test.
+	* testsuite/libjava.jvmti/interp/getlocalvartable.jar: New test.
+	* testsuite/libjava.jvmti/interp/getlocalvartable.out: Output
+	for new test.
+	* testsuite/libjava.jvmti/interp/getlocalvartable.h: New test.
+	* testsuite/libjava.jvmti/interp/natgetlocalvartable.cc: New test.
+
+	2007-02-15  Kyle Galloway  <kgallowa@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine (getFrames): Implement.
+
+	2007-02-13  Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(jdwpBreakpointCB): New function.
+	(jdwpVMInitCB): Define and enable the breakpoint
+	callback.
+
+	2007-02-12  Keith Seitz  <keiths@redhat.com>
+	* jvmti.cc (_Jv_JVMTI_GetStackTrace): Remove cast
+	from jthread to Thread *; it is no longer needed.
+	(_Jv_JVMTI_GetFrameCount): Likewise.
+	Fix small formatting typo.
+
+	2007-02-09  Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/VMVirtualMachine.java
+	(_stepping_threads): New member.
+	* classpath/lib/gnu/classpath/jdwp/VMVirtualMachine.class:
+	Regenerated.
+	* gnu/classpath/jdwp/VMVirtualMachine.h:
+	Regenerated.
+	* gnu/claspath/jdwp/natVMVirtualMachine.cc
+	(get_request_step_filter): New function.
+	(DISABLE_EVENT): New macro.
+	(initialize): Initialize _stepping_threads.
+	(registerEvent): Implement EVENT_SINGLE_STEP.
+	(unregisterEvent): Likewise.
+
+	2007-02-08  Keith Seitz  <keiths@redhat.com>
+	* sources.am: Regenerate.
+	* Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+	* gcj/Makefile.in: Regenerate.
+	* include/Makefile.in: Regenerate.
+
+	* classpath/lib/javax/management/MBeanServerFactory.class:
+	Regenerate.
+
+	2007-02-08  Kyle Galloway  <kgallowa@redhat.com>
+	* classpath/gnu/classpath/jdwp/processor/
+	StackFrameCommandSet.java (executeGetValues): Pass jlong instead
+	of ByteBuffer.
+	(executeSetValues): Ditto.
+	(executeThisObject): Ditto.
+	* classpath/gnu/classpath/jdwp/processor/
+	StackFrameCommandSet.class: Rebuilt.
+	* classpath/lib/gnu/classpath/jdwp/VMVirtualMachine.class:
+	Rebuilt.
+	* classpath/lib/gnu/classpath/jdwp/VMFrame.class: Rebuilt.
+	* classpath/lib/gnu/classpath/jdwp/exception/
+	InvalidFrameException.java: New file.
+	* gnu/classpath/jdwp/VMFrame.java: Added field for thread of
+	frame.
+	(Constructor): New method.
+	* gnu/classpath/jdwp/VMFrame.h: Regenerated.
+	* gnu/classpath/jdwp/VMVirtualMachine.java
+	(getFrame): Changed ByteBuffer to jlong.
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(getFrame): Implement.
+	* gnu/classpath/jdwp/VMVirtualMachine.h: Regenerated.
+
+	2007-02-08  Kyle Galloway  <kgallowa@redhat.com>
+	* include/java-interp.h (_Jv_InterpFrame): obj_ptr field added
+	to hold "this" pointer for frame.
+	(_Jv_InterpFrame::get_this_ptr): New method.
+	* interpret-run.cc: Copy the "this" pointer into obj_ptr.
+
+	2007-02-07  Keith Seitz  <keiths@redhat.com>
+	* include/java-interp.h (_Jv_Frame::depth):
+	New function.
+	* jvmti.cc (_Jv_JVMTI_GetFrameCount): Use _Jv_Frame::depth.
+
+	2007-02-07  Kyle Galloway  <kgallowa@redhat.com>
+	* jvmti.cc (CHECK_FOR_NATIVE_METHOD): New macro.
+	(_Jv_JVMTI_GetMaxLocals): New method.
+	* include/java-interp.h
+	(_Jv_InterpMethod::get_max_locals): New method.
+
+	2007-02-05  Keith Seitz  <keiths@redhat.com>
+	* jvmti.cc (_envListLock): Change type to
+	ReentrantReadWriteLock.
+	(_Jv_JVMTI_DisposeEnvironment): Switch to read/write
+	lock.
+	(check_enabled_event): Likewise.
+	(_Jv_GetJVMTIEnv): Likewise.
+	(_Jv_JVMTI_Init): Likewise.
+	(_Jv_JVMTI_PostEvent): Likewise. 
+
+	2007-02-05  Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(registerEvent): Implement EVENT_BREAKPOINT.
+	(unregisterEvent): Likewise.
+	(get_request_location): New function.
+
+	2007-02-02  Kyle Galloway  <kgallowa@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc (getFrameCount):
+	Implment.
+
+	2007-01-31  Keith Seitz  <keiths@redhat.com>
+	* include/jvmti-int.h (JVMTI): Declare member "enabled".
+	* jvmti.cc (JVMTI): Add member "enabled".
+	(_Jv_GetJVMTIEnv): Mark JVMTI enabled.
+	* interpret.cc (_Jv_InterpMethod::ncode): Use JVMTI::enabled
+	instead of gnu::classpath::jdwp::Jdwp::isDebugging.
+	(_Jv_CompileMethod): If JVMTI is enabled, use run_debug
+	instead of run to compile the method.
+
+	* interpret-run.cc [DEBUG] (NEXT_INSN): Add JVMTI single step
+	notification.
+
+	2007-01-31  Keith Seitz  <keiths@redhat.com>
+	* testsuite/libjava.jvmti/getmethodname.h: New file.
+	* testsuite/libjava.jvmti/getmethodname.jar: New file.
+
+	2007-01-29  Kyle Galloway  <kgallowa@redhat.com>
+	* include/java-interp.h:  Added _Jv_Frame class and its two
+	subclasses _Jv_InterpFrame and _Jv_NativeFrame.  Also moved
+	_Jv_FrameType from java-stack.h.
+	* include/java-stack.h: Removed _Jv_FrameType.
+	* java/lang/Thread.java: Added frame member to hold new
+	composite frame stack.
+	* java/lang/Thread.h: Regenerated.
+	* java/lang/Thread.class: Rebuilt.
+	* jni.cc (_Jv_JNIMethod::call): Push a frame onto the stack when
+	calling a JNI method.
+	* jvmti.cc (_Jv_JVMTI_GetStackTrace): New Method.
+	(_Jv_JVMTI_GetFrameCount): New method.
+	* stacktrace.cc (UnwindTraceFn): Modified to use new _Jv_Frame
+	classes.
+	* testsuite/libjava.jvmti/interp/getstacktrace.jar: New test.
+	* testsuite/libjava.jvmti/interp/natgetstacktrace.cc: New test.
+	* testsuite/libjava.jvmti/interp/getstacktrace.h: New test.
+	* testsuite/libjava.jvmti/interp/getstacktrace.jar: New test.
+	* testsuite/libjava.jvmti/interp/getstacktrace.out: Output file
+	for test. 
+
+	2007-01-29  Keith Seitz  <keiths@redhat.com>
+	* include/jvmti_md.h (_CLASSPATH_VM_JVMTI_TYPES_DEFINED):
+	Define.
+	[__GCJ_JNI_IMPL__]: Define our own JVMTI types when building
+	gcj. All jvmti object types now are defined to be their
+	corresponding java classes.
+	* jvmti.cc (_Jv_JVMTI_SuspendThread): Remove casting from
+	jthread to Thread*.
+	(_Jv_JVMTI_ResumeThread): Likewise.
+	(_Jv_JVMTI_InterruptThread): Likewise.
+	(_Jv_JVMTI_SetEventNotificationMode): Likewise.
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(jdwpClassPrepareCB): Likewise.
+	(jdwpThreadEndCB): Likewise.
+	(jdwpThreadStartCB): Likewise.
+	(jdwpVMInitCB): Likewise.
+
+	2007-01-27  Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(getAllClassMethods): Move error handling to ...
+	(throw_jvmti_error): ... here.
+	(jdwpClassPrepareCB): New function.
+	(jdwpThreadEndCB): New function.
+	(jdwpThreadStartCB): New function.
+	(jdwpVMDeathCB): New function.
+	(jdwpVMInitCB): Define and enable callbacks for
+	ClassPrepare, ThreadEnd, ThreadStart, and VMDeath.
+
+	2007-01-25  Keith Seitz  <keiths@redhat.com>
+	* include/jvmti-int.h (_Jv_GetJDWP_JVMTIEnv): Declare.
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(_Jv_GetJDWP_JVMTIEnv): New function.
+	* gnu/classpath/jdwp/natVMMethod.cc (getName): Implement.
+	(getSignature): Implement.
+	(getModifiers): Implement.
+
+	2007-01-25  Keith Seitz  <keiths@redhat.com>
+	* jvmti.cc (_Jv_JVMTI_GetMethodName): New function.
+	(_Jv_JVMTI_Interface): Define GetMethodName.
+	* testsuite/libjava.jvmti/getmethodname.java: New file.
+	* testsuite/libjava.jvmti/natgetmethodname.cc: New file.
+	* testsuite/libjava.jvmti/getmethodname.out: New file. 
+
+	2007-01-24  Kyle Galloway  <kgallowa@redhat.com>
+	* libjava/testsuite/libjava.jvmti/jvmti-interp.exp: New file.
+	* libjava/testsuite/libjava.jvmti/interp: New folder.
+	* libjava/testsuite/lib/libjava.exp (exec_gij): New Method.
+
+	2007-01-24  Keith Seitz  <keiths@redhat.com>
+	* link.cc (_Jv_Linker::wait_for_state): Add JVMTI
+	CLASS_PREPARE notification.
+
+	2007-01-24  Keith Seitz  <keiths@redhat.com>
+	* interpret.cc: Include gnu/gcj/jvmti/Breakpoint.h,
+	gnu/gcj/jvmti/BreakpointManager.h, jvmti.h, and jvmti-int.h
+	* interpret-run.cc: Implement insn_breakpoint.
+
+	2007-01-24  Keith Seitz  <keiths@redhat.com>
+	* prims.cc (_Jv_RunMain): Send JVMTI event notifications
+	for VM_INIT and VM_DEATH instead of the JDWP notifications.
+
+	2007-01-24  Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(getAllClassMethods): Implement.
+
+	2007-01-22  Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc
+	(getClassMethod): Implement.
+
+	2007-01-22  Keith  Seitz  <keiths@redhat.com>
+	* java/lang/Class.h (_Jv_GetClassStatus): Declare.
+	* java/lang/natClass.cc (_Jv_GetClassStatus): New function.
+	* jvmti.cc (_Jv_JVMTI_GetClassStatus): New function.
+	(_Jv_JVMTI_Interface): Define GetClassStatus.
+
+	2007-01-19  Keith Seitz  <keiths@redhat.com>
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc: Mark unused parameters
+	in methods and reformat.
+
+	* gnu/classpath/jdwp/natVMFrame.cc: Mark unused parameters with
+	MAYBE_UNUSED.
+
+	2007-01-18  Keith Seitz  <keiths@redhat.com>
+	From Macro Trudel <mtrudel@gmx.ch>:
+	* gnu/classpath/jdwp/natVMVirtualMachine.cc (jdwpVMInitCB):
+	Use JNICALL.
+
+	2007-01-17  Keith Seitz  <keiths@redhat.com>
+	* java/lang/natThread.cc (finish_): Add JVMTI ThreadEnd notification.
+	(_Jv_NotifyThreadStart): Add JVMTI ThreadStart notification.
+
 2007-05-03  Thomas Fitzsimmons  <fitzsim@redhat.com>
 
 	https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=237304
Index: libjava/testsuite/libjava.jvmti/geterrorname.h
===================================================================
--- libjava/testsuite/libjava.jvmti/geterrorname.h	(revision 0)
+++ libjava/testsuite/libjava.jvmti/geterrorname.h	(revision 126334)
@@ -0,0 +1,27 @@
+
+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-
+
+#ifndef __geterrorname__
+#define __geterrorname__
+
+#pragma interface
+
+#include <java/lang/Object.h>
+#include <gcj/array.h>
+
+extern "Java"
+{
+    class geterrorname;
+}
+
+class geterrorname : public ::java::lang::Object
+{
+
+public:
+  geterrorname();
+  static void do_errorname_tests();
+  static void main(JArray< ::java::lang::String * > *);
+  static ::java::lang::Class class$;
+};
+
+#endif // __geterrorname__
Index: libjava/testsuite/libjava.jvmti/jvmti-interp.exp
===================================================================
--- libjava/testsuite/libjava.jvmti/jvmti-interp.exp	(revision 0)
+++ libjava/testsuite/libjava.jvmti/jvmti-interp.exp	(revision 126334)
@@ -0,0 +1,165 @@
+# Interpreted Tests for JVMTI code.
+# These tests are used to test JVMTI functions in a purley interpreted setting
+# This file compiles the JNI code into a shared object, then invokes gij to run
+# the test.
+
+
+# Compile a single C file and produce a .so file.  OPTIONS is a list
+# of options to pass to the compiler.  Returns 0 on failure, 1 on
+# success.
+proc gcj_jni_compile_c_to_so {file {options {}}} {
+  global srcdir subdir
+  global host_triplet
+  verbose "options: $options"
+  set options_cxx $options
+  set options ""
+
+# Apple uses a different extension for shared/dynamic libraries
+# so we check against powerpc-apple-darwin and set them to
+# dylib.
+# HP-UX uses sl, so we check this too, otherwise we take so.
+
+  if { [istarget "*-*-darwin*"] } {
+      set so_extension "dylib"
+      set so_flag "-dynamiclib"
+  } elseif { [istarget "hppa*-hp-hpux*"] } {
+      set so_extension "sl"
+      set so_flag "-shared"
+  } else {
+      set so_extension "so"
+      set so_flag "-shared"
+  }
+    
+  set filename [file tail $file]
+  set name [file rootname $filename]
+  set soname lib${name}.${so_extension}
+
+  lappend options "additional_flags=${so_flag} -fPIC"
+  # Find the generated header.
+  lappend options "additional_flags=-I. -I.. -I$srcdir/$subdir"
+
+  # Ensure that the generated header has correct prototypes.
+  set cfile [file rootname $file].c
+  if { [file exists $cfile] } {
+      # This option is only valid for C sources.
+      lappend options "additional_flags=-Wmissing-prototypes"
+  }
+
+  # Find jni.h and jni_md.h.
+  lappend options "additional_flags=-I$srcdir/../include  \
+                   -I$srcdir/../classpath/include"
+
+  # Append C++ options
+  lappend options "additional_flags=$options_cxx"
+
+  set x [libjava_prune_warnings \
+	     [target_compile $file $soname executable $options]]
+  if {$x != ""} {
+      verbose "target_compile failed: $x" 2
+      fail "$filename compilation"
+      return 0
+  }
+
+  pass "$filename compilation"
+  return 1
+}
+
+# Do all the work for a single JVMTI test.  Return 0 on failure.
+proc gij_jvmti_test_one {file} {
+  global runtests
+
+  # The base name.  We use it for several purposes.
+  set main [file rootname [file tail $file]]
+  if {! [runtest_file_p $runtests $main] } {
+      # Simply skip it.
+      return 1
+  }
+
+#  if {! [bytecompile_file $file [pwd]] } {
+#     fail "bytecompile $file"
+#     # FIXME - should use `untested' on all remaining tests.
+#     # But that is hard.
+#     return 0
+#   }
+#   pass "bytecompile $file"
+
+#   if {! [gcj_jvmti_build_headers $file] } {
+#     # FIXME
+#     return 0
+#   }
+  
+  set cfile [file join [file dirname $file] nat$main.c]
+  set cxxflags ""
+  set cxxldlibflags {}
+  # If there is no `.c' file, assume there is a `.cc' file.
+  if {! [file exists $cfile] } {
+      set cfile [file join [file dirname $file] nat$main.cc]
+
+      set cxxflaglist {}
+      foreach arg [split [libjava_find_lib libstdc++-v3/src stdc++] " "] {
+          switch -glob -- $arg {
+	          "-L*" {
+	              set arg [string range $arg 2 end]
+	              lappend cxxldlibflags $arg
+	              # Strip the `.libs' directory; we link with libtool which
+	              # doesn't need it.
+	              set arg "-L[file dirname $arg]"
+       	            }
+          }
+      
+          lappend cxxflaglist $arg
+          # In case the libstdc++ is not installed yet, we pass the build
+          # directory of it to the cxxflaglist.
+          lappend cxxflaglist "-L$cxxldlibflags"
+      }
+      # If you're building the compiler with --prefix set to a place
+      # where it's not yet installed, then the linker won't be able to
+      # find the libgcc used by libgcj.dylib/libstdc++.dylib. We could pass
+      # the -dylib_file option, but that's complicated, and it's much easier
+      # to just make the linker find libgcc using -L options.
+      if { [istarget "*-*-darwin*"] } {
+	  lappend cxxflaglist "-shared-libgcc -lstdc++"
+      } else {
+	  lappend cxxflaglist "-lstdc++"
+      }
+      set cxxflags [join $cxxflaglist]
+  }
+
+  if {! [gcj_jni_compile_c_to_so $cfile $cxxflags] } {
+      # FIXME
+      return 0
+  }
+
+  libjava_arguments
+  
+  set jarfile [file join [file dirname $file] $main.jar]
+  if {! [exec_gij $jarfile [file rootname $file].out {}]} {
+      return 0
+  }
+
+  # When we succeed we remove all our clutter.
+  eval gcj_cleanup [glob -nocomplain -- ${main}.*]  \
+                   [list $main.class libnat$main.so]
+
+  return 1
+}
+
+# Run the JVMTI tests.
+proc gij_jvmti_run {} {
+  global srcdir subdir
+  global build_triplet host_triplet
+
+  # For now we only test JVMTI on native builds.
+  if {$build_triplet == $host_triplet} {
+      catch { lsort [glob -nocomplain ${srcdir}/${subdir}/interp/*.jar] \
+             } srcfiles
+
+      foreach x $srcfiles {
+        gij_jvmti_test_one $x
+      }
+  } else {
+      verbose "JVMTI tests not run in cross-compilation environment"
+  }
+}
+
+gij_jvmti_run
Index: libjava/testsuite/libjava.jvmti/getmethodname.out
===================================================================
--- libjava/testsuite/libjava.jvmti/getmethodname.out	(revision 0)
+++ libjava/testsuite/libjava.jvmti/getmethodname.out	(revision 126334)
@@ -0,0 +1,59 @@
+JVMTI GetMethodName tests
+null jmethodID: invalid method ID
+GetClassMethods: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+GetMethodName - name: none
+GetMethodName - signature: none
+GetMethodName - generic: none
+name=clone, signature=()Ljava.lang.Object;, generic=null
+names match
+signatures match
+generic not yet
+name=equals, signature=(Ljava.lang.Object;)Z, generic=null
+names match
+signatures match
+generic not yet
+name=finalize, signature=()V, generic=null
+names match
+signatures match
+generic not yet
+name=getClass, signature=()Ljava.lang.Class;, generic=null
+names match
+signatures match
+generic not yet
+name=hashCode, signature=()I, generic=null
+names match
+signatures match
+generic not yet
+name=notify, signature=()V, generic=null
+names match
+signatures match
+generic not yet
+name=notifyAll, signature=()V, generic=null
+names match
+signatures match
+generic not yet
+name=toString, signature=()Ljava.lang.String;, generic=null
+names match
+signatures match
+generic not yet
Index: libjava/testsuite/libjava.jvmti/events.h
===================================================================
--- libjava/testsuite/libjava.jvmti/events.h	(revision 0)
+++ libjava/testsuite/libjava.jvmti/events.h	(revision 126334)
@@ -0,0 +1,27 @@
+
+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-
+
+#ifndef __events__
+#define __events__
+
+#pragma interface
+
+#include <java/lang/Object.h>
+#include <gcj/array.h>
+
+extern "Java"
+{
+    class events;
+}
+
+class events : public ::java::lang::Object
+{
+
+public:
+  events();
+  static void do_events_tests();
+  static void main(JArray< ::java::lang::String * > *);
+  static ::java::lang::Class class$;
+};
+
+#endif // __events__
Index: libjava/testsuite/libjava.jvmti/natevents.cc
===================================================================
--- libjava/testsuite/libjava.jvmti/natevents.cc	(revision 125219)
+++ libjava/testsuite/libjava.jvmti/natevents.cc	(revision 126334)
@@ -200,7 +200,7 @@
   printf (" field_klass=%#llx object=%#llx field=%#llx signature_type=%c",
 	  (unsigned long long) field_klass, (unsigned long long) object,
 	  (unsigned long long) field, signature_type);
-  printf (" new_value=%#llx\n", new_value.l);
+  printf (" new_value=%#llx\n", (unsigned long long) new_value.l);
 }
 
 static void
Index: libjava/testsuite/libjava.jvmti/interp/getlocalvartable.h
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/getlocalvartable.h	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/getlocalvartable.h	(revision 126334)
@@ -0,0 +1,19 @@
+/* DO NOT EDIT THIS FILE - it is machine generated */
+
+#ifndef __getlocalvartable__
+#define __getlocalvartable__
+
+#include <jni.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+JNIEXPORT jint JNICALL Java_getlocalvartable_do_1getlocalvartable_1tests (JNIEnv *env, jclass);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __getlocalvartable__ */
Index: libjava/testsuite/libjava.jvmti/interp/getlocalvartable.out
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/getlocalvartable.out	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/getlocalvartable.out	(revision 126334)
@@ -0,0 +1,109 @@
+JVMTI getlocalvartable Interpreted Test
+Slot: 0
+  Name: this
+  Sig: Lgetlocalvartable;
+  Gen Sig: Lgetlocalvartable;
+  Start Loc: 0
+  Length: 28
+Slot: 1
+  Name: pone
+  Sig: F
+  Gen Sig: F
+  Start Loc: 0
+  Length: 28
+Slot: 2
+  Name: ptwo
+  Sig: F
+  Gen Sig: F
+  Start Loc: 0
+  Length: 28
+Slot: 3
+  Name: fone
+  Sig: F
+  Gen Sig: F
+  Start Loc: 2
+  Length: 26
+Slot: 4
+  Name: ftwo
+  Sig: F
+  Gen Sig: F
+  Start Loc: 7
+  Length: 21
+Slot: 5
+  Name: done
+  Sig: D
+  Gen Sig: D
+  Start Loc: 14
+  Length: 14
+Slot: 7
+  Name: dtwo
+  Sig: D
+  Gen Sig: D
+  Start Loc: 22
+  Length: 6
+Slot: 0
+  Name: this
+  Sig: Lgetlocalvartable;
+  Gen Sig: Lgetlocalvartable;
+  Start Loc: 0
+  Length: 25
+Slot: 1
+  Name: ipone
+  Sig: I
+  Gen Sig: I
+  Start Loc: 0
+  Length: 25
+Slot: 2
+  Name: iptwo
+  Sig: I
+  Gen Sig: I
+  Start Loc: 0
+  Length: 25
+Slot: 3
+  Name: ione
+  Sig: I
+  Gen Sig: I
+  Start Loc: 2
+  Length: 23
+Slot: 4
+  Name: itwo
+  Sig: I
+  Gen Sig: I
+  Start Loc: 7
+  Length: 18
+Slot: 5
+  Name: lone
+  Sig: J
+  Gen Sig: J
+  Start Loc: 11
+  Length: 14
+Slot: 7
+  Name: ltwo
+  Sig: J
+  Gen Sig: J
+  Start Loc: 19
+  Length: 6
+Slot: 0
+  Name: this
+  Sig: Lgetlocalvartable;
+  Gen Sig: Lgetlocalvartable;
+  Start Loc: 0
+  Length: 8
+Slot: 1
+  Name: op
+  Sig: Ljava/lang/Object;
+  Gen Sig: Ljava/lang/Object;
+  Start Loc: 0
+  Length: 8
+Slot: 2
+  Name: oone
+  Sig: Ljava/lang/Object;
+  Gen Sig: Ljava/lang/Object;
+  Start Loc: 2
+  Length: 6
+Slot: 3
+  Name: otwo
+  Sig: Ljava/lang/Object;
+  Gen Sig: Ljava/lang/Object;
+  Start Loc: 4
+  Length: 4
Index: libjava/testsuite/libjava.jvmti/interp/natgetlocalvartable.cc
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/natgetlocalvartable.cc	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/natgetlocalvartable.cc	(revision 126334)
@@ -0,0 +1,70 @@
+#include <jni.h>
+
+#include <jvmti.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "getlocalvartable.h"
+
+JNIEXPORT jint JNICALL Java_getlocalvartable_do_1getlocalvartable_1tests
+(JNIEnv *env, jclass klass)
+{
+  JavaVM *vm;
+  jint err = env->GetJavaVM (&vm);
+  if (err < 0)
+    {
+      fprintf (stderr, "error getting VM\n");
+      exit (1);
+    }
+
+  jvmtiEnv *jvmti = NULL;
+  vm->GetEnv ((void **) &jvmti, JVMTI_VERSION_1_0);
+
+  if (jvmti == NULL)
+    {
+      fprintf (stderr, "error getting jvmti environment\n");
+      exit (1);
+    }
+  
+  jint entrys;
+  jvmtiLocalVariableEntry *var_table;
+
+  jvmtiError jerr;
+  
+  jmethodID meth_ids[3];
+  
+  meth_ids[0] = env->GetMethodID (klass, "aMethod", "(FF)D");
+  meth_ids[1] = env->GetMethodID (klass, "bMethod", "(II)J");
+  meth_ids[2] = env->GetMethodID (klass, "cMethod", 
+                                  "(Ljava/lang/Object;)Ljava/lang/Object;");
+  for (int i = 0; i < 3; i++)
+    {
+      jerr = jvmti->GetLocalVariableTable (meth_ids[i], &entrys, &var_table);
+      if (jerr != JVMTI_ERROR_NONE)
+        {
+          char *error_name;
+          jvmti->GetErrorName (jerr, &error_name);
+          fprintf (stderr, "JVMTI Error: %s\n", error_name);
+          jvmti->Deallocate (reinterpret_cast<unsigned char *> (error_name));
+        }
+      else
+        {
+          for (int j = 0; j < entrys; j++)
+            {
+              printf ("Slot: %d\n", static_cast<int> (var_table[j].slot));
+              printf ("  Name: %s\n", var_table[j].name);
+              jvmti->Deallocate (reinterpret_cast<unsigned char *> (var_table[j].name));
+              printf ("  Sig: %s\n", var_table[j].signature);
+              jvmti->Deallocate (reinterpret_cast<unsigned char *> (var_table[j].signature));
+              printf ("  Gen Sig: %s\n", var_table[j].generic_signature);
+              jvmti->Deallocate (reinterpret_cast<unsigned char *> (var_table[j].generic_signature));
+              printf ("  Start Loc: %ld\n", static_cast<long> (var_table[j].start_location));
+              printf ("  Length: %d\n", static_cast<int> (var_table[j].length));
+            }
+          
+          jvmti->Deallocate (reinterpret_cast<unsigned char *> (var_table));
+        }
+    }
+    
+    return 0;
+}
Index: libjava/testsuite/libjava.jvmti/interp/getargssize.java
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/getargssize.java	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/getargssize.java	(revision 126334)
@@ -0,0 +1,36 @@
+public class getargssize
+{
+  static
+    {
+      System.loadLibrary("natgetargssize");
+    }
+
+  public int aMethod (float fone, int ione)
+  {
+    return 0;
+  }
+  
+  public long bMethod (long lone, double done, int ione)
+  {
+    return 0;
+  }
+  
+  public static boolean cMethod ()
+  {
+    return false;
+  }
+  
+  public static Object dMethod (Object op)
+  {
+    return op;
+  }
+
+  public static native int do_getargssize_tests ();
+
+  public static void main (String[] args)
+  {
+    System.out.println ("JVMTI getargssize Interpreted Test");
+
+    do_getargssize_tests ();
+  }
+}
Index: libjava/testsuite/libjava.jvmti/interp/getlocalvartable.java
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/getlocalvartable.java	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/getlocalvartable.java	(revision 126334)
@@ -0,0 +1,63 @@
+public class getlocalvartable
+{
+  public boolean done = false;
+
+  // num_frames is the number of frames > the original run () call so if
+  // num_frames = 1, the thread will have 2 frames, the original Thread.run
+  // call, plus one additional
+  public int num_frames, thread_num;
+
+  public static int num_threads = 1;
+
+  static
+    {
+      System.loadLibrary("natgetlocalvartable");
+    }
+
+  public double aMethod (float pone, float ptwo)
+  {
+    float fone, ftwo;
+    double done, dtwo;
+    
+    fone = pone;
+    ftwo = 2 * ptwo;
+    
+    done = 5 * fone;
+    dtwo = 6 * ftwo;
+    
+    return done + dtwo;
+  }
+  
+  public long bMethod (int ipone, int iptwo)
+  {
+    int ione, itwo;
+    long lone, ltwo;
+    
+    ione = ipone;
+    itwo = 5 * iptwo;
+    
+    lone = ione;
+    ltwo = 8 * itwo;
+    
+    return lone + ltwo;
+  }
+  
+  public Object cMethod (Object op)
+  {
+    Object oone, otwo;
+    oone = op;
+    otwo = oone;
+    oone = null;
+    
+    return otwo;
+  }
+
+  public static native int do_getlocalvartable_tests ();
+
+  public static void main (String[] args)
+  {
+    System.out.println ("JVMTI getlocalvartable Interpreted Test");
+
+    do_getlocalvartable_tests ();
+  }
+}
Index: libjava/testsuite/libjava.jvmti/interp/getargssize.h
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/getargssize.h	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/getargssize.h	(revision 126334)
@@ -0,0 +1,19 @@
+/* DO NOT EDIT THIS FILE - it is machine generated */
+
+#ifndef __getargssize__
+#define __getargssize__
+
+#include <jni.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+JNIEXPORT jint JNICALL Java_getargssize_do_1getargssize_1tests (JNIEnv *env, jclass);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __getargssize__ */
Index: libjava/testsuite/libjava.jvmti/interp/getargssize.out
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/getargssize.out	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/getargssize.out	(revision 126334)
@@ -0,0 +1,5 @@
+JVMTI getargssize Interpreted Test
+Method 0 requires 3 slots for its arguments
+Method 1 requires 6 slots for its arguments
+Method 2 requires 0 slots for its arguments
+Method 3 requires 1 slots for its arguments
Index: libjava/testsuite/libjava.jvmti/interp/natgetargssize.cc
===================================================================
--- libjava/testsuite/libjava.jvmti/interp/natgetargssize.cc	(revision 0)
+++ libjava/testsuite/libjava.jvmti/interp/natgetargssize.cc	(revision 126334)
@@ -0,0 +1,58 @@
+#include <jni.h>
+
+#include <jvmti.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "getargssize.h"
+
+JNIEXPORT jint JNICALL Java_getargssize_do_1getargssize_1tests
+(JNIEnv *env, jclass klass)
+{
+  JavaVM *vm;
+  jint err = env->GetJavaVM (&vm);
+  if (err < 0)
+    {
+      fprintf (stderr, "error getting VM\n");
+      exit (1);
+    }
+
+  jvmtiEnv *jvmti = NULL;
+  vm->GetEnv ((void **) &jvmti, JVMTI_VERSION_1_0);
+
+  if (jvmti == NULL)
+    {
+      fprintf (stderr, "error getting jvmti environment\n");
+      exit (1);
+    }
+  
+  jint args_size;
+
+  jvmtiError jerr;
+  
+  jmethodID meth_ids[4];
+  
+  meth_ids[0] = env->GetMethodID (klass, "aMethod", "(FI)I");
+  meth_ids[1] = env->GetMethodID (klass, "bMethod", "(JDI)J");
+  meth_ids[2] = env->GetStaticMethodID (klass, "cMethod", "()Z");
+  meth_ids[3] = env->GetStaticMethodID (klass, "dMethod", 
+                                     "(Ljava/lang/Object;)Ljava/lang/Object;");
+  for (int i = 0; i < 4; i++)
+    {
+      jerr = jvmti->GetArgumentsSize (meth_ids[i], &args_size);
+      if (jerr != JVMTI_ERROR_NONE)
+        {
+          char *error_name;
+          jvmti->GetErrorName (jerr, &error_name);
+          fprintf (stderr, "JVMTI Error: %s\n", error_name);
+          jvmti->Deallocate (reinterpret_cast<unsigned char *> (error_name));
+        }
+      else
+        {
+          printf ("Method %d requires %d slots for its arguments\n", i,
+                  args_size);
+        }
+    }
+    
+    return 0;
+}
Index: libjava/testsuite/libjava.jvmti/getmethodname.java
===================================================================
--- libjava/testsuite/libjava.jvmti/getmethodname.java	(revision 0)
+++ libjava/testsuite/libjava.jvmti/getmethodname.java	(revision 126334)
@@ -0,0 +1,10 @@
+public class getmethodname
+{
+  public static native void do_getmethodname_tests ();
+
+  public static void main (String[] args)
+  {
+    System.out.println ("JVMTI GetMethodName tests");
+    do_getmethodname_tests ();
+  }
+}
Index: libjava/testsuite/libjava.jvmti/getmethodname.h
===================================================================
--- libjava/testsuite/libjava.jvmti/getmethodname.h	(revision 0)
+++ libjava/testsuite/libjava.jvmti/getmethodname.h	(revision 126334)
@@ -0,0 +1,27 @@
+
+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-
+
+#ifndef __getmethodname__
+#define __getmethodname__
+
+#pragma interface
+
+#include <java/lang/Object.h>
+#include <gcj/array.h>
+
+extern "Java"
+{
+    class getmethodname;
+}
+
+class getmethodname : public ::java::lang::Object
+{
+
+public:
+  getmethodname();
+  static void do_getmethodname_tests();
+  static void main(JArray< ::java::lang::String * > *);
+  static ::java::lang::Class class$;
+};
+
+#endif // __getmethodname__
Index: libjava/testsuite/libjava.jvmti/natgetmethodname.cc
===================================================================
--- libjava/testsuite/libjava.jvmti/natgetmethodname.cc	(revision 0)
+++ libjava/testsuite/libjava.jvmti/natgetmethodname.cc	(revision 126334)
@@ -0,0 +1,116 @@
+#include <gcj/cni.h>
+
+#include <jvm.h>
+#include <jvmti.h>
+#include <stdio.h>
+
+#include <java/lang/Object.h>
+
+#include "getmethodname.h"
+
+static void
+print_error (jvmtiEnv *env, const char *msg,  jvmtiError err)
+{
+  char *error_msg;
+  env->GetErrorName (err, &error_msg);
+  printf ("%s: %s\n", msg, error_msg);
+  env->Deallocate (reinterpret_cast<unsigned char *> (error_msg));
+}
+
+#define NUM_METHODS 8
+static const char *function_names[] = { "clone",
+					"equals",
+					"finalize",
+					"getClass",
+					"hashCode",
+					"notify",
+					"notifyAll",
+					"toString" };
+static int
+function_index (const char *name)
+{
+  for (int i = 0; i < NUM_METHODS; ++i)
+    {
+      if (strcmp (function_names[i], name) == 0)
+	return i;
+    }
+
+  return -1;
+}
+
+void
+getmethodname::do_getmethodname_tests ()
+{
+  jvmtiEnv *env;
+  JavaVM *vm = _Jv_GetJavaVM ();
+  vm->GetEnv (reinterpret_cast<void **> (&env), JVMTI_VERSION_1_0);
+
+  jvmtiError err;
+  err = env->GetMethodName (reinterpret_cast<jmethodID> (NULL),
+			    reinterpret_cast<char **> (NULL),
+			    reinterpret_cast<char **> (NULL),
+			    reinterpret_cast<char **> (NULL));
+  print_error (env, "null jmethodID", err);
+
+  jint count;
+  jmethodID *methods;
+  err = env->GetClassMethods (&java::lang::Object::class$, &count, &methods);
+  print_error (env, "GetClassMethods", err);
+
+  char *names[NUM_METHODS], *solo_names[NUM_METHODS];
+  char *signatures[NUM_METHODS], *solo_signatures[NUM_METHODS];
+  char *generics[NUM_METHODS], *solo_generics[NUM_METHODS];
+
+  for (jint i = 0; i < count; ++i)
+    {
+      char *name, *n;
+      char *signature, *s;
+      char *generic, *g;
+      err = env->GetMethodName (methods[i], &name, &signature, &generic);
+
+      int idx = -1;
+      if (err != JVMTI_ERROR_NONE)
+	{
+	  print_error (env, "GetMethodName - all fields", err);
+	  continue;
+	}
+
+      idx = function_index (name);
+      if (idx == -1)
+	continue;
+
+      names[idx] = name;
+      signatures[idx] = signature;
+      generics[idx] = generic;
+
+      err = env->GetMethodName (methods[i], &n, NULL, NULL);
+      print_error (env, "GetMethodName - name", err);
+      solo_names[idx] = n;
+
+      err = env->GetMethodName (methods[i], NULL, &s, NULL);
+      print_error (env, "GetMethodName - signature", err);
+      solo_signatures[idx] = s;
+
+      err = env->GetMethodName (methods[i], NULL, NULL, &g);
+      print_error (env, "GetMethodName - generic", err);
+      solo_generics[idx] = g;
+    }
+
+#define WRAP(X) ((X) == NULL ? "null" : (X))
+#define MATCH(X,Y) (strcmp ((X),(Y)) == 0 ? "match" : "do not match")
+  for (int i = 0; i < NUM_METHODS; ++i)
+    {
+      printf ("name=%s, signature=%s, generic=%s\n",
+	      WRAP (names[i]), WRAP (signatures[i]), WRAP (generics[i]));
+      printf ("names %s\n", MATCH (solo_names[i], names[i]));
+      printf ("signatures %s\n", MATCH (solo_signatures[i], signatures[i]));
+      printf ("generic %s\n", "not yet");
+
+      env->Deallocate (reinterpret_cast<unsigned char *> (names[i]));
+      env->Deallocate (reinterpret_cast<unsigned char *> (solo_names[i]));
+      env->Deallocate (reinterpret_cast<unsigned char *> (signatures[i]));
+      env->Deallocate (reinterpret_cast<unsigned char *> (solo_signatures[i]));
+      env->Deallocate (reinterpret_cast<unsigned char *> (generics[i]));
+      env->Deallocate (reinterpret_cast<unsigned char *> (solo_generics[i]));
+    }
+}
Index: libjava/testsuite/libjava.jvmti/getallthreads.h
===================================================================
--- libjava/testsuite/libjava.jvmti/getallthreads.h	(revision 0)
+++ libjava/testsuite/libjava.jvmti/getallthreads.h	(revision 126334)
@@ -0,0 +1,35 @@
+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-
+
+#ifndef __getallthreads__
+#define __getallthreads__
+
+#pragma interface
+
+#include <java/lang/Thread.h>
+#include <gcj/array.h>
+
+extern "Java"
+{
+  class getallthreads;
+}
+
+class getallthreads : public ::java::lang::Thread
+{
+public:
+  getallthreads ();
+  static void do_getallthreads_tests ();
+  virtual void run ();
+  virtual void natPlaceholder ();
+  virtual void natRunner ();
+  virtual void placeholder ();
+  virtual void runner ();
+  static void main (JArray< ::java::lang::String *> *);
+  static jint thread_num;
+  static ::java::util::ArrayList *threads;
+  jint __attribute__((aligned(__alignof__( ::java::lang::Thread ))))  ex_frames;
+  jboolean done;
+
+  static ::java::lang::Class class$;
+};
+
+#endif /* __getallthreads__ */
Index: libjava/testsuite/lib/libjava.exp
===================================================================
--- libjava/testsuite/lib/libjava.exp	(revision 125219)
+++ libjava/testsuite/lib/libjava.exp	(revision 126334)
@@ -494,6 +494,52 @@
   }
 }
 
+proc exec_gij {jarfile expectFile ld_library_additions} {
+  global env
+  global libjava_ld_library_path
+  global ld_library_path
+
+  set ld_library_path "$libjava_ld_library_path"
+  if {[llength $ld_library_additions] > 0} {
+  append ld_library_path :[join $ld_library_additions :]
+  }
+	
+  set_ld_library_path_env_vars
+  if [info exists env(LD_LIBRARY_PATH)] {
+    verbose "LD_LIBRARY_PATH=$env(LD_LIBRARY_PATH)"
+  }
+  
+  set gij [libjava_find_gij]
+  set classname [file rootname [file tail $jarfile]]
+  
+  puts "LD_LIBRARY_PATH=. $gij -cp $jarfile $classname"
+	
+  set result [libjava_load $gij "-cp $jarfile $classname"]
+  set status [lindex $result 0]
+  set output [lindex $result 1]
+
+  restore_ld_library_path_env_vars
+
+  if {$status != "pass"} {
+    verbose "got $output"
+    fail "$classname run"
+    untested "$classname output"
+    return 0
+  }
+
+  set id [open $expectFile r]
+  set expected [read $id]
+  close $id
+
+  if {! [string compare $output $expected]} {
+    pass "$classname output"
+    return 1
+  } else {
+    fail "$classname output"
+    return 0
+  }
+}
+
 # Invoke a program and check its output.  EXECUTABLE is the program;
 # ARGS are the arguments to the program.  Returns 1 if tests passed
 # (or things were left untested), 0 otherwise.
Index: libjava/gij.cc
===================================================================
--- libjava/gij.cc	(revision 125219)
+++ libjava/gij.cc	(revision 126334)
@@ -121,11 +121,11 @@
         continue;
       else if (! strcmp (arg, "-jrockit"))
         continue;
-      // Ignore JVM Tool Interface options
+      // JVM Tool Interface options.
       else if (! strncmp (arg, "-agentlib:", sizeof ("-agentlib:") - 1))
-        continue;
+        add_option (vm_args, arg, NULL);
       else if (! strncmp (arg, "-agentpath:", sizeof ("-agentpath:") - 1))
-        continue;
+        add_option (vm_args, arg, NULL);
       else if (! strcmp (arg, "-classpath") || ! strcmp (arg, "-cp"))
         {
           if (i >= argc - 1)
Index: libjava/jni.cc
===================================================================
--- libjava/jni.cc	(revision 125219)
+++ libjava/jni.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // jni.cc - JNI implementation, including the jump table.
 
-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
    Free Software Foundation
 
    This file is part of libgcj.
@@ -23,6 +23,7 @@
 #include <jvmpi.h>
 #endif
 #include <jvmti.h>
+#include "jvmti-int.h"
 
 #include <java/lang/Class.h>
 #include <java/lang/ClassLoader.h>
@@ -456,6 +457,8 @@
     {
       jthrowable t = env->ex;
       env->ex = NULL;
+      if (JVMTI_REQUESTED_EVENT (Exception))
+	_Jv_ReportJVMTIExceptionThrow (t);
       throw t;
     }
 }
Index: libjava/jvmti.cc
===================================================================
--- libjava/jvmti.cc	(revision 125219)
+++ libjava/jvmti.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // jvmti.cc - JVMTI implementation
 
-/* Copyright (C) 2006 Free Software Foundation
+/* Copyright (C) 2006, 2007 Free Software Foundation
 
    This file is part of libgcj.
 
@@ -27,16 +27,18 @@
 
 #include <java/lang/Class.h>
 #include <java/lang/ClassLoader.h>
-#include <java/lang/Object.h>
 #include <java/lang/OutOfMemoryError.h>
 #include <java/lang/Thread.h>
 #include <java/lang/ThreadGroup.h>
+#include <java/lang/Thread$State.h>
 #include <java/lang/Throwable.h>
 #include <java/lang/VMClassLoader.h>
 #include <java/lang/reflect/Field.h>
 #include <java/lang/reflect/Modifier.h>
 #include <java/util/Collection.h>
 #include <java/util/HashMap.h>
+#include <java/util/concurrent/locks/Lock.h>
+#include <java/util/concurrent/locks/ReentrantReadWriteLock.h>
 #include <java/net/URL.h>
 
 static void check_enabled_events (void);
@@ -44,6 +46,10 @@
 
 namespace JVMTI
 {
+  // Is JVMTI enabled? (i.e., any jvmtiEnv created?)
+  bool enabled;
+
+  // Event notifications
   bool VMInit = false;
   bool VMDeath = false;
   bool ThreadStart = false;
@@ -99,7 +105,8 @@
   struct jvmti_env_list *next;
 };
 static struct jvmti_env_list *_jvmtiEnvironments = NULL;
-static java::lang::Object *_envListLock = NULL;
+static java::util::concurrent::locks::
+ReentrantReadWriteLock *_envListLock = NULL;
 #define FOREACH_ENVIRONMENT(Ele) \
   for (Ele = _jvmtiEnvironments; Ele != NULL; Ele = Ele->next)
 
@@ -149,18 +156,28 @@
     }						\
   while (0)
 
+#define CHECK_FOR_NATIVE_METHOD(AjmethodID)	\
+  do					\
+    {					\
+      jboolean is_native;		\
+      jvmtiError jerr = env->IsMethodNative (AjmethodID, &is_native);	\
+      if (jerr != JVMTI_ERROR_NONE)					\
+        return jerr;							\
+      if (is_native)							\
+        return JVMTI_ERROR_NATIVE_METHOD;			        \
+    }									\
+  while (0)
+
 static jvmtiError JNICALL
 _Jv_JVMTI_SuspendThread (MAYBE_UNUSED jvmtiEnv *env, jthread thread)
 {
   using namespace java::lang;
 
   THREAD_DEFAULT_TO_CURRENT (thread);
- 
-  Thread *t = reinterpret_cast<Thread *> (thread);
-  THREAD_CHECK_VALID (t);
-  THREAD_CHECK_IS_ALIVE (t);
+  THREAD_CHECK_VALID (thread);
+  THREAD_CHECK_IS_ALIVE (thread);
 
-  _Jv_Thread_t *data = _Jv_ThreadGetData (t);
+  _Jv_Thread_t *data = _Jv_ThreadGetData (thread);
   _Jv_SuspendThread (data);
   return JVMTI_ERROR_NONE;
 }
@@ -171,12 +188,10 @@
   using namespace java::lang;
 
   THREAD_DEFAULT_TO_CURRENT (thread);
+  THREAD_CHECK_VALID (thread);
+  THREAD_CHECK_IS_ALIVE (thread);
 
-  Thread *t = reinterpret_cast<Thread *> (thread);
-  THREAD_CHECK_VALID (t);
-  THREAD_CHECK_IS_ALIVE (t);
-
-  _Jv_Thread_t *data = _Jv_ThreadGetData (t);
+  _Jv_Thread_t *data = _Jv_ThreadGetData (thread);
   _Jv_ResumeThread (data);
   return JVMTI_ERROR_NONE;
 }
@@ -191,14 +206,260 @@
   if (thread == NULL)
     return JVMTI_ERROR_INVALID_THREAD;
 
-  Thread *real_thread = reinterpret_cast<Thread *> (thread);
-  THREAD_CHECK_VALID (real_thread);
-  THREAD_CHECK_IS_ALIVE (real_thread);
-  real_thread->interrupt();
+  THREAD_CHECK_VALID (thread);
+  THREAD_CHECK_IS_ALIVE (thread);
+  thread->interrupt();
   return JVMTI_ERROR_NONE;
 }
 
-jvmtiError
+// This method performs the common tasks to get and set variables of all types.
+// It is called by the _Jv_JVMTI_Get/SetLocalInt/Object/.... methods.
+static jvmtiError
+getLocalFrame (jvmtiEnv *env, jthread thread, jint depth, jint slot, char type,
+               _Jv_InterpFrame **iframe)
+{
+  using namespace java::lang;
+   
+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);
+   
+  ILLEGAL_ARGUMENT (depth < 0);
+  
+  THREAD_DEFAULT_TO_CURRENT (thread);
+  THREAD_CHECK_VALID (thread);
+  THREAD_CHECK_IS_ALIVE (thread);
+  
+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thread->frame);
+  
+  for (int i = 0; i < depth; i++)
+    {    
+      frame = frame->next;
+    
+      if (frame == NULL)
+        return JVMTI_ERROR_NO_MORE_FRAMES; 
+    }
+  
+  if (frame->frame_type == frame_native)
+    return JVMTI_ERROR_OPAQUE_FRAME;
+  
+  jint max_locals;
+  jvmtiError jerr = env->GetMaxLocals (reinterpret_cast<jmethodID> 
+                                         (frame->self->get_method ()),
+                                       &max_locals);
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr; 
+  
+  _Jv_InterpFrame *tmp_iframe = reinterpret_cast<_Jv_InterpFrame *> (frame);
+  
+  // The second slot taken up by a long type is marked as type 'x' meaning it
+  // is not valid for access since it holds only the 4 low bytes of the value.
+  if (tmp_iframe->locals_type[slot] == 'x')
+    return JVMTI_ERROR_INVALID_SLOT;
+  
+  if (tmp_iframe->locals_type[slot] != type)
+    return JVMTI_ERROR_TYPE_MISMATCH;
+  
+  // Check for invalid slots, if the type is a long type, we must check that
+  // the next slot is valid as well.
+  if (slot < 0 || slot >= max_locals 
+      || ((type == 'l' || type == 'd') && slot + 1 >= max_locals))
+    return JVMTI_ERROR_INVALID_SLOT;
+  
+  *iframe = tmp_iframe;
+  
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_GetLocalObject (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                          jobject *value)
+{
+  NULL_CHECK (value);
+
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'o', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  *value = frame->locals[slot].o;
+  
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_SetLocalObject (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                          jobject value)
+{
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'o', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  frame->locals[slot].o = value;
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_GetLocalInt (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                       jint *value)
+{
+  NULL_CHECK (value);
+  
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'i', &frame);
+
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+
+  *value = frame->locals[slot].i;
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_SetLocalInt (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                       jint value)
+{
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'i', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  frame->locals[slot].i = value;
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_GetLocalLong (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                        jlong *value)
+{
+  NULL_CHECK (value);
+
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'l', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+
+#if SIZEOF_VOID_P==8
+  *value = frame->locals[slot].l;
+#else
+  _Jv_word2 val;
+  val.ia[0] = frame->locals[slot].ia[0];
+  val.ia[1] = frame->locals[slot + 1].ia[0];
+  *value = val.l;
+#endif
+  
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_SetLocalLong (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                        jlong value)
+{
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'l', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+
+#if SIZEOF_VOID_P==8
+  frame->locals[slot].l = value;
+#else
+  _Jv_word2 val;
+	val.l = value;
+	frame->locals[slot].ia[0] = val.ia[0];
+	frame->locals[slot + 1].ia[0] = val.ia[1];
+#endif
+
+  return JVMTI_ERROR_NONE;
+}
+
+
+static jvmtiError JNICALL
+_Jv_JVMTI_GetLocalFloat (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                         jfloat *value)
+{
+  NULL_CHECK (value);
+
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'f', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  *value = frame->locals[slot].f;
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_SetLocalFloat (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                         jfloat value)
+{
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'f', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  frame->locals[slot].f = value;
+
+  return JVMTI_ERROR_NONE;
+}
+
+
+static jvmtiError JNICALL
+_Jv_JVMTI_GetLocalDouble (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                          jdouble *value)
+{
+  NULL_CHECK (value);
+
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'd', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+#if SIZEOF_VOID_P==8
+  *value = frame->locals[slot].d;
+#else
+  _Jv_word2 val;
+  val.ia[0] = frame->locals[slot].ia[0];
+  val.ia[1] = frame->locals[slot + 1].ia[0];
+  *value = val.d;
+#endif
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_SetLocalDouble (jvmtiEnv *env, jthread thread, jint depth, jint slot,
+                          jdouble value)
+{
+  _Jv_InterpFrame *frame;
+  jvmtiError jerr = getLocalFrame (env, thread, depth, slot, 'd', &frame);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+    
+#if SIZEOF_VOID_P==8
+  frame->locals[slot].d = value;
+#else
+  _Jv_word2 val;
+  val.d = value;
+  frame->locals[slot].ia[0] = val.ia[0];
+  frame->locals[slot + 1].ia[0] = val.ia[1]; 
+#endif
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
 _Jv_JVMTI_GetAllThreads(MAYBE_UNUSED jvmtiEnv *env, jint *thread_cnt,
                         jthread **threads)
 {
@@ -207,7 +468,6 @@
   NULL_CHECK (threads);
    
   using namespace java::lang;
-  Thread *thr = Thread::currentThread ();
    
   ThreadGroup *root_grp = ThreadGroup::root;
   jint estimate = root_grp->activeCount ();
@@ -217,10 +477,9 @@
   // Allocate some extra space since threads can be created between calls
   try
     { 
-      thr_arr
-			  = reinterpret_cast<JArray<Thread *> *> (JvNewObjectArray 
-			                                           ((estimate * 2),
-                                                 &Thread::class$, NULL));
+      thr_arr = reinterpret_cast<JArray<Thread *> *> (JvNewObjectArray 
+						      ((estimate * 2),
+						       &Thread::class$, NULL));
     }
   catch (java::lang::OutOfMemoryError *err)
     {
@@ -244,6 +503,85 @@
 }
 
 static jvmtiError JNICALL
+_Jv_JVMTI_GetFrameCount (MAYBE_UNUSED jvmtiEnv *env, jthread thread,
+                         jint *frame_count)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);
+  
+  NULL_CHECK (frame_count);
+	
+  using namespace java::lang;
+  
+  THREAD_DEFAULT_TO_CURRENT (thread);
+  THREAD_CHECK_VALID (thread);
+  THREAD_CHECK_IS_ALIVE (thread);
+   
+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thread->frame);
+  (*frame_count) = frame->depth ();
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_GetThreadState (MAYBE_UNUSED jvmtiEnv *env, jthread thread,
+			  jint *thread_state_ptr)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);
+
+  THREAD_DEFAULT_TO_CURRENT (thread);
+  THREAD_CHECK_VALID (thread);
+  NULL_CHECK (thread_state_ptr);
+
+  jint state = 0;
+  if (thread->isAlive ())
+    {
+      state |= JVMTI_THREAD_STATE_ALIVE;
+
+      _Jv_Thread_t *data = _Jv_ThreadGetData (thread);
+      if (_Jv_IsThreadSuspended (data))
+	state |= JVMTI_THREAD_STATE_SUSPENDED;
+
+      if (thread->isInterrupted ())
+	state |= JVMTI_THREAD_STATE_INTERRUPTED;
+
+      _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thread->frame);
+      if (frame != NULL && frame->frame_type == frame_native)
+	state |= JVMTI_THREAD_STATE_IN_NATIVE;
+
+      using namespace java::lang;
+      Thread$State *ts = thread->getState ();
+      if (ts == Thread$State::RUNNABLE)
+	state |= JVMTI_THREAD_STATE_RUNNABLE;
+      else if (ts == Thread$State::BLOCKED)
+	state |= JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;
+      else if (ts == Thread$State::TIMED_WAITING
+	       || ts == Thread$State::WAITING)
+	{
+	  state |= JVMTI_THREAD_STATE_WAITING;
+	  state |= ((ts == Thread$State::WAITING)
+		    ? JVMTI_THREAD_STATE_WAITING_INDEFINITELY
+		    : JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT);
+
+	  /* FIXME: We don't have a way to tell
+	     the caller why the thread is suspended,
+	     i.e., JVMTI_THREAD_STATE_SLEEPING,
+	     JVMTI_THREAD_STATE_PARKED, and
+	     JVMTI_THREAD_STATE_IN_OBJECT_WAIT
+	     are never set. */
+	}
+    }
+  else
+    {
+      using namespace java::lang;
+      Thread$State *ts = thread->getState ();
+      if (ts == Thread$State::TERMINATED)
+	state |= JVMTI_THREAD_STATE_TERMINATED;
+    }
+
+  *thread_state_ptr = state;
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
 _Jv_JVMTI_CreateRawMonitor (MAYBE_UNUSED jvmtiEnv *env, const char *name,
 			    jrawMonitorID *result)
 {
@@ -422,6 +760,36 @@
 }
 
 static jvmtiError JNICALL
+_Jv_JVMTI_GetClassStatus (MAYBE_UNUSED jvmtiEnv *env, jclass klass,
+			  jint *status_ptr)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);
+  NULL_CHECK (status_ptr);
+  if (klass == NULL)
+    return JVMTI_ERROR_INVALID_CLASS;
+
+  if (klass->isArray ())
+    *status_ptr = JVMTI_CLASS_STATUS_ARRAY;
+  else if (klass->isPrimitive ())
+    *status_ptr  = JVMTI_CLASS_STATUS_PRIMITIVE;
+  else
+    {
+      jbyte state = _Jv_GetClassState (klass);
+      *status_ptr = 0;
+      if (state >= JV_STATE_LINKED)
+	(*status_ptr) |= JVMTI_CLASS_STATUS_VERIFIED;
+      if (state >= JV_STATE_PREPARED)
+	(*status_ptr) |= JVMTI_CLASS_STATUS_PREPARED;
+      if (state == JV_STATE_ERROR || state == JV_STATE_PHANTOM)
+	(*status_ptr) |= JVMTI_CLASS_STATUS_ERROR;
+      else if (state == JV_STATE_DONE)
+	(*status_ptr) |= JVMTI_CLASS_STATUS_INITIALIZED;
+    }
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
 _Jv_JVMTI_GetClassModifiers (MAYBE_UNUSED jvmtiEnv *env, jclass klass,
 			     jint *mods)
 {
@@ -540,6 +908,48 @@
 }
 
 static jvmtiError JNICALL
+_Jv_JVMTI_GetMethodName (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,
+			 char **name_ptr, char **signature_ptr,
+			 char **generic_ptr)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);
+
+  if (method == NULL)
+    return JVMTI_ERROR_INVALID_METHODID;
+
+  if (name_ptr != NULL)
+    {
+      int len = static_cast<int> (method->name->len ());
+      *name_ptr = (char *) _Jv_MallocUnchecked (len + 1);
+      if (*name_ptr == NULL)
+	return JVMTI_ERROR_OUT_OF_MEMORY;
+      strncpy (*name_ptr, method->name->chars (), len);
+      (*name_ptr)[len] = '\0';
+    }
+
+  if (signature_ptr != NULL)
+    {
+      int len = static_cast<int> (method->signature->len ());
+      *signature_ptr = (char *) _Jv_MallocUnchecked (len + 1);
+      if (*signature_ptr == NULL)
+	{
+	  if (name_ptr != NULL)
+	    _Jv_Free (*name_ptr);
+	  return JVMTI_ERROR_OUT_OF_MEMORY;
+	}
+      strncpy (*signature_ptr, method->signature->chars (), len);
+      (*signature_ptr)[len] = '\0';
+    }
+
+  if (generic_ptr != NULL)
+    {
+      *generic_ptr = NULL;
+    }
+
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
 _Jv_JVMTI_GetMethodModifiers (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,
 			      jint *result)
 {
@@ -602,6 +1012,88 @@
 }
 
 static jvmtiError JNICALL
+_Jv_JVMTI_GetLocalVariableTable (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,
+                                 jint *num_locals,
+                                 jvmtiLocalVariableEntry **locals)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);
+  NULL_CHECK (num_locals);
+  NULL_CHECK (locals);
+  
+  CHECK_FOR_NATIVE_METHOD(method);
+  
+  jclass klass;
+  jvmtiError jerr = env->GetMethodDeclaringClass (method, &klass);
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+
+  _Jv_InterpMethod *imeth = reinterpret_cast<_Jv_InterpMethod *> 
+                              (_Jv_FindInterpreterMethod (klass, method));
+  
+  if (imeth == NULL)
+    return JVMTI_ERROR_INVALID_METHODID;
+  
+  jerr = env->GetMaxLocals (method, num_locals);
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  jerr = env->Allocate (static_cast<jlong> 
+                          ((*num_locals) * sizeof (jvmtiLocalVariableEntry)),
+                        reinterpret_cast<unsigned char **> (locals));
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  //the slot in the methods local_var_table to get
+  int table_slot = 0;
+  char *name;
+  char *sig;
+  char *generic_sig;
+  
+  while (table_slot < *num_locals 
+         && imeth->get_local_var_table (&name, &sig, &generic_sig,
+                                 &((((*locals)[table_slot].start_location))),
+                                 &((*locals)[table_slot].length), 
+                                 &((*locals)[table_slot].slot),
+                                 table_slot) 
+            >= 0)
+    {
+      char **str_ptr = &(*locals)[table_slot].name;
+      jerr = env->Allocate (static_cast<jlong> (strlen (name) + 1),
+                             reinterpret_cast<unsigned char **> (str_ptr));
+      if (jerr != JVMTI_ERROR_NONE)
+        return jerr;
+      strcpy ((*locals)[table_slot].name, name);
+      
+      str_ptr = &(*locals)[table_slot].signature;
+      jerr = env->Allocate (static_cast<jlong> (strlen (sig) + 1),
+                               reinterpret_cast<unsigned char **> (str_ptr));
+      if (jerr != JVMTI_ERROR_NONE)
+        return jerr;
+      strcpy ((*locals)[table_slot].signature, sig);
+      
+      str_ptr = &(*locals)[table_slot].generic_signature;
+      jerr = env->Allocate (static_cast<jlong> (strlen (generic_sig) + 1),
+                               reinterpret_cast<unsigned char **> (str_ptr));
+      if (jerr != JVMTI_ERROR_NONE)
+        return jerr;
+      strcpy ((*locals)[table_slot].generic_signature, generic_sig);
+      
+      table_slot++;
+    }
+
+  if (table_slot == 0)
+    return JVMTI_ERROR_ABSENT_INFORMATION;
+  
+  // If there are double or long variables in the table, the the table will be
+  // smaller than the max number of slots, so correct for this here.
+  if ((table_slot) < *num_locals)
+    *num_locals = table_slot;
+  
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
 _Jv_JVMTI_IsMethodNative (MAYBE_UNUSED jvmtiEnv *env, jmethodID method,
 			  jboolean *result)
 {
@@ -631,6 +1123,75 @@
 }
 
 static jvmtiError JNICALL
+_Jv_JVMTI_GetMaxLocals (jvmtiEnv *env, jmethodID method, jint *max_locals)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);
+  NULL_CHECK (max_locals);
+  
+  CHECK_FOR_NATIVE_METHOD (method);
+  
+  jclass klass;
+  jvmtiError jerr = env->GetMethodDeclaringClass (method, &klass);
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+
+  _Jv_InterpMethod *imeth = reinterpret_cast<_Jv_InterpMethod *> 
+                              (_Jv_FindInterpreterMethod (klass, method));
+    
+  if (imeth == NULL)
+    return JVMTI_ERROR_INVALID_METHODID;
+  
+  *max_locals = imeth->get_max_locals ();
+  
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
+_Jv_JVMTI_GetArgumentsSize (jvmtiEnv *env, jmethodID method, jint *size)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_START | JVMTI_PHASE_LIVE);
+  NULL_CHECK (size);
+  
+  CHECK_FOR_NATIVE_METHOD (method);
+  
+  jvmtiError jerr;
+  char *sig;
+  jint num_slots = 0;
+  
+  jerr = env->GetMethodName (method, NULL, &sig, NULL);
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  // If the method is non-static add a slot for the "this" pointer.
+  if ((method->accflags & java::lang::reflect::Modifier::STATIC) == 0)
+    num_slots++;
+  
+  for (int i = 0; sig[i] != ')'; i++)
+    {
+      if (sig[i] == 'Z' || sig[i] == 'B' || sig[i] == 'C' || sig[i] == 'S'
+          || sig[i] == 'I' || sig[i] == 'F')
+        num_slots++;
+      else if (sig[i] == 'J' || sig[i] == 'D')
+        {
+          // If this is an array of wide types it uses a single slot
+          if (i > 0 && sig[i - 1] == '[')
+            num_slots++;
+          else
+            num_slots += 2;
+        }
+      else if (sig[i] == 'L')
+        {
+          num_slots++;
+          while (sig[i] != ';')
+            i++;
+        }
+    }
+  
+  *size = num_slots;
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
 _Jv_JVMTI_GetMethodDeclaringClass (MAYBE_UNUSED jvmtiEnv *env,
 				   jmethodID method,
 				   jclass *declaring_class_ptr)
@@ -683,6 +1244,80 @@
 }
 
 static jvmtiError JNICALL
+_Jv_JVMTI_GetStackTrace (MAYBE_UNUSED jvmtiEnv *env, jthread thread,
+                         jint start_depth, jint max_frames,
+                         jvmtiFrameInfo *frames, jint *frame_count)
+{
+  REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);
+
+  ILLEGAL_ARGUMENT (max_frames < 0);
+  
+  NULL_CHECK (frames);
+  NULL_CHECK (frame_count);
+	
+  using namespace java::lang;
+  
+  THREAD_DEFAULT_TO_CURRENT (thread);
+  THREAD_CHECK_VALID (thread);
+  THREAD_CHECK_IS_ALIVE (thread);
+    
+  jvmtiError jerr = env->GetFrameCount (thread, frame_count);
+  if (jerr != JVMTI_ERROR_NONE)
+    return jerr;
+  
+  // start_depth can be either a positive number, indicating the depth of the
+  // stack at which to begin the trace, or a negative number indicating the
+  // number of frames at the bottom of the stack to exclude.  These checks
+  // ensure that it is a valid value in either case
+  
+  ILLEGAL_ARGUMENT (start_depth >= (*frame_count));
+  ILLEGAL_ARGUMENT (start_depth < (-(*frame_count)));
+  
+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thread->frame);
+
+  // If start_depth is negative use this to determine at what depth to start
+  // the trace by adding it to the length of the call stack.  This allows the
+  // use of the same frame "discarding" mechanism as for a positive start_depth
+  if (start_depth < 0)
+    start_depth = *frame_count + start_depth;
+  
+  // If start_depth > 0 "remove" start_depth frames from the beginning
+  // of the stack before beginning the trace by moving along the frame list.
+  while (start_depth > 0)
+    {
+      frame = frame->next;
+      start_depth--;
+      (*frame_count)--;
+    }
+  
+  // Now check to see if the array supplied by the agent is large enough to
+  // hold frame_count frames, after adjustment for start_depth.
+  if ((*frame_count) > max_frames)
+    (*frame_count) = max_frames;
+  
+  for (int i = 0; i < (*frame_count); i++)
+    {
+      frames[i].method = frame->self->get_method ();
+      
+      // Set the location in the frame, native frames have location = -1
+      if (frame->frame_type == frame_interpreter)
+        {
+          _Jv_InterpMethod *imeth 
+            = static_cast<_Jv_InterpMethod *> (frame->self);
+          _Jv_InterpFrame *interp_frame 
+            = static_cast<_Jv_InterpFrame *> (frame);
+          frames[i].location = imeth->insn_index (interp_frame->get_pc ());
+        }
+      else
+        frames[i].location = -1;
+        
+      frame = frame->next;
+    }
+    
+  return JVMTI_ERROR_NONE;
+}
+
+static jvmtiError JNICALL
 _Jv_JVMTI_ForceGarbageCollection (MAYBE_UNUSED jvmtiEnv *env)
 {
   REQUIRE_PHASE (env, JVMTI_PHASE_LIVE);
@@ -723,7 +1358,7 @@
     return JVMTI_ERROR_INVALID_ENVIRONMENT;
   else
     {
-      JvSynchronize dummy (_envListLock);
+      _envListLock->writeLock ()->lock ();
       if (_jvmtiEnvironments->env == env)
 	{
 	  struct jvmti_env_list *next = _jvmtiEnvironments->next;
@@ -736,12 +1371,16 @@
 	  while (e->next != NULL && e->next->env != env)
 	    e = e->next;
 	  if (e->next == NULL)
-	    return JVMTI_ERROR_INVALID_ENVIRONMENT;
+	    {
+	      _envListLock->writeLock ()->unlock ();
+	      return JVMTI_ERROR_INVALID_ENVIRONMENT;
+	    }
 
 	  struct jvmti_env_list *next = e->next->next;
 	  _Jv_Free (e->next);
 	  e->next = next;
 	}
+      _envListLock->writeLock ()->unlock ();
     }
 
   _Jv_Free (env);
@@ -1042,18 +1681,24 @@
 
   int index = EVENT_INDEX (type); // safe since caller checks this
 
-  JvSynchronize dummy (_envListLock);
-  struct jvmti_env_list *e;
-  FOREACH_ENVIRONMENT (e)
+  if (_jvmtiEnvironments != NULL)
     {
-      char *addr
-	= reinterpret_cast<char *> (&e->env->callbacks) + offset;
-      void **callback = reinterpret_cast<void **> (addr);
-      if (e->env->enabled[index] && *callback != NULL)
+      _envListLock->readLock ()->lock ();
+      struct jvmti_env_list *e;
+      FOREACH_ENVIRONMENT (e)
 	{
-	  *enabled = true;
-	  return;
+	  char *addr
+	    = reinterpret_cast<char *> (&e->env->callbacks) + offset;
+	  void **callback = reinterpret_cast<void **> (addr);
+	  if (e->env->enabled[index] && *callback != NULL)
+	    {
+	      *enabled = true;
+	      _envListLock->readLock ()->unlock ();
+	      return;
+	    }
 	}
+
+      _envListLock->readLock ()->unlock ();
     }
 
   *enabled = false;
@@ -1102,10 +1747,8 @@
 
   if (event_thread != NULL)
     {
-      using namespace java::lang;
-      Thread *t = reinterpret_cast<Thread *> (event_thread);
-      THREAD_CHECK_VALID (t);
-      THREAD_CHECK_IS_ALIVE (t);
+      THREAD_CHECK_VALID (event_thread);
+      THREAD_CHECK_IS_ALIVE (event_thread);
     }
 
   bool enabled;
@@ -1421,21 +2064,21 @@
   UNIMPLEMENTED,		// GetTopThreadGroups
   UNIMPLEMENTED,		// GetThreadGroupInfo
   UNIMPLEMENTED,		// GetThreadGroupChildren
-  UNIMPLEMENTED,		// GetFrameCount
-  UNIMPLEMENTED,		// GetThreadState
+  _Jv_JVMTI_GetFrameCount,		// GetFrameCount
+  _Jv_JVMTI_GetThreadState,	// GetThreadState
   RESERVED,			// reserved18
   UNIMPLEMENTED,		// GetFrameLocation
   UNIMPLEMENTED,		// NotifyPopFrame
-  UNIMPLEMENTED,		// GetLocalObject
-  UNIMPLEMENTED,		// GetLocalInt
-  UNIMPLEMENTED,		// GetLocalLong
-  UNIMPLEMENTED,		// GetLocalFloat
-  UNIMPLEMENTED,		// GetLocalDouble
-  UNIMPLEMENTED,		// SetLocalObject
-  UNIMPLEMENTED,		// SetLocalInt
-  UNIMPLEMENTED,		// SetLocalLong
-  UNIMPLEMENTED,		// SetLocalFloat
-  UNIMPLEMENTED,		// SetLocalDouble
+  _Jv_JVMTI_GetLocalObject,		// GetLocalObject
+  _Jv_JVMTI_GetLocalInt,		// GetLocalInt
+  _Jv_JVMTI_GetLocalLong,		// GetLocalLong
+  _Jv_JVMTI_GetLocalFloat,		// GetLocalFloat
+  _Jv_JVMTI_GetLocalDouble,		// GetLocalDouble
+  _Jv_JVMTI_SetLocalObject,		// SetLocalObject
+  _Jv_JVMTI_SetLocalInt,		// SetLocalInt
+  _Jv_JVMTI_SetLocalLong,		// SetLocalLong
+  _Jv_JVMTI_SetLocalFloat,		// SetLocalFloat
+  _Jv_JVMTI_SetLocalDouble,		// SetLocalDouble
   _Jv_JVMTI_CreateRawMonitor,	// CreateRawMonitor
   _Jv_JVMTI_DestroyRawMonitor,	// DestroyRawMonitor
   _Jv_JVMTI_RawMonitorEnter,	// RawMonitorEnter
@@ -1454,7 +2097,7 @@
   _Jv_JVMTI_Allocate,		// Allocate
   _Jv_JVMTI_Deallocate,		// Deallocate
   UNIMPLEMENTED,		// GetClassSignature
-  UNIMPLEMENTED,		// GetClassStatus
+  _Jv_JVMTI_GetClassStatus,	// GetClassStatus
   UNIMPLEMENTED,		// GetSourceFileName
   _Jv_JVMTI_GetClassModifiers,	// GetClassModifiers
   _Jv_JVMTI_GetClassMethods,	// GetClassMethods
@@ -1469,15 +2112,15 @@
   UNIMPLEMENTED,		// GetFieldDeclaringClass
   _Jv_JVMTI_GetFieldModifiers,	// GetFieldModifiers
   _Jv_JVMTI_IsFieldSynthetic,	// IsFieldSynthetic
-  UNIMPLEMENTED,		// GetMethodName
+  _Jv_JVMTI_GetMethodName,	// GetMethodName
   _Jv_JVMTI_GetMethodDeclaringClass,  // GetMethodDeclaringClass
   _Jv_JVMTI_GetMethodModifiers,	// GetMethodModifers
   RESERVED,			// reserved67
-  UNIMPLEMENTED,		// GetMaxLocals
-  UNIMPLEMENTED,		// GetArgumentsSize
+  _Jv_JVMTI_GetMaxLocals,		// GetMaxLocals
+  _Jv_JVMTI_GetArgumentsSize,		// GetArgumentsSize
   _Jv_JVMTI_GetLineNumberTable,	// GetLineNumberTable
   UNIMPLEMENTED,		// GetMethodLocation
-  UNIMPLEMENTED,		// GetLocalVariableTable
+  _Jv_JVMTI_GetLocalVariableTable,		// GetLocalVariableTable
   RESERVED,			// reserved73
   RESERVED,			// reserved74
   UNIMPLEMENTED,		// GetBytecodes
@@ -1509,7 +2152,7 @@
   UNIMPLEMENTED,		// GetThreadListStackTraces
   UNIMPLEMENTED,		// GetThreadLocalStorage
   UNIMPLEMENTED,		// SetThreadLocalStorage
-  UNIMPLEMENTED,		// GetStackTrace
+  _Jv_JVMTI_GetStackTrace,		// GetStackTrace
   RESERVED,			// reserved105
   UNIMPLEMENTED,		// GetTag
   UNIMPLEMENTED,		// SetTag
@@ -1568,25 +2211,27 @@
   _Jv_JVMTIEnv *env
     = (_Jv_JVMTIEnv *) _Jv_MallocUnchecked (sizeof (_Jv_JVMTIEnv));
   env->p = &_Jv_JVMTI_Interface;
+  struct jvmti_env_list *element
+    = (struct jvmti_env_list *) _Jv_MallocUnchecked (sizeof (struct jvmti_env_list));
+  element->env = env;
+  element->next = NULL;
 
-  {
-    JvSynchronize dummy (_envListLock);
-    struct jvmti_env_list *element
-      = (struct jvmti_env_list *) _Jv_MallocUnchecked (sizeof (struct jvmti_env_list));
-    element->env = env;
-    element->next = NULL;
+  _envListLock->writeLock ()->lock ();
+  if (_jvmtiEnvironments == NULL)
+    _jvmtiEnvironments = element;
+  else
+    {
+      struct jvmti_env_list *e;
+      for (e = _jvmtiEnvironments; e->next != NULL; e = e->next)
+	;
+      e->next = element;
+    }
+  _envListLock->writeLock ()->unlock ();
 
-    if (_jvmtiEnvironments == NULL)
-      _jvmtiEnvironments = element;
-    else
-      {
-	struct jvmti_env_list *e;
-	for (e = _jvmtiEnvironments; e->next != NULL; e = e->next)
-	  ;
-	e->next = element;
-      }
-  }
-
+  /* Mark JVMTI active. This is used to force the interpreter
+     to use either debugging or non-debugging code. Once JVMTI
+     has been enabled, the non-debug interpreter cannot be used. */
+  JVMTI::enabled = true;
   return env;
 }
 
@@ -1594,7 +2239,8 @@
 _Jv_JVMTI_Init ()
 {
   _jvmtiEnvironments = NULL;
-  _envListLock = new java::lang::Object ();
+  _envListLock
+    = new java::util::concurrent::locks::ReentrantReadWriteLock ();
 
   // No environments, so this should set all JVMTI:: members to false
   check_enabled_events ();
@@ -1958,7 +2604,7 @@
   va_list args;
   va_start (args, event_thread);
 
-  JvSynchronize dummy (_envListLock);
+  _envListLock->readLock ()->lock ();
   struct jvmti_env_list *e;
   FOREACH_ENVIRONMENT (e)
     {
@@ -1974,6 +2620,6 @@
 	  post_event (e->env, type, event_thread, args);
 	}
     }
-
+  _envListLock->readLock ()->unlock ();
   va_end (args);
 }
Index: libjava/prims.cc
===================================================================
--- libjava/prims.cc	(revision 125219)
+++ libjava/prims.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // prims.cc - Code for core of runtime environment.
 
-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation
+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -32,6 +32,9 @@
 #include <java/lang/ThreadGroup.h>
 #endif
 
+#include <jvmti.h>
+#include "jvmti-int.h"
+
 #ifndef DISABLE_GETENV_PROPERTIES
 #include <ctype.h>
 #include <java-props.h>
@@ -66,8 +69,6 @@
 #include <execution.h>
 #include <gnu/classpath/jdwp/Jdwp.h>
 #include <gnu/classpath/jdwp/VMVirtualMachine.h>
-#include <gnu/classpath/jdwp/event/VmDeathEvent.h>
-#include <gnu/classpath/jdwp/event/VmInitEvent.h>
 #include <gnu/java/lang/MainThread.h>
 
 #ifdef USE_LTDL
@@ -107,6 +108,16 @@
 static char defaultJdwpOptions[] = "";
 static char *jdwpOptions = defaultJdwpOptions;
 
+// Typedefs for JVMTI agent functions.
+typedef jint jvmti_agent_onload_func (JavaVM *vm, char *options,
+                                      void *reserved);
+typedef jint jvmti_agent_onunload_func (JavaVM *vm);
+
+// JVMTI agent function pointers.
+static jvmti_agent_onload_func *jvmti_agentonload = NULL;
+static jvmti_agent_onunload_func *jvmti_agentonunload = NULL;
+static char *jvmti_agent_opts;
+
 // Argument support.
 int
 _Jv_GetNbArgs (void)
@@ -1357,7 +1368,63 @@
   return 0;
 }
 
+// This function loads the agent functions for JVMTI from the library indicated
+// by name.  It returns a negative value on failure, the value of which
+// indicates where ltdl failed, it also prints an error message.
 static jint
+load_jvmti_agent (const char *name)
+{
+#ifdef USE_LTDL
+  if (lt_dlinit ())
+    {
+      fprintf (stderr, 
+              "libgcj: Error in ltdl init while loading agent library.\n");
+      return -1;
+    }
+ 
+  lt_dlhandle lib = lt_dlopenext (name);
+  if (!lib)
+    {
+      fprintf (stderr, 
+               "libgcj: Error opening agent library.\n");
+      return -2;
+    }
+
+  if (lib)
+    {
+      jvmti_agentonload 
+        = (jvmti_agent_onload_func *) lt_dlsym (lib, "Agent_OnLoad");
+ 
+      if (!jvmti_agentonload)
+        {
+          fprintf (stderr, 
+                   "libgcj: Error finding agent function in library %s.\n",
+                   name);
+          lt_dlclose (lib);
+          lib = NULL;
+          return -4;
+        }
+      else
+        {
+          jvmti_agentonunload
+            = (jvmti_agent_onunload_func *) lt_dlsym (lib, "Agent_OnUnload");
+	   
+          return 0;
+        }
+    }
+  else
+    {
+      fprintf (stderr, "libgcj: Library %s not found in library path.\n", name);
+      return -3;
+    }
+
+#endif /* USE_LTDL */
+
+  // If LTDL cannot be used, return an error code indicating this.
+  return -99;
+}
+
+static jint
 parse_init_args (JvVMInitArgs* vm_args)
 {
   // if _Jv_Compiler_Properties is non-NULL then it needs to be
@@ -1409,6 +1476,95 @@
 
 	  continue;
 	}
+      else if (! strncmp (option_string, "-agentlib", sizeof ("-agentlib") - 1))
+	{
+          char *strPtr;
+	                                              
+          if (strlen(option_string) > (sizeof ("-agentlib:") - 1))
+            strPtr = &option_string[sizeof ("-agentlib:") - 1];
+          else
+            {
+              fprintf (stderr,
+                "libgcj: Malformed agentlib argument %s: expected lib name\n",
+                option_string);
+              return -1;
+            }
+
+          // These are optional arguments to pass to the agent library.
+          jvmti_agent_opts = strchr (strPtr, '=');
+   
+          if (! strncmp (strPtr, "jdwp", 4))
+            {    	
+              // We want to run JDWP here so set the correct variables.
+              remoteDebug = true;
+              jdwpOptions = ++jvmti_agent_opts;
+            }
+          else
+            {
+              jint nameLength;
+   
+              if (jvmti_agent_opts == NULL)
+                nameLength = strlen (strPtr);
+              else
+                {
+                  nameLength = jvmti_agent_opts - strPtr;
+                  jvmti_agent_opts++;
+                }
+               
+              char lib_name[nameLength + 3 + 1];
+              strcpy (lib_name, "lib");
+              strncat (lib_name, strPtr, nameLength);
+      
+              jint result = load_jvmti_agent (lib_name);
+      
+              if (result < 0)
+	        {
+	          return -1;
+	        }
+            }
+    
+          continue;
+	}
+      else if (! strncmp (option_string, "-agentpath:", 
+                          sizeof ("-agentpath:") - 1))
+	{
+          char *strPtr;
+	                                              
+          if (strlen(option_string) > 10)
+            strPtr = &option_string[10];
+          else
+            {
+              fprintf (stderr,
+                "libgcj: Malformed agentlib argument %s: expected lib path\n",
+                option_string);
+              return -1;
+            }
+		
+          // These are optional arguments to pass to the agent library.
+          jvmti_agent_opts = strchr (strPtr, '=');
+    
+          jint nameLength;
+   
+          if (jvmti_agent_opts == NULL)
+            nameLength = strlen (strPtr);
+          else
+            {
+              nameLength = jvmti_agent_opts - strPtr;
+              jvmti_agent_opts++;
+            }
+    
+          char lib_name[nameLength + 3 + 1];
+          strcpy (lib_name, "lib");
+          strncat (lib_name, strPtr, nameLength);
+          jint result = load_jvmti_agent (strPtr);
+
+          if (result < 0)
+            {
+              return -1;
+            }
+	
+          continue;
+	}
       else if (vm_args->ignoreUnrecognized)
         {
           if (option_string[0] == '_')
@@ -1569,6 +1725,10 @@
 	main_thread = new MainThread (JvNewStringUTF (name),
 				      arg_vec, is_jar);
       _Jv_AttachCurrentThread (main_thread);
+      
+      // Start JVMTI if an agent function has been found.
+      if (jvmti_agentonload)
+        (*jvmti_agentonload) (_Jv_GetJavaVM (), jvmti_agent_opts, NULL);
 
       // Start JDWP
       if (remoteDebug)
@@ -1583,11 +1743,9 @@
 	  // Wait for JDWP to initialize and start
 	  jdwp->join ();
 	}
-
-      // Send VmInit
-      gnu::classpath::jdwp::event::VmInitEvent *event;
-      event = new gnu::classpath::jdwp::event::VmInitEvent (main_thread);
-      gnu::classpath::jdwp::Jdwp::notify (event);
+      // Send VMInit
+      if (JVMTI_REQUESTED_EVENT (VMInit))
+	_Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_INIT, main_thread);
     }
   catch (java::lang::Throwable *t)
     {
@@ -1602,13 +1760,17 @@
 
   _Jv_ThreadRun (main_thread);
 
-  // Notify debugger of VM's death
-  if (gnu::classpath::jdwp::Jdwp::isDebugging)
+  // Send VMDeath
+  if (JVMTI_REQUESTED_EVENT (VMDeath))
     {
-      using namespace gnu::classpath::jdwp;
-      event::VmDeathEvent *event = new event::VmDeathEvent ();
-      Jdwp::notify (event);
+      java::lang::Thread *thread = java::lang::Thread::currentThread ();
+      JNIEnv *jni_env = _Jv_GetCurrentJNIEnv ();
+      _Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_DEATH, thread, jni_env);
     }
+    
+   // Run JVMTI AgentOnUnload if it exists and an agent is loaded.
+  if (jvmti_agentonunload)
+    (*jvmti_agentonunload) (_Jv_GetJavaVM ());
 
   // If we got here then something went wrong, as MainThread is not
   // supposed to terminate.
Index: libjava/link.cc
===================================================================
--- libjava/link.cc	(revision 125219)
+++ libjava/link.cc	(revision 126334)
@@ -33,6 +33,8 @@
 #include <limits.h>
 #include <java-cpool.h>
 #include <execution.h>
+#include <jvmti.h>
+#include "jvmti-int.h"
 #include <java/lang/Class.h>
 #include <java/lang/String.h>
 #include <java/lang/StringBuffer.h>
@@ -1982,33 +1984,35 @@
   if (klass->state >= state)
     return;
 
-  JvSynchronize sync (klass);
-
-  // This is similar to the strategy for class initialization.  If we
-  // already hold the lock, just leave.
   java::lang::Thread *self = java::lang::Thread::currentThread();
-  while (klass->state <= state
-	 && klass->thread 
-	 && klass->thread != self)
-    klass->wait ();
 
-  java::lang::Thread *save = klass->thread;
-  klass->thread = self;
+  {
+    JvSynchronize sync (klass);
 
-  // Allocate memory for static fields and constants.
-  if (GC_base (klass) && klass->fields && ! GC_base (klass->fields))
-    {
-      jsize count = klass->field_count;
-      if (count)
-	{
-	  _Jv_Field* fields 
-	    = (_Jv_Field*) _Jv_AllocRawObj (count * sizeof (_Jv_Field));
-	  memcpy ((void*)fields,
-		  (void*)klass->fields,
-		  count * sizeof (_Jv_Field));
-	  klass->fields = fields;
-	}
-    }
+    // This is similar to the strategy for class initialization.  If we
+    // already hold the lock, just leave.
+    while (klass->state <= state
+	   && klass->thread 
+	   && klass->thread != self)
+      klass->wait ();
+
+    java::lang::Thread *save = klass->thread;
+    klass->thread = self;
+
+    // Allocate memory for static fields and constants.
+    if (GC_base (klass) && klass->fields && ! GC_base (klass->fields))
+      {
+	jsize count = klass->field_count;
+	if (count)
+	  {
+	    _Jv_Field* fields 
+	      = (_Jv_Field*) _Jv_AllocRawObj (count * sizeof (_Jv_Field));
+	    memcpy ((void*)fields,
+		    (void*)klass->fields,
+		    count * sizeof (_Jv_Field));
+	    klass->fields = fields;
+	  }
+      }
       
   // Print some debugging info if requested.  Interpreted classes are
   // handled in defineclass, so we only need to handle the two
@@ -2022,49 +2026,59 @@
       ++gcj::loadedClasses;
     }
 
-  try
-    {
-      if (state >= JV_STATE_LOADING && klass->state < JV_STATE_LOADING)
-	{
-	  ensure_supers_installed (klass);
-	  klass->set_state(JV_STATE_LOADING);
-	}
+    try
+      {
+	if (state >= JV_STATE_LOADING && klass->state < JV_STATE_LOADING)
+	  {
+	    ensure_supers_installed (klass);
+	    klass->set_state(JV_STATE_LOADING);
+	  }
 
-      if (state >= JV_STATE_LOADED && klass->state < JV_STATE_LOADED)
-	{
-	  ensure_method_table_complete (klass);
-	  klass->set_state(JV_STATE_LOADED);
-	}
+	if (state >= JV_STATE_LOADED && klass->state < JV_STATE_LOADED)
+	  {
+	    ensure_method_table_complete (klass);
+	    klass->set_state(JV_STATE_LOADED);
+	  }
 
-      if (state >= JV_STATE_PREPARED && klass->state < JV_STATE_PREPARED)
-	{
-	  ensure_fields_laid_out (klass);
-	  make_vtable (klass);
-	  layout_interface_methods (klass);
-	  prepare_constant_time_tables (klass);
-	  klass->set_state(JV_STATE_PREPARED);
-	}
+	if (state >= JV_STATE_PREPARED && klass->state < JV_STATE_PREPARED)
+	  {
+	    ensure_fields_laid_out (klass);
+	    make_vtable (klass);
+	    layout_interface_methods (klass);
+	    prepare_constant_time_tables (klass);
+	    klass->set_state(JV_STATE_PREPARED);
+	  }
 
-      if (state >= JV_STATE_LINKED && klass->state < JV_STATE_LINKED)
-	{
-	  if (gcj::verifyClasses)
-	    verify_class (klass);
+	if (state >= JV_STATE_LINKED && klass->state < JV_STATE_LINKED)
+	  {
+	    if (gcj::verifyClasses)
+	      verify_class (klass);
 
-	  ensure_class_linked (klass);
-	  link_exception_table (klass);
-	  link_symbol_table (klass);
-	  klass->set_state(JV_STATE_LINKED);
-	}
-    }
-  catch (java::lang::Throwable *exc)
+	    ensure_class_linked (klass);
+	    link_exception_table (klass);
+	    link_symbol_table (klass);
+	    klass->set_state(JV_STATE_LINKED);
+	  }
+      }
+    catch (java::lang::Throwable *exc)
+      {
+	klass->thread = save;
+	klass->set_state(JV_STATE_ERROR);
+	throw exc;
+      }
+
+    klass->thread = save;
+
+    if (klass->state == JV_STATE_ERROR)
+      throw new java::lang::LinkageError;
+  }
+
+  if (__builtin_expect (klass->state == JV_STATE_LINKED, false)
+      && state >= JV_STATE_LINKED
+      && JVMTI_REQUESTED_EVENT (ClassPrepare))
     {
-      klass->thread = save;
-      klass->set_state(JV_STATE_ERROR);
-      throw exc;
+      JNIEnv *jni_env = _Jv_GetCurrentJNIEnv ();
+      _Jv_JVMTI_PostEvent (JVMTI_EVENT_CLASS_PREPARE, self, jni_env,
+			   klass);
     }
-
-  klass->thread = save;
-
-  if (klass->state == JV_STATE_ERROR)
-    throw new java::lang::LinkageError;
 }
Index: libjava/gnu/classpath/jdwp/VMMethod.java
===================================================================
--- libjava/gnu/classpath/jdwp/VMMethod.java	(revision 125219)
+++ libjava/gnu/classpath/jdwp/VMMethod.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* VMMethod.java -- a method in a virtual machine
-   Copyright (C) 2006 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -175,4 +175,15 @@
   {
     return VMVirtualMachine.getClassMethod(klass, bb.getLong());
   }
+
+  public boolean equals(Object obj)
+  {
+    if (obj instanceof VMMethod)
+      {
+	VMMethod m = (VMMethod) obj;
+	return (getId() == m.getId());
+      }
+
+    return false;
+  }
 }
Index: libjava/gnu/classpath/jdwp/natVMFrame.cc
===================================================================
--- libjava/gnu/classpath/jdwp/natVMFrame.cc	(revision 125219)
+++ libjava/gnu/classpath/jdwp/natVMFrame.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // natFrame.cc -- native support for VMFrame.java
 
-/* Copyright (C) 2006 Free Software Foundation
+/* Copyright (C) 2006, 2007 Free Software Foundation
 
    This file is part of libgcj.
 
@@ -8,19 +8,331 @@
 Libgcj License. Please consult the file "LIBGCJ_LICENSE" for
 details. */
 
+#include <config.h>
 #include <gcj/cni.h>
+#include <jvm.h>
+#include <jvmti.h>
+#include "jvmti-int.h"
 
+#include <java-interp.h>
+
 #include <gnu/classpath/jdwp/VMFrame.h>
+#include <gnu/classpath/jdwp/VMVirtualMachine.h>
+#include <gnu/classpath/jdwp/exception/InvalidFrameException.h>
+#include <gnu/classpath/jdwp/exception/InvalidSlotException.h>
+#include <gnu/classpath/jdwp/exception/InvalidThreadException.h>
+#include <gnu/classpath/jdwp/exception/JdwpInternalErrorException.h>
+#include <gnu/classpath/jdwp/exception/TypeMismatchException.h>
+#include <gnu/classpath/jdwp/util/NullObject.h>
+#include <gnu/classpath/jdwp/value/ArrayValue.h>
+#include <gnu/classpath/jdwp/value/ByteValue.h>
+#include <gnu/classpath/jdwp/value/BooleanValue.h>
+#include <gnu/classpath/jdwp/value/CharValue.h>
+#include <gnu/classpath/jdwp/value/DoubleValue.h>
+#include <gnu/classpath/jdwp/value/FloatValue.h>
+#include <gnu/classpath/jdwp/value/IntValue.h>
+#include <gnu/classpath/jdwp/value/LongValue.h>
+#include <gnu/classpath/jdwp/value/ObjectValue.h>
+#include <gnu/classpath/jdwp/value/ShortValue.h>
+#include <gnu/classpath/jdwp/value/Value.h>
+#include <gnu/classpath/jdwp/value/VoidValue.h>
 
 using namespace java::lang;
+using namespace gnu::classpath::jdwp;
+using namespace gnu::classpath::jdwp::exception;
 
-Object*
-gnu::classpath::jdwp::VMFrame::getValue (jint slot)
+
+// All the jvmti GetLocalXX and SetLocalXX functions return the same potential
+// errors, so this function handles them all and throws the appropriate JDWP
+// exception.
+static void
+checkJVMTIError (jvmtiEnv *env, jthread thread, jvmtiError jerr, jint slot,
+                 jbyte sig)
 {
-  return 0;
+  if (jerr != JVMTI_ERROR_NONE)
+    {
+      char *error;
+      env->GetErrorName (jerr, &error);
+      String *msg = reinterpret_cast<String *> (JvNewStringUTF (error));
+      env->Deallocate ((unsigned char *) error);
+      
+      if (jerr == JVMTI_ERROR_INVALID_THREAD)
+        throw new InvalidThreadException ((jlong) thread);
+      else if (jerr == JVMTI_ERROR_NO_MORE_FRAMES)
+        throw new InvalidFrameException (msg);
+      else if (jerr == JVMTI_ERROR_INVALID_SLOT)
+        throw new InvalidSlotException (slot);
+      else if (jerr == JVMTI_ERROR_TYPE_MISMATCH)
+        throw new TypeMismatchException (sig);
+      else
+        throw new JdwpInternalErrorException (msg);
+    }
 }
 
-void
-gnu::classpath::jdwp::VMFrame::setValue (jint slot, Object* value)
+
+static jobject
+getObjectJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)
 {
+  jobject value;
+  jvmtiError jerr = env->GetLocalObject (thread, depth, slot, &value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+  
+  return value;
 }
+
+static void
+setObjectJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth,
+                jbyte sig, jobject value)
+{
+  if (value->getClass ()->isAssignableFrom (&util::NullObject::class$))
+    value = NULL;
+	
+  jvmtiError jerr = env->SetLocalObject (thread, depth, slot, value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+}
+
+static jint
+getIntJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)
+{
+  jint value;
+  jvmtiError jerr = env->GetLocalInt (thread, depth, slot, &value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+  return value;
+}
+
+static void
+setIntJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig,
+             jint value)
+{
+  jvmtiError jerr = env->SetLocalInt (thread, depth, slot, value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+}
+
+static jlong
+getLongJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)
+{
+  jlong value;
+  jvmtiError jerr = env->GetLocalLong (thread, depth, slot, &value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+  
+  return value;
+}
+
+static void
+setLongJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig,
+              jlong value)
+{
+  jvmtiError jerr = env->SetLocalLong (thread, depth, slot, value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+}
+
+static jfloat
+getFloatJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig)
+{
+  jfloat value;
+  jvmtiError jerr = env->GetLocalFloat (thread, depth, slot, &value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+  
+  return value;
+}
+
+static void
+setFloatJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, jbyte sig,
+               jfloat value)
+{
+  jvmtiError jerr = env->SetLocalFloat (thread, depth, slot, value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+}
+
+static jdouble
+getDoubleJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth,
+                jbyte sig)
+{
+  jdouble value;
+  jvmtiError jerr = env->GetLocalDouble (thread, depth, slot, &value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+  
+  return value;
+}
+
+static void
+setDoubleJVMTI (jvmtiEnv *env, jthread thread, jint slot, jint depth, 
+                jbyte sig, jdouble value)
+{
+  jvmtiError jerr = env->SetLocalDouble (thread, depth, slot, value);
+  
+  checkJVMTIError (env, thread, jerr, slot, sig);
+}
+
+// This is necessary since JVMTI requires a stack depth as a parameter in all
+// its local variable functions.  Since JDWP needs frameids, we have to run
+// through the call stack to translate these ids into the parameters JVMTI
+// wants.
+static jint
+getFrameDepth (_Jv_Frame *frame)
+{
+  jint depth = 0;
+  _Jv_Frame *top_frame = (_Jv_Frame *) frame->thread->frame;
+  jint num_frames = VMVirtualMachine::getFrameCount (frame->thread);
+  
+  while (frame != top_frame)
+    {
+      top_frame = top_frame->next;
+      depth++;
+      
+      if (depth >= num_frames || top_frame == NULL)
+        throw new InvalidFrameException ((jlong) frame);
+    }
+  
+  return depth;
+}
+
+using namespace gnu::classpath::jdwp::value;
+
+Value *
+gnu::classpath::jdwp::VMFrame::getValue (jint slot, jbyte sig)
+{
+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (id);
+  jint depth = getFrameDepth (frame);
+  jthread thread = reinterpret_cast<jthread> (frame->thread);
+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();
+  
+  Value *value = NULL;
+
+  switch (sig)
+    {
+    case 'B':
+      value = new ByteValue ((jbyte) getIntJVMTI (env, thread, slot, depth, 
+                                                  sig));
+      break;
+    case 'Z':
+      value = new BooleanValue ((jboolean) getIntJVMTI (env, thread, slot,
+                                                        depth, sig));
+      break;
+    case 'C':
+      value = new CharValue ((jchar) getIntJVMTI (env, thread, slot, depth,
+                                                  sig));
+      break;
+    case 'S':
+      value = new ShortValue ((jshort) getIntJVMTI (env, thread, slot, depth,
+                                                    sig));
+      break;
+    case 'I':
+      value = new IntValue (getIntJVMTI (env, thread, slot, depth, sig));
+      break;
+    case 'J':
+      value = new LongValue (getLongJVMTI (env, thread, slot, depth, sig));
+      break;
+    case 'F':
+      value = new FloatValue (getFloatJVMTI (env, thread, slot, depth, sig));
+      break;
+    case 'D':
+      value = new DoubleValue (getDoubleJVMTI (env, thread, slot, depth, sig));
+      break;
+    case 'V':
+      value = new VoidValue ();
+      break;
+    case '[':
+      {
+        Object *obj = getObjectJVMTI (env, thread, slot, depth, sig);
+        if (obj == NULL)
+          obj = new util::NullObject ();
+        value = new ArrayValue (obj);
+        break;
+      }
+    default:
+      Object *obj = getObjectJVMTI (env, thread, slot, depth, sig);
+      if (obj == NULL)
+        obj = new util::NullObject ();
+      value = new ObjectValue (obj);
+      break;
+    }
+  
+  return value;
+}
+
+void
+gnu::classpath::jdwp::VMFrame::setValue (jint slot, Value* value)
+{	
+  jbyte sig = value->getTag ();
+  
+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (id);
+  jint depth = getFrameDepth (frame);
+  jthread thread = reinterpret_cast<jthread> (frame->thread);
+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();
+  
+  switch (sig)
+    {
+    case 'B':
+      {
+        ByteValue *val = reinterpret_cast<ByteValue *> (value);
+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());
+        break;
+      }
+    case 'Z':
+      {
+        BooleanValue *val = reinterpret_cast<BooleanValue *> (value);
+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());
+        break;
+      }
+    case 'C':
+      {
+        CharValue *val = reinterpret_cast<CharValue *> (value);
+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());
+        break;
+      }
+    case 'S':
+      {
+        ShortValue *val = reinterpret_cast<ShortValue *> (value);
+        setIntJVMTI (env, thread, slot, depth, sig, (jint) val->getValue ());
+        break;
+      }
+    case 'I':
+      {
+        IntValue *val = reinterpret_cast<IntValue *> (value);
+        setIntJVMTI (env, thread, slot, depth, sig, val->getValue ());
+        break;
+      }
+    case 'J':
+      {
+        LongValue *val = reinterpret_cast<LongValue *> (value);
+        setLongJVMTI (env, thread, slot, depth, sig, val->getValue ());
+        break;
+      }
+    case 'F':
+      {
+        FloatValue *val = reinterpret_cast<FloatValue *> (value);
+        setFloatJVMTI (env, thread, slot, depth, sig, val->getValue ());
+        break;
+      }
+    case 'D':
+      {
+        DoubleValue *val = reinterpret_cast<DoubleValue *> (value);
+        setDoubleJVMTI (env, thread, slot, depth, sig, val->getValue ());
+        break;
+      }
+    case 'V':
+      break;
+    case '[':
+      {
+        ArrayValue *val = reinterpret_cast<ArrayValue *> (value);
+        setObjectJVMTI (env, thread, slot, depth, sig, val->getObject ());
+        break;
+      }
+    default:
+      {
+        ObjectValue *val = reinterpret_cast<ObjectValue *> (value);
+        setObjectJVMTI (env, thread, slot, depth, sig, val->getObject());
+        break;
+      }
+    }
+}
Index: libjava/gnu/classpath/jdwp/natVMVirtualMachine.cc
===================================================================
--- libjava/gnu/classpath/jdwp/natVMVirtualMachine.cc	(revision 125219)
+++ libjava/gnu/classpath/jdwp/natVMVirtualMachine.cc	(revision 126334)
@@ -10,6 +10,8 @@
 
 #include <config.h>
 #include <gcj/cni.h>
+#include <java-assert.h>
+#include <java-interp.h>
 #include <jvm.h>
 #include <jvmti.h>
 
@@ -19,40 +21,111 @@
 #include <java/lang/String.h>
 #include <java/lang/StringBuilder.h>
 #include <java/lang/Thread.h>
+#include <java/lang/Throwable.h>
 #include <java/nio/ByteBuffer.h>
+#include <java/nio/ByteBufferImpl.h>
 #include <java/util/ArrayList.h>
+#include <java/util/Collection.h>
 #include <java/util/Hashtable.h>
 #include <java/util/Iterator.h>
 
 #include <gnu/classpath/jdwp/Jdwp.h>
+#include <gnu/classpath/jdwp/JdwpConstants$StepDepth.h>
+#include <gnu/classpath/jdwp/JdwpConstants$StepSize.h>
+#include <gnu/classpath/jdwp/JdwpConstants$ThreadStatus.h>
 #include <gnu/classpath/jdwp/VMFrame.h>
 #include <gnu/classpath/jdwp/VMMethod.h>
 #include <gnu/classpath/jdwp/VMVirtualMachine.h>
+#include <gnu/classpath/jdwp/event/BreakpointEvent.h>
+#include <gnu/classpath/jdwp/event/ClassPrepareEvent.h>
+#include <gnu/classpath/jdwp/event/ExceptionEvent.h>
+#include <gnu/classpath/jdwp/event/EventManager.h>
 #include <gnu/classpath/jdwp/event/EventRequest.h>
+#include <gnu/classpath/jdwp/event/SingleStepEvent.h>
+#include <gnu/classpath/jdwp/event/ThreadEndEvent.h>
+#include <gnu/classpath/jdwp/event/ThreadStartEvent.h>
+#include <gnu/classpath/jdwp/event/VmDeathEvent.h>
 #include <gnu/classpath/jdwp/event/VmInitEvent.h>
+#include <gnu/classpath/jdwp/event/filters/IEventFilter.h>
+#include <gnu/classpath/jdwp/event/filters/LocationOnlyFilter.h>
+#include <gnu/classpath/jdwp/event/filters/StepFilter.h>
+#include <gnu/classpath/jdwp/exception/AbsentInformationException.h>
+#include <gnu/classpath/jdwp/exception/InvalidFrameException.h>
+#include <gnu/classpath/jdwp/exception/InvalidLocationException.h>
+#include <gnu/classpath/jdwp/exception/InvalidMethodException.h>
 #include <gnu/classpath/jdwp/exception/JdwpInternalErrorException.h>
+#include <gnu/classpath/jdwp/id/ThreadId.h>
+#include <gnu/classpath/jdwp/util/Location.h>
 #include <gnu/classpath/jdwp/util/MethodResult.h>
+#include <gnu/gcj/jvmti/Breakpoint.h>
+#include <gnu/gcj/jvmti/BreakpointManager.h>
 
 using namespace java::lang;
 using namespace gnu::classpath::jdwp::event;
 using namespace gnu::classpath::jdwp::util;
 
+// Stepping information
+struct step_info
+{
+  jint size;   // See gnu.classpath.jdwp.JdwpConstants.StepSize
+  jint depth;  // See gnu.classpath.jdwp.JdwpConstants.StepDepth
+  int stack_depth;  // stack depth at start of stepping
+  jmethodID method; // method in which we are stepping
+};
+
 // Forward declarations
-static void jdwpVMInitCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread);
+static jvmtiError get_linetable (jvmtiEnv *, jmethodID, jint *,
+				 jvmtiLineNumberEntry **);
+static Location *get_request_location (EventRequest *);
+static gnu::classpath::jdwp::event::filters::StepFilter *
+get_request_step_filter (EventRequest *);
+static void handle_single_step (jvmtiEnv *, struct step_info *, jthread,
+				jmethodID, jlocation);
+static void JNICALL jdwpBreakpointCB (jvmtiEnv *, JNIEnv *, jthread,
+				      jmethodID, jlocation);
+static void JNICALL jdwpClassPrepareCB (jvmtiEnv *, JNIEnv *, jthread, jclass);
+static void JNICALL jdwpExceptionCB (jvmtiEnv *, JNIEnv *jni_env, jthread,
+				     jmethodID, jlocation, jobject,
+				     jmethodID, jlocation);
+static void JNICALL jdwpSingleStepCB (jvmtiEnv *, JNIEnv *, jthread,
+				      jmethodID, jlocation);
+static void JNICALL jdwpThreadEndCB (jvmtiEnv *, JNIEnv *, jthread);
+static void JNICALL jdwpThreadStartCB (jvmtiEnv *, JNIEnv *, jthread);
+static void JNICALL jdwpVMDeathCB (jvmtiEnv *, JNIEnv *);
+static void JNICALL jdwpVMInitCB (jvmtiEnv *, JNIEnv *, jthread);
+static void throw_jvmti_error (jvmtiError);
 
 #define DEFINE_CALLBACK(Cb,Event) Cb.Event = jdwp ## Event ## CB
+#define DISABLE_EVENT(Event,Thread)					\
+  _jdwp_jvmtiEnv->SetEventNotificationMode (JVMTI_DISABLE,		\
+					    JVMTI_EVENT_ ## Event, Thread)
 #define ENABLE_EVENT(Event,Thread)					\
   _jdwp_jvmtiEnv->SetEventNotificationMode (JVMTI_ENABLE,		\
 					    JVMTI_EVENT_ ## Event, Thread)
 // JVMTI environment
 static jvmtiEnv *_jdwp_jvmtiEnv;
 
+jvmtiEnv *
+_Jv_GetJDWP_JVMTIEnv (void)
+{
+  return _jdwp_jvmtiEnv;
+}
+
 void
 gnu::classpath::jdwp::VMVirtualMachine::initialize ()
 {
   _jdwp_suspend_counts = new ::java::util::Hashtable ();
+  _stepping_threads = new ::java::util::Hashtable ();
+  _event_list = new ::java::util::ArrayList ();
+
   JavaVM *vm = _Jv_GetJavaVM ();
-  vm->GetEnv (reinterpret_cast<void **> (&_jdwp_jvmtiEnv), JVMTI_VERSION_1_0);
+  union
+  {
+    void *ptr;
+    jvmtiEnv *env;
+  } foo;
+  vm->GetEnv (&(foo.ptr), JVMTI_VERSION_1_0);
+  _jdwp_jvmtiEnv = foo.env;
 
   // Wait for VM_INIT to do more initialization
   jvmtiEventCallbacks callbacks;
@@ -62,7 +135,7 @@
 }
 
 void
-gnu::classpath::jdwp::VMVirtualMachine ::suspendThread (Thread *thread)
+gnu::classpath::jdwp::VMVirtualMachine::suspendThread (Thread *thread)
 {
   jint value;
   Integer *count;
@@ -170,9 +243,57 @@
   switch (request->getEventKind ())
     {
     case EventRequest::EVENT_SINGLE_STEP:
+      {
+	Thread *thread;
+	filters::StepFilter *filter = get_request_step_filter (request);
+	if (filter == NULL)
+	  {
+	    // No filter specified: report every step in every
+	    // thread.
+	    thread = NULL;
+	  }
+	else
+	  {
+	    // Add stepping information to list of stepping threads
+	    thread = filter->getThread ()->getThread ();
+	    _Jv_InterpFrame *frame
+	      = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);
+	    struct step_info *sinfo
+	      = (struct step_info *) JvAllocBytes (sizeof (struct step_info));
+	    sinfo->size = filter->getSize ();
+	    sinfo->depth = filter->getDepth ();
+	    sinfo->stack_depth = frame->depth ();
+	    sinfo->method = frame->self->get_method ();
+	    _stepping_threads->put (thread, (jobject) sinfo);
+	  }
+
+	ENABLE_EVENT (SINGLE_STEP, thread);
+      }
       break;
 
     case EventRequest::EVENT_BREAKPOINT:
+      {
+	using namespace ::gnu::gcj::jvmti;
+	Location *loc = get_request_location (request);
+	if (loc == NULL)
+	  {
+	    using namespace gnu::classpath::jdwp::exception;
+	    throw new InvalidLocationException ();
+	  }
+
+	jlong method = loc->getMethod ()->getId ();
+	jlocation index = loc->getIndex ();
+	Breakpoint  *bp = BreakpointManager::getBreakpoint (method, index);
+	if (bp == NULL)
+	  {
+	    // Breakpoint not in interpreter yet
+	    bp = BreakpointManager::newBreakpoint (method, index);
+	  }
+	else
+	  {
+	    // Ignore the duplicate
+	  }
+      }
       break;
 
     case EventRequest::EVENT_FRAME_POP:
@@ -213,7 +334,7 @@
 
     case EventRequest::EVENT_VM_INIT:
       break;
-      
+
     case EventRequest::EVENT_VM_DEATH:
       break;
     }
@@ -225,9 +346,62 @@
   switch (request->getEventKind ())
     {
     case EventRequest::EVENT_SINGLE_STEP:
+      {
+	Thread *thread;
+	filters::StepFilter *filter = get_request_step_filter (request);
+	if (filter == NULL)
+	  thread = NULL;
+	else
+	  {
+	    thread = filter->getThread ()->getThread ();
+	    _stepping_threads->remove (thread);
+	  }
+
+	DISABLE_EVENT (SINGLE_STEP, thread);
+      }
       break;
 
     case EventRequest::EVENT_BREAKPOINT:
+      {
+	using namespace gnu::gcj::jvmti;
+	::java::util::Collection *breakpoints;
+	EventManager *em = EventManager::getDefault ();
+	breakpoints = em->getRequests (EventRequest::EVENT_BREAKPOINT);
+
+	// Check for duplicates
+	int matches = 0;
+	Location *the_location = get_request_location (request);
+
+	// This should not be possible: we REQUIRE a Location
+	// to install a breakpoint
+	JvAssert (the_location != NULL);
+
+	::java::util::Iterator *iter = breakpoints->iterator ();
+	while (iter->hasNext ())
+	  {
+	    EventRequest *er
+	      = reinterpret_cast<EventRequest *> (iter->next ());
+	    Location *loc = get_request_location (er);
+	    JvAssert (loc != NULL);
+	    if (loc->equals (the_location) && ++matches == 2)
+	      {
+		// Short-circuit: already more than one breakpoint
+		return;
+	      }
+	  }
+
+	if (matches == 0)
+	  {
+	    using namespace gnu::classpath::jdwp::exception;
+	    jstring msg
+	      = JvNewStringLatin1 ("attempt to remove unknown breakpoint");
+	    throw new JdwpInternalErrorException (msg);
+	  }
+
+	jlong methodId = the_location->getMethod ()->getId ();
+	BreakpointManager::deleteBreakpoint (methodId,
+					     the_location->getIndex ());
+      }
       break;
 
     case EventRequest::EVENT_FRAME_POP:
@@ -244,7 +418,7 @@
 
     case EventRequest::EVENT_THREAD_END:
       break;
-	
+
     case EventRequest::EVENT_CLASS_PREPARE:
       break;
 
@@ -268,103 +442,718 @@
 
     case EventRequest::EVENT_VM_INIT:
       break;
-      
+
     case EventRequest::EVENT_VM_DEATH:
       break;
     }
 }
 
 void
-gnu::classpath::jdwp::VMVirtualMachine::clearEvents (jbyte kind)
+gnu::classpath::jdwp::VMVirtualMachine::clearEvents (MAYBE_UNUSED jbyte kind)
 {
 }
 
-jint
-gnu::classpath::jdwp::VMVirtualMachine::getAllLoadedClassesCount (void)
-{
-  return 0;
-}
-
-java::util::Iterator *
+java::util::Collection *
 gnu::classpath::jdwp::VMVirtualMachine::getAllLoadedClasses (void)
 {
-  return NULL;
+  using namespace ::java::util;
+  return (Collection *) new ArrayList ();
 }
 
 jint
-gnu::classpath::jdwp::VMVirtualMachine::getClassStatus (jclass klass)
+gnu::classpath::jdwp::VMVirtualMachine::
+getClassStatus (jclass klass)
 {
-  return 0;
+  jint flags = 0;
+  jvmtiError err = _jdwp_jvmtiEnv->GetClassStatus (klass, &flags);
+  if (err != JVMTI_ERROR_NONE)
+    throw_jvmti_error (err);
+
+  using namespace gnu::classpath::jdwp::event;
+  jint status = 0;
+  if (flags & JVMTI_CLASS_STATUS_VERIFIED)
+    status |= ClassPrepareEvent::STATUS_VERIFIED;
+  if (flags & JVMTI_CLASS_STATUS_PREPARED)
+    status |= ClassPrepareEvent::STATUS_PREPARED;
+  if (flags & JVMTI_CLASS_STATUS_ERROR)
+    status |= ClassPrepareEvent::STATUS_ERROR;
+  if (flags & JVMTI_CLASS_STATUS_INITIALIZED)
+    status |= ClassPrepareEvent::STATUS_INITIALIZED;
+
+  return status;
 }
 
 JArray<gnu::classpath::jdwp::VMMethod *> *
-gnu::classpath::jdwp::VMVirtualMachine::getAllClassMethods (jclass klass)
+gnu::classpath::jdwp::VMVirtualMachine::
+getAllClassMethods (jclass klass)
 {
-  return NULL;
+  jint count;
+  jmethodID *methods;
+  jvmtiError err = _jdwp_jvmtiEnv->GetClassMethods (klass, &count, &methods);
+  if (err != JVMTI_ERROR_NONE)
+    throw_jvmti_error (err);
+
+  JArray<VMMethod *> *result
+    = (JArray<VMMethod *> *) JvNewObjectArray (count,
+					       &VMMethod::class$, NULL);
+  VMMethod **rmeth = elements (result);
+  for (int i = 0; i < count; ++i)
+    {
+      jlong id = reinterpret_cast<jlong> (methods[i]);
+      rmeth[i] = getClassMethod (klass, id);
+    }
+
+  _jdwp_jvmtiEnv->Deallocate ((unsigned char *) methods);
+  return result;
 }
 
 gnu::classpath::jdwp::VMMethod *
-gnu::classpath::jdwp::VMVirtualMachine::getClassMethod (jclass klass, jlong id)
+gnu::classpath::jdwp::VMVirtualMachine::
+getClassMethod (jclass klass, jlong id)
 {
-  return NULL;
+  jint count;
+  jmethodID *methods;
+  jvmtiError err = _jdwp_jvmtiEnv->GetClassMethods (klass, &count, &methods);
+  if (err != JVMTI_ERROR_NONE)
+    throw_jvmti_error (err);
+
+  jmethodID meth_id = reinterpret_cast<jmethodID> (id);
+
+  using namespace gnu::classpath::jdwp;
+
+  // Check if this method is defined for the given class and if so return a
+  // VMMethod representing it.
+  for (int i = 0; i < count; i++)
+    {
+      if (methods[i] == meth_id)
+        return new VMMethod (klass, reinterpret_cast<jlong> (meth_id));
+    }
+
+  throw new exception::InvalidMethodException (id);
 }
 
 java::util::ArrayList *
-gnu::classpath::jdwp::VMVirtualMachine::getFrames (Thread *thread,
-						   jint start,
-						   jint length)
+gnu::classpath::jdwp::VMVirtualMachine::getFrames (Thread *thread, jint start,
+                                                   jint length)
 {
-  return NULL;
+  jint frame_count = getFrameCount (thread);
+  ::java::util::ArrayList *frame_list;
+  
+  // Calculate the max number of frames to be returned.
+  jint num_frames = frame_count - start;
+  
+  // Check if num_frames is valid.
+  if (num_frames < 0)
+    num_frames = 0;
+  
+  // Check if there are more than length frames left after start.
+  // If length ios -1 return all remaining frames.
+  if (length != -1 && num_frames > length)
+    num_frames = length;
+     
+  frame_list = new ::java::util::ArrayList (num_frames);
+  
+  _Jv_Frame *vm_frame = reinterpret_cast<_Jv_Frame *> (thread->frame);
+  
+  // Take start frames off the top of the stack
+  while (vm_frame != NULL && start > 0)
+    {
+      start--;
+      vm_frame = vm_frame->next;
+    }
+  
+  // Use as a counter for the number of frames returned.
+  num_frames = 0;
+  
+  while (vm_frame != NULL && (num_frames < length || length == -1))
+    {  
+      jlong frameId = reinterpret_cast<jlong> (vm_frame);
+      
+      VMFrame *frame = getFrame (thread, frameId);
+      frame_list->add (frame);
+      vm_frame = vm_frame->next;
+      num_frames++;
+    }
+  
+  return frame_list;
 }
 
 gnu::classpath::jdwp::VMFrame *
-gnu::classpath::jdwp::VMVirtualMachine::getFrame (Thread *thread,
-						  ::java::nio::ByteBuffer *bb)
+gnu::classpath::jdwp::VMVirtualMachine::
+getFrame (Thread *thread, jlong frameID)
 {
-  return NULL;
+  using namespace gnu::classpath::jdwp::exception;
+  
+  _Jv_Frame *vm_frame = (_Jv_Frame *) thread->frame;
+  jint depth = 0;
+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (frameID); 
+  
+  // We need to find the stack depth of the frame, so search through the call
+  // stack to find it.  This also checks for a valid frameID.
+  while (vm_frame != frame)
+    {
+      vm_frame = vm_frame->next;
+      depth++;
+      if (vm_frame == NULL)
+        throw new InvalidFrameException (frameID);
+    }
+  
+  Location *loc = NULL;
+  jvmtiFrameInfo info;
+  jvmtiError jerr;
+  jint num_frames;
+  jclass klass;
+  
+  // Get the info for the frame of interest
+  jerr = _jdwp_jvmtiEnv->GetStackTrace (thread, depth, 1, &info, &num_frames);
+   
+  if (jerr != JVMTI_ERROR_NONE)
+    throw_jvmti_error (jerr);
+  
+  jerr = _jdwp_jvmtiEnv->GetMethodDeclaringClass (info.method, &klass);
+      
+  if (jerr != JVMTI_ERROR_NONE)
+    throw_jvmti_error (jerr);
+
+  VMMethod *meth 
+    = getClassMethod (klass, reinterpret_cast<jlong> (info.method));
+  
+  jobject this_obj;
+  
+  if (info.location == -1)
+    {
+      loc = new Location (meth, 0);
+      this_obj = NULL;
+    }
+  else
+    {
+      loc = new Location (meth, info.location);
+      _Jv_InterpFrame *iframe = reinterpret_cast<_Jv_InterpFrame *> (vm_frame);
+      this_obj = iframe->get_this_ptr ();
+    }
+  
+  return new VMFrame (thread, reinterpret_cast<jlong> (vm_frame), loc,
+                      this_obj); 
 }
 
 jint
-gnu::classpath::jdwp::VMVirtualMachine::getFrameCount (Thread *thread)
+gnu::classpath::jdwp::VMVirtualMachine::
+getFrameCount (Thread *thread)
 {
-  return 0;
+  jint frame_count;
+  
+  jvmtiError jerr = _jdwp_jvmtiEnv->GetFrameCount (thread, &frame_count);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    throw_jvmti_error (jerr);
+  
+  return frame_count;
 }
 
 jint
-gnu::classpath::jdwp::VMVirtualMachine::getThreadStatus (Thread *thread)
+gnu::classpath::jdwp::VMVirtualMachine::
+getThreadStatus (Thread *thread)
 {
-  return 0;
+  jint thr_state, status;
+  
+  jvmtiError jerr = _jdwp_jvmtiEnv->GetThreadState (thread, &thr_state);
+  if (jerr != JVMTI_ERROR_NONE)
+    throw_jvmti_error (jerr);
+  
+  if (thr_state & JVMTI_THREAD_STATE_SLEEPING)
+    status = gnu::classpath::jdwp::JdwpConstants$ThreadStatus::SLEEPING;
+  else if (thr_state & JVMTI_THREAD_STATE_RUNNABLE)
+    status = gnu::classpath::jdwp::JdwpConstants$ThreadStatus::RUNNING;
+  else if (thr_state & JVMTI_THREAD_STATE_WAITING)
+    {
+      if (thr_state & (JVMTI_THREAD_STATE_IN_OBJECT_WAIT
+                       | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER))
+        status = gnu::classpath::jdwp::JdwpConstants$ThreadStatus::MONITOR;
+      else
+        status = gnu::classpath::jdwp::JdwpConstants$ThreadStatus::WAIT;
+    }
+  else
+    {
+      // The thread is not SLEEPING, MONITOR, or WAIT.  It may, however, be
+      // alive but not yet started.
+      if (!(thr_state & (JVMTI_THREAD_STATE_ALIVE 
+                         | JVMTI_THREAD_STATE_TERMINATED)))
+        status = gnu::classpath::jdwp::JdwpConstants$ThreadStatus::RUNNING;
+      status = gnu::classpath::jdwp::JdwpConstants$ThreadStatus::ZOMBIE;     
+    }   
+
+  return status;
 }
 
 java::util::ArrayList *
-gnu::classpath::jdwp::VMVirtualMachine::getLoadRequests (ClassLoader *cl)
+gnu::classpath::jdwp::VMVirtualMachine::
+getLoadRequests (MAYBE_UNUSED ClassLoader *cl)
 {
-  return NULL;
+  return new ::java::util::ArrayList ();
 }
 
 MethodResult *
-gnu::classpath::jdwp::VMVirtualMachine::executeMethod (jobject obj,
-						       Thread *thread,
-						       jclass clazz,
-						       reflect::Method *method,
-						       jobjectArray values,
-						       jboolean nonVirtual)
+gnu::classpath::jdwp::VMVirtualMachine::
+executeMethod (MAYBE_UNUSED jobject obj, MAYBE_UNUSED Thread *thread,
+	       MAYBE_UNUSED jclass clazz, MAYBE_UNUSED reflect::Method *method,
+	       MAYBE_UNUSED jobjectArray values,
+	       MAYBE_UNUSED jboolean nonVirtual)
 {
   return NULL;
 }
 
 jstring
-gnu::classpath::jdwp::VMVirtualMachine::getSourceFile (jclass clazz)
+gnu::classpath::jdwp::VMVirtualMachine::
+getSourceFile (jclass clazz)
 {
+  jstring file = _Jv_GetInterpClassSourceFile (clazz);
+  
+  // Check if the source file was found.
+  if (file == NULL)
+    throw new exception::AbsentInformationException (
+                           _Jv_NewStringUTF("Source file not found"));
+  
+  return file;
+}
+
+void
+gnu::classpath::jdwp::VMVirtualMachine::
+redefineClasses (MAYBE_UNUSED JArray<jclass> *types,
+		 MAYBE_UNUSED JArray<jbyteArray> *bytecodes)
+{
+}
+
+void
+gnu::classpath::jdwp::VMVirtualMachine::
+setDefaultStratum (MAYBE_UNUSED jstring stratum)
+{
+}
+
+jstring
+gnu::classpath::jdwp::VMVirtualMachine::
+getSourceDebugExtension (MAYBE_UNUSED jclass klass)
+{
   return NULL;
 }
 
+jbyteArray
+gnu::classpath::jdwp::VMVirtualMachine::
+getBytecodes (MAYBE_UNUSED gnu::classpath::jdwp::VMMethod *method)
+{
+  return NULL;
+}
+
+gnu::classpath::jdwp::util::MonitorInfo *
+gnu::classpath::jdwp::VMVirtualMachine::
+getMonitorInfo (MAYBE_UNUSED jobject obj)
+{
+  return NULL;
+}
+
+jobjectArray
+gnu::classpath::jdwp::VMVirtualMachine::
+getOwnedMonitors (MAYBE_UNUSED ::java::lang::Thread *thread)
+{
+  return NULL;
+}
+
+jobject
+gnu::classpath::jdwp::VMVirtualMachine::
+getCurrentContendedMonitor (MAYBE_UNUSED ::java::lang::Thread *thread)
+{
+  return NULL;
+}
+
+void
+gnu::classpath::jdwp::VMVirtualMachine::
+popFrames (MAYBE_UNUSED ::java::lang::Thread *thread,
+	   MAYBE_UNUSED jlong frameId)
+{
+}
+
+// A simple caching function used while single-stepping
+static jvmtiError
+get_linetable (jvmtiEnv *env, jmethodID method, jint *count_ptr,
+	       jvmtiLineNumberEntry **table_ptr)
+{
+  static jint last_count = 0;
+  static jvmtiLineNumberEntry *last_table = NULL;
+  static jmethodID last_method = 0;
+
+  if (method == last_method)
+    {
+      *count_ptr = last_count;
+      *table_ptr = last_table;
+      return JVMTI_ERROR_NONE;
+    }
+
+  jvmtiError err;
+  jint count;
+  jvmtiLineNumberEntry *table;
+  err = env->GetLineNumberTable (method, &count, &table);
+  if (err != JVMTI_ERROR_NONE)
+    {
+      // Keep last table in cache
+      return err;
+    }
+
+  env->Deallocate ((unsigned char *) last_table);
+  last_table = *table_ptr = table;
+  last_count = *count_ptr = count;
+  return JVMTI_ERROR_NONE;
+}
+
+static gnu::classpath::jdwp::event::filters::StepFilter *
+get_request_step_filter (EventRequest *request)
+{
+  ::java::util::Collection *filters = request->getFilters ();
+  ::java::util::Iterator *iter = filters->iterator ();
+  filters::StepFilter *filter = NULL;
+  while (iter->hasNext ())
+    {
+      using namespace gnu::classpath::jdwp::event::filters;
+      IEventFilter *next = (IEventFilter *) iter->next ();
+      if (next->getClass () == &StepFilter::class$)
+	{
+	  filter = reinterpret_cast<StepFilter *> (next);
+	  break;
+	}
+    }
+
+  return filter;
+}
+
+static Location *
+get_request_location (EventRequest *request)
+{
+  Location *loc = NULL;
+  ::java::util::Collection *filters = request->getFilters ();
+  ::java::util::Iterator *iter = filters->iterator ();
+  while (iter->hasNext ())
+    {
+      using namespace gnu::classpath::jdwp::event::filters;
+      IEventFilter *filter = (IEventFilter *) iter->next ();
+      if (filter->getClass () == &LocationOnlyFilter::class$)
+	{
+	  LocationOnlyFilter *lof
+	    = reinterpret_cast<LocationOnlyFilter *> (filter);
+	  loc = lof->getLocation ();
+	}
+    }
+
+  return loc;
+}
+
 static void
+handle_single_step (jvmtiEnv *env, struct step_info *sinfo, jthread thread,
+		    jmethodID method, jlocation location)
+{
+  using namespace gnu::classpath::jdwp;
+
+  if (sinfo == NULL || sinfo->size == JdwpConstants$StepSize::MIN)
+    {
+      // Stop now
+      goto send_notification;
+    }
+  else
+    {
+      // Check if we're on a new source line
+      /* This is a little inefficient when we're stepping OVER,
+	 but this must be done when stepping INTO. */
+      jint count;
+      jvmtiLineNumberEntry *table;
+      if (get_linetable (env, method, &count, &table) == JVMTI_ERROR_NONE)
+	{
+	  jint i;
+	  for (i = 0; i < count; ++i)
+	    {
+	      if (table[i].start_location == location)
+		{
+		  // This is the start of a new line -- stop
+		  goto send_notification;
+		}
+	    }
+
+	  // Not at a new source line -- just keep stepping
+	  return;
+	}
+      else
+	{
+	  /* Something went wrong: either "absent information"
+	     or "out of memory" ("invalid method id" and "native
+	     method" aren't possible -- those are validated before
+	     single stepping is enabled).
+
+	     Do what gdb does: just keep going. */
+	  return;
+	}
+    }
+
+ send_notification:
+  jclass klass;
+  jvmtiError err = env->GetMethodDeclaringClass (method, &klass);
+  if (err != JVMTI_ERROR_NONE)
+    {
+      fprintf (stderr, "libgcj: internal error: could not find class for method while single stepping -- continuing\n");
+      return;
+    }
+
+  VMMethod *vmmethod = new VMMethod (klass, reinterpret_cast<jlong> (method));
+  Location *loc = new Location (vmmethod, location);
+  JvAssert (thread->frame.frame_type == frame_interpreter);
+  _Jv_InterpFrame *iframe
+    = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);  
+  jobject instance = iframe->get_this_ptr ();
+  event::SingleStepEvent *event
+    = new event::SingleStepEvent (thread, loc, instance);
+
+  // We only want to send the notification (and consequently
+  // suspend) if we are not about to execute a breakpoint.
+  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (iframe->self);
+  if (im->breakpoint_at (location))
+    {
+      // Next insn is a breakpoint -- record event and
+      // wait for the JVMTI breakpoint notification to
+      // enforce a suspension policy.
+      VMVirtualMachine::_event_list->add (event);
+    }
+  else
+    {
+      // Next insn is not a breakpoint, so send notification
+      // and enforce the suspend policy.
+      Jdwp::notify (event);
+    }
+}
+
+static void
+throw_jvmti_error (jvmtiError err)
+{
+  char *error;
+  jstring msg;
+  if (_jdwp_jvmtiEnv->GetErrorName (err, &error) == JVMTI_ERROR_NONE)
+    {
+      msg = JvNewStringLatin1 (error);
+      _jdwp_jvmtiEnv->Deallocate ((unsigned char *) error);
+    }
+  else
+    msg = JvNewStringLatin1 ("out of memory");
+
+  using namespace gnu::classpath::jdwp::exception;
+  throw new JdwpInternalErrorException (msg);
+}
+
+static void JNICALL
+jdwpBreakpointCB (jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,
+		  jthread thread, jmethodID method, jlocation location)
+{
+  jclass klass;
+  jvmtiError err;
+  err = env->GetMethodDeclaringClass (method, &klass);
+  JvAssert (err == JVMTI_ERROR_NONE);
+
+  using namespace gnu::classpath::jdwp;
+  using namespace gnu::classpath::jdwp::event;
+
+  jlong methodId = reinterpret_cast<jlong> (method);
+  VMMethod *meth = VMVirtualMachine::getClassMethod (klass, methodId);
+  Location *loc = new Location (meth, location);
+  JvAssert (thread->frame.frame_type == frame_interpreter);
+  _Jv_InterpFrame *iframe
+    = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);
+  jobject instance = iframe->get_this_ptr ();
+  BreakpointEvent *event = new BreakpointEvent (thread, loc, instance);
+  
+  VMVirtualMachine::_event_list->add (event);
+  JArray<Event *> *events
+    = ((JArray<Event *> *)
+       JvNewObjectArray (VMVirtualMachine::_event_list->size (),
+			 &Event::class$, NULL));
+  VMVirtualMachine::_event_list->toArray ((jobjectArray) events);
+  VMVirtualMachine::_event_list->clear ();
+  Jdwp::notify (events);
+}
+
+static void JNICALL
+jdwpClassPrepareCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,
+		    jthread thread, jclass klass)
+{
+  using namespace gnu::classpath::jdwp;
+
+  jint status = VMVirtualMachine::getClassStatus (klass);
+  event::ClassPrepareEvent *event
+    = new event::ClassPrepareEvent (thread, klass, status);
+  Jdwp::notify (event);
+}
+
+static void JNICALL
+jdwpExceptionCB (jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env, jthread thread,
+		 jmethodID method, jlocation location, jobject exception,
+		 jmethodID catch_method, jlocation catch_location)
+{
+  using namespace gnu::classpath::jdwp;
+  jclass throw_klass;
+  jvmtiError err = env->GetMethodDeclaringClass (method, &throw_klass);
+  if (err != JVMTI_ERROR_NONE)
+    {
+      fprintf (stderr, "libgcj: internal error: could not find class for ");
+      fprintf (stderr, "method throwing exception -- continuing\n");
+      return;
+    }
+
+  VMMethod *vmmethod = new VMMethod (throw_klass,
+				     reinterpret_cast<jlong> (method));
+  Location *throw_loc = new Location (vmmethod, location);  
+  Location *catch_loc = NULL;
+  if (catch_method == 0)
+    catch_loc = Location::getEmptyLocation ();
+  else
+    {
+      jclass catch_klass;
+      err = env->GetMethodDeclaringClass (catch_method, &catch_klass);
+      if (err != JVMTI_ERROR_NONE)
+	{
+	  fprintf (stderr,
+		   "libgcj: internal error: could not find class for ");
+	  fprintf (stderr,
+		   "method catching exception -- ignoring\n");
+	}
+      else
+	{
+	  vmmethod = new VMMethod (catch_klass,
+				   reinterpret_cast<jlong> (catch_method));
+	  catch_loc = new Location (vmmethod, catch_location);
+	}
+    }
+
+  _Jv_InterpFrame *iframe
+    = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);
+  jobject instance = (iframe == NULL) ? NULL : iframe->get_this_ptr ();
+  Throwable *throwable = reinterpret_cast<Throwable *> (exception);
+  event::ExceptionEvent *e = new ExceptionEvent (throwable, thread,
+						 throw_loc, catch_loc,
+						 throw_klass, instance);
+  Jdwp::notify (e);
+}
+
+static void JNICALL
+jdwpSingleStepCB (jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env, jthread thread,
+		  jmethodID method, jlocation location)
+{
+  jobject si =
+    gnu::classpath::jdwp::VMVirtualMachine::_stepping_threads->get (thread);
+  struct step_info *sinfo = reinterpret_cast<struct step_info *> (si);
+
+  if (sinfo == NULL)
+    {
+      // no step filter for this thread - simply report it
+      handle_single_step (env, NULL, thread, method, location);
+    }
+  else
+    {
+      // A step filter exists for this thread
+      using namespace gnu::classpath::jdwp;
+
+      _Jv_InterpFrame *frame
+	= reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);
+
+      switch (sinfo->depth)
+	{
+	case JdwpConstants$StepDepth::INTO:
+	  /* This is the easy case. We ignore the method and
+	     simply stop at either the next insn, or the next source
+	     line. */
+	  handle_single_step (env, sinfo, thread, method, location);
+	  break;
+
+	case JdwpConstants$StepDepth::OVER:
+	  /* This is also a pretty easy case. We just make sure that
+	     the methods are the same and that we are at the same
+	     stack depth, but we should also stop on the next
+	     insn/line if the stack depth is LESS THAN it was when
+	     we started stepping. */
+	  if (method == sinfo->method)
+	    {
+	      // Still in the same method -- must be at same stack depth
+	      // to avoid confusion with recursive methods.
+	      if (frame->depth () == sinfo->stack_depth)
+		handle_single_step (env, sinfo, thread, method, location);
+	    }
+	  else if (frame->depth () < sinfo->stack_depth)
+	    {
+	      // The method in which we were stepping was popped off
+	      // the stack. We simply need to stop at the next insn/line.
+	      handle_single_step (env, sinfo, thread, method, location);
+	    }
+	  break;
+
+	case JdwpConstants$StepDepth::OUT:
+	  // All we need to do is check the stack depth
+	  if (sinfo->stack_depth > frame->depth ())
+	    handle_single_step (env, sinfo, thread, method, location);
+	  break;
+
+	default:
+	  /* This should not happen. The JDWP back-end should have
+	     validated the StepFilter. */
+	  fprintf (stderr,
+		   "libgcj: unknown step depth while single stepping\n");
+	  return;
+	}
+    }
+}
+
+static void JNICALL
+jdwpThreadEndCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,
+		 jthread thread)
+{
+  using namespace gnu::classpath::jdwp::event;
+
+  ThreadEndEvent *e = new ThreadEndEvent (thread);
+  gnu::classpath::jdwp::Jdwp::notify (e);
+}
+
+static void JNICALL
+jdwpThreadStartCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,
+		   jthread thread)
+{
+  using namespace gnu::classpath::jdwp::event;
+
+  ThreadStartEvent *e = new ThreadStartEvent (thread);
+  gnu::classpath::jdwp::Jdwp::notify (e);
+}
+
+static void JNICALL
+jdwpVMDeathCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env)
+{
+  using namespace gnu::classpath::jdwp::event;
+  gnu::classpath::jdwp::Jdwp::notify (new VmDeathEvent ());
+}
+
+static void JNICALL
 jdwpVMInitCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,
 	      jthread thread)
 {
+  // The VM is now initialized, add our callbacks
+  jvmtiEventCallbacks callbacks;
+  DEFINE_CALLBACK (callbacks, Breakpoint);
+  DEFINE_CALLBACK (callbacks, ClassPrepare);
+  DEFINE_CALLBACK (callbacks, Exception);
+  DEFINE_CALLBACK (callbacks, SingleStep);
+  DEFINE_CALLBACK (callbacks, ThreadEnd);
+  DEFINE_CALLBACK (callbacks, ThreadStart);
+  DEFINE_CALLBACK (callbacks, VMDeath);
+  _jdwp_jvmtiEnv->SetEventCallbacks (&callbacks, sizeof (callbacks));
+
+  // Enable callbacks
+  ENABLE_EVENT (BREAKPOINT, NULL);
+  ENABLE_EVENT (CLASS_PREPARE, NULL);
+  ENABLE_EVENT (EXCEPTION, NULL);
+  // SingleStep is enabled only when needed
+  ENABLE_EVENT (THREAD_END, NULL);
+  ENABLE_EVENT (THREAD_START, NULL);
+  ENABLE_EVENT (VM_DEATH, NULL);
+
   // Send JDWP VMInit
   using namespace gnu::classpath::jdwp::event;
-  Thread *init_thread = reinterpret_cast<Thread *> (thread);
-  gnu::classpath::jdwp::Jdwp::notify (new VmInitEvent (init_thread));
+  gnu::classpath::jdwp::Jdwp::notify (new VmInitEvent (thread));
 }
Index: libjava/gnu/classpath/jdwp/VMIdManager.java
===================================================================
--- libjava/gnu/classpath/jdwp/VMIdManager.java	(revision 125219)
+++ libjava/gnu/classpath/jdwp/VMIdManager.java	(revision 126334)
@@ -1,7 +1,7 @@
 /* VMIdManager.java -- A reference/example implementation of a manager for
    JDWP object/reference type IDs
 
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -337,6 +337,10 @@
    */
   public ObjectId getObjectId (Object theObject)
   {
+    // Special case: null object.
+    if (theObject == null)
+      return new NullObjectId ();
+	  
     ReferenceKey ref = new ReferenceKey (theObject, _refQueue);
     ObjectId id = (ObjectId) _oidTable.get (ref);
     if (id == null)
@@ -364,6 +368,10 @@
   public ObjectId get (long id)
     throws InvalidObjectException
   {
+    // Special case: null object id.
+    if (id == 0)
+      return new NullObjectId ();
+    
     ObjectId oid = (ObjectId) _idTable.get (new Long (id));
     if (oid == null)
       throw new InvalidObjectException (id);
Index: libjava/gnu/classpath/jdwp/natVMMethod.cc
===================================================================
--- libjava/gnu/classpath/jdwp/natVMMethod.cc	(revision 125219)
+++ libjava/gnu/classpath/jdwp/natVMMethod.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // natVMMethod.cc -- native support for VMMethod
 
-/* Copyright (C) 2006 Free Software Foundation
+/* Copyright (C) 2006, 2007 Free Software Foundation
 
    This file is part of libgcj.
 
@@ -11,39 +11,74 @@
 #include <config.h>
 #include <gcj/cni.h>
 #include <java-interp.h>
+#include <jvmti.h>
+#include "jvmti-int.h"
 
+#include <java/lang/reflect/Modifier.h>
 #include <gnu/classpath/jdwp/VMMethod.h>
+#include <gnu/classpath/jdwp/exception/AbsentInformationException.h>
+#include <gnu/classpath/jdwp/exception/InvalidMethodException.h>
 #include <gnu/classpath/jdwp/exception/JdwpInternalErrorException.h>
 #include <gnu/classpath/jdwp/util/LineTable.h>
 #include <gnu/classpath/jdwp/util/VariableTable.h>
 
-java::lang::String*
+using namespace java::lang;
+
+#define CHECK_INTERP_CLASS()	\
+do								\
+  {								\
+    if (!_Jv_IsInterpretedClass (getDeclaringClass ()))	\
+      {													\
+        ::java::lang::String *msg = JvNewStringLatin1 ("native class"); \
+        throw new exception::JdwpInternalErrorException (msg); 			\
+      }													\
+  }								\
+while (0)
+
+jstring
 gnu::classpath::jdwp::VMMethod::getName ()
 {
-  return NULL;
+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();
+  jmethodID method = reinterpret_cast<jmethodID> (_methodId);
+  char *name;
+  env->GetMethodName (method, &name, NULL, NULL);
+  jstring string = JvNewStringUTF (name);
+  env->Deallocate (reinterpret_cast<unsigned char *> (name));
+  return string;
 }
 
-java::lang::String*
+jstring
 gnu::classpath::jdwp::VMMethod::getSignature ()
 {
-  return NULL;
+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();
+  jmethodID method = reinterpret_cast<jmethodID> (_methodId);
+  char *signature;
+  env->GetMethodName (method, NULL, &signature, NULL);
+  jstring string = JvNewStringUTF (signature);
+  env->Deallocate (reinterpret_cast<unsigned char *> (signature));
+  return string;
 }
 
 jint
 gnu::classpath::jdwp::VMMethod::getModifiers ()
 {
-  return 0;
+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();
+  jmethodID method = reinterpret_cast<jmethodID> (_methodId);
+  jint flags;
+  env->GetMethodModifiers (method, &flags);
+
+  // If this class is compiled, as far as JDWP is concerned, its methods are 
+  // native.  This will set the native flag for these methods.
+  if (!_Jv_IsInterpretedClass (getDeclaringClass ()))
+    flags |= ::java::lang::reflect::Modifier::NATIVE;
+
+  return flags;
 }
 
 gnu::classpath::jdwp::util::LineTable *
 gnu::classpath::jdwp::VMMethod::getLineTable ()
 {
-  if (!_Jv_IsInterpretedClass (getDeclaringClass ()))
-    {
-      // this should not happen
-      ::java::lang::String *msg = JvNewStringLatin1 ("native class");
-      throw new exception::JdwpInternalErrorException (msg);
-    }
+  CHECK_INTERP_CLASS ();
 
   jmethodID desired_method = reinterpret_cast<jmethodID> (_methodId);
 
@@ -79,5 +114,78 @@
 gnu::classpath::jdwp::util::VariableTable*
 gnu::classpath::jdwp::VMMethod::getVariableTable ()
 {
-  return NULL;
+  using namespace gnu::classpath::jdwp::util;
+  
+  jvmtiEnv *env = _Jv_GetJDWP_JVMTIEnv ();
+	
+  CHECK_INTERP_CLASS ();
+  
+  jmethodID meth = reinterpret_cast<jmethodID> (_methodId);
+  jvmtiLocalVariableEntry *var_table;
+  jint num_slots, args_len;
+  
+  jvmtiError jerr = env->GetLocalVariableTable (meth, &num_slots, &var_table);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    goto error;
+  
+  jerr = env->GetArgumentsSize (meth, &args_len);
+  
+  if (jerr != JVMTI_ERROR_NONE)
+    {
+    error:
+      using namespace gnu::classpath::jdwp::exception;
+      char *error;
+      env->GetErrorName (jerr, &error);
+      String *msg = JvNewStringUTF (error);
+      env->Deallocate (reinterpret_cast<unsigned char *> (error));
+      
+      if (jerr == JVMTI_ERROR_NATIVE_METHOD)
+        throw new AbsentInformationException (msg);
+      else if (jerr == JVMTI_ERROR_INVALID_METHODID)
+        throw new InvalidMethodException (_methodId);
+      else
+        throw new JdwpInternalErrorException (msg);
+    }
+  
+  jlongArray start_pcs = JvNewLongArray (num_slots);
+  jlong *start_pcs_ptr = elements (start_pcs);
+  jintArray lengths = JvNewIntArray (num_slots);
+  jint *lengths_ptr = elements (lengths);
+  jintArray slots = JvNewIntArray (num_slots);
+  jint *slots_ptr = elements (slots);
+  JArray<String *> *names = reinterpret_cast<JArray<String *> *> 
+                              (JvNewObjectArray (num_slots, 
+                                                 &String::class$, NULL));
+  jstring *names_ptr = elements (names);
+  JArray<String *> *signatures = reinterpret_cast<JArray<String *> *>
+                                   (JvNewObjectArray (num_slots, 
+                                                      &String::class$, NULL));
+  jstring *signatures_ptr = elements (signatures);
+  
+  // Get the information out of the JVMTI strucutre and Deallocate the strings.
+  for (int i = 0; i < num_slots; i++)
+    {
+      start_pcs_ptr[i] = var_table[i].start_location;
+      lengths_ptr[i] = var_table[i].length;
+      slots_ptr[i] = var_table[i].slot;
+      names_ptr[i] = JvNewStringUTF (var_table[i].name);
+      env->Deallocate (reinterpret_cast<unsigned char *> 
+                         (var_table[i].name));
+      signatures_ptr[i] = JvNewStringUTF (var_table[i].signature);
+      env->Deallocate (reinterpret_cast<unsigned char *> 
+                         (var_table[i].signature));
+      env->Deallocate (reinterpret_cast<unsigned char *>
+                         (var_table[i].generic_signature));
+    }
+  
+  // Now Deallocate the table since it's strings have already been freed.
+  env->Deallocate (reinterpret_cast<unsigned char *> (var_table));
+  
+  // Create the new JDWP VariableTable to return with the now filled arrays.
+  VariableTable* jdwp_vtable = new VariableTable (args_len, num_slots,
+                                                  start_pcs, names, signatures,
+                                                  lengths, slots);
+  
+  return jdwp_vtable;
 }
Index: libjava/gnu/classpath/jdwp/VMFrame.java
===================================================================
--- libjava/gnu/classpath/jdwp/VMFrame.java	(revision 125219)
+++ libjava/gnu/classpath/jdwp/VMFrame.java	(revision 126334)
@@ -1,5 +1,5 @@
 /* VMFrame.java -- Reference implementation of VM hooks for JDWP Frame access.
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -40,6 +40,7 @@
 package gnu.classpath.jdwp;
 
 import gnu.classpath.jdwp.util.Location;
+import gnu.classpath.jdwp.value.Value;
 
 /**
  * Reference implementation of VM hooks for JDWP Frame access.
@@ -54,7 +55,10 @@
    */
   public static final int SIZE = 8;
 
-  // The object this frame resides in
+  // The thread this frame resides in
+  private Thread thread;
+   
+  //The object of this frame
   private Object obj;
   
   // The current location of this frame
@@ -64,6 +68,22 @@
   private long id;
   
   /**
+   * Create a new VMFrame object.
+   * 
+   * @param thr a Thread, the thread this frame is in
+   * @param frame_id a long, the jframeID of this frame
+   * @param frame_loc a Location, the location of this frame
+   */
+  public VMFrame(Thread thr, long frame_id, Location frame_loc,
+                 Object frame_obj)
+  {
+    thread = thr;
+    id = frame_id;
+    loc = frame_loc;
+    obj = frame_obj;
+  }
+  
+  /**
    * Gets the current location of the frame.
    */
   public Location getLocation()
@@ -76,14 +96,22 @@
    * 
    * @param slot the slot containing the variable
    */
-  public native Object getValue(int slot);
+  public native Value getValue(int slot, byte sig);
 
   /**
    * Assigns the given variable to the given value. 
    * @param slot The slot which contains the variable
    * @param value The value to assign the variable to
    */
-  public native void setValue(int slot, Object value);
+  public native void setValue(int slot, Value value);
+  
+  /**
+   * Get the thread this frame is in.
+   */
+  public Thread getThread()
+  {
+    return thread;
+  }
 
   /**
    * Get the object which is represented by 'this' in the context of the frame,
Index: libjava/gnu/classpath/jdwp/VMVirtualMachine.java
===================================================================
--- libjava/gnu/classpath/jdwp/VMVirtualMachine.java	(revision 125219)
+++ libjava/gnu/classpath/jdwp/VMVirtualMachine.java	(revision 126334)
@@ -1,7 +1,7 @@
 /* VMVirtualMachine.java -- A reference implementation of a JDWP virtual
    machine
 
-   Copyright (C) 2005, 2006 Free Software Foundation
+   Copyright (C) 2005, 2006, 2007 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -45,11 +45,13 @@
 import gnu.classpath.jdwp.exception.InvalidMethodException;
 import gnu.classpath.jdwp.exception.JdwpException;
 import gnu.classpath.jdwp.util.MethodResult;
+import gnu.classpath.jdwp.util.MonitorInfo;
+
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Hashtable;
-import java.util.Iterator;
 
 /**
  * A virtual machine according to JDWP.
@@ -58,9 +60,32 @@
  */
 public class VMVirtualMachine
 {
+  // VM Capabilities
+  public static final boolean canWatchFieldModification = false;
+  public static final boolean canWatchFieldAccess = false;
+  public static final boolean canGetBytecodes = false;
+  public static final boolean canGetSyntheticAttribute = false;
+  public static final boolean canGetOwnedMonitorInfo = false;
+  public static final boolean canGetCurrentContendedMonitor = false;
+  public static final boolean canGetMonitorInfo = false;
+  public static final boolean canRedefineClasses = false;
+  public static final boolean canAddMethod = false;
+  public static final boolean canUnrestrictedlyRedefineClasses = false;
+  public static final boolean canPopFrames = false;
+  public static final boolean canUseInstanceFilters = false;
+  public static final boolean canGetSourceDebugExtension = false;
+  public static final boolean canRequestVMDeathEvent = false;
+  public static final boolean canSetDefaultStratum = false;
+
   // Thread suspension table. Maps Thread to suspend count (Integer)
   private static Hashtable _jdwp_suspend_counts;
 
+  // List of stepping threads: maps Thread -> stepping info
+  static Hashtable _stepping_threads;
+  
+  // List of co-located JVMTI events
+  static ArrayList _event_list;
+
   public static native void initialize ();
 
   /**
@@ -176,18 +201,12 @@
     throws JdwpException;
  
   /**
-   * Returns a count of the number of loaded classes in the VM
+   * Returns a Collection of all classes loaded in the VM
    */
-  public static native int getAllLoadedClassesCount ()
+  public static native Collection getAllLoadedClasses ()
     throws JdwpException;
 
   /**
-   * Returns an iterator over all the loaded classes in the VM
-   */
-  public static native Iterator getAllLoadedClasses ()
-    throws JdwpException;
-
-  /**
    * Returns the status of the given class
    *
    * @param  clazz  the class whose status is desired
@@ -243,7 +262,7 @@
    * @param  bb      buffer containing the frame's ID
    * @return the desired frame
    */
-  public static native VMFrame getFrame (Thread thread, ByteBuffer bb)
+  public static native VMFrame getFrame (Thread thread, long frameID)
     throws JdwpException;
 
   /**
@@ -332,4 +351,86 @@
    */
   public static native void clearEvents (byte kind)
     throws JdwpException;
+
+  /**
+   * Redefines the given types. VM must support canRedefineClasses
+   * capability (may also require canAddMethod and/or
+   * canUnrestrictedlyRedefineClasses capabilities)
+   *
+   * @param types the classes to redefine
+   * @param bytecodes the new bytecode definitions for the classes
+   */
+  public static native void redefineClasses(Class[] types, byte[][] bytecodes)
+    throws JdwpException;
+
+  /**
+   * Sets the default stratum. VM must support the
+   * canSetDefaultStratum capability.
+   *
+   * @param stratum the new default stratum or empty string to
+   *        use the reference default
+   */
+  public static native void setDefaultStratum(String stratum)
+    throws JdwpException;
+
+  /**
+   * Returns the source debug extension. VM must support the
+   * canGetSourceDebugExtension capability.
+   *
+   * @param klass the class for which to return information
+   * @returns the source debug extension
+   */
+  public static native String getSourceDebugExtension(Class klass)
+    throws JdwpException;
+
+  /**
+   * Returns the bytecode for the given method. VM must support the
+   * canGetBytecodes capability.
+   *
+   * @param method the method for which to get bytecodes
+   * @returns the bytecodes
+   */
+  public static native byte[] getBytecodes(VMMethod method)
+    throws JdwpException;
+
+  /**
+   * Returns monitor information about an object. VM must support
+   * the canGetMonitorInformation capability.
+   *
+   * @param obj the object
+   * @returns monitor information (owner, entry count, waiters)
+   */
+  public static native MonitorInfo getMonitorInfo(Object obj)
+    throws JdwpException;
+
+  /**
+   * Returns a list of owned monitors. VM must support the
+   * canGetOwnedMonitorInfo capability.
+   *
+   * @param thread a thread
+   * @returns the list of monitors owned by this thread
+   */
+  public static native Object[] getOwnedMonitors(Thread thread)
+    throws JdwpException;
+
+  /**
+   * Returns the current contended monitor for a thread. VM must
+   * support canGetCurrentContendedMonitor capability.
+   *
+   * @param thread the thread
+   * @returns the contended monitor
+   */
+  public static native Object getCurrentContendedMonitor(Thread thread)
+    throws JdwpException;
+
+  /**
+   * Pop all frames up to and including the given frame. VM must
+   * support canPopFrames capability. It is the responsibility
+   * of the VM to check if the thread is suspended. If it is not,
+   * the VM should throw ThreadNotSuspendedException.
+   *
+   * @param thread the thread
+   * @param frame the frame ID
+   */
+  public static native void popFrames(Thread thread, long frameId);
 }
Index: libjava/gnu/gcj/jvmti/natBreakpoint.cc
===================================================================
--- libjava/gnu/gcj/jvmti/natBreakpoint.cc	(revision 125219)
+++ libjava/gnu/gcj/jvmti/natBreakpoint.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // natBreakpoint.cc - C++ side of Breakpoint
 
-/* Copyright (C) 2006  Free Software Foundation
+/* Copyright (C) 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -17,6 +17,7 @@
 #include <jvmti.h>
 
 #include <gnu/gcj/jvmti/Breakpoint.h>
+#include <gnu/gcj/jvmti/BreakpointManager.h>
 
 static _Jv_InterpMethod *
 get_interp_method (jlong method)
@@ -39,7 +40,6 @@
   pc_t code = imeth->get_insn (location);
   data = (RawDataManaged *) JvAllocBytes (sizeof (*code));
   memcpy (data, code, sizeof (*code));
-  install ();
 }
 
 void
@@ -55,3 +55,18 @@
   _Jv_InterpMethod *imeth = get_interp_method (method);
   imeth->set_insn (location, reinterpret_cast<pc_t> (data));
 }
+
+#ifdef DIRECT_THREADED
+void
+_Jv_RewriteBreakpointInsn (jmethodID mid, jlocation loc, pc_t new_insn)
+{
+  using namespace ::gnu::gcj::jvmti;
+  Breakpoint *bp
+    = BreakpointManager::getBreakpoint (reinterpret_cast<jlong> (mid), loc);
+  if (bp != NULL)
+    {
+      pc_t old_insn = (pc_t) bp->data;
+      old_insn->insn = new_insn;
+    }
+}
+#endif // DIRECT_THREADED
Index: libjava/gnu/gcj/jvmti/BreakpointManager.java
===================================================================
--- libjava/gnu/gcj/jvmti/BreakpointManager.java	(revision 125219)
+++ libjava/gnu/gcj/jvmti/BreakpointManager.java	(revision 126334)
@@ -1,6 +1,6 @@
 // BreakpointManager.java - A convenience class for dealing with breakpoints
 
-/* Copyright (C) 2006  Free Software Foundation
+/* Copyright (C) 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -45,6 +45,7 @@
   {
     Breakpoint bp = new Breakpoint (method, location);
     Location loc = new Location (method, location);
+    bp.install ();
     _instance._breakpoints.put (loc, bp);
     return bp;
   }
@@ -58,7 +59,12 @@
   public static void deleteBreakpoint (long method, long location)
   {
     Location loc = new Location (method, location);
-    _instance._breakpoints.remove (loc);
+    Breakpoint bp = (Breakpoint) _instance._breakpoints.get (loc);
+    if (bp != null)
+      {
+	bp.remove ();
+	_instance._breakpoints.remove (loc);
+      }
   }
 
   /**
Index: libjava/headers.txt
===================================================================
--- libjava/headers.txt	(revision 125219)
+++ libjava/headers.txt	(revision 126334)
@@ -65,5 +65,13 @@
 friend java::lang::reflect::Method* ::_Jv_GetReflectedMethod (jclass, _Jv_Utf8Const*, _Jv_Utf8Const*);
 friend java::lang::reflect::Method* ::_Jv_LookupProxyMethod (jclass, _Jv_Utf8Const *, _Jv_Utf8Const *);
 
+class gnu/gcj/jvmti/Breakpoint
+prepend #ifdef DIRECT_THREADED
+prepend void _Jv_RewriteBreakpointInsn (jmethodID, jlocation, pc_t);
+prepend #endif
+add #ifdef DIRECT_THREADED
+add friend void (::_Jv_RewriteBreakpointInsn (jmethodID, jlocation, pc_t));
+add #endif
+
 class gnu/gcj/runtime/ExtensionClassLoader
 friend class ::java::lang::ClassLoader;
Index: libjava/interpret-run.cc
===================================================================
--- libjava/interpret-run.cc	(revision 125219)
+++ libjava/interpret-run.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // interpret-run.cc - Code to interpret bytecode
 
-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation
+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation
 
    This file is part of libgcj.
 
@@ -12,6 +12,8 @@
  * compiled directly.	*/
 
   using namespace java::lang::reflect;
+  
+  pc_t pc = NULL;
 
   // FRAME_DESC registers this particular invocation as the top-most
   // interpreter frame.  This lets the stack tracing code (for
@@ -20,13 +22,108 @@
   // destructor so it cleans up automatically when the interpreter
   // returns.
   java::lang::Thread *thread = java::lang::Thread::currentThread();
+  
+#ifdef DEBUG
+  _Jv_InterpFrame frame_desc (meth, thread, NULL, &pc);
+#else
   _Jv_InterpFrame frame_desc (meth, thread);
+#endif
 
   _Jv_word stack[meth->max_stack];
   _Jv_word *sp = stack;
 
   _Jv_word locals[meth->max_locals];
 
+#ifdef DEBUG
+  // This is the information needed to get and set local variables with
+  // proper type checking.
+  frame_desc.locals = locals;
+  char locals_type[meth->max_locals];
+  frame_desc.locals_type = locals_type;
+  
+  // Set all slots as invalid until they are written to.
+  memset (locals_type, 'x', meth->max_locals);
+  
+  // We need to set the local variable types for the method arguments since
+  // they are valid at invocation.
+  
+  _Jv_Method *method = meth->get_method ();
+  int type_ctr = 0;
+  
+  // If the method is non-static, we need to set the type for the "this" pointer.
+  if ((method->accflags & java::lang::reflect::Modifier::STATIC) == 0)
+    {
+      if (args)
+        {
+          // Set the "this" pointer for this frame.
+          _Jv_word *this_ptr = reinterpret_cast<_Jv_word *> (args);
+          frame_desc.obj_ptr = this_ptr[0].o;
+        }
+
+      frame_desc.locals_type[0] = 'o';
+      type_ctr++;
+    }
+  
+  // Now parse the method signature to set the types of the other arguments.  
+  int sig_len = method->signature->len ();
+  char *signature = method->signature->chars ();
+  for (int i = 1; signature[i] != ')' && i <= sig_len; i++)
+    {
+      if (signature[i] == 'Z' || signature[i] == 'B' || signature[i] == 'C' 
+          || signature[i] == 'S' || signature[i] == 'I')
+        {
+          frame_desc.locals_type[type_ctr] = 'i';
+          type_ctr++;
+          continue;
+        }
+      else if (signature[i] == 'F')
+        {
+          frame_desc.locals_type[type_ctr] = 'f';
+          type_ctr++;
+          continue;
+        }
+      else if (signature[i] == 'J')
+        {
+          frame_desc.locals_type[type_ctr] = 'l';
+          frame_desc.locals_type[type_ctr+1] = 'x';
+          type_ctr += 2;
+          continue;
+        }
+      else if (signature[i] == 'D')
+        {
+          frame_desc.locals_type[type_ctr] = 'd';
+          frame_desc.locals_type[type_ctr+1] = 'x';
+          type_ctr += 2;
+          continue;
+        }
+      else if (signature[i] == 'L')
+        {
+          frame_desc.locals_type[type_ctr] = 'o';
+          type_ctr++;
+          while (signature[i] != ';')
+            i++;
+          continue;
+        }
+      else if (signature[i] == '[')
+        {
+          frame_desc.locals_type[type_ctr] = 'o';
+          type_ctr++;
+          
+          // Ignore multi-dimensional arrays.
+          while (signature[i] == '[')
+            i++;
+          
+          // Check for an object array
+          if (signature[i] == 'L')
+            {
+              while (signature[i] != ';')
+                i++;
+            }
+          continue;
+        }
+    }
+#endif /* DEBUG */
+
 #define INSN_LABEL(op) &&insn_##op
 
   static const void *const insn_target[] = 
@@ -217,7 +314,7 @@
     INSN_LABEL(invokespecial),
     INSN_LABEL(invokestatic),
     INSN_LABEL(invokeinterface),
-    INSN_LABEL (breakpoint),
+    INSN_LABEL(breakpoint),
     INSN_LABEL(new),
     INSN_LABEL(newarray),
     INSN_LABEL(anewarray),
@@ -244,11 +341,58 @@
 #endif
   };
 
-  pc_t pc;
-
 #ifdef DIRECT_THREADED
 
+#ifdef DEBUG
+#undef NEXT_INSN
+#define NEXT_INSN							\
+  do									\
+    {									\
+      pc_t insn = pc++;							\
+      if (JVMTI_REQUESTED_EVENT (SingleStep))				\
+	{								\
+	  JNIEnv *env = _Jv_GetCurrentJNIEnv ();			\
+	  jmethodID method = meth->self;				\
+	  jlocation loc = meth->insn_index (insn);			\
+	  _Jv_JVMTI_PostEvent (JVMTI_EVENT_SINGLE_STEP, thread,		\
+			       env, method, loc);			\
+	}								\
+      goto *(insn->insn);						\
+    }									\
+  while (0)
+
+#undef REWRITE_INSN
+#define REWRITE_INSN(INSN,SLOT,VALUE)					\
+  do {									\
+    if (pc[-2].insn == breakpoint_insn->insn)				\
+      {									\
+	using namespace ::gnu::gcj::jvmti;				\
+	jlocation location = meth->insn_index (pc - 2);			\
+	_Jv_RewriteBreakpointInsn (meth->self, location, (pc_t) INSN);	\
+      }									\
+    else								\
+      pc[-2].insn = INSN;						\
+									\
+    pc[-1].SLOT = VALUE;						\
+  }									\
+  while (0)
+
+#undef INTERP_REPORT_EXCEPTION
+#define INTERP_REPORT_EXCEPTION(Jthrowable) REPORT_EXCEPTION (Jthrowable)
+#else // !DEBUG
+#undef NEXT_INSN
 #define NEXT_INSN goto *((pc++)->insn)
+#define REWRITE_INSN(INSN,SLOT,VALUE)		\
+  do {						\
+    pc[-2].insn = INSN;				\
+    pc[-1].SLOT = VALUE;			\
+  }						\
+  while (0)
+
+#undef INTERP_REPORT_EXCEPTION
+#define INTERP_REPORT_EXCEPTION(Jthrowable) /* not needed when not debugging */
+#endif // !DEBUG
+
 #define INTVAL() ((pc++)->int_val)
 #define AVAL() ((pc++)->datum)
 
@@ -281,7 +425,22 @@
 
 #else
 
+#ifdef DEBUG
+#define NEXT_INSN							\
+  do									\
+    {									\
+      if (JVMTI_REQUESTED_EVENT (SingleStep))				\
+	{								\
+	  JNIEnv *env = _Jv_GetCurrentJNIEnv ();			\
+	  jmethodID method = meth->self;				\
+	  jlocation loc = meth->insn_index (pc);			\
+	  _Jv_JVMTI_PostEvent (JVMTI_EVENT_SINGLE_STEP, thread,		\
+			       env, method, loc);			\
+	}								\
+      goto *(insn_target[*pc++])
+#else
 #define NEXT_INSN goto *(insn_target[*pc++])
+#endif
 
 #define GET1S() get1s (pc++)
 #define GET2S() (pc += 2, get2s (pc- 2))
@@ -381,8 +540,7 @@
 #ifdef DIRECT_THREADED
 	// Rewrite instruction so that we use a faster pre-resolved
 	// method.
-	pc[-2].insn = &&invokevirtual_resolved;
-	pc[-1].datum = rmeth;
+	REWRITE_INSN (&&invokevirtual_resolved, datum, rmeth);
 #endif /* DIRECT_THREADED */
       }
       goto perform_invoke;
@@ -1716,8 +1874,7 @@
 	  }
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = newinsn;
-	pc[-1].datum = field->u.addr;
+	REWRITE_INSN (newinsn, datum, field->u.addr);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -1807,8 +1964,7 @@
 	  }
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = newinsn;
-	pc[-1].int_val = field_offset;
+	REWRITE_INSN (newinsn, int_val, field_offset);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -1923,8 +2079,7 @@
 	  }
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = newinsn;
-	pc[-1].datum = field->u.addr;
+	REWRITE_INSN (newinsn, datum, field->u.addr);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -2022,8 +2177,7 @@
 	  }
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = newinsn;
-	pc[-1].int_val = field_offset;
+	REWRITE_INSN (newinsn, int_val, field_offset);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -2098,8 +2252,7 @@
 #ifdef DIRECT_THREADED
 	// Rewrite instruction so that we use a faster pre-resolved
 	// method.
-	pc[-2].insn = &&invokespecial_resolved;
-	pc[-1].datum = rmeth;
+	REWRITE_INSN (&&invokespecial_resolved, datum, rmeth);
 #endif /* DIRECT_THREADED */
       }
       goto perform_invoke;
@@ -2136,8 +2289,7 @@
 #ifdef DIRECT_THREADED
 	// Rewrite instruction so that we use a faster pre-resolved
 	// method.
-	pc[-2].insn = &&invokestatic_resolved;
-	pc[-1].datum = rmeth;
+	REWRITE_INSN (&&invokestatic_resolved, datum, rmeth);
 #endif /* DIRECT_THREADED */
       }
       goto perform_invoke;
@@ -2175,8 +2327,7 @@
 #ifdef DIRECT_THREADED
 	// Rewrite instruction so that we use a faster pre-resolved
 	// method.
-	pc[-2].insn = &&invokeinterface_resolved;
-	pc[-1].datum = rmeth;
+	REWRITE_INSN (&&invokeinterface_resolved, datum, rmeth);
 #else
 	// Skip dummy bytes.
 	pc += 2;
@@ -2209,13 +2360,16 @@
 	/* VM spec, section 3.11.5 */
 	if ((klass->getModifiers() & Modifier::ABSTRACT)
 	    || klass->isInterface())
-	  throw new java::lang::InstantiationException;
+	  {
+	    jthrowable t = new java::lang::InstantiationException;
+	    INTERP_REPORT_EXCEPTION (t);
+	    throw t;
+	  }
 	jobject res = _Jv_AllocObject (klass);
 	PUSHA (res);
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = &&new_resolved;
-	pc[-1].datum = klass;
+	REWRITE_INSN (&&new_resolved, datum, klass);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -2250,8 +2404,7 @@
 	PUSHA (result);
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = &&anewarray_resolved;
-	pc[-1].datum = klass;
+	REWRITE_INSN (&&anewarray_resolved, datum, klass);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -2278,7 +2431,9 @@
     insn_athrow:
       {
 	jobject value = POPA();
-	throw static_cast<jthrowable>(value);
+	jthrowable t = static_cast<jthrowable> (value);
+	INTERP_REPORT_EXCEPTION (t);
+	throw t;
       }
       NEXT_INSN;
 
@@ -2295,8 +2450,7 @@
 	PUSHA (value);
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = &&checkcast_resolved;
-	pc[-1].datum = to;
+	REWRITE_INSN (&&checkcast_resolved, datum, to);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -2323,8 +2477,7 @@
 	PUSHI (to->isInstance (value));
 
 #ifdef DIRECT_THREADED
-	pc[-2].insn = &&instanceof_resolved;
-	pc[-1].datum = to;
+	REWRITE_INSN (&&instanceof_resolved, datum, to);
 #endif /* DIRECT_THREADED */
       }
       NEXT_INSN;
@@ -2466,48 +2619,57 @@
 
     insn_breakpoint:
       {
-	// nothing just yet
+	JvAssert (JVMTI_REQUESTED_EVENT (Breakpoint));
+
+	// Send JVMTI notification
+	using namespace ::java::lang;
+	jmethodID method = meth->self;
+	jlocation location = meth->insn_index (pc - 1);
+	Thread *thread = Thread::currentThread ();
+	JNIEnv *jni_env = _Jv_GetCurrentJNIEnv ();
+
+	// Save the insn here since the breakpoint could be removed
+	// before the JVMTI notification returns.
+	using namespace gnu::gcj::jvmti;
+	Breakpoint *bp
+	  = BreakpointManager::getBreakpoint (reinterpret_cast<jlong> (method),
+					      location);
+	JvAssert (bp != NULL);
+	pc_t opc = reinterpret_cast<pc_t> (bp->getInsn ());
+
+	_Jv_JVMTI_PostEvent (JVMTI_EVENT_BREAKPOINT, thread, jni_env,
+			     method, location);
+
+	// Continue execution
+#ifdef DIRECT_THREADED
+	goto *(opc->insn);
+#else
+	goto *(insn_target[*opc]);
+#endif
       }
     }
   catch (java::lang::Throwable *ex)
     {
-#ifdef DIRECT_THREADED
-      void *logical_pc = (void *) ((insn_slot *) pc - 1);
-#else
-      int logical_pc = pc - 1 - meth->bytecode ();
+      // Check if the exception is handled and, if so, set the pc to the start
+      // of the appropriate catch block.
+      if (meth->check_handler (&pc, meth, ex))
+        {
+          sp = stack;
+          sp++->o = ex; // Push exception.
+#ifdef DEBUG
+          if (JVMTI_REQUESTED_EVENT (ExceptionCatch))
+            {
+              using namespace gnu::gcj::jvmti;
+              jlong catch_meth = reinterpret_cast<jlong> (meth->get_method ());
+              jlong catch_loc = meth->insn_index (pc);
+	      _Jv_JVMTI_PostEvent (JVMTI_EVENT_EXCEPTION_CATCH, thread,
+				   _Jv_GetCurrentJNIEnv (), catch_meth,
+				   catch_loc, ex);
+            }
 #endif
-      _Jv_InterpException *exc = meth->exceptions ();
-      jclass exc_class = ex->getClass ();
+          NEXT_INSN;
+        }
 
-      for (int i = 0; i < meth->exc_count; i++)
-	{
-	  if (PCVAL (exc[i].start_pc) <= logical_pc
-	      && logical_pc < PCVAL (exc[i].end_pc))
-	    {
-#ifdef DIRECT_THREADED
-	      jclass handler = (jclass) exc[i].handler_type.p;
-#else
-	      jclass handler = NULL;
-	      if (exc[i].handler_type.i != 0)
-		handler = (_Jv_Linker::resolve_pool_entry (meth->defining_class,
-							   exc[i].handler_type.i)).clazz;
-#endif /* DIRECT_THREADED */
-
-	      if (handler == NULL || handler->isAssignableFrom (exc_class))
-		{
-
-#ifdef DIRECT_THREADED
-		  pc = (insn_slot *) exc[i].handler_pc.p;
-#else
-		  pc = meth->bytecode () + exc[i].handler_pc.i;
-#endif /* DIRECT_THREADED */
-		  sp = stack;
-		  sp++->o = ex; // Push exception.
-		  NEXT_INSN;
-		}
-	    }
-	}
-
       // No handler, so re-throw.
       throw ex;
     }
Index: libjava/boehm.cc
===================================================================
--- libjava/boehm.cc	(revision 125219)
+++ libjava/boehm.cc	(revision 126334)
@@ -722,6 +722,17 @@
 #endif
 }
 
+int
+_Jv_IsThreadSuspended (_Jv_Thread_t *thread)
+{
+#if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \
+     && !defined(GC_WIN32_THREADS) && !defined(GC_DARWIN_THREADS)
+  return GC_is_thread_suspended (_Jv_GetPlatformThreadID (thread));
+#else
+  return 0;
+#endif
+}
+
 void
 _Jv_GCAttachThread ()
 {
Index: libjava/sources.am
===================================================================
--- libjava/sources.am	(revision 125219)
+++ libjava/sources.am	(revision 126334)
@@ -326,15 +326,19 @@
 
 
 gnu_classpath_jdwp_exception_source_files = \
+classpath/gnu/classpath/jdwp/exception/AbsentInformationException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidClassException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidClassLoaderException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidCountException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidEventTypeException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidFieldException.java \
+classpath/gnu/classpath/jdwp/exception/InvalidFrameException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidLocationException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidMethodException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidObjectException.java \
+classpath/gnu/classpath/jdwp/exception/InvalidSlotException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidStringException.java \
+classpath/gnu/classpath/jdwp/exception/InvalidTagException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidThreadException.java \
 classpath/gnu/classpath/jdwp/exception/InvalidThreadGroupException.java \
 classpath/gnu/classpath/jdwp/exception/JdwpException.java \
@@ -342,6 +346,7 @@
 classpath/gnu/classpath/jdwp/exception/JdwpInternalErrorException.java \
 classpath/gnu/classpath/jdwp/exception/NativeMethodException.java \
 classpath/gnu/classpath/jdwp/exception/NotImplementedException.java \
+classpath/gnu/classpath/jdwp/exception/TypeMismatchException.java \
 classpath/gnu/classpath/jdwp/exception/VmDeadException.java
 
 gnu_classpath_jdwp_exception_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_exception_source_files)))
@@ -361,6 +366,7 @@
 classpath/gnu/classpath/jdwp/id/ClassReferenceTypeId.java \
 classpath/gnu/classpath/jdwp/id/InterfaceReferenceTypeId.java \
 classpath/gnu/classpath/jdwp/id/JdwpId.java \
+classpath/gnu/classpath/jdwp/id/NullObjectId.java \
 classpath/gnu/classpath/jdwp/id/ObjectId.java \
 classpath/gnu/classpath/jdwp/id/ReferenceTypeId.java \
 classpath/gnu/classpath/jdwp/id/StringId.java \
@@ -429,6 +435,8 @@
 classpath/gnu/classpath/jdwp/util/LineTable.java \
 classpath/gnu/classpath/jdwp/util/Location.java \
 classpath/gnu/classpath/jdwp/util/MethodResult.java \
+classpath/gnu/classpath/jdwp/util/MonitorInfo.java \
+classpath/gnu/classpath/jdwp/util/NullObject.java \
 classpath/gnu/classpath/jdwp/util/Signature.java \
 classpath/gnu/classpath/jdwp/util/Value.java \
 classpath/gnu/classpath/jdwp/util/VariableTable.java
@@ -442,6 +450,31 @@
 -include gnu/classpath/jdwp/util.deps
 
 
+gnu_classpath_jdwp_value_source_files = \
+classpath/gnu/classpath/jdwp/value/ArrayValue.java \
+classpath/gnu/classpath/jdwp/value/BooleanValue.java \
+classpath/gnu/classpath/jdwp/value/ByteValue.java \
+classpath/gnu/classpath/jdwp/value/CharValue.java \
+classpath/gnu/classpath/jdwp/value/DoubleValue.java \
+classpath/gnu/classpath/jdwp/value/FloatValue.java \
+classpath/gnu/classpath/jdwp/value/IntValue.java \
+classpath/gnu/classpath/jdwp/value/LongValue.java \
+classpath/gnu/classpath/jdwp/value/ObjectValue.java \
+classpath/gnu/classpath/jdwp/value/ShortValue.java \
+classpath/gnu/classpath/jdwp/value/StringValue.java \
+classpath/gnu/classpath/jdwp/value/Value.java \
+classpath/gnu/classpath/jdwp/value/ValueFactory.java \
+classpath/gnu/classpath/jdwp/value/VoidValue.java
+
+gnu_classpath_jdwp_value_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_value_source_files)))
+
+gnu/classpath/jdwp/value.list: $(gnu_classpath_jdwp_value_source_files)
+	@$(mkinstalldirs) $(dir $@)
+	echo $(srcdir)/classpath/lib/gnu/classpath/jdwp/value/*.class > gnu/classpath/jdwp/value.list
+
+-include gnu/classpath/jdwp/value.deps
+
+
 gnu_gcj_source_files = \
 gnu/gcj/Core.java \
 gnu/gcj/RawData.java \
@@ -8341,6 +8374,7 @@
   gnu/classpath/jdwp/processor.list \
   gnu/classpath/jdwp/transport.list \
   gnu/classpath/jdwp/util.list \
+  gnu/classpath/jdwp/value.list \
   gnu/gcj.list \
   gnu/gcj/convert.list \
   gnu/gcj/io.list \
@@ -8585,6 +8619,7 @@
   $(gnu_classpath_jdwp_processor_header_files) \
   $(gnu_classpath_jdwp_transport_header_files) \
   $(gnu_classpath_jdwp_util_header_files) \
+  $(gnu_classpath_jdwp_value_header_files) \
   $(gnu_gcj_header_files) \
   $(gnu_gcj_convert_header_files) \
   $(gnu_gcj_io_header_files) \
Index: libjava/java/lang/Thread.java
===================================================================
--- libjava/java/lang/Thread.java	(revision 125219)
+++ libjava/java/lang/Thread.java	(revision 126334)
@@ -185,6 +185,9 @@
   
   // This describes the top-most interpreter frame for this thread.
   RawData interp_frame;
+  
+  // This describes the top most frame in the composite (interp + JNI) stack
+  RawData frame;
 
   // Current state.
   volatile int state;
Index: libjava/java/lang/natClass.cc
===================================================================
--- libjava/java/lang/natClass.cc	(revision 125219)
+++ libjava/java/lang/natClass.cc	(revision 126334)
@@ -1,6 +1,6 @@
 // natClass.cc - Implementation of java.lang.Class native methods.
 
-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
    Free Software Foundation
 
    This file is part of libgcj.
@@ -2079,3 +2079,21 @@
   return reinterpret_cast<jclass> (_Jv_StackTrace::ncodeMap->get (obj));
 }
 
+jbyte
+_Jv_GetClassState (jclass klass)
+{
+  return klass->state;
+}
+
+jstring
+_Jv_GetInterpClassSourceFile (jclass klass)
+{
+  if (_Jv_IsInterpretedClass (klass))
+    {
+      _Jv_InterpClass *iclass =
+	reinterpret_cast<_Jv_InterpClass *> (klass->aux_info);
+      return iclass->source_file_name;
+    }
+
+  return NULL;
+}
Index: libjava/java/lang/natThread.cc
===================================================================
--- libjava/java/lang/natThread.cc	(revision 125219)
+++ libjava/java/lang/natThread.cc	(revision 126334)
@@ -27,6 +27,8 @@
 #include <java/lang/NullPointerException.h>
 
 #include <jni.h>
+#include <jvmti.h>
+#include "jvmti-int.h"
 
 #ifdef ENABLE_JVMPI
 #include <jvmpi.h>
@@ -215,6 +217,9 @@
   nt->park_helper.deactivate ();
   group->removeThread (this);
 
+  if (JVMTI_REQUESTED_EVENT (ThreadEnd))
+    _Jv_JVMTI_PostEvent (JVMTI_EVENT_THREAD_END, this, nt->jni_env);
+
 #ifdef ENABLE_JVMPI  
   if (_Jv_JVMPI_Notify_THREAD_END)
     {
@@ -253,6 +258,12 @@
 static void
 _Jv_NotifyThreadStart (java::lang::Thread* thread)
 {
+  if (JVMTI_REQUESTED_EVENT (ThreadStart))
+    {
+      natThread *nt = reinterpret_cast<natThread *> (thread->data);
+      _Jv_JVMTI_PostEvent (JVMTI_EVENT_THREAD_START, thread, nt->jni_env);
+    }
+
 #ifdef ENABLE_JVMPI
       if (_Jv_JVMPI_Notify_THREAD_START)
 	{
Index: libjava/java/lang/Class.h
===================================================================
--- libjava/java/lang/Class.h	(revision 125219)
+++ libjava/java/lang/Class.h	(revision 126334)
@@ -1,6 +1,6 @@
 // Class.h - Header file for java.lang.Class.  -*- c++ -*-
 
-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation
+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007  Free Software Foundation
 
    This file is part of libgcj.
 
@@ -269,8 +269,11 @@
 // Finds a desired interpreter method in the given class or NULL if not found
 class _Jv_MethodBase;
 _Jv_MethodBase *_Jv_FindInterpreterMethod (jclass, jmethodID);
+jstring _Jv_GetInterpClassSourceFile (jclass);
 #endif
 
+jbyte _Jv_GetClassState (jclass);
+
 // Friend classes and functions to implement the ClassLoader
 class java::lang::ClassLoader;
 class java::lang::VMClassLoader;
@@ -571,7 +574,9 @@
 #ifdef INTERPRETER
   friend _Jv_MethodBase *(::_Jv_FindInterpreterMethod) (jclass klass,
 							jmethodID desired_method);
+  friend jstring ::_Jv_GetInterpClassSourceFile (jclass);
 #endif
+  friend jbyte (::_Jv_GetClassState) (jclass klass);
 
   // Friends classes and functions to implement the ClassLoader
   friend class java::lang::ClassLoader;
Index: libjava/defineclass.cc
===================================================================
--- libjava/defineclass.cc	(revision 125219)
+++ libjava/defineclass.cc	(revision 126334)
@@ -300,6 +300,9 @@
 
   /** check an utf8 entry, without creating a Utf8Const object */
   bool is_attribute_name (int index, const char *name);
+  
+  /** return the value of a utf8 entry in the passed array */
+  int pool_Utf8_to_char_arr (int index, char **entry);
 
   /** here goes the class-loader members defined out-of-line */
   void handleConstantPool ();
@@ -785,6 +788,18 @@
     return !memcmp (bytes+offsets[index]+2, name, len);
 }
 
+// Get a UTF8 value from the constant pool and turn it into a garbage
+// collected char array.
+int _Jv_ClassReader::pool_Utf8_to_char_arr (int index, char** entry)
+{
+  check_tag (index, JV_CONSTANT_Utf8);
+  int len = get2u (bytes + offsets[index]);
+  *entry = reinterpret_cast<char *> (_Jv_AllocBytes (len + 1));
+  (*entry)[len] = '\0';
+  memcpy (*entry, bytes + offsets[index] + 2, len);
+  return len + 1;
+}
+
 void _Jv_ClassReader::read_one_field_attribute (int field_index,
 						bool *found_value)
 {
@@ -980,6 +995,34 @@
       method->line_table_len = table_len;
       method->line_table = table;
     }
+  else if (is_attribute_name (name, "LocalVariableTable"))
+    {
+      _Jv_InterpMethod *method = reinterpret_cast<_Jv_InterpMethod *>
+	                       (def_interp->interpreted_methods[method_index]);
+      if (method->local_var_table != NULL)
+        throw_class_format_error ("Method already has LocalVariableTable");
+	
+      int table_len = read2u ();
+      _Jv_LocalVarTableEntry *table 
+        = reinterpret_cast<_Jv_LocalVarTableEntry *>
+            (_Jv_AllocRawObj (table_len * sizeof (_Jv_LocalVarTableEntry)));
+                               
+      for (int i = 0; i < table_len; i++)
+        {
+          table[i].bytecode_start_pc = read2u ();
+          table[i].length = read2u ();
+          int len;
+          len = pool_Utf8_to_char_arr (read2u (), &table[i].name);
+          len = pool_Utf8_to_char_arr (read2u (), &table[i].descriptor);
+          table[i].slot = read2u ();
+          
+          if (table[i].slot > method->max_locals || table[i].slot < 0)
+            throw_class_format_error ("Malformed Local Variable Table: Invalid Slot");
+        }
+	    
+      method->local_var_table_len = table_len;
+      method->local_var_table = table;
+    }
   else
     {
       /* ignore unknown code attributes */
Index: libjava/nogc.cc
===================================================================
--- libjava/nogc.cc	(revision 125219)
+++ libjava/nogc.cc	(revision 126334)
@@ -184,3 +184,9 @@
 _Jv_ResumeThread (_Jv_Thread_t *thread)
 {
 }
+
+int
+_Jv_IsThreadSuspended (_Jv_Thread_t *thread)
+{
+  return 0;
+}
--- libjava/sources.am.old	2007-07-18 23:38:45.215265000 +0200
+++ libjava/sources.am	2007-07-19 01:28:59.115034261 +0200
@@ -438,7 +438,6 @@
 classpath/gnu/classpath/jdwp/util/MonitorInfo.java \
 classpath/gnu/classpath/jdwp/util/NullObject.java \
 classpath/gnu/classpath/jdwp/util/Signature.java \
-classpath/gnu/classpath/jdwp/util/Value.java \
 classpath/gnu/classpath/jdwp/util/VariableTable.java
 
 gnu_classpath_jdwp_util_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_util_source_files)))
--- libjava/Makefile.in.old	2007-07-18 23:39:00.645497000 +0200
+++ libjava/Makefile.in	2007-07-19 01:34:08.019694018 +0200
@@ -1270,7 +1270,6 @@
 classpath/gnu/classpath/jdwp/util/MonitorInfo.java \
 classpath/gnu/classpath/jdwp/util/NullObject.java \
 classpath/gnu/classpath/jdwp/util/Signature.java \
-classpath/gnu/classpath/jdwp/util/Value.java \
 classpath/gnu/classpath/jdwp/util/VariableTable.java
 
 gnu_classpath_jdwp_util_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_classpath_jdwp_util_source_files)))
