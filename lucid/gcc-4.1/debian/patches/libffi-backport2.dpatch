#! /bin/sh -e

# DP: Add missing bits for the libffi backport from the trunk
# DP: - parisc chunks
# DP: - missing testcases in testsuite/libffi.call

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p0 < $0
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p0 < $0
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0

diff -urN 4.1/libffi/include/ffi.h.in libffi/include/ffi.h.in
--- 4.1/libffi/include/ffi.h.in	2004-08-30 17:43:03.000000000 +0200
+++ libffi/include/ffi.h.in	2006-07-26 11:41:43.000000000 +0200
@@ -112,16 +112,24 @@
  #error "int size not supported"
 #endif
 
-#define ffi_type_ulong         ffi_type_uint64
-#define ffi_type_slong         ffi_type_sint64
 #if LONG_MAX == 2147483647
 # if FFI_LONG_LONG_MAX != 9223372036854775807
-  #error "no 64-bit data type supported"
+ #error "no 64-bit data type supported"
 # endif
 #elif LONG_MAX != 9223372036854775807
  #error "long size not supported"
 #endif
 
+#if LONG_MAX == 2147483647
+# define ffi_type_ulong        ffi_type_uint32
+# define ffi_type_slong        ffi_type_sint32
+#elif LONG_MAX == 9223372036854775807
+# define ffi_type_ulong        ffi_type_uint64
+# define ffi_type_slong        ffi_type_sint64
+#else
+ #error "long size not supported"
+#endif
+
 /* The closure code assumes that this works on pointers, i.e. a size_t	*/
 /* can hold a pointer.							*/
 
diff -urN 4.1/libffi/src/pa/ffi.c libffi/src/pa/ffi.c
--- 4.1/libffi/src/pa/ffi.c	2006-08-15 01:18:41.799179248 +0200
+++ libffi/src/pa/ffi.c	2006-05-24 04:11:35.000000000 +0200
@@ -2,6 +2,7 @@
    ffi.c - (c) 2003-2004 Randolph Chung <tausq@debian.org>
 
    HPPA Foreign Function Interface
+   HP-UX PA ABI support (c) 2006 Free Software Foundation, Inc.
 
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
@@ -134,7 +135,7 @@
    NOTE: We load floating point args in this function... that means we
    assume gcc will not mess with fp regs in here.  */
 
-void ffi_prep_args_LINUX(UINT32 *stack, extended_cif *ecif, unsigned bytes)
+void ffi_prep_args_pa32(UINT32 *stack, extended_cif *ecif, unsigned bytes)
 {
   register unsigned int i;
   register ffi_type **p_arg;
@@ -213,6 +214,14 @@
 	    }
 	  break;
 
+#ifdef PA_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+	  /* Long doubles are passed in the same manner as structures
+	     larger than 8 bytes.  */
+	  *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);
+	  break;
+#endif
+
 	case FFI_TYPE_STRUCT:
 
 	  /* Structs smaller or equal than 4 bytes are passed in one
@@ -262,7 +271,7 @@
   return;
 }
 
-static void ffi_size_stack_LINUX(ffi_cif *cif)
+static void ffi_size_stack_pa32(ffi_cif *cif)
 {
   ffi_type **ptr;
   int i;
@@ -280,6 +289,9 @@
 	  z += 2 + (z & 1); /* must start on even regs, so we may waste one */
 	  break;
 
+#ifdef PA_HPUX
+	case FFI_TYPE_LONGDOUBLE:
+#endif
 	case FFI_TYPE_STRUCT:
 	  z += 1; /* pass by ptr, callee will copy */
 	  break;
@@ -311,6 +323,13 @@
       cif->flags = (unsigned) cif->rtype->type;
       break;
 
+#ifdef PA_HPUX
+    case FFI_TYPE_LONGDOUBLE:
+      /* Long doubles are treated like a structure.  */
+      cif->flags = FFI_TYPE_STRUCT;
+      break;
+#endif
+
     case FFI_TYPE_STRUCT:
       /* For the return type we have to check the size of the structures.
 	 If the size is smaller or equal 4 bytes, the result is given back
@@ -334,8 +353,8 @@
      own stack sizing.  */
   switch (cif->abi)
     {
-    case FFI_LINUX:
-      ffi_size_stack_LINUX(cif);
+    case FFI_PA32:
+      ffi_size_stack_pa32(cif);
       break;
 
     default:
@@ -346,7 +365,7 @@
   return FFI_OK;
 }
 
-extern void ffi_call_LINUX(void (*)(UINT32 *, extended_cif *, unsigned),
+extern void ffi_call_pa32(void (*)(UINT32 *, extended_cif *, unsigned),
 			  extended_cif *, unsigned, unsigned, unsigned *,
 			  void (*fn)());
 
@@ -360,17 +379,25 @@
   /* If the return value is a struct and we don't have a return
      value address then we need to make one.  */
 
-  if (rvalue == NULL && cif->rtype->type == FFI_TYPE_STRUCT)
-    ecif.rvalue = alloca(cif->rtype->size);
+  if (rvalue == NULL
+#ifdef PA_HPUX
+      && (cif->rtype->type == FFI_TYPE_STRUCT
+	  || cif->rtype->type == FFI_TYPE_LONGDOUBLE))
+#else
+      && cif->rtype->type == FFI_TYPE_STRUCT)
+#endif
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
   else
     ecif.rvalue = rvalue;
 
 
   switch (cif->abi)
     {
-    case FFI_LINUX:
-      debug(3, "Calling ffi_call_LINUX: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);
-      ffi_call_LINUX(ffi_prep_args_LINUX, &ecif, cif->bytes,
+    case FFI_PA32:
+      debug(3, "Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);
+      ffi_call_pa32(ffi_prep_args_pa32, &ecif, cif->bytes,
 		     cif->flags, ecif.rvalue, fn);
       break;
 
@@ -385,7 +412,7 @@
    the stack, and we need to fill them into a cif structure and invoke
    the user function. This really ought to be in asm to make sure
    the compiler doesn't do things we don't expect.  */
-ffi_status ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)
+ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)
 {
   ffi_cif *cif;
   void **avalue;
@@ -432,6 +459,7 @@
 	  break;
 
 	case FFI_TYPE_FLOAT:
+#ifdef PA_LINUX
 	  /* The closure call is indirect.  In Linux, floating point
 	     arguments in indirect calls with a prototype are passed
 	     in the floating point registers instead of the general
@@ -445,17 +473,20 @@
 	    case 2: fstw(fr6, (void *)(stack - slot)); break;
 	    case 3: fstw(fr7, (void *)(stack - slot)); break;
 	    }
+#endif
 	  avalue[i] = (void *)(stack - slot);
 	  break;
 
 	case FFI_TYPE_DOUBLE:
 	  slot += (slot & 1) ? 1 : 2;
+#ifdef PA_LINUX
 	  /* See previous comment for FFI_TYPE_FLOAT.  */
 	  switch (slot - FIRST_ARG_SLOT)
 	    {
 	    case 1: fstd(fr5, (void *)(stack - slot)); break;
 	    case 3: fstd(fr7, (void *)(stack - slot)); break;
 	    }
+#endif
 	  avalue[i] = (void *)(stack - slot);
 	  break;
 
@@ -579,7 +610,7 @@
    cif specifies the argument and result types for fun.
    The cif must already be prep'ed.  */
 
-extern void ffi_closure_LINUX(void);
+extern void ffi_closure_pa32(void);
 
 ffi_status
 ffi_prep_closure (ffi_closure* closure,
@@ -588,12 +619,16 @@
 		  void *user_data)
 {
   UINT32 *tramp = (UINT32 *)(closure->tramp);
+#ifdef PA_HPUX
+  UINT32 *tmp;
+#endif
 
-  FFI_ASSERT (cif->abi == FFI_LINUX);
+  FFI_ASSERT (cif->abi == FFI_PA32);
 
   /* Make a small trampoline that will branch to our
      handler function. Use PC-relative addressing.  */
 
+#ifdef PA_LINUX
   tramp[0] = 0xeaa00000; /* b,l .+8,%r21        ; %r21 <- pc+8 */
   tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21    ; mask priv bits */
   tramp[2] = 0x4aa10028; /* ldw 20(%r21),%r1    ; load plabel */
@@ -601,7 +636,7 @@
   tramp[4] = 0x0c201096; /* ldw 0(%r1),%r22     ; address of handler */
   tramp[5] = 0xeac0c000; /* bv%r0(%r22)         ; branch to handler */
   tramp[6] = 0x0c281093; /* ldw 4(%r1),%r19     ; GP of handler */
-  tramp[7] = ((UINT32)(ffi_closure_LINUX) & ~2);
+  tramp[7] = ((UINT32)(ffi_closure_pa32) & ~2);
 
   /* Flush d/icache -- have to flush up 2 two lines because of
      alignment.  */
@@ -622,6 +657,45 @@
 		   : "r"((unsigned long)tramp & ~31),
 		     "r"(32 /* stride */)
 		   : "memory");
+#endif
+
+#ifdef PA_HPUX
+  tramp[0] = 0xeaa00000; /* b,l .+8,%r21        ; %r21 <- pc+8  */
+  tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21    ; mask priv bits  */
+  tramp[2] = 0x4aa10038; /* ldw 28(%r21),%r1    ; load plabel  */
+  tramp[3] = 0x36b53ff1; /* ldo -8(%r21),%r21   ; get closure addr  */
+  tramp[4] = 0x0c201096; /* ldw 0(%r1),%r22     ; address of handler  */
+  tramp[5] = 0x02c010b4; /* ldsid (%r22),%r20   ; load space id  */
+  tramp[6] = 0x00141820; /* mtsp %r20,%sr0      ; into %sr0  */
+  tramp[7] = 0xe2c00000; /* be 0(%sr0,%r22)     ; branch to handler  */
+  tramp[8] = 0x0c281093; /* ldw 4(%r1),%r19     ; GP of handler  */
+  tramp[9] = ((UINT32)(ffi_closure_pa32) & ~2);
+
+  /* Flush d/icache -- have to flush three lines because of alignment.  */
+  __asm__ volatile(
+		   "copy %1,%0\n\t"
+		   "fdc,m %2(%0)\n\t"
+		   "fdc,m %2(%0)\n\t"
+		   "fdc,m %2(%0)\n\t"
+		   "ldsid (%1),%0\n\t"
+		   "mtsp %0,%%sr0\n\t"
+		   "copy %1,%0\n\t"
+		   "fic,m %2(%%sr0,%0)\n\t"
+		   "fic,m %2(%%sr0,%0)\n\t"
+		   "fic,m %2(%%sr0,%0)\n\t"
+		   "sync\n\t"
+		   "nop\n\t"
+		   "nop\n\t"
+		   "nop\n\t"
+		   "nop\n\t"
+		   "nop\n\t"
+		   "nop\n\t"
+		   "nop\n"
+		   : "=&r" ((unsigned long)tmp)
+		   : "r" ((unsigned long)tramp & ~31),
+		     "r" (32/* stride */)
+		   : "memory");
+#endif
 
   closure->cif  = cif;
   closure->user_data = user_data;
diff -urN 4.1/libffi/src/pa/ffitarget.h libffi/src/pa/ffitarget.h
--- 4.1/libffi/src/pa/ffitarget.h	2006-08-15 01:18:41.798179400 +0200
+++ libffi/src/pa/ffitarget.h	2006-04-06 00:02:56.000000000 +0200
@@ -35,9 +35,20 @@
 typedef enum ffi_abi {
   FFI_FIRST_ABI = 0,
 
-#ifdef PA
-  FFI_LINUX,
-  FFI_DEFAULT_ABI = FFI_LINUX,
+#ifdef PA_LINUX
+  FFI_PA32,
+  FFI_DEFAULT_ABI = FFI_PA32,
+#endif
+
+#ifdef PA_HPUX
+  FFI_PA32,
+  FFI_DEFAULT_ABI = FFI_PA32,
+#endif
+
+#ifdef PA64_HPUX
+#error "PA64_HPUX FFI is not yet implemented"
+  FFI_PA64,
+  FFI_DEFAULT_ABI = FFI_PA64,
 #endif
 
   FFI_LAST_ABI = FFI_DEFAULT_ABI + 1
@@ -49,7 +60,11 @@
 #define FFI_CLOSURES 1
 #define FFI_NATIVE_RAW_API 0
 
+#ifdef PA_LINUX
 #define FFI_TRAMPOLINE_SIZE 32
+#else
+#define FFI_TRAMPOLINE_SIZE 40
+#endif
 
 #define FFI_TYPE_SMALL_STRUCT2 -1
 #define FFI_TYPE_SMALL_STRUCT3 -2
diff -urN 4.1/libffi/src/pa/hpux32.S libffi/src/pa/hpux32.S
--- 4.1/libffi/src/pa/hpux32.S	1970-01-01 01:00:00.000000000 +0100
+++ libffi/src/pa/hpux32.S	2006-04-13 20:20:08.000000000 +0200
@@ -0,0 +1,367 @@
+/* -----------------------------------------------------------------------
+   hpux32.S - Copyright (c) 2006 Free Software Foundation, Inc.
+   based on src/pa/linux.S
+
+   HP-UX PA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+	.LEVEL 1.1
+	.SPACE	$PRIVATE$
+	.IMPORT	$global$,DATA
+	.IMPORT	$$dyncall,MILLICODE
+	.SUBSPA	$DATA$
+	.align	4
+
+	/* void ffi_call_pa32(void (*)(char *, extended_cif *),
+			       extended_cif *ecif,
+			       unsigned bytes,
+			       unsigned flags,
+			       unsigned *rvalue,
+			       void (*fn)());
+	 */
+
+	.export	ffi_call_pa32,ENTRY,PRIV_LEV=3
+	.import	ffi_prep_args_pa32,CODE
+
+	.SPACE	$TEXT$
+	.SUBSPA $CODE$
+	.align	4
+
+L$FB1
+ffi_call_pa32
+	.proc
+	.callinfo	FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
+	.entry
+	stw	%rp, -20(%sp)
+	copy	%r3, %r1
+L$CFI11
+	copy	%sp, %r3
+L$CFI12
+
+	/* Setup the stack for calling prep_args...
+	   We want the stack to look like this:
+
+	   [ Previous stack                            ] <- %r3
+
+	   [ 64-bytes register save area               ] <- %r4
+
+	   [ Stack space for actual call, passed as    ] <- %arg0
+	   [     arg0 to ffi_prep_args_pa32           ]
+
+	   [ Stack for calling prep_args               ] <- %sp
+	 */
+
+	stwm	%r1, 64(%sp)
+	stw	%r4, 12(%r3)
+L$CFI13
+	copy	%sp, %r4
+
+	addl	%arg2, %r4, %arg0	; arg stack
+	stw	%arg3, -48(%r3)		; save flags we need it later
+
+	/* Call prep_args:
+	   %arg0(stack) -- set up above
+	   %arg1(ecif)  -- same as incoming param
+	   %arg2(bytes) -- same as incoming param */
+	bl	ffi_prep_args_pa32,%r2
+	ldo	64(%arg0), %sp
+	ldo	-64(%sp), %sp
+
+	/* now %sp should point where %arg0 was pointing.  */
+
+	/* Load the arguments that should be passed in registers
+	   The fp args are loaded by the prep_args function.  */
+	ldw	-36(%sp), %arg0
+	ldw	-40(%sp), %arg1
+	ldw	-44(%sp), %arg2
+	ldw	-48(%sp), %arg3
+
+	/* in case the function is going to return a structure
+	   we need to give it a place to put the result.  */
+	ldw	-52(%r3), %ret0		; %ret0 <- rvalue
+	ldw	-56(%r3), %r22		; %r22 <- function to call
+	bl	$$dyncall, %r31		; Call the user function
+	copy	%r31, %rp
+
+	/* Prepare to store the result; we need to recover flags and rvalue.  */
+	ldw	-48(%r3), %r21		; r21 <- flags
+	ldw	-52(%r3), %r20		; r20 <- rvalue
+
+	/* Store the result according to the return type.  The most
+	   likely types should come first.  */
+
+L$checkint
+	comib,<>,n FFI_TYPE_INT, %r21, L$checkint8
+	b	L$done
+	stw	%ret0, 0(%r20)
+
+L$checkint8
+	comib,<>,n FFI_TYPE_UINT8, %r21, L$checkint16
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$checkint16
+	comib,<>,n FFI_TYPE_UINT16, %r21, L$checkdbl
+	b	L$done
+	sth	%ret0, 0(%r20)
+
+L$checkdbl
+	comib,<>,n FFI_TYPE_DOUBLE, %r21, L$checkfloat
+	b	L$done
+	fstd	%fr4,0(%r20)
+
+L$checkfloat
+	comib,<>,n FFI_TYPE_FLOAT, %r21, L$checkll
+	b	L$done
+	fstw	%fr4L,0(%r20)
+
+L$checkll
+	comib,<>,n FFI_TYPE_UINT64, %r21, L$checksmst2
+	stw	%ret0, 0(%r20)
+	b	L$done
+	stw	%ret1, 4(%r20)
+
+L$checksmst2
+	comib,<>,n FFI_TYPE_SMALL_STRUCT2, %r21, L$checksmst3
+	/* 2-byte structs are returned in ret0 as ????xxyy.  */
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$checksmst3
+	comib,<>,n FFI_TYPE_SMALL_STRUCT3, %r21, L$checksmst4
+	/* 3-byte structs are returned in ret0 as ??xxyyzz.  */
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$checksmst4
+	comib,<>,n FFI_TYPE_SMALL_STRUCT4, %r21, L$checksmst5
+	/* 4-byte structs are returned in ret0 as wwxxyyzz.  */
+	extru	%ret0, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret0, 0(%r20)
+
+L$checksmst5
+	comib,<>,n FFI_TYPE_SMALL_STRUCT5, %r21, L$checksmst6
+	/* 5 byte values are returned right justified:
+	      ret0     ret1
+	   5: ??????aa bbccddee */
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret1, 0(%r20)
+
+L$checksmst6
+	comib,<>,n FFI_TYPE_SMALL_STRUCT6, %r21, L$checksmst7
+	/* 6 byte values are returned right justified:
+	      ret0     ret1
+	   6: ????aabb ccddeeff */
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret1, 0(%r20)
+
+L$checksmst7
+	comib,<>,n FFI_TYPE_SMALL_STRUCT7, %r21, L$checksmst8
+	/* 7 byte values are returned right justified:
+	      ret0     ret1
+	   7: ??aabbcc ddeeffgg */
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	b	L$done
+	stb	%ret1, 0(%r20)
+
+L$checksmst8
+	comib,<>,n FFI_TYPE_SMALL_STRUCT8, %r21, L$done
+	/* 8 byte values are returned right justified:
+	      ret0     ret1
+	   8: aabbccdd eeffgghh */
+	extru	%ret0, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret0, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stbs,ma	%ret0, 1(%r20)
+	extru	%ret1, 7, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 15, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	extru	%ret1, 23, 8, %r22
+	stbs,ma	%r22, 1(%r20)
+	stb	%ret1, 0(%r20)
+
+L$done
+	/* all done, return */
+	copy	%r4, %sp	; pop arg stack
+	ldw	12(%r3), %r4
+	ldwm	-64(%sp), %r3	; .. and pop stack
+	ldw	-20(%sp), %rp
+	bv	%r0(%rp)
+	nop
+	.exit
+	.procend
+L$FE1
+
+	/* void ffi_closure_pa32(void);
+	   Called with closure argument in %r21 */
+
+	.SPACE $TEXT$
+	.SUBSPA $CODE$
+	.export ffi_closure_pa32,ENTRY,PRIV_LEV=3,RTNVAL=GR
+	.import ffi_closure_inner_pa32,CODE
+	.align 4
+L$FB2
+ffi_closure_pa32
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3
+	.entry
+
+	stw	%rp, -20(%sp)
+	copy	%r3, %r1
+L$CFI21
+	copy	%sp, %r3
+L$CFI22
+	stwm	%r1, 64(%sp)
+
+	/* Put arguments onto the stack and call ffi_closure_inner.  */
+	stw	%arg0, -36(%r3)
+	stw	%arg1, -40(%r3)
+	stw	%arg2, -44(%r3)
+	stw	%arg3, -48(%r3)
+
+	copy	%r21, %arg0
+	bl	ffi_closure_inner_pa32, %r2
+	copy    %r3, %arg1
+	ldwm	-64(%sp), %r3
+	ldw	-20(%sp), %rp
+	ldw	-36(%sp), %ret0
+	bv	%r0(%rp)
+	ldw	-40(%sp), %ret1
+	.exit
+	.procend
+L$FE2:
+
+	.SPACE $PRIVATE$
+	.SUBSPA $DATA$
+
+	.align 4
+	.EXPORT _GLOBAL__F_ffi_call_pa32,DATA
+_GLOBAL__F_ffi_call_pa32
+L$frame1:
+	.word   L$ECIE1-L$SCIE1 ;# Length of Common Information Entry
+L$SCIE1:
+	.word   0x0     ;# CIE Identifier Tag
+	.byte   0x1     ;# CIE Version
+	.ascii "\0"     ;# CIE Augmentation
+	.uleb128 0x1    ;# CIE Code Alignment Factor
+	.sleb128 4      ;# CIE Data Alignment Factor
+	.byte   0x2     ;# CIE RA Column
+	.byte   0xc     ;# DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 0x0
+	.align 4
+L$ECIE1:
+L$SFDE1:
+	.word   L$EFDE1-L$ASFDE1        ;# FDE Length
+L$ASFDE1:
+	.word   L$ASFDE1-L$frame1       ;# FDE CIE offset
+	.word   L$FB1   ;# FDE initial location
+	.word   L$FE1-L$FB1     ;# FDE address range
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI11-L$FB1
+	.byte	0x83	;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI12-L$CFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI13-L$CFI12
+	.byte	0x84	;# DW_CFA_offset, column 0x4
+	.uleb128 0x3
+
+	.align 4
+L$EFDE1:
+
+L$SFDE2:
+	.word   L$EFDE2-L$ASFDE2        ;# FDE Length
+L$ASFDE2:
+	.word   L$ASFDE2-L$frame1       ;# FDE CIE offset
+	.word   L$FB2   ;# FDE initial location
+	.word   L$FE2-L$FB2     ;# FDE address range
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI21-L$FB2
+	.byte   0x83    ;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   L$CFI22-L$CFI21
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.align 4
+L$EFDE2:
diff -urN 4.1/libffi/src/pa/linux.S libffi/src/pa/linux.S
--- 4.1/libffi/src/pa/linux.S	2006-08-15 01:18:41.797179552 +0200
+++ libffi/src/pa/linux.S	2006-04-13 20:20:08.000000000 +0200
@@ -31,7 +31,7 @@
 	.level 1.1
 	.align 4
 
-	/* void ffi_call_LINUX(void (*)(char *, extended_cif *),
+	/* void ffi_call_pa32(void (*)(char *, extended_cif *),
 			       extended_cif *ecif,
 			       unsigned bytes,
 			       unsigned flags,
@@ -39,12 +39,12 @@
 			       void (*fn)());
 	 */
 
-	.export ffi_call_LINUX,code
-	.import ffi_prep_args_LINUX,code
+	.export ffi_call_pa32,code
+	.import ffi_prep_args_pa32,code
 
-	.type ffi_call_LINUX, @function
+	.type ffi_call_pa32, @function
 .LFB1:
-ffi_call_LINUX:
+ffi_call_pa32:
 	.proc
 	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
 	.entry
@@ -63,7 +63,7 @@
 	   [ 64-bytes register save area               ] <- %r4
 
 	   [ Stack space for actual call, passed as    ] <- %arg0
-	   [     arg0 to ffi_prep_args_LINUX           ]
+	   [     arg0 to ffi_prep_args_pa32           ]
 
 	   [ Stack for calling prep_args               ] <- %sp
 	 */
@@ -80,7 +80,7 @@
 	   %arg0(stack) -- set up above
 	   %arg1(ecif) -- same as incoming param
 	   %arg2(bytes) -- same as incoming param */
-	bl ffi_prep_args_LINUX,%r2
+	bl ffi_prep_args_pa32,%r2
 	ldo 64(%arg0), %sp
 	ldo -64(%sp), %sp
 
@@ -250,14 +250,14 @@
 	.procend
 .LFE1:
 
-	/* void ffi_closure_LINUX(void);
+	/* void ffi_closure_pa32(void);
 	   Called with closure argument in %r21 */
-	.export ffi_closure_LINUX,code
-	.import ffi_closure_inner_LINUX,code
+	.export ffi_closure_pa32,code
+	.import ffi_closure_inner_pa32,code
 
-	.type ffi_closure_LINUX, @function
+	.type ffi_closure_pa32, @function
 .LFB2:
-ffi_closure_LINUX:
+ffi_closure_pa32:
 	.proc
 	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3
 	.entry
@@ -277,7 +277,7 @@
 	stw %arg3, -48(%r3)
 
 	copy %r21, %arg0
-	bl ffi_closure_inner_LINUX, %r2
+	bl ffi_closure_inner_pa32, %r2
 	copy %r3, %arg1
 
 	ldwm -64(%sp), %r3
diff -urN 4.1/libffi/testsuite/libffi.call/closure_fn6.c libffi/testsuite/libffi.call/closure_fn6.c
--- 4.1/libffi/testsuite/libffi.call/closure_fn6.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/closure_fn6.c	2006-07-21 12:09:57.000000000 +0200
@@ -0,0 +1,98 @@
+/* Area:	closure_call
+   Purpose:	Check multiple values passing from different type.
+		Also, exceed the limit of gpr and fpr registers on PowerPC.
+   Limitations:	none.
+   PR:		PR23404
+   Originator:	<andreast@gcc.gnu.org> 20050830	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+static void
+closure_test_fn0(ffi_cif* cif __UNUSED__, void* resp, void** args,
+		 void* userdata)
+{
+  *(ffi_arg*)resp =
+    (int)*(unsigned long long *)args[0] +
+    (int)(*(unsigned long long *)args[1]) +
+    (int)(*(unsigned long long *)args[2]) +
+    (int)*(unsigned long long *)args[3] +
+    (int)(*(int *)args[4]) + (int)(*(double *)args[5]) +
+    (int)*(double *)args[6] + (int)(*(float *)args[7]) +
+    (int)(*(double *)args[8]) + (int)*(double *)args[9] +
+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
+    (int)*(int *)args[12] + (int)(*(int *)args[13]) +
+    (int)(*(double *)args[14]) +  (int)*(double *)args[15] +
+    (int)(long)userdata;
+
+  printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
+	 (int)*(unsigned long long  *)args[0],
+	 (int)(*(unsigned long long  *)args[1]),
+	 (int)(*(unsigned long long  *)args[2]),
+	 (int)*(unsigned long long  *)args[3],
+	 (int)(*(int *)args[4]), (int)(*(double *)args[5]),
+	 (int)*(double *)args[6], (int)(*(float *)args[7]),
+	 (int)(*(double *)args[8]), (int)*(double *)args[9],
+	 (int)(*(int *)args[10]), (int)(*(float *)args[11]),
+	 (int)*(int *)args[12], (int)(*(int *)args[13]),
+	 (int)(*(double *)args[14]), (int)(*(double *)args[15]),
+	 (int)(long)userdata, (int)*(ffi_arg *)resp);
+
+}
+
+typedef int (*closure_test_type0)(unsigned long long,
+				  unsigned long long,
+				  unsigned long long,
+				  unsigned long long,
+				  int, double, double, float, double, double,
+				  int, float, int, int, double, double);
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  ffi_type * cl_arg_types[17];
+  int res;
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cl_arg_types[0] = &ffi_type_uint64;
+  cl_arg_types[1] = &ffi_type_uint64;
+  cl_arg_types[2] = &ffi_type_uint64;
+  cl_arg_types[3] = &ffi_type_uint64;
+  cl_arg_types[4] = &ffi_type_uint;
+  cl_arg_types[5] = &ffi_type_double;
+  cl_arg_types[6] = &ffi_type_double;
+  cl_arg_types[7] = &ffi_type_float;
+  cl_arg_types[8] = &ffi_type_double;
+  cl_arg_types[9] = &ffi_type_double;
+  cl_arg_types[10] = &ffi_type_uint;
+  cl_arg_types[11] = &ffi_type_float;
+  cl_arg_types[12] = &ffi_type_uint;
+  cl_arg_types[13] = &ffi_type_uint;
+  cl_arg_types[14] = &ffi_type_double;
+  cl_arg_types[15] = &ffi_type_double;
+  cl_arg_types[16] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
+		     &ffi_type_sint, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,
+			 (void *) 3 /* userdata */) == FFI_OK);
+
+  res = (*((closure_test_type0)pcl))
+    (1, 2, 3, 4, 127, 429., 7., 8., 9.5, 10., 11, 12., 13,
+     19, 21., 1.);
+  /* { dg-output "1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680" } */
+  printf("res: %d\n",res);
+  /* { dg-output "\nres: 680" } */
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/float4.c libffi/testsuite/libffi.call/float4.c
--- 4.1/libffi/testsuite/libffi.call/float4.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/float4.c	2006-04-09 12:10:58.000000000 +0200
@@ -0,0 +1,60 @@
+/* Area:	ffi_call
+   Purpose:	Check denorm double value.
+   Limitations:	none.
+   PR:		PR26483.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+#include "float.h"
+
+typedef union
+{
+  double d;
+  unsigned char c[sizeof (double)];
+} value_type;
+
+#define CANARY 0xba
+
+static double dblit(double d)
+{
+  return d;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double d;
+  value_type result[2];
+  unsigned int i;
+
+  args[0] = &ffi_type_double;
+  values[0] = &d;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_double, args) == FFI_OK);
+  
+  d = DBL_MIN / 2;
+  
+  /* Put a canary in the return array.  This is a regression test for
+     a buffer overrun.  */
+  memset(result[1].c, CANARY, sizeof (double));
+
+  ffi_call(&cif, FFI_FN(dblit), &result[0].d, values);
+  
+  /* The standard delta check doesn't work for denorms.  Since we didn't do
+     any arithmetic, we should get the original result back, and hence an
+     exact check should be OK here.  */
+ 
+  CHECK(result[0].d == dblit(d));
+
+  /* Check the canary.  */
+  for (i = 0; i < sizeof (double); ++i)
+    CHECK(result[1].c[i] == CANARY);
+
+  exit(0);
+
+}
diff -urN 4.1/libffi/testsuite/libffi.call/nested_struct10.c libffi/testsuite/libffi.call/nested_struct10.c
--- 4.1/libffi/testsuite/libffi.call/nested_struct10.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/nested_struct10.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,141 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  unsigned char y;
+  struct A x;
+  unsigned int z;
+} B;
+
+typedef struct C {
+  unsigned long long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b3.z + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+
+  printf("%d %d %d %d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y, b3.z, (int)b4.d, b4.e,
+	 (int)result.x.a, result.x.b, result.y);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[4];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  struct A e_dbl = { 1LL, 7};
+  struct B f_dbl = { 99, {12LL , 127}, 255};
+  struct C g_dbl = { 2LL, 9};
+
+  struct B res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_uint64;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &ffi_type_uchar;
+  cls_struct_fields1[1] = &cls_struct_type;
+  cls_struct_fields1[2] = &ffi_type_uint32;
+  cls_struct_fields1[3] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_uint64;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 255 2 9: 270 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 255 2 9: 270 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/nested_struct4.c libffi/testsuite/libffi.call/nested_struct4.c
--- 4.1/libffi/testsuite/libffi.call/nested_struct4.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/nested_struct4.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,119 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		PR 25630.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* powerpc*-*-darwin* } } */
+#include "ffitest.h"
+
+typedef struct A {
+  double a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b2, struct B b3)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a;
+  result.x.b = b2.b + b3.x.b + b3.y;
+  result.y = b2.b + b3.x.b;
+
+  printf("%d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y,
+	 (int)result.x.a, result.x.b, result.y);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  struct A e_dbl = { 1.0, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/nested_struct5.c libffi/testsuite/libffi.call/nested_struct5.c
--- 4.1/libffi/testsuite/libffi.call/nested_struct5.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/nested_struct5.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,120 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+typedef struct A {
+  long double a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b2, struct B b3)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a;
+  result.x.b = b2.b + b3.x.b + b3.y;
+  result.y = b2.b + b3.x.b;
+
+  printf("%d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y,
+	 (int)result.x.a, result.x.b, result.y);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  struct A e_dbl = { 1.0, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_longdouble;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+
+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/nested_struct6.c libffi/testsuite/libffi.call/nested_struct6.c
--- 4.1/libffi/testsuite/libffi.call/nested_struct6.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/nested_struct6.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,139 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		PR 25630.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* powerpc*-*-darwin* } } */
+#include "ffitest.h"
+
+typedef struct A {
+  double a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+typedef struct C {
+  long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+
+  printf("%d %d %d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y, (int)b4.d, b4.e,
+	 (int)result.x.a, result.x.b, result.y);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  struct A e_dbl = { 1.0, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+  struct C g_dbl = { 2, 9};
+
+  struct B res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_double;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_mylong;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/nested_struct7.c libffi/testsuite/libffi.call/nested_struct7.c
--- 4.1/libffi/testsuite/libffi.call/nested_struct7.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/nested_struct7.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,119 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+static B B_fn(struct A b2, struct B b3)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a;
+  result.x.b = b2.b + b3.x.b + b3.y;
+  result.y = b2.b + b3.x.b;
+
+  printf("%d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y,
+	 (int)result.x.a, result.x.b, result.y);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  struct A e_dbl = { 1LL, 7};
+  struct B f_dbl = {{12.0 , 127}, 99};
+
+  struct B res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_uint64;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);
+  /* { dg-output "\n1 7 12 127 99: 13 233 134" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));
+
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/nested_struct8.c libffi/testsuite/libffi.call/nested_struct8.c
--- 4.1/libffi/testsuite/libffi.call/nested_struct8.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/nested_struct8.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,139 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned long long a;
+  unsigned char b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+typedef struct C {
+  unsigned long long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+
+  printf("%d %d %d %d %d %d %d: %d %d %d\n", (int)b2.a, b2.b,
+	 (int)b3.x.a, b3.x.b, b3.y, (int)b4.d, b4.e,
+	 (int)result.x.a, result.x.b, result.y);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  struct A e_dbl = { 1LL, 7};
+  struct B f_dbl = {{12LL , 127}, 99};
+  struct C g_dbl = { 2LL, 9};
+
+  struct B res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_uint64;
+  cls_struct_fields[1] = &ffi_type_uchar;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_uint64;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/nested_struct9.c libffi/testsuite/libffi.call/nested_struct9.c
--- 4.1/libffi/testsuite/libffi.call/nested_struct9.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/nested_struct9.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,139 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing with different structure size.
+		Contains structs as parameter of the struct itself.
+		Sample taken from Alan Modras patch to src/prep_cif.c.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20051010	 */
+
+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */
+#include "ffitest.h"
+
+typedef struct A {
+  unsigned char a;
+  unsigned long long b;
+} A;
+
+typedef struct B {
+  struct A x;
+  unsigned char y;
+} B;
+
+typedef struct C {
+  unsigned long d;
+  unsigned char e;
+} C;
+
+static B B_fn(struct A b2, struct B b3, struct C b4)
+{
+  struct B result;
+
+  result.x.a = b2.a + b3.x.a + b4.d;
+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;
+  result.y = b2.b + b3.x.b + b4.e;
+
+  printf("%d %d %d %d %d %d %d: %d %d %d\n", b2.a, (int)b2.b,
+	 b3.x.a, (int)b3.x.b, b3.y, (int)b4.d, b4.e,
+	 result.x.a, (int)result.x.b, result.y);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  struct A b0;
+  struct B b1;
+  struct C b2;
+
+  b0 = *(struct A*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+  b2 = *(struct C*)(args[2]);
+
+  *(B*)resp = B_fn(b0, b1, b2);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+#ifndef USING_MMAP
+  static ffi_closure cl;
+#endif
+  ffi_closure *pcl;
+  void* args_dbl[4];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type* cls_struct_fields2[3];
+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;
+  ffi_type* dbl_arg_types[4];
+
+#ifdef USING_MMAP
+  pcl = allocate_mmap (sizeof(ffi_closure));
+#else
+  pcl = &cl;
+#endif
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_type2.size = 0;
+  cls_struct_type2.alignment = 0;
+  cls_struct_type2.type = FFI_TYPE_STRUCT;
+  cls_struct_type2.elements = cls_struct_fields2;
+
+  struct A e_dbl = { 1, 7LL};
+  struct B f_dbl = {{12.0 , 127}, 99};
+  struct C g_dbl = { 2, 9};
+
+  struct B res_dbl;
+
+  cls_struct_fields[0] = &ffi_type_uchar;
+  cls_struct_fields[1] = &ffi_type_uint64;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &cls_struct_type;
+  cls_struct_fields1[1] = &ffi_type_uchar;
+  cls_struct_fields1[2] = NULL;
+
+  cls_struct_fields2[0] = &ffi_type_mylong;
+  cls_struct_fields2[1] = &ffi_type_uchar;
+  cls_struct_fields2[2] = NULL;
+
+
+  dbl_arg_types[0] = &cls_struct_type;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = &cls_struct_type2;
+  dbl_arg_types[3] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = &g_dbl;
+  args_dbl[3] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);
+
+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);
+  /* { dg-output "\n1 7 12 127 99 2 9: 15 242 143" } */
+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));
+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));
+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));
+
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_dbl.c libffi/testsuite/libffi.call/return_dbl.c
--- 4.1/libffi/testsuite/libffi.call/return_dbl.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_dbl.c	2006-02-17 13:47:07.000000000 +0100
@@ -0,0 +1,35 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static double return_dbl(double dbl)
+{
+  return 2 * dbl;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double dbl, rdbl;
+
+  args[0] = &ffi_type_double;
+  values[0] = &dbl;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_double, args) == FFI_OK);
+
+  for (dbl = -127.3; dbl <  127; dbl++)
+    {
+      ffi_call(&cif, FFI_FN(return_dbl), &rdbl, values);
+      printf ("%f vs %f\n", rdbl, return_dbl(dbl));
+      CHECK(rdbl == 2 * dbl);
+    }
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_dbl1.c libffi/testsuite/libffi.call/return_dbl1.c
--- 4.1/libffi/testsuite/libffi.call/return_dbl1.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_dbl1.c	2006-02-17 13:47:07.000000000 +0100
@@ -0,0 +1,43 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static double return_dbl(double dbl1, float fl2, unsigned int in3, double dbl4)
+{
+  return dbl1 + fl2 + in3 + dbl4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double dbl1, dbl4, rdbl;
+  float fl2;
+  unsigned int in3;
+  args[0] = &ffi_type_double;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_uint32;
+  args[3] = &ffi_type_double;
+  values[0] = &dbl1;
+  values[1] = &fl2;
+  values[2] = &in3;
+  values[3] = &dbl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_double, args) == FFI_OK);
+  dbl1 = 127.0;
+  fl2 = 128.0;
+  in3 = 255;
+  dbl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_dbl), &rdbl, values);
+  printf ("%f vs %f\n", rdbl, return_dbl(dbl1, fl2, in3, dbl4));
+  CHECK(rdbl ==  dbl1 + fl2 + in3 + dbl4);
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_dbl2.c libffi/testsuite/libffi.call/return_dbl2.c
--- 4.1/libffi/testsuite/libffi.call/return_dbl2.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_dbl2.c	2006-02-17 13:47:07.000000000 +0100
@@ -0,0 +1,42 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static double return_dbl(double dbl1, double dbl2, unsigned int in3, double dbl4)
+{
+  return dbl1 + dbl2 + in3 + dbl4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  double dbl1, dbl2, dbl4, rdbl;
+  unsigned int in3;
+  args[0] = &ffi_type_double;
+  args[1] = &ffi_type_double;
+  args[2] = &ffi_type_uint32;
+  args[3] = &ffi_type_double;
+  values[0] = &dbl1;
+  values[1] = &dbl2;
+  values[2] = &in3;
+  values[3] = &dbl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_double, args) == FFI_OK);
+  dbl1 = 127.0;
+  dbl2 = 128.0;
+  in3 = 255;
+  dbl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_dbl), &rdbl, values);
+  printf ("%f vs %f\n", rdbl, return_dbl(dbl1, dbl2, in3, dbl4));
+  CHECK(rdbl ==  dbl1 + dbl2 + in3 + dbl4);
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_fl.c libffi/testsuite/libffi.call/return_fl.c
--- 4.1/libffi/testsuite/libffi.call/return_fl.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_fl.c	2006-02-17 13:47:07.000000000 +0100
@@ -0,0 +1,35 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static float return_fl(float fl)
+{
+  return 2 * fl;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl, rfl;
+
+  args[0] = &ffi_type_float;
+  values[0] = &fl;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_float, args) == FFI_OK);
+
+  for (fl = -127.0; fl <  127; fl++)
+    {
+      ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+      printf ("%f vs %f\n", rfl, return_fl(fl));
+      CHECK(rfl ==  2 * fl);
+    }
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_fl1.c libffi/testsuite/libffi.call/return_fl1.c
--- 4.1/libffi/testsuite/libffi.call/return_fl1.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_fl1.c	2006-02-17 13:47:07.000000000 +0100
@@ -0,0 +1,36 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static float return_fl(float fl1, float fl2)
+{
+  return fl1 + fl2;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl1, fl2, rfl;
+
+  args[0] = &ffi_type_float;
+  args[1] = &ffi_type_float;
+  values[0] = &fl1;
+  values[1] = &fl2;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_float, args) == FFI_OK);
+  fl1 = 127.0;
+  fl2 = 128.0;
+
+  ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+  printf ("%f vs %f\n", rfl, return_fl(fl1, fl2));
+  CHECK(rfl ==  fl1 + fl2);
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_fl2.c libffi/testsuite/libffi.call/return_fl2.c
--- 4.1/libffi/testsuite/libffi.call/return_fl2.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_fl2.c	2006-03-03 02:48:12.000000000 +0100
@@ -0,0 +1,45 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+/* To avoid a false negative on ix86 do not declare the return_fl static.
+   See PR323.
+*/
+float return_fl(float fl1, float fl2, float fl3, float fl4)
+{
+  return fl1 + fl2 + fl3 + fl4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl1, fl2, fl3, fl4, rfl;
+
+  args[0] = &ffi_type_float;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_float;
+  args[3] = &ffi_type_float;
+  values[0] = &fl1;
+  values[1] = &fl2;
+  values[2] = &fl3;
+  values[3] = &fl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_float, args) == FFI_OK);
+  fl1 = 127.0;
+  fl2 = 128.0;
+  fl3 = 255.1;
+  fl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+  printf ("%f vs %f\n", rfl, return_fl(fl1, fl2, fl3, fl4));
+  CHECK(rfl ==  fl1 + fl2 + fl3 + fl4);
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_fl3.c libffi/testsuite/libffi.call/return_fl3.c
--- 4.1/libffi/testsuite/libffi.call/return_fl3.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_fl3.c	2006-02-17 13:47:07.000000000 +0100
@@ -0,0 +1,42 @@
+/* Area:	ffi_call
+   Purpose:	Check return value float.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<andreast@gcc.gnu.org> 20050212  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+static float return_fl(float fl1, float fl2, unsigned int in3, float fl4)
+{
+  return fl1 + fl2 + in3 + fl4;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  float fl1, fl2, fl4, rfl;
+  unsigned int in3;
+  args[0] = &ffi_type_float;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_uint32;
+  args[3] = &ffi_type_float;
+  values[0] = &fl1;
+  values[1] = &fl2;
+  values[2] = &in3;
+  values[3] = &fl4;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &ffi_type_float, args) == FFI_OK);
+  fl1 = 127.0;
+  fl2 = 128.0;
+  in3 = 255;
+  fl4 = 512.7;
+
+  ffi_call(&cif, FFI_FN(return_fl), &rfl, values);
+  printf ("%f vs %f\n", rfl, return_fl(fl1, fl2, in3, fl4));
+  CHECK(rfl ==  fl1 + fl2 + in3 + fl4);
+  exit(0);
+}
diff -urN 4.1/libffi/testsuite/libffi.call/return_ul.c libffi/testsuite/libffi.call/return_ul.c
--- 4.1/libffi/testsuite/libffi.call/return_ul.c	1970-01-01 01:00:00.000000000 +0100
+++ libffi/testsuite/libffi.call/return_ul.c	2006-07-26 11:41:44.000000000 +0200
@@ -0,0 +1,38 @@
+/* Area:	ffi_call
+   Purpose:	Check if unsigned long as return type is handled correctly.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<kaffeetisch at gmx dot de> 20060724  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+static unsigned long return_ul(unsigned long ul1, unsigned long ul2)
+{
+  return ul1 + ul2;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  unsigned long res;
+  unsigned long ul1, ul2;
+
+  args[0] = &ffi_type_ulong;
+  args[1] = &ffi_type_ulong;
+  values[0] = &ul1;
+  values[1] = &ul2;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,
+		     &ffi_type_ulong, args) == FFI_OK);
+
+  ul1 = 1073741823L;
+  ul2 = 1073741824L;
+
+  ffi_call(&cif, FFI_FN(return_ul), &res, values);
+  printf("res: %ld, %ld\n", res, ul1 + ul2);
+  /* { dg-output "res: 2147483647, 2147483647" } */
+
+  exit(0);
+}
