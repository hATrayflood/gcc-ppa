# DP: updates from the 4.9 branch upto 20150427 (r221736).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Fri Mar 27 17:03:40 CET 2015
Fri Mar 27 16:03:40 UTC 2015 (revision 221736)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_4_9_2_release svn://gcc.gnu.org/svn/gcc/branches/gcc-4_9-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libitm/configure.tgt
===================================================================
--- a/src/libitm/configure.tgt	(.../tags/gcc_4_9_2_release)
+++ b/src/libitm/configure.tgt	(.../branches/gcc-4_9-branch)
@@ -102,7 +102,7 @@
   x86_64)
 	case " ${CC} ${CFLAGS} " in
 	  *" -m32 "*)
-	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=i686"
+	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=generic"
 	    XCFLAGS="${XCFLAGS} -fomit-frame-pointer"
 	    ;;
 	esac
Index: libitm/ChangeLog
===================================================================
--- a/src/libitm/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libitm/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,7 @@
+2014-12-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* configure.tgt (x86_64): Tune -m32 multilib to generic.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: Makefile.in
===================================================================
--- a/src/Makefile.in	(.../tags/gcc_4_9_2_release)
+++ b/src/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -46988,6 +46988,38 @@
 configure-stage4-gcc: maybe-all-stage4-gmp
 configure-stageprofile-gcc: maybe-all-stageprofile-gmp
 configure-stagefeedback-gcc: maybe-all-stagefeedback-gmp
+configure-gcc: maybe-all-mpfr
+
+configure-stage1-gcc: maybe-all-stage1-mpfr
+configure-stage2-gcc: maybe-all-stage2-mpfr
+configure-stage3-gcc: maybe-all-stage3-mpfr
+configure-stage4-gcc: maybe-all-stage4-mpfr
+configure-stageprofile-gcc: maybe-all-stageprofile-mpfr
+configure-stagefeedback-gcc: maybe-all-stagefeedback-mpfr
+configure-gcc: maybe-all-mpc
+
+configure-stage1-gcc: maybe-all-stage1-mpc
+configure-stage2-gcc: maybe-all-stage2-mpc
+configure-stage3-gcc: maybe-all-stage3-mpc
+configure-stage4-gcc: maybe-all-stage4-mpc
+configure-stageprofile-gcc: maybe-all-stageprofile-mpc
+configure-stagefeedback-gcc: maybe-all-stagefeedback-mpc
+configure-gcc: maybe-all-isl
+
+configure-stage1-gcc: maybe-all-stage1-isl
+configure-stage2-gcc: maybe-all-stage2-isl
+configure-stage3-gcc: maybe-all-stage3-isl
+configure-stage4-gcc: maybe-all-stage4-isl
+configure-stageprofile-gcc: maybe-all-stageprofile-isl
+configure-stagefeedback-gcc: maybe-all-stagefeedback-isl
+configure-gcc: maybe-all-cloog
+
+configure-stage1-gcc: maybe-all-stage1-cloog
+configure-stage2-gcc: maybe-all-stage2-cloog
+configure-stage3-gcc: maybe-all-stage3-cloog
+configure-stage4-gcc: maybe-all-stage4-cloog
+configure-stageprofile-gcc: maybe-all-stageprofile-cloog
+configure-stagefeedback-gcc: maybe-all-stagefeedback-cloog
 configure-gcc: maybe-all-lto-plugin
 
 configure-stage1-gcc: maybe-all-stage1-lto-plugin
Index: libgomp/configure.tgt
===================================================================
--- a/src/libgomp/configure.tgt	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/configure.tgt	(.../branches/gcc-4_9-branch)
@@ -82,7 +82,7 @@
 	config_path="linux/x86 linux posix"
 	case " ${CC} ${CFLAGS} " in
 	  *" -m32 "*)
-	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=i686"
+	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=generic"
 	    ;;
 	esac
 	;;
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,37 @@
+2015-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64824
+	* testsuite/libgomp.c/atomic-18.c: New test.
+	* testsuite/libgomp.c++/atomic-16.C: New test.
+
+	Backported from mainline
+	2015-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64824
+	PR c/64868
+	* testsuite/libgomp.c/pr64824.c: New test.
+	* testsuite/libgomp.c/pr64868.c: New test.
+	* testsuite/libgomp.c++/pr64824.C: New test.
+	* testsuite/libgomp.c++/pr64868.C: New test.
+
+2015-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64734
+	* libgomp.c/pr64734.c: New test.
+
+2014-12-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* configure.tgt (x86_64-*-linux*): Tune -m32 multilib to generic.
+
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/63938
+	* libgomp.fortran/pr63938-1.f90: New test.
+	* libgomp.fortran/pr63938-2.f90: New test.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libgomp/testsuite/libgomp.c++/pr64868.C
===================================================================
--- a/src/libgomp/testsuite/libgomp.c++/pr64868.C	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.c++/pr64868.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,5 @@
+// PR c/64868
+// { dg-do run }
+// { dg-options "-O2 -fopenmp" }
+
+#include "../libgomp.c/pr64868.c"
Index: libgomp/testsuite/libgomp.c++/atomic-16.C
===================================================================
--- a/src/libgomp/testsuite/libgomp.c++/atomic-16.C	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.c++/atomic-16.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,5 @@
+// PR c/64824
+// { dg-do run }
+// { dg-options "-O2 -fopenmp" }
+
+#include "../libgomp.c/atomic-18.c"
Index: libgomp/testsuite/libgomp.c++/pr64824.C
===================================================================
--- a/src/libgomp/testsuite/libgomp.c++/pr64824.C	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.c++/pr64824.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,5 @@
+// PR c/64824
+// { dg-do run }
+// { dg-options "-O2 -fopenmp" }
+
+#include "../libgomp.c/pr64824.c"
Index: libgomp/testsuite/libgomp.fortran/pr63938-1.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/pr63938-1.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/pr63938-1.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+! PR fortran/63938
+! { dg-do run }
+
+program pr63938_1
+  integer :: i, x(1)
+  x(1) = 0
+!$omp parallel do
+  do i = 1, 1000
+    !$omp atomic
+    x(1) = x(1) + 1
+  end do
+!$omp end parallel do
+  if (x(1) .ne. 1000) call abort
+end program pr63938_1
Index: libgomp/testsuite/libgomp.fortran/pr63938-2.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/pr63938-2.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/pr63938-2.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+! PR fortran/63938
+! { dg-do run }
+
+program pr63938_2
+  type t
+    integer :: x
+  end type
+  integer :: i
+  type(t) :: x
+  x%x = 0
+!$omp parallel do
+  do i = 1, 1000
+    !$omp atomic
+    x%x = x%x + 1
+  end do
+!$omp end parallel do
+  if (x%x .ne. 1000) call abort
+end program pr63938_2
Index: libgomp/testsuite/libgomp.c/atomic-18.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/atomic-18.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.c/atomic-18.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,61 @@
+/* PR c/64824 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fopenmp" } */
+
+void
+f1 (void)
+{
+  short a;
+  short b = 1;
+  int c = 3;
+#pragma omp atomic capture
+  a = b = c << b;
+  if (b != 6 || a != 6)
+    __builtin_abort ();
+}
+
+void
+f2 (void)
+{
+  short a;
+  short b = 1;
+  int c = 3;
+#pragma omp atomic capture
+  a = b = c + b;
+  if (b != 4 || a != 4)
+    __builtin_abort ();
+}
+
+void
+f3 (void)
+{
+  short a;
+  short b = 1;
+  long long int c = 3;
+#pragma omp atomic capture
+  a = b = c + b;
+  if (b != 4 || a != 4)
+    __builtin_abort ();
+}
+
+void
+f4 (void)
+{
+  char a;
+  char b = 1;
+  long long int c = 3LL;
+#pragma omp atomic capture
+  a = b = c << b;
+  if (b != 6 || a != 6)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/pr64868.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr64868.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr64868.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,87 @@
+/* PR c/64868 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fopenmp" } */
+
+float f = 2.0f;
+double d = 4.0;
+long double ld = 8.0L;
+
+void
+foo ()
+{
+#pragma omp atomic
+  f = 1.0f / f;
+#pragma omp atomic
+  f = 1 / f;
+#pragma omp atomic
+  f = f / 2.0f;
+#pragma omp atomic
+  f = f / 2;
+#pragma omp atomic
+  f /= 2.0f;
+#pragma omp atomic
+  f /= 2;
+#pragma omp atomic
+  d = 1.0 / d;
+#pragma omp atomic
+  d = 1 / d;
+#pragma omp atomic
+  d = d / 2.0;
+#pragma omp atomic
+  d = d / 2;
+#pragma omp atomic
+  d /= 2.0;
+#pragma omp atomic
+  d /= 2;
+#pragma omp atomic
+  ld = 1.0L / ld;
+#pragma omp atomic
+  ld = 1 / ld;
+#pragma omp atomic
+  ld = ld / 2.0L;
+#pragma omp atomic
+  ld = ld / 2;
+#pragma omp atomic
+  ld /= 2.0L;
+#pragma omp atomic
+  ld /= 2;
+  if (f != 0.125f || d != 0.25 || ld != 0.5L)
+    __builtin_abort ();
+}
+
+#ifdef __cplusplus
+template <typename T, int N1, int N2>
+void
+bar ()
+{
+  T v = ::d;
+#pragma omp atomic
+  v *= 16;
+#pragma omp atomic
+  v = 1.0 / v;
+#pragma omp atomic
+  v = N1 / v;
+#pragma omp atomic
+  v = v / 2.0;
+#pragma omp atomic
+  v = v / N2;
+#pragma omp atomic
+  v /= 2.0;
+#pragma omp atomic
+  v /= N2;
+  if (v != 0.25)
+    __builtin_abort ();
+}
+#endif
+
+int
+main ()
+{
+  foo ();
+#ifdef __cplusplus
+  bar<float, 1, 2> ();
+  bar<double, 1, 2> ();
+  bar<long double, 1, 2> ();
+#endif
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/pr64734.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr64734.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr64734.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,55 @@
+/* PR middle-end/64734 */
+
+#include <stdlib.h>
+
+void
+foo (int *x, int *y)
+{
+  #pragma omp target map (alloc:x[0]) map (alloc:y[0:8])
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+      if (y[i] != 2 + i)
+	break;
+    if (i != 8 || *x != 1)
+      *x = 6;
+    else
+      {
+	*x = 8;
+	for (i = 0; i < 8; i++)
+	  y[i] = 9 + i;
+      }
+  }
+  #pragma omp target update from (y[0:8]) from (x[0])
+}
+
+void
+bar (void)
+{
+  int x = 1, y[32] = { 0 };
+  #pragma omp target data map (to:y[0:32]) map (to:x)
+    ;
+}
+
+int
+main ()
+{
+  int x = 1, y[8] = { 2, 3, 4, 5, 6, 7, 8, 9 }, i;
+  #pragma omp target data map (to:y[0:8]) map (to:x)
+    ;
+  #pragma omp target data map (to:y[0:8]) map (to:x)
+    {
+      #pragma omp target update from (y[0:8]) from (x)
+    }
+
+  #pragma omp target data map (to:y[0:8]) map (to:x)
+    foo (&x, &y[0]);
+
+  if (x != 8)
+    abort ();
+  for (i = 0; i < 8; i++)
+    if (y[i] != 9 + i)
+      abort ();
+
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/pr64824.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr64824.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr64824.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* PR c/64824 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fopenmp" } */
+
+int
+main ()
+{
+  long long a;
+  long long b = 1LL;
+  int c = 3;
+#pragma omp atomic capture
+  a = b = c << b;
+  if (b != 6LL || a != 6LL)
+    __builtin_abort ();
+  return 0;
+}
Index: libquadmath/configure
===================================================================
--- a/src/libquadmath/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/libquadmath/configure	(.../branches/gcc-4_9-branch)
@@ -613,7 +613,6 @@
 LIBQUAD_USE_SYMVER_TRUE
 toolexeclibdir
 toolexecdir
-multi_basedir
 MAINT
 MAINTAINER_MODE_FALSE
 MAINTAINER_MODE_TRUE
@@ -682,6 +681,7 @@
 INSTALL_DATA
 INSTALL_SCRIPT
 INSTALL_PROGRAM
+multi_basedir
 target_noncanonical
 target_os
 target_vendor
@@ -736,6 +736,7 @@
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
+enable_multilib
 enable_version_specific_runtime_libs
 enable_dependency_tracking
 with_bugurl
@@ -746,7 +747,6 @@
 with_gnu_ld
 enable_libtool_lock
 enable_maintainer_mode
-enable_multilib
 enable_symvers
 enable_generated_files_in_srcdir
 '
@@ -1379,6 +1379,7 @@
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-multilib       build many library versions (default)
   --enable-version-specific-runtime-libs
                           specify that runtime libraries should be installed
                           in a compiler-specific directory
@@ -1391,7 +1392,6 @@
   --disable-libtool-lock  avoid locking (might break parallel builds)
   --enable-maintainer-mode  enable make rules and dependencies not useful
 			  (and sometimes confusing) to the casual installer
-  --enable-multilib       build many library versions (default)
   --disable-symvers       disable symbol versioning for libquadmath
   --enable-generated-files-in-srcdir
                           put copies of generated files in source dir intended
@@ -2370,6 +2370,44 @@
 
 
 
+# Default to --enable-multilib
+# Check whether --enable-multilib was given.
+if test "${enable_multilib+set}" = set; then :
+  enableval=$enable_multilib; case "$enableval" in
+  yes) multilib=yes ;;
+  no)  multilib=no ;;
+  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
+ esac
+else
+  multilib=yes
+fi
+
+
+# We may get other options which we leave undocumented:
+# --with-target-subdir, --with-multisrctop, --with-multisubdir
+# See config-ml.in if you want the gory details.
+
+if test "$srcdir" = "."; then
+  if test "$with_target_subdir" != "."; then
+    multi_basedir="$srcdir/$with_multisrctop../.."
+  else
+    multi_basedir="$srcdir/$with_multisrctop.."
+  fi
+else
+  multi_basedir="$srcdir/.."
+fi
+
+
+# Even if the default multilib is not a cross compilation,
+# it may be that some of the other multilibs are.
+if test $cross_compiling = no && test $multilib = yes \
+   && test "x${with_multisubdir}" != x ; then
+   cross_compiling=maybe
+fi
+
+ac_config_commands="$ac_config_commands default-1"
+
+
 target_alias=${target_alias-$host_alias}
 
 
@@ -10527,7 +10565,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10530 "configure"
+#line 10568 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10633,7 +10671,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10636 "configure"
+#line 10674 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10918,44 +10956,7 @@
   MAINT=$MAINTAINER_MODE_TRUE
 
 
-# Default to --enable-multilib
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "$enableval" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
- esac
-else
-  multilib=yes
-fi
 
-
-# We may get other options which we leave undocumented:
-# --with-target-subdir, --with-multisrctop, --with-multisubdir
-# See config-ml.in if you want the gory details.
-
-if test "$srcdir" = "."; then
-  if test "$with_target_subdir" != "."; then
-    multi_basedir="$srcdir/$with_multisrctop../.."
-  else
-    multi_basedir="$srcdir/$with_multisrctop.."
-  fi
-else
-  multi_basedir="$srcdir/.."
-fi
-
-
-# Even if the default multilib is not a cross compilation,
-# it may be that some of the other multilibs are.
-if test $cross_compiling = no && test $multilib = yes \
-   && test "x${with_multisubdir}" != x ; then
-   cross_compiling=maybe
-fi
-
-ac_config_commands="$ac_config_commands default-1"
-
-
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -13644,6 +13645,20 @@
 #
 # INIT-COMMANDS
 #
+
+srcdir="$srcdir"
+host="$host"
+target="$target"
+with_multisubdir="$with_multisubdir"
+with_multisrctop="$with_multisrctop"
+with_target_subdir="$with_target_subdir"
+ac_configure_args="${multilib_arg} ${ac_configure_args}"
+multi_basedir="$multi_basedir"
+CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+CC="$CC"
+CXX="$CXX"
+GFORTRAN="$GFORTRAN"
+GCJ="$GCJ"
 AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
 
 
@@ -13906,20 +13921,6 @@
 
 
 
-srcdir="$srcdir"
-host="$host"
-target="$target"
-with_multisubdir="$with_multisubdir"
-with_multisrctop="$with_multisrctop"
-with_target_subdir="$with_target_subdir"
-ac_configure_args="${multilib_arg} ${ac_configure_args}"
-multi_basedir="$multi_basedir"
-CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
-CC="$CC"
-CXX="$CXX"
-GFORTRAN="$GFORTRAN"
-GCJ="$GCJ"
-
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
@@ -13929,9 +13930,9 @@
 do
   case $ac_config_target in
     "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
 
   *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
@@ -14517,6 +14518,14 @@
 
 
   case $ac_file$ac_mode in
+    "default-1":C)
+# Only add multilib support code if we just rebuilt the top-level
+# Makefile.
+case " $CONFIG_FILES " in
+ *" Makefile "*)
+   ac_file=Makefile . ${multi_basedir}/config-ml.in
+   ;;
+esac ;;
     "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
   # Autoconf 2.62 quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
@@ -15251,14 +15260,6 @@
   chmod +x "$ofile"
 
  ;;
-    "default-1":C)
-# Only add multilib support code if we just rebuilt the top-level
-# Makefile.
-case " $CONFIG_FILES " in
- *" Makefile "*)
-   ac_file=Makefile . ${multi_basedir}/config-ml.in
-   ;;
-esac ;;
 
   esac
 done # for ac_tag
Index: libquadmath/ChangeLog
===================================================================
--- a/src/libquadmath/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libquadmath/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2015-01-26  Matthias Klose  <doko@ubuntu.com>
+
+	* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC.
+	* configure: Regenerate.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libquadmath/configure.ac
===================================================================
--- a/src/libquadmath/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/libquadmath/configure.ac	(.../branches/gcc-4_9-branch)
@@ -23,6 +23,8 @@
 AC_CANONICAL_SYSTEM
 ACX_NONCANONICAL_TARGET
 
+AM_ENABLE_MULTILIB(, ..)
+
 target_alias=${target_alias-$host_alias}
 AC_SUBST(target_alias)
 
@@ -60,7 +62,6 @@
 AC_SUBST(enable_static)
 
 AM_MAINTAINER_MODE
-AM_ENABLE_MULTILIB(, ..)
 
 AC_LANG_C
 # The same as in boehm-gc and libstdc++. Have to borrow it from there.
Index: libsanitizer/configure
===================================================================
--- a/src/libsanitizer/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/libsanitizer/configure	(.../branches/gcc-4_9-branch)
@@ -659,7 +659,6 @@
 MAINT
 MAINTAINER_MODE_FALSE
 MAINTAINER_MODE_TRUE
-multi_basedir
 am__fastdepCC_FALSE
 am__fastdepCC_TRUE
 CCDEPMODE
@@ -717,6 +716,7 @@
 LDFLAGS
 CFLAGS
 CC
+multi_basedir
 target_alias
 host_alias
 build_alias
@@ -758,9 +758,9 @@
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
+enable_multilib
 enable_version_specific_runtime_libs
 enable_dependency_tracking
-enable_multilib
 enable_maintainer_mode
 enable_shared
 enable_static
@@ -1404,10 +1404,10 @@
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-multilib       build many library versions (default)
   --enable-version-specific-runtime-libs    Specify that runtime libraries should be installed in a compiler-specific directory
   --disable-dependency-tracking  speeds up one-time build
   --enable-dependency-tracking   do not reject slow dependency extractors
-  --enable-multilib       build many library versions (default)
   --enable-maintainer-mode  enable make rules and dependencies not useful
 			  (and sometimes confusing) to the casual installer
   --enable-shared[=PKGS]  build shared libraries [default=yes]
@@ -2625,6 +2625,44 @@
 
 
 
+# Default to --enable-multilib
+# Check whether --enable-multilib was given.
+if test "${enable_multilib+set}" = set; then :
+  enableval=$enable_multilib; case "$enableval" in
+  yes) multilib=yes ;;
+  no)  multilib=no ;;
+  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
+ esac
+else
+  multilib=yes
+fi
+
+
+# We may get other options which we leave undocumented:
+# --with-target-subdir, --with-multisrctop, --with-multisubdir
+# See config-ml.in if you want the gory details.
+
+if test "$srcdir" = "."; then
+  if test "$with_target_subdir" != "."; then
+    multi_basedir="$srcdir/$with_multisrctop../.."
+  else
+    multi_basedir="$srcdir/$with_multisrctop.."
+  fi
+else
+  multi_basedir="$srcdir/.."
+fi
+
+
+# Even if the default multilib is not a cross compilation,
+# it may be that some of the other multilibs are.
+if test $cross_compiling = no && test $multilib = yes \
+   && test "x${with_multisubdir}" != x ; then
+   cross_compiling=maybe
+fi
+
+ac_config_commands="$ac_config_commands default-1"
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for --enable-version-specific-runtime-libs" >&5
 $as_echo_n "checking for --enable-version-specific-runtime-libs... " >&6; }
 # Check whether --enable-version-specific-runtime-libs was given.
@@ -4701,44 +4739,7 @@
 
 
 
-# Default to --enable-multilib
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "$enableval" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
- esac
-else
-  multilib=yes
-fi
 
-
-# We may get other options which we leave undocumented:
-# --with-target-subdir, --with-multisrctop, --with-multisubdir
-# See config-ml.in if you want the gory details.
-
-if test "$srcdir" = "."; then
-  if test "$with_target_subdir" != "."; then
-    multi_basedir="$srcdir/$with_multisrctop../.."
-  else
-    multi_basedir="$srcdir/$with_multisrctop.."
-  fi
-else
-  multi_basedir="$srcdir/.."
-fi
-
-
-# Even if the default multilib is not a cross compilation,
-# it may be that some of the other multilibs are.
-if test $cross_compiling = no && test $multilib = yes \
-   && test "x${with_multisubdir}" != x ; then
-   cross_compiling=maybe
-fi
-
-ac_config_commands="$ac_config_commands default-1"
-
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
 $as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
     # Check whether --enable-maintainer-mode was given.
@@ -12019,7 +12020,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12022 "configure"
+#line 12023 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12125,7 +12126,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12128 "configure"
+#line 12129 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -17090,7 +17091,6 @@
 #
 # INIT-COMMANDS
 #
-AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
 
 srcdir="$srcdir"
 host="$host"
@@ -17105,6 +17105,7 @@
 CXX="$CXX"
 GFORTRAN="$GFORTRAN"
 GCJ="$GCJ"
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
 
 
 # The HP-UX ksh and POSIX shell print the target directory to stdout
@@ -17492,8 +17493,8 @@
 for ac_config_target in $ac_config_targets
 do
   case $ac_config_target in
+    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
-    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
     "gstdint.h") CONFIG_COMMANDS="$CONFIG_COMMANDS gstdint.h" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
@@ -18091,6 +18092,14 @@
 
 
   case $ac_file$ac_mode in
+    "default-1":C)
+# Only add multilib support code if we just rebuilt the top-level
+# Makefile.
+case " $CONFIG_FILES " in
+ *" Makefile "*)
+   ac_file=Makefile . ${multi_basedir}/config-ml.in
+   ;;
+esac ;;
     "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
   # Autoconf 2.62 quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
@@ -18186,14 +18195,6 @@
   done
 }
  ;;
-    "default-1":C)
-# Only add multilib support code if we just rebuilt the top-level
-# Makefile.
-case " $CONFIG_FILES " in
- *" Makefile "*)
-   ac_file=Makefile . ${multi_basedir}/config-ml.in
-   ;;
-esac ;;
     "libtool":C)
 
     # See if we are running on zsh, and set the options which allow our
Index: libsanitizer/ChangeLog
===================================================================
--- a/src/libsanitizer/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libsanitizer/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2015-01-27  Matthias Klose  <doko@ubuntu.com>
+
+	* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC.
+	* configure: Regenerate.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libsanitizer/configure.ac
===================================================================
--- a/src/libsanitizer/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/libsanitizer/configure.ac	(.../branches/gcc-4_9-branch)
@@ -5,6 +5,8 @@
 AC_INIT(package-unused, version-unused, libsanitizer)
 AC_CONFIG_SRCDIR([include/sanitizer/common_interface_defs.h])
 
+AM_ENABLE_MULTILIB(, ..)
+
 AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])
 AC_ARG_ENABLE(version-specific-runtime-libs,
 [  --enable-version-specific-runtime-libs    Specify that runtime libraries should be installed in a compiler-specific directory ],
@@ -26,7 +28,6 @@
 GCC_LIBSTDCXX_RAW_CXX_FLAGS
 
 AM_INIT_AUTOMAKE(foreign no-dist)
-AM_ENABLE_MULTILIB(, ..)
 AM_MAINTAINER_MODE
 
 # Calculate toolexeclibdir
Index: libstdc++-v3/configure.host
===================================================================
--- a/src/libstdc++-v3/configure.host	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/configure.host	(.../branches/gcc-4_9-branch)
@@ -219,7 +219,6 @@
     os_include_dir="os/aix"
     atomicity_dir="os/aix"
     atomic_word_dir="os/aix"
-    OPT_LDFLAGS="-Wl,-G"
     ;;
   aix4.*)
     os_include_dir="os/generic"
Index: libstdc++-v3/include/std/shared_mutex
===================================================================
--- a/src/libstdc++-v3/include/std/shared_mutex	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/shared_mutex	(.../branches/gcc-4_9-branch)
@@ -36,10 +36,8 @@
 #else
 
 #include <bits/c++config.h>
-#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
-# include <mutex>
-# include <condition_variable>
-#endif
+#include <mutex>
+#include <condition_variable>
 #include <bits/functexcept.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -51,7 +49,8 @@
    * @{
    */
 
-#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
+#ifdef _GLIBCXX_USE_C99_STDINT_TR1
+#ifdef _GLIBCXX_HAS_GTHREADS
 
 #define __cpp_lib_shared_timed_mutex 201402
 
@@ -254,7 +253,7 @@
 	}
     }
   };
-#endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1
+#endif // _GLIBCXX_HAS_GTHREADS
 
   /// shared_lock
   template<typename _Mutex>
@@ -393,6 +392,8 @@
     swap(shared_lock<_Mutex>& __x, shared_lock<_Mutex>& __y) noexcept
     { __x.swap(__y); }
 
+#endif // _GLIBCXX_USE_C99_STDINT_TR1
+
   // @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/include/std/tuple
===================================================================
--- a/src/libstdc++-v3/include/std/tuple	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/tuple	(.../branches/gcc-4_9-branch)
@@ -88,21 +88,22 @@
       constexpr _Head_base(const _Head& __h)
       : _Head(__h) { }
 
-      template<typename _UHead, typename = typename
-	       enable_if<!is_convertible<_UHead,
-	                                 __uses_alloc_base>::value>::type>
+      constexpr _Head_base(const _Head_base&) = default;
+      constexpr _Head_base(_Head_base&&) = default;
+
+      template<typename _UHead>
         constexpr _Head_base(_UHead&& __h)
 	: _Head(std::forward<_UHead>(__h)) { }
 
-      _Head_base(__uses_alloc0)
+      _Head_base(allocator_arg_t, __uses_alloc0)
       : _Head() { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc1<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 	: _Head(allocator_arg, *__a._M_a) { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc2<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 	: _Head(*__a._M_a) { }
 
       template<typename _UHead>
@@ -133,21 +134,22 @@
       constexpr _Head_base(const _Head& __h)
       : _M_head_impl(__h) { }
 
-      template<typename _UHead, typename = typename
-	       enable_if<!is_convertible<_UHead,
-	                                 __uses_alloc_base>::value>::type>
+      constexpr _Head_base(const _Head_base&) = default;
+      constexpr _Head_base(_Head_base&&) = default;
+
+      template<typename _UHead>
         constexpr _Head_base(_UHead&& __h)
 	: _M_head_impl(std::forward<_UHead>(__h)) { }
 
-      _Head_base(__uses_alloc0)
+      _Head_base(allocator_arg_t, __uses_alloc0)
       : _M_head_impl() { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc1<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 	: _M_head_impl(allocator_arg, *__a._M_a) { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc2<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 	: _M_head_impl(*__a._M_a) { }
 
       template<typename _UHead>
@@ -285,7 +287,7 @@
       template<typename _Alloc>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 	: _Inherited(__tag, __a),
-          _Base(__use_alloc<_Head>(__a)) { }
+          _Base(__tag, __use_alloc<_Head>(__a)) { }
 
       template<typename _Alloc>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
Index: libstdc++-v3/include/std/future
===================================================================
--- a/src/libstdc++-v3/include/std/future	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/future	(.../branches/gcc-4_9-branch)
@@ -1450,7 +1450,8 @@
       operator()(_ArgTypes... __args)
       {
 	__future_base::_State_base::_S_check(_M_state);
-	_M_state->_M_run(std::forward<_ArgTypes>(__args)...);
+	auto __state = _M_state;
+	__state->_M_run(std::forward<_ArgTypes>(__args)...);
       }
 
       void
Index: libstdc++-v3/include/std/functional
===================================================================
--- a/src/libstdc++-v3/include/std/functional	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/functional	(.../branches/gcc-4_9-branch)
@@ -2407,9 +2407,9 @@
     {
       if (static_cast<bool>(__x))
 	{
+	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	  _M_invoker = __x._M_invoker;
 	  _M_manager = __x._M_manager;
-	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	}
     }
 
Index: libstdc++-v3/include/std/istream
===================================================================
--- a/src/libstdc++-v3/include/std/istream	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/istream	(.../branches/gcc-4_9-branch)
@@ -870,7 +870,10 @@
   template<typename _CharT, typename _Traits, typename _Tp>
     inline basic_istream<_CharT, _Traits>&
     operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
-    { return (__is >> __x); }
+    { 
+      __is >> __x;
+      return __is;
+    }
 #endif // C++11
 
 _GLIBCXX_END_NAMESPACE_VERSION
Index: libstdc++-v3/include/std/ostream
===================================================================
--- a/src/libstdc++-v3/include/std/ostream	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/ostream	(.../branches/gcc-4_9-branch)
@@ -600,7 +600,10 @@
   template<typename _CharT, typename _Traits, typename _Tp>
     inline basic_ostream<_CharT, _Traits>&
     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
-    { return (__os << __x); }
+    {
+      __os << __x;
+      return __os;
+    }
 #endif // C++11
 
 _GLIBCXX_END_NAMESPACE_VERSION
Index: libstdc++-v3/include/std/scoped_allocator
===================================================================
--- a/src/libstdc++-v3/include/std/scoped_allocator	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/scoped_allocator	(.../branches/gcc-4_9-branch)
@@ -105,6 +105,8 @@
       __inner_type_impl() = default;
       __inner_type_impl(const __inner_type_impl&) = default;
       __inner_type_impl(__inner_type_impl&&) = default;
+      __inner_type_impl& operator=(const __inner_type_impl&) = default;
+      __inner_type_impl& operator=(__inner_type_impl&&) = default;
       
       template<typename _Alloc>
       __inner_type_impl(const __inner_type_impl<_Alloc>& __other)
@@ -136,6 +138,8 @@
       __inner_type_impl() = default;
       __inner_type_impl(const __inner_type_impl&) = default;
       __inner_type_impl(__inner_type_impl&&) = default;
+      __inner_type_impl& operator=(const __inner_type_impl&) = default;
+      __inner_type_impl& operator=(__inner_type_impl&&) = default;
       
       template<typename... _Allocs>
       __inner_type_impl(const __inner_type_impl<_Allocs...>& __other)
@@ -310,6 +314,12 @@
           _M_inner(std::move(__other._M_inner))
         { }
 
+      scoped_allocator_adaptor&
+      operator=(const scoped_allocator_adaptor&) = default;
+
+      scoped_allocator_adaptor&
+      operator=(scoped_allocator_adaptor&&) = default;
+
       inner_allocator_type& inner_allocator() noexcept
       { return _M_inner._M_get(this); }
 
Index: libstdc++-v3/include/parallel/numeric
===================================================================
--- a/src/libstdc++-v3/include/parallel/numeric	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/parallel/numeric	(.../branches/gcc-4_9-branch)
@@ -85,8 +85,7 @@
     __accumulate_switch(__RAIter __begin, __RAIter __end, 
                       _Tp __init, _BinaryOperation __binary_op, 
                       random_access_iterator_tag, 
-                      __gnu_parallel::_Parallelism __parallelism_tag  
-                      = __gnu_parallel::parallel_unbalanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -193,8 +192,7 @@
 			   _BinaryFunction2 __binary_op2,
 			   random_access_iterator_tag,
 			   random_access_iterator_tag,
-			   __gnu_parallel::_Parallelism __parallelism_tag
-			   = __gnu_parallel::parallel_unbalanced)
+			   __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION((__last1 - __first1)
                                       >= __gnu_parallel::_Settings::get().
@@ -419,8 +417,7 @@
 				 random_access_iterator_tag,
 				 random_access_iterator_tag,
 				 __gnu_parallel::_Parallelism
-				 __parallelism_tag
-				 = __gnu_parallel::parallel_balanced)
+				 __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
Index: libstdc++-v3/include/parallel/algo.h
===================================================================
--- a/src/libstdc++-v3/include/parallel/algo.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/parallel/algo.h	(.../branches/gcc-4_9-branch)
@@ -81,9 +81,8 @@
   template<typename _RAIter, typename _Function>
     _Function
     __for_each_switch(_RAIter __begin, _RAIter __end, 
-                    _Function __f, random_access_iterator_tag, 
-                    __gnu_parallel::_Parallelism __parallelism_tag
-                    = __gnu_parallel::parallel_balanced)
+                    _Function __f, random_access_iterator_tag,
+                    __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -896,8 +895,7 @@
     typename iterator_traits<_RAIter>::difference_type
     __count_switch(_RAIter __begin, _RAIter __end, 
                  const _Tp& __value, random_access_iterator_tag, 
-                 __gnu_parallel::_Parallelism __parallelism_tag 
-                 = __gnu_parallel::parallel_unbalanced)
+                 __gnu_parallel::_Parallelism __parallelism_tag)
     {
       typedef iterator_traits<_RAIter> _TraitsType;
       typedef typename _TraitsType::value_type _ValueType;
@@ -966,8 +964,7 @@
     typename iterator_traits<_RAIter>::difference_type
     __count_if_switch(_RAIter __begin, _RAIter __end, 
                     _Predicate __pred, random_access_iterator_tag,
-                    __gnu_parallel::_Parallelism __parallelism_tag
-                    = __gnu_parallel::parallel_unbalanced)
+                    __gnu_parallel::_Parallelism __parallelism_tag)
     {
       typedef iterator_traits<_RAIter> _TraitsType;
       typedef typename _TraitsType::value_type _ValueType;
@@ -1225,8 +1222,7 @@
     __transform1_switch(_RAIter1 __begin, _RAIter1 __end,
                       _RAIter2 __result, _UnaryOperation __unary_op,
                       random_access_iterator_tag, random_access_iterator_tag,
-                      __gnu_parallel::_Parallelism __parallelism_tag
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -1315,8 +1311,7 @@
                       _RAIter3 __result, _BinaryOperation __binary_op,
                       random_access_iterator_tag, random_access_iterator_tag,
                       random_access_iterator_tag,
-                      __gnu_parallel::_Parallelism __parallelism_tag 
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             (__end1 - __begin1) >=
@@ -1422,8 +1417,7 @@
     __replace_switch(_RAIter __begin, _RAIter __end, 
                    const _Tp& __old_value, const _Tp& __new_value, 
                    random_access_iterator_tag, 
-                   __gnu_parallel::_Parallelism __parallelism_tag
-                   = __gnu_parallel::parallel_balanced)
+                   __gnu_parallel::_Parallelism __parallelism_tag)
     {
       // XXX parallel version is where?
       replace(__begin, __end, __old_value, __new_value, 
@@ -1478,8 +1472,7 @@
     __replace_if_switch(_RAIter __begin, _RAIter __end,
                       _Predicate __pred, const _Tp& __new_value,
                       random_access_iterator_tag,
-                      __gnu_parallel::_Parallelism __parallelism_tag
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -1544,8 +1537,7 @@
     void
     __generate_switch(_RAIter __begin, _RAIter __end,
                     _Generator __gen, random_access_iterator_tag, 
-                    __gnu_parallel::_Parallelism __parallelism_tag
-                    = __gnu_parallel::parallel_balanced)
+                    __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -1608,8 +1600,7 @@
     inline _RAIter
     __generate_n_switch(_RAIter __begin, _Size __n, _Generator __gen, 
                       random_access_iterator_tag, 
-                      __gnu_parallel::_Parallelism __parallelism_tag
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       // XXX parallel version is where?
       return generate_n(__begin, __n, __gen, __gnu_parallel::sequential_tag());
@@ -2204,8 +2195,7 @@
     _RAIter
     __max_element_switch(_RAIter __begin, _RAIter __end, 
                        _Compare __comp, random_access_iterator_tag, 
-                       __gnu_parallel::_Parallelism __parallelism_tag
-                       = __gnu_parallel::parallel_balanced)
+			 __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -2296,8 +2286,7 @@
     _RAIter
     __min_element_switch(_RAIter __begin, _RAIter __end, 
                        _Compare __comp, random_access_iterator_tag, 
-                       __gnu_parallel::_Parallelism __parallelism_tag
-                       = __gnu_parallel::parallel_balanced)
+                       __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
Index: libstdc++-v3/include/bits/stl_uninitialized.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../branches/gcc-4_9-branch)
@@ -115,8 +115,9 @@
       const bool __assignable = true;
 #else
       // trivial types can have deleted assignment
-      typedef typename iterator_traits<_InputIterator>::reference _RefType;
-      const bool __assignable = is_assignable<_ValueType1, _RefType>::value;
+      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
+      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
+      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
 #endif
 
       return std::__uninitialized_copy<__is_trivial(_ValueType1)
Index: libstdc++-v3/include/bits/stl_algo.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_algo.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/stl_algo.h	(.../branches/gcc-4_9-branch)
@@ -3595,7 +3595,8 @@
 
       // Efficiently compare identical prefixes:  O(N) if sequences
       // have the same elements in the same order.
-      for (; __first1 != __last1; ++__first1, ++__first2)
+      for (; __first1 != __last1 && __first2 != __last2;
+	  ++__first1, ++__first2)
 	if (!__pred(__first1, __first2))
 	  break;
 
Index: libstdc++-v3/include/bits/regex_executor.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex_executor.tcc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/regex_executor.tcc	(.../branches/gcc-4_9-branch)
@@ -267,9 +267,11 @@
 	    _M_dfs<__match_mode>(__state._M_next);
 	  break;
 	case _S_opcode_match:
+	  if (_M_current == _M_end)
+	    break;
 	  if (__dfs_mode)
 	    {
-	      if (_M_current != _M_end && __state._M_matches(*_M_current))
+	      if (__state._M_matches(*_M_current))
 		{
 		  ++_M_current;
 		  _M_dfs<__match_mode>(__state._M_next);
@@ -350,23 +352,24 @@
     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
     _M_word_boundary(_State<_TraitsT> __state) const
     {
-      // By definition.
-      bool __ans = false;
-      auto __pre = _M_current;
-      --__pre;
-      if (!(_M_at_begin() && _M_at_end()))
+      bool __left_is_word = false;
+      if (_M_current != _M_begin
+	  || (_M_flags & regex_constants::match_prev_avail))
 	{
-	  if (_M_at_begin())
-	    __ans = _M_is_word(*_M_current)
-	      && !(_M_flags & regex_constants::match_not_bow);
-	  else if (_M_at_end())
-	    __ans = _M_is_word(*__pre)
-	      && !(_M_flags & regex_constants::match_not_eow);
-	  else
-	    __ans = _M_is_word(*_M_current)
-	      != _M_is_word(*__pre);
+	  auto __prev = _M_current;
+	  if (_M_is_word(*std::prev(__prev)))
+	    __left_is_word = true;
 	}
-      return __ans;
+      bool __right_is_word =
+	_M_current != _M_end && _M_is_word(*_M_current);
+
+      if (__left_is_word == __right_is_word)
+	return false;
+      if (__left_is_word && !(_M_flags & regex_constants::match_not_eow))
+	return true;
+      if (__right_is_word && !(_M_flags & regex_constants::match_not_bow))
+	return true;
+      return false;
     }
 
 _GLIBCXX_END_NAMESPACE_VERSION
Index: libstdc++-v3/include/bits/regex.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex.tcc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/regex.tcc	(.../branches/gcc-4_9-branch)
@@ -62,6 +62,7 @@
 	return false;
 
       typename match_results<_BiIter, _Alloc>::_Base_type& __res = __m;
+      __m._M_begin = __s;
       __res.resize(__re._M_automaton->_M_sub_count() + 2);
       for (auto& __it : __res)
 	__it.matched = false;
@@ -274,53 +275,20 @@
 	  "right-curly-bracket",
 	  "tilde",
 	  "DEL",
-	  ""
 	};
 
-      // same as boost
-      //static const char* __digraphs[] =
-      //  {
-      //    "ae",
-      //    "Ae",
-      //    "AE",
-      //    "ch",
-      //    "Ch",
-      //    "CH",
-      //    "ll",
-      //    "Ll",
-      //    "LL",
-      //    "ss",
-      //    "Ss",
-      //    "SS",
-      //    "nj",
-      //    "Nj",
-      //    "NJ",
-      //    "dz",
-      //    "Dz",
-      //    "DZ",
-      //    "lj",
-      //    "Lj",
-      //    "LJ",
-      //    ""
-      //  };
+      string __s;
+      for (; __first != __last; ++__first)
+	__s += __fctyp.narrow(*__first, 0);
 
-      std::string __s(__last - __first, '?');
-      __fctyp.narrow(__first, __last, '?', &*__s.begin());
+      for (const auto& __it : __collatenames)
+	if (__s == __it)
+	  return string_type(1, __fctyp.widen(
+	    static_cast<char>(&__it - __collatenames)));
 
-      for (unsigned int __i = 0; *__collatenames[__i]; __i++)
-	if (__s == __collatenames[__i])
-	  return string_type(1, __fctyp.widen(static_cast<char>(__i)));
+      // TODO Add digraph support:
+      // http://boost.sourceforge.net/libs/regex/doc/collating_names.html
 
-      //for (unsigned int __i = 0; *__digraphs[__i]; __i++)
-      //  {
-      //    const char* __now = __digraphs[__i];
-      //    if (__s == __now)
-      //      {
-      //	string_type ret(__s.size(), __fctyp.widen('?'));
-      //	__fctyp.widen(__now, __now + 2/* ouch */, &*ret.begin());
-      //	return ret;
-      //      }
-      //  }
       return string_type();
     }
 
@@ -331,12 +299,10 @@
     lookup_classname(_Fwd_iter __first, _Fwd_iter __last, bool __icase) const
     {
       typedef std::ctype<char_type> __ctype_type;
-      typedef std::ctype<char> __cctype_type;
-      typedef const pair<const char*, char_class_type> _ClassnameEntry;
       const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));
-      const __cctype_type& __cctyp(use_facet<__cctype_type>(_M_locale));
 
-      static _ClassnameEntry __classnames[] =
+      // Mappings from class name to class mask.
+      static const pair<const char*, char_class_type> __classnames[] =
       {
 	{"d", ctype_base::digit},
 	{"w", {ctype_base::alnum, _RegexMask::_S_under}},
@@ -355,22 +321,19 @@
 	{"xdigit", ctype_base::xdigit},
       };
 
-      std::string __s(__last - __first, '?');
-      __fctyp.narrow(__first, __last, '?', &__s[0]);
-      __cctyp.tolower(&*__s.begin(), &*__s.begin() + __s.size());
-      for (_ClassnameEntry* __it = __classnames;
-	   __it < *(&__classnames + 1);
-	   ++__it)
-	{
-	  if (__s == __it->first)
-	    {
-	      if (__icase
-		  && ((__it->second
-		       & (ctype_base::lower | ctype_base::upper)) != 0))
-		return ctype_base::alpha;
-	      return __it->second;
-	    }
-	}
+      string __s;
+      for (; __first != __last; ++__first)
+	__s += __fctyp.narrow(__fctyp.tolower(*__first), 0);
+
+      for (const auto& __it : __classnames)
+	if (__s == __it.first)
+	  {
+	    if (__icase
+		&& ((__it.second
+		     & (ctype_base::lower | ctype_base::upper)) != 0))
+	      return ctype_base::alpha;
+	    return __it.second;
+	  }
       return 0;
     }
 
@@ -581,8 +544,10 @@
 				   | regex_constants::match_continuous))
 		    {
 		      _GLIBCXX_DEBUG_ASSERT(_M_match[0].matched);
-		      _M_match.at(_M_match.size()).first = __prefix_first;
-		      _M_match._M_in_iterator = true;
+		      auto& __prefix = _M_match.at(_M_match.size());
+		      __prefix.first = __prefix_first;
+		      __prefix.matched = __prefix.first != __prefix.second;
+		      // [28.12.1.4.5]
 		      _M_match._M_begin = _M_begin;
 		      return *this;
 		    }
@@ -594,8 +559,10 @@
 	  if (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))
 	    {
 	      _GLIBCXX_DEBUG_ASSERT(_M_match[0].matched);
-	      _M_match.at(_M_match.size()).first = __prefix_first;
-	      _M_match._M_in_iterator = true;
+	      auto& __prefix = _M_match.at(_M_match.size());
+	      __prefix.first = __prefix_first;
+	      __prefix.matched = __prefix.first != __prefix.second;
+	      // [28.12.1.4.5]
 	      _M_match._M_begin = _M_begin;
 	    }
 	  else
@@ -614,11 +581,9 @@
       _M_position = __rhs._M_position;
       _M_subs = __rhs._M_subs;
       _M_n = __rhs._M_n;
-      _M_result = __rhs._M_result;
       _M_suffix = __rhs._M_suffix;
       _M_has_m1 = __rhs._M_has_m1;
-      if (__rhs._M_result == &__rhs._M_suffix)
-	_M_result = &_M_suffix;
+      _M_normalize_result();
       return *this;
     }
 
Index: libstdc++-v3/include/bits/regex.h
===================================================================
--- a/src/libstdc++-v3/include/bits/regex.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/regex.h	(.../branches/gcc-4_9-branch)
@@ -449,7 +449,7 @@
        */
       explicit
       basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)
-      : basic_regex(__p, __p + _Rx_traits::length(__p), __f)
+      : basic_regex(__p, __p + char_traits<_Ch_type>::length(__p), __f)
       { }
 
       /**
@@ -476,7 +476,10 @@
        */
       basic_regex(const basic_regex& __rhs)
       : _M_flags(__rhs._M_flags), _M_original_str(__rhs._M_original_str)
-      { this->imbue(__rhs.getloc()); }
+      {
+	_M_traits.imbue(__rhs.getloc());
+	this->assign(_M_original_str, _M_flags);
+      }
 
       /**
        * @brief Move-constructs a basic regular expression.
@@ -490,7 +493,8 @@
       : _M_flags(__rhs._M_flags),
       _M_original_str(std::move(__rhs._M_original_str))
       {
-	this->imbue(__rhs.getloc());
+	_M_traits.imbue(__rhs.getloc());
+	this->assign(_M_original_str, _M_flags);
 	__rhs._M_automaton.reset();
       }
 
@@ -580,10 +584,22 @@
        */
       basic_regex&
       operator=(const _Ch_type* __p)
-      { return this->assign(__p, flags()); }
+      { return this->assign(__p); }
 
       /**
        * @brief Replaces a regular expression with a new one constructed from
+       * an initializer list.
+       *
+       * @param __l  The initializer list.
+       *
+       * @throws regex_error if @p __l is not a valid regular expression.
+       */
+      basic_regex&
+      operator=(initializer_list<_Ch_type> __l)
+      { return this->assign(__l.begin(), __l.end()); }
+
+      /**
+       * @brief Replaces a regular expression with a new one constructed from
        * a string.
        *
        * @param __s A pointer to a string containing a regular expression.
@@ -591,7 +607,7 @@
       template<typename _Ch_typeraits, typename _Alloc>
 	basic_regex&
 	operator=(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s)
-	{ return this->assign(__s, flags()); }
+	{ return this->assign(__s); }
 
       // [7.8.3] assign
       /**
@@ -604,7 +620,8 @@
       {
 	_M_flags = __rhs._M_flags;
 	_M_original_str = __rhs._M_original_str;
-	this->imbue(__rhs.getloc());
+	_M_traits.imbue(__rhs.getloc());
+	this->assign(_M_original_str, _M_flags);
 	return *this;
       }
 
@@ -622,7 +639,9 @@
 	_M_flags = __rhs._M_flags;
 	_M_original_str = std::move(__rhs._M_original_str);
 	__rhs._M_automaton.reset();
-	this->imbue(__rhs.getloc());
+	_M_traits.imbue(__rhs.getloc());
+	this->assign(_M_original_str, _M_flags);
+	return *this;
       }
 
       /**
@@ -675,12 +694,10 @@
 	assign(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s,
 	       flag_type __flags = ECMAScript)
 	{
+	  _M_automaton = __detail::__compile_nfa(
+	    __s.data(), __s.data() + __s.size(), _M_traits, __flags);
+	  _M_original_str = __s;
 	  _M_flags = __flags;
-	  _M_original_str.assign(__s.begin(), __s.end());
-	  auto __p = _M_original_str.c_str();
-	  _M_automaton = __detail::__compile_nfa(__p,
-						 __p + _M_original_str.size(),
-						 _M_traits, _M_flags);
 	  return *this;
 	}
 
@@ -725,7 +742,11 @@
        */
       unsigned int
       mark_count() const
-      { return _M_automaton->_M_sub_count() - 1; }
+      {
+	if (_M_automaton)
+	  return _M_automaton->_M_sub_count() - 1;
+	return 0;
+      }
 
       /**
        * @brief Gets the flags used to construct the regular expression
@@ -744,9 +765,8 @@
       locale_type
       imbue(locale_type __loc)
       {
-	auto __ret = _M_traits.imbue(__loc);
-	this->assign(_M_original_str, _M_flags);
-	return __ret;
+	_M_automaton.reset();
+	return _M_traits.imbue(__loc);
       }
 
       /**
@@ -767,8 +787,10 @@
       swap(basic_regex& __rhs)
       {
 	std::swap(_M_flags, __rhs._M_flags);
-	std::swap(_M_original_str, __rhs._M_original_str);
-	this->imbue(__rhs.imbue(this->getloc()));
+	std::swap(_M_traits, __rhs._M_traits);
+	auto __tmp = std::move(_M_original_str);
+	this->assign(__rhs._M_original_str, _M_flags);
+	__rhs.assign(__tmp, __rhs._M_flags);
       }
 
 #ifdef _GLIBCXX_DEBUG
@@ -777,7 +799,7 @@
       { _M_automaton->_M_dot(__ostr); }
 #endif
 
-    protected:
+    private:
       typedef std::shared_ptr<__detail::_NFA<_Rx_traits>> _AutomatonPtr;
 
       template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,
@@ -1568,42 +1590,30 @@
        */
       explicit
       match_results(const _Alloc& __a = _Alloc())
-      : _Base_type(__a), _M_in_iterator(false)
+      : _Base_type(__a)
       { }
 
       /**
        * @brief Copy constructs a %match_results.
        */
-      match_results(const match_results& __rhs)
-      : _Base_type(__rhs), _M_in_iterator(false)
-      { }
+      match_results(const match_results& __rhs) = default;
 
       /**
        * @brief Move constructs a %match_results.
        */
-      match_results(match_results&& __rhs) noexcept
-      : _Base_type(std::move(__rhs)), _M_in_iterator(false)
-      { }
+      match_results(match_results&& __rhs) noexcept = default;
 
       /**
        * @brief Assigns rhs to *this.
        */
       match_results&
-      operator=(const match_results& __rhs)
-      {
-	match_results(__rhs).swap(*this);
-	return *this;
-      }
+      operator=(const match_results& __rhs) = default;
 
       /**
        * @brief Move-assigns rhs to *this.
        */
       match_results&
-      operator=(match_results&& __rhs)
-      {
-	match_results(std::move(__rhs)).swap(*this);
-	return *this;
-      }
+      operator=(match_results&& __rhs) = default;
 
       /**
        * @brief Destroys a %match_results object.
@@ -1690,13 +1700,8 @@
       difference_type
       position(size_type __sub = 0) const
       {
-	// [28.12.1.4.5]
-	if (_M_in_iterator)
-	  return __sub < size() ? std::distance(_M_begin,
-						(*this)[__sub].first) : -1;
-	else
-	  return __sub < size() ? std::distance(this->prefix().first,
-						(*this)[__sub].first) : -1;
+	return __sub < size() ? std::distance(_M_begin,
+					      (*this)[__sub].first) : -1;
       }
 
       /**
@@ -1778,7 +1783,7 @@
        */
       const_iterator
       cbegin() const
-      { return _Base_type::cbegin() + 2; }
+      { return this->begin(); }
 
       /**
        * @brief Gets an iterator to one-past-the-end of the collection.
@@ -1792,7 +1797,7 @@
        */
       const_iterator
       cend() const
-      { return _Base_type::cend(); }
+      { return this->end(); }
 
       //@}
 
@@ -1881,7 +1886,11 @@
        */
       void
       swap(match_results& __that)
-      { _Base_type::swap(__that); }
+      {
+	using std::swap;
+	_Base_type::swap(__that);
+	swap(_M_begin, __that._M_begin);
+      }
       //@}
 
     private:
@@ -2620,7 +2629,7 @@
 			     regex_constants::match_flag_type __m
 			     = regex_constants::match_default)
       : _M_position(__a, __b, __re, __m),
-      _M_subs(__submatches, *(&__submatches+1)), _M_n(0)
+      _M_subs(__submatches, __submatches + _Nm), _M_n(0)
       { _M_init(__a, __b); }
 
       /**
@@ -2629,12 +2638,8 @@
        */
       regex_token_iterator(const regex_token_iterator& __rhs)
       : _M_position(__rhs._M_position), _M_subs(__rhs._M_subs),
-      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_result(__rhs._M_result),
-      _M_has_m1(__rhs._M_has_m1)
-      {
-	if (__rhs._M_result == &__rhs._M_suffix)
-	  _M_result = &_M_suffix;
-      }
+      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_has_m1(__rhs._M_has_m1)
+      { _M_normalize_result(); }
 
       /**
        * @brief Assigns a %regex_token_iterator to another.
@@ -2706,6 +2711,18 @@
       _M_end_of_seq() const
       { return _M_result == nullptr; }
 
+      // [28.12.2.2.4]
+      void
+      _M_normalize_result()
+      {
+	if (_M_position != _Position())
+	  _M_result = &_M_current_match();
+	else if (_M_has_m1)
+	  _M_result = &_M_suffix;
+	else
+	  _M_result = nullptr;
+      }
+
       _Position         _M_position;
       std::vector<int>  _M_subs;
       value_type        _M_suffix;
Index: libstdc++-v3/include/bits/regex_compiler.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex_compiler.tcc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/regex_compiler.tcc	(.../branches/gcc-4_9-branch)
@@ -271,7 +271,7 @@
 		{
 		  auto& __tmp = _M_nfa[__stack.top()];
 		  __stack.pop();
-		  swap(__tmp._M_next, __tmp._M_alt);
+		  std::swap(__tmp._M_next, __tmp._M_alt);
 		}
 	    }
 	  _M_stack.push(__e);
Index: libstdc++-v3/include/tr1/functional
===================================================================
--- a/src/libstdc++-v3/include/tr1/functional	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/tr1/functional	(.../branches/gcc-4_9-branch)
@@ -2112,9 +2112,9 @@
     {
       if (static_cast<bool>(__x))
 	{
+	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	  _M_invoker = __x._M_invoker;
 	  _M_manager = __x._M_manager;
-	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	}
     }
 
@@ -2130,9 +2130,9 @@
 
 	if (_My_handler::_M_not_empty_function(__f))
 	  {
+	    _My_handler::_M_init_functor(_M_functor, __f);
 	    _M_invoker = &_My_handler::_M_invoke;
 	    _M_manager = &_My_handler::_M_manager;
-	    _My_handler::_M_init_functor(_M_functor, __f);
 	  }
       }
 
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,197 @@
+2015-03-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2015-03-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/65279
+	* include/std/scoped_allocator (__inner_type_impl,
+	scoped_allocator_adaptor): Add defaulted copy assignment and move
+	assignment operators.
+	* testsuite/20_util/scoped_allocator/65279.cc: New.
+
+2015-03-25  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/65543
+	* include/std/istream (operator>>(basic_istream<>&&, _Tp&): Revert
+	thinko in r150387.
+	* include/std/ostream (operator<<(basic_ostream<>&&, const _Tp&):
+	Likewise.
+	* testsuite/27_io/rvalue_streams-2.cc: New.
+
+2015-02-03  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64680
+	Backported from mainline
+	2015-01-22  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.h (basic_regex<>::basic_regex,
+	basic_regex<>::operator=, basic_regex<>::imbue): Conform to the
+	standard interface.
+	* testsuite/28_regex/basic_regex/assign/char/cstring.cc: New testcase.
+
+2015-02-03  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64649
+	Backported from mainline
+	2015-01-22  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.tcc (regex_traits<>::lookup_collatename,
+	regex_traits<>::lookup_classname): Correctly narrow input chars.
+	* testsuite/28_regex/traits/wchar_t/user_defined.cc: New testcase.
+
+2015-01-19  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64649
+	Backported from mainline
+	2015-01-19  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.tcc (regex_traits<>::lookup_collatename,
+	regex_traits<>::lookup_classname): Support forward iterators.
+	* testsuite/28_regex/traits/char/lookup_classname.cc: New testcases.
+	* testsuite/28_regex/traits/char/lookup_collatename.cc: New testcase.
+
+2015-01-19  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64584
+	PR libstdc++/64585
+	* include/bits/regex.h (basic_regex<>::basic_regex,
+	basic_regex<>::assign, basic_regex<>::imbue,
+	basic_regex<>::swap, basic_regex<>::mark_count): Drop NFA after
+	imbuing basic_regex; Make assign() transactional against exception.
+	* testsuite/28_regex/basic_regex/assign/char/string.cc: New testcase.
+	* testsuite/28_regex/basic_regex/imbue/string.cc: New testcase.
+
+2015-01-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/64646
+	* include/bits/stl_algo.h (__is_permutation): Also test for reaching
+	end of the second range.
+	* testsuite/25_algorithms/is_permutation/64646.cc: New.
+
+2015-01-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/64476
+	* include/bits/stl_uninitialized.h (uninitialized_copy): Fix
+	is_assignable arguments.
+	* testsuite/20_util/specialized_algorithms/uninitialized_copy/64476.cc:
+	New.
+
+2015-01-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60966
+	* include/std/future (packaged_task::operator()): Increment the
+	reference count on the shared state until the function returns.
+
+2015-01-09  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64239
+	Backported form mainline
+	2015-01-09  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.h (match_results<>::swap): Use std::swap
+	instead of swap.
+	* include/bits/regex_compiler.tcc (_Compiler<>::_M_quantifier):
+	Likewise.
+	* testsuite/28_regex/match_results/swap.cc: New testcase.
+
+2014-12-17  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64302
+	PR libstdc++/64303
+	Backported form mainline
+	2014-12-17  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.h (match_results::cbegin, match_results::cend,
+	regex_token_iterator::regex_token_iterator,
+	regex_token_iterator::_M_normalize_result): Fix match_results cbegin
+	and cend and regex_token_iterator::_M_result invariant.
+	* include/bits/regex.tcc: Fix regex_token_iterator::_M_result invariant.
+	* testsuite/28_regex/iterators/regex_token_iterator/64303.cc: Testcase.
+
+2014-12-13  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64239
+	* include/bits/regex.h (match_results<>::match_results,
+	match_results<>::operator=, match_results<>::position,
+	match_results<>::swap): Fix ctor/assign/swap.
+	* include/bits/regex.tcc: (__regex_algo_impl<>,
+	regex_iterator<>::operator++): Set match_results::_M_begin as
+	"start position".
+	* testsuite/28_regex/iterators/regex_iterator/char/
+	string_position_01.cc: Test cases.
+
+2014-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/64203
+	* include/std/shared_mutex: Fix preprocessor conditions.
+	* testsuite/experimental/feat-cxx14.cc: Check conditions.
+
+2014-12-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/63840
+	* include/std/functional (function::function(const function&)): Set
+	_M_manager after operations that might throw.
+	* include/tr1/functional (function::function(const function&),
+	function::function(_Functor, _Useless)): Likewise.
+	* testsuite/20_util/function/63840.cc: New.
+	* testsuite/tr1/3_function_objects/function/63840.cc: New.
+
+	PR libstdc++/61947
+	* include/std/tuple (_Head_base): Use allocator_arg_t parameters to
+	disambiguate unary constructors.
+	(_Tuple_impl): Pass allocator_arg_t arguments.
+	* testsuite/20_util/tuple/61947.cc: New.
+	* testsuite/20_util/uses_allocator/cons_neg.cc: Adjust dg-error line.
+
+2014-12-06  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64140
+	Backport form mainline
+	2014-12-04  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.tcc (regex_iterator<>::operator++): Update
+	prefix.matched after modifying prefix.first.
+	* testsuite/28_regex/iterators/regex_iterator/char/64140.cc: New
+	testcase.
+
+2014-12-02  Matthias Klose  <doko@ubuntu.com>
+
+	PR libstdc++/64103
+	Backport from mainline
+	2014-11-03  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* include/parallel/algo.h: Do not use default arguments in function
+	template redeclarations (definitions).
+
+	2014-11-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/parallel/numeric.h: Do not use default arguments in function
+	template redeclarations (definitions).
+
+2014-11-28  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/63497
+	* include/bits/regex_executor.tcc (_Executor::_M_dfs,
+	_Executor::_M_word_boundary): Avoid dereferecing _M_current at _M_end
+	or other invalid position.
+
+2014-11-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-09-10  Tony Wang  <tony.wang@arm.com>
+
+	PR target/56846
+	* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION):
+	Return with CONTINUE_UNWINDING when the state pattern
+	contains: _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND
+
+2014-10-30  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backported from mainline.
+	2014-10-30  David Edelsohn  <dje.gcc@gmail.com>
+
+	* configure.host (aix4.3+, 5+): Do not use -G in link command.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libstdc++-v3/libsupc++/eh_personality.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/eh_personality.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/libsupc++/eh_personality.cc	(.../branches/gcc-4_9-branch)
@@ -378,6 +378,12 @@
   switch (state & _US_ACTION_MASK)
     {
     case _US_VIRTUAL_UNWIND_FRAME:
+      // If the unwind state pattern is
+      // _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND
+      // then we don't need to search for any handler as it is not a real
+      // exception. Just unwind the stack.
+      if (state & _US_FORCE_UNWIND)
+	CONTINUE_UNWINDING;
       actions = _UA_SEARCH_PHASE;
       break;
 
Index: libstdc++-v3/testsuite/25_algorithms/is_permutation/64646.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/25_algorithms/is_permutation/64646.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/25_algorithms/is_permutation/64646.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++14" }
+
+#include <algorithm>
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::forward_list<int> l1{0}, l2;
+  VERIFY( !std::is_permutation(l1.begin(), l1.end(), l2.begin(), l2.end()) );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/27_io/rvalue_streams-2.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/rvalue_streams-2.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/27_io/rvalue_streams-2.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <sstream>
+
+struct A {};
+
+void operator<<(std::ostream&, const A&) { }
+void operator>>(std::istream&, A&) { }
+
+// PR libstdc++/65543
+int main()
+{
+  A a;
+
+  std::ostringstream() << a;
+  std::istringstream() >> a;
+}
Index: libstdc++-v3/testsuite/28_regex/traits/wchar_t/user_defined.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/traits/wchar_t/user_defined.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/traits/wchar_t/user_defined.cc	(.../branches/gcc-4_9-branch)
@@ -55,8 +55,32 @@
   VERIFY(!regex_match(L"\u2029", re));
 }
 
+struct MyCtype : std::ctype<wchar_t>
+{
+  char
+  do_narrow(wchar_t c, char dflt) const override
+  {
+    if (c >= 256)
+      return dflt;
+    return ((char)c)+1;
+  }
+};
+
+void
+test02()
+{
+  std::locale loc(std::locale(), new MyCtype);
+  std::regex_traits<wchar_t> traits;
+  traits.imbue(loc);
+  wchar_t wch = L'p';
+  VERIFY(traits.lookup_collatename(&wch, &wch+1) == L"q");
+  std::wstring ws = L"chfhs"; // chars of "digit" shifted by 1.
+  VERIFY(traits.lookup_classname(ws.begin(), ws.end()) != 0);
+}
+
 int main()
 {
   test01();
+  test02();
   return 0;
 }
Index: libstdc++-v3/testsuite/28_regex/traits/char/lookup_collatename.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/traits/char/lookup_collatename.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/traits/char/lookup_collatename.cc	(.../branches/gcc-4_9-branch)
@@ -26,6 +26,7 @@
 // 28.7 (8) Class template regex_traits [re.traits]
 
 #include <regex>
+#include <forward_list>
 #include <testsuite_hooks.h>
 
 void
@@ -40,8 +41,19 @@
   VERIFY(t.lookup_collatename(name, name+sizeof(name)-1) == "~");
 }
 
+// Test forward iterator.
+void
+test02()
+{
+  const char strlit[] = "tilde";
+  std::forward_list<char> s(strlit, strlit + strlen(strlit));
+  std::regex_traits<char> traits;
+  VERIFY(traits.lookup_collatename(s.begin(), s.end()) == "~");
+}
+
 int main()
 {
 	test01();
+	test02();
 	return 0;
 }
Index: libstdc++-v3/testsuite/28_regex/traits/char/lookup_classname.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/traits/char/lookup_classname.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/traits/char/lookup_classname.cc	(.../branches/gcc-4_9-branch)
@@ -26,6 +26,7 @@
 // 28.7(9) Class template regex_traits [re.traits]
 
 #include <regex>
+#include <forward_list>
 #include <testsuite_hooks.h>
 
 void
@@ -47,8 +48,29 @@
 	VERIFY( c2 == c3 );
 }
 
+// Test forward iterator
+void
+test02()
+{
+  const char strlit[] = "upper";
+  std::forward_list<char> s(strlit, strlit + strlen(strlit));
+  std::regex_traits<char> traits;
+  VERIFY(traits.isctype('C', traits.lookup_classname(s.begin(), s.end(), false)));
+}
+
+// icase
+void
+test03()
+{
+  std::string s("lower");
+  std::regex_traits<char> traits;
+  VERIFY(traits.isctype('C', traits.lookup_classname(s.begin(), s.end(), true)));
+}
+
 int main()
 {
 	test01();
+	test02();
+	test03();
 	return 0;
 }
Index: libstdc++-v3/testsuite/28_regex/basic_regex/imbue/string.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/basic_regex/imbue/string.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/basic_regex/imbue/string.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,44 @@
+// { dg-options "-std=gnu++11" }
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// [28.8.5] class template basic_regex locale
+
+#include <string>
+#include <regex>
+#include <testsuite_hooks.h>
+
+// libstdc++/64585
+void test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  static const char s[] = "a";
+  std::regex re("a");
+  VERIFY(std::regex_search(s, re));
+
+  auto loc = re.imbue(re.getloc());
+  VERIFY(!std::regex_search(s, re));
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/28_regex/basic_regex/assign/char/string.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/basic_regex/assign/char/string.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/basic_regex/assign/char/string.cc	(.../branches/gcc-4_9-branch)
@@ -1,4 +1,3 @@
-// { dg-do compile }
 // { dg-options "-std=gnu++0x" }
 
 // 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>
@@ -29,6 +28,7 @@
 // Tests C++ string assignment of the basic_regex class.  
 void test01()
 {
+  bool test __attribute__((unused)) = true;
   typedef std::basic_regex<char> test_type;
 
   std::string s("a*b");
@@ -36,9 +36,27 @@
   re.assign(s);
 }
 
+// libstdc++/64584
+void test02()
+{
+  bool test __attribute__((unused)) = true;
+  std::regex re("", std::regex_constants::extended);
+  auto flags = re.flags();
+  try
+    {
+      re.assign("(", std::regex_constants::icase);
+      VERIFY(false);
+    }
+  catch (const std::regex_error& e)
+    {
+      VERIFY(flags == re.flags());
+    }
+}
+
 int
 main()
 { 
   test01();
+  test02();
   return 0;
 }
Index: libstdc++-v3/testsuite/28_regex/basic_regex/assign/char/cstring.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/basic_regex/assign/char/cstring.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/basic_regex/assign/char/cstring.cc	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,4 @@
-// { dg-do compile }
-// { dg-options "-std=c++0x" }
+// { dg-options "-std=c++11" }
 
 // 2009-06-05  Stephen M. Webb  <stephen.webb@bregmasoft.ca>
 //
@@ -36,9 +35,19 @@
   re.assign(cs);
 }
 
+// basic_regex::operator=() resets flags. libstdc++/64680
+void test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::regex re("[[:alnum:]]", std::regex_constants::basic);
+  re = "\\w+";
+}
+
 int
 main()
 { 
   test01();
+  test02();
   return 0;
 }
Index: libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/64140.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/64140.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/64140.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// libstdc++/64140
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  const std::regex e("z*");
+  const std::string s("ab");
+
+  auto it = std::sregex_iterator(s.begin(), s.end(), e);
+  auto end = std::sregex_iterator();
+  VERIFY(it != end);
+  VERIFY(!it->prefix().matched);
+  ++it;
+  VERIFY(it != end);
+  VERIFY(it->prefix().matched);
+  ++it;
+  VERIFY(it != end);
+  VERIFY(it->prefix().matched);
+  ++it;
+  VERIFY(it == end);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_position_01.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_position_01.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_position_01.cc	(.../branches/gcc-4_9-branch)
@@ -24,6 +24,7 @@
 // Tests iter->position() behavior
 
 #include <regex>
+#include <tuple>
 #include <testsuite_hooks.h>
 
 void
@@ -41,9 +42,53 @@
   }
 }
 
+// PR libstdc++/64239
+void
+test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::regex re("\\w+");
+  std::string s("-a-b-c-");
+
+  std::tuple<int, int, const char*> expected[] =
+  {
+    std::make_tuple(1, 1, "a"),
+    std::make_tuple(3, 1, "b"),
+    std::make_tuple(5, 1, "c"),
+  };
+
+  int i = 0;
+  for (auto it1 = std::sregex_iterator(s.begin(), s.end(), re),
+       end = std::sregex_iterator(); it1 != end; ++it1, i++)
+    {
+      auto it2 = it1;
+      VERIFY(it1->position() == std::get<0>(expected[i]));
+      VERIFY(it1->length() == std::get<1>(expected[i]));
+      VERIFY(it1->str() == std::get<2>(expected[i]));
+      VERIFY(it2->position() == std::get<0>(expected[i]));
+      VERIFY(it2->length() == std::get<1>(expected[i]));
+      VERIFY(it2->str() == std::get<2>(expected[i]));
+    }
+}
+
+void
+test03()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::smatch m;
+  std::string s = "abcde";
+  std::regex_search(s, m, std::regex("bcd"));
+  VERIFY(m.position() == 1);
+  VERIFY(m.position() == m.prefix().length());
+}
+
 int
 main()
 {
   test01();
+  test02();
+  test03();
   return 0;
 }
Index: libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/64303.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/64303.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/64303.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,49 @@
+// { dg-do run }
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 28.12.2 Class template regex_token_iterator
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  const std::string s("  111  222  ");
+  const std::regex re("\\w+");
+
+  std::sregex_token_iterator it1(s.begin(), s.end(), re), it2(it1), end;
+
+  for (; it1 != end; ++it1, ++it2) {
+    VERIFY(it1 == it2);
+    VERIFY(*it1 == *it2);
+  }
+  VERIFY(it2 == end);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/28_regex/match_results/swap.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/match_results/swap.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/match_results/swap.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::cmatch m;
+  std::regex_match("a", m, std::regex("a"));
+  std::cmatch mm1 = m, mm2;
+  mm1.swap(mm2);
+  VERIFY(m == mm2);
+  std::swap(mm1, mm2);
+  VERIFY(m == mm1);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/experimental/feat-cxx14.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/feat-cxx14.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/experimental/feat-cxx14.cc	(.../branches/gcc-4_9-branch)
@@ -106,10 +106,12 @@
 #  error "<shared_mutex>"
 #endif
 
-#ifndef  __cpp_lib_shared_timed_mutex
-#  error "__cpp_lib_shared_timed_mutex"
-#elif  __cpp_lib_shared_timed_mutex != 201402
-#  error "__cpp_lib_shared_timed_mutex != 201402"
+#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
+#  ifndef  __cpp_lib_shared_timed_mutex
+#    error "__cpp_lib_shared_timed_mutex"
+#  elif  __cpp_lib_shared_timed_mutex != 201402
+#    error "__cpp_lib_shared_timed_mutex != 201402"
+#  endif
 #endif
 
 #ifndef  __cpp_lib_is_final
Index: libstdc++-v3/testsuite/tr1/3_function_objects/function/63840.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/tr1/3_function_objects/function/63840.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/tr1/3_function_objects/function/63840.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,55 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tr1/functional>
+#include <stdexcept>
+#include <testsuite_hooks.h>
+
+struct functor
+{
+  functor() : copies(0) { }
+
+  functor(const functor& f)
+  : copies(f.copies + 1)
+  {
+    if (copies > 1)
+      throw std::runtime_error("functor");
+  }
+
+  void operator()() const { }
+
+  int copies;
+};
+
+
+void
+test01()
+{
+  std::tr1::function<void()> f = functor();
+  try {
+    std::tr1::function<void()> g = f;
+  } catch (const std::runtime_error& e) {
+    return;
+  }
+  VERIFY(false);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/tuple/61947.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/tuple/61947.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/tuple/61947.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tuple>
+
+struct ConvertibleToAny {
+  template <class T> operator T() const { return T(); }
+};
+
+int main() {
+  std::tuple<ConvertibleToAny&&> t(ConvertibleToAny{});
+}
Index: libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(.../branches/gcc-4_9-branch)
@@ -44,4 +44,4 @@
 
   tuple<Type> t(allocator_arg, a, 1);
 }
-// { dg-error "no matching function" "" { target *-*-* } 118 }
+// { dg-error "no matching function" "" { target *-*-* } 119 }
Index: libstdc++-v3/testsuite/20_util/scoped_allocator/65279.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/scoped_allocator/65279.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/scoped_allocator/65279.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,54 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+#include <memory>
+#include <type_traits>
+#include <scoped_allocator>
+
+template<typename T>
+  struct Allocator : std::allocator<T>
+  {
+    template<typename U>
+      struct rebind { using other = Allocator<U>; };
+
+    using propagate_on_container_copy_assignment = std::true_type;
+    using propagate_on_container_move_assignment = std::true_type;
+  };
+
+template<typename... T>
+  using alloc = std::scoped_allocator_adaptor<Allocator<T>...>;
+
+void
+test01()
+{
+  // Test partial specialization for sizeof...(InnerAlloc) == 0
+  alloc<int> a;
+  a = a;
+  a = std::move(a);
+}
+
+void
+test02()
+{
+  // Test partial specialization for sizeof...(InnerAlloc) >= 1
+  alloc<int, char> a;
+  a = a;
+  a = std::move(a);
+}
Index: libstdc++-v3/testsuite/20_util/function/63840.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/function/63840.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/function/63840.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,55 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <functional>
+#include <stdexcept>
+#include <testsuite_hooks.h>
+
+struct functor
+{
+  functor() = default;
+
+  functor(const functor&)
+  {
+    throw std::runtime_error("test");
+  }
+
+  functor(functor&& f) = default;
+
+  void operator()() const { }
+};
+
+
+void
+test01()
+{
+  std::function<void()> f = functor{};
+  try {
+    auto g = f;
+  } catch (const std::runtime_error& e) {
+    return;
+  }
+  VERIFY(false);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/64476.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/64476.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/64476.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,65 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <memory>
+#include <testsuite_hooks.h>
+
+struct X
+{
+  X() = default;
+  X(X const &) = default;
+  X& operator=(X const&) = delete;
+};
+
+static_assert(__is_trivial(X), "X is trivial");
+
+int constructed = 0;
+int assigned = 0;
+
+struct Y
+{
+  Y() = default;
+  Y(Y const &) = default;
+  Y& operator=(Y const&) = default;
+
+  Y(const X&) { ++constructed; }
+  Y& operator=(const X&)& { ++assigned; return *this; }
+  Y& operator=(const X&)&& = delete;
+  Y& operator=(X&&) = delete;
+};
+
+static_assert(__is_trivial(Y), "Y is trivial");
+
+void
+test01()
+{
+  X a[100];
+  Y b[100];
+
+  std::uninitialized_copy(a, a+10, b);
+
+  VERIFY(constructed == 0);
+  VERIFY(assigned == 10);
+}
+
+int
+main()
+{
+  test01();
+}
Index: configure.ac
===================================================================
--- a/src/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/configure.ac	(.../branches/gcc-4_9-branch)
@@ -1658,6 +1658,9 @@
     ISL_CHECK_VERSION(0,11)
     if test "${gcc_cv_isl}" = no ; then
       ISL_CHECK_VERSION(0,12)
+      if test "${gcc_cv_isl}" = no ; then
+        ISL_CHECK_VERSION(0,14)
+      fi
     fi
   fi
   dnl Only execute fail-action, if ISL has been requested.
Index: ChangeLog
===================================================================
--- a/src/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,10 @@
+2014-12-04  Tobias Burnus  <burnus@net-b.de>
+
+	* configure.ac: Permit also ISL 0.14 with CLooG.
+	* Makefile.def: Make more dependent on mpfr, mpc, isl, and cloog.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libatomic/fop_n.c
===================================================================
--- a/src/libatomic/fop_n.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libatomic/fop_n.c	(.../branches/gcc-4_9-branch)
@@ -112,9 +112,9 @@
 
   pre_barrier (smodel);
 
-  wptr = (UWORD *)mptr;
-  shift = 0;
-  mask = -1;
+  wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);
+  shift = (((uintptr_t)mptr % WORDSIZE) * CHAR_BIT) ^ SIZE(INVERT_MASK);
+  mask = SIZE(MASK) << shift;
 
   wopval = (UWORD)opval << shift;
   woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);
@@ -136,9 +136,9 @@
 
   pre_barrier (smodel);
 
-  wptr = (UWORD *)mptr;
-  shift = 0;
-  mask = -1;
+  wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);
+  shift = (((uintptr_t)mptr % WORDSIZE) * CHAR_BIT) ^ SIZE(INVERT_MASK);
+  mask = SIZE(MASK) << shift;
 
   wopval = (UWORD)opval << shift;
   woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);
Index: libatomic/ChangeLog
===================================================================
--- a/src/libatomic/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libatomic/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2015-01-21  Andrew Waterman <waterman@cs.berkeley.edu>
+
+	* fop_n.c (libat_fetch_op): Align address to word boundary.
+	(libat_op_fetch): Likewise.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libbacktrace/configure
===================================================================
--- a/src/libbacktrace/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/libbacktrace/configure	(.../branches/gcc-4_9-branch)
@@ -614,7 +614,6 @@
 WARN_FLAGS
 EXTRA_FLAGS
 BACKTRACE_FILE
-multi_basedir
 OTOOL64
 OTOOL
 LIPO
@@ -680,6 +679,7 @@
 build_vendor
 build_cpu
 build
+multi_basedir
 target_alias
 host_alias
 build_alias
@@ -721,6 +721,7 @@
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
+enable_multilib
 enable_maintainer_mode
 with_target_subdir
 enable_shared
@@ -729,7 +730,6 @@
 enable_fast_install
 with_gnu_ld
 enable_libtool_lock
-enable_multilib
 with_system_libunwind
 enable_host_shared
 '
@@ -1362,6 +1362,7 @@
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-multilib       build many library versions (default)
   --enable-maintainer-mode  enable make rules and dependencies not useful
 			  (and sometimes confusing) to the casual installer
   --enable-shared[=PKGS]  build shared libraries [default=no]
@@ -1369,7 +1370,6 @@
   --enable-fast-install[=PKGS]
                           optimize for fast installation [default=yes]
   --disable-libtool-lock  avoid locking (might break parallel builds)
-  --enable-multilib       build many library versions (default)
   --enable-host-shared    build host code as shared libraries
 
 Optional Packages:
@@ -2453,6 +2453,46 @@
 ac_config_headers="$ac_config_headers config.h"
 
 
+if test -n "${with_target_subdir}"; then
+  # Default to --enable-multilib
+# Check whether --enable-multilib was given.
+if test "${enable_multilib+set}" = set; then :
+  enableval=$enable_multilib; case "$enableval" in
+  yes) multilib=yes ;;
+  no)  multilib=no ;;
+  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
+ esac
+else
+  multilib=yes
+fi
+
+
+# We may get other options which we leave undocumented:
+# --with-target-subdir, --with-multisrctop, --with-multisubdir
+# See config-ml.in if you want the gory details.
+
+if test "$srcdir" = "."; then
+  if test "$with_target_subdir" != "."; then
+    multi_basedir="$srcdir/$with_multisrctop../.."
+  else
+    multi_basedir="$srcdir/$with_multisrctop.."
+  fi
+else
+  multi_basedir="$srcdir/.."
+fi
+
+
+# Even if the default multilib is not a cross compilation,
+# it may be that some of the other multilibs are.
+if test $cross_compiling = no && test $multilib = yes \
+   && test "x${with_multisubdir}" != x ; then
+   cross_compiling=maybe
+fi
+
+ac_config_commands="$ac_config_commands default-1"
+
+fi
+
 ac_aux_dir=
 for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
   for ac_t in install-sh install.sh shtool; do
@@ -11089,7 +11129,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11092 "configure"
+#line 11132 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11195,7 +11235,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11198 "configure"
+#line 11238 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11439,43 +11479,6 @@
 if test -n "${with_target_subdir}"; then
   # We are compiling a GCC library.  We can assume that the unwind
   # library exists.
-  # Default to --enable-multilib
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "$enableval" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
- esac
-else
-  multilib=yes
-fi
-
-
-# We may get other options which we leave undocumented:
-# --with-target-subdir, --with-multisrctop, --with-multisubdir
-# See config-ml.in if you want the gory details.
-
-if test "$srcdir" = "."; then
-  if test "$with_target_subdir" != "."; then
-    multi_basedir="$srcdir/$with_multisrctop../.."
-  else
-    multi_basedir="$srcdir/$with_multisrctop.."
-  fi
-else
-  multi_basedir="$srcdir/.."
-fi
-
-
-# Even if the default multilib is not a cross compilation,
-# it may be that some of the other multilibs are.
-if test $cross_compiling = no && test $multilib = yes \
-   && test "x${with_multisubdir}" != x ; then
-   cross_compiling=maybe
-fi
-
-ac_config_commands="$ac_config_commands default-1"
-
   BACKTRACE_FILE="backtrace.lo simple.lo"
 else
   ac_fn_c_check_header_mongrel "$LINENO" "unwind.h" "ac_cv_header_unwind_h" "$ac_includes_default"
@@ -13174,7 +13177,21 @@
 # INIT-COMMANDS
 #
 
+srcdir="$srcdir"
+host="$host"
+target="$target"
+with_multisubdir="$with_multisubdir"
+with_multisrctop="$with_multisrctop"
+with_target_subdir="$with_target_subdir"
+ac_configure_args="${multilib_arg} ${ac_configure_args}"
+multi_basedir="$multi_basedir"
+CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+CC="$CC"
+CXX="$CXX"
+GFORTRAN="$GFORTRAN"
+GCJ="$GCJ"
 
+
 # The HP-UX ksh and POSIX shell print the target directory to stdout
 # if CDPATH is set.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
@@ -13434,20 +13451,6 @@
 
 
 
-srcdir="$srcdir"
-host="$host"
-target="$target"
-with_multisubdir="$with_multisubdir"
-with_multisrctop="$with_multisrctop"
-with_target_subdir="$with_target_subdir"
-ac_configure_args="${multilib_arg} ${ac_configure_args}"
-multi_basedir="$multi_basedir"
-CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
-CC="$CC"
-CXX="$CXX"
-GFORTRAN="$GFORTRAN"
-GCJ="$GCJ"
-
 GCC="$GCC"
 CC="$CC"
 acx_cv_header_stdint="$acx_cv_header_stdint"
@@ -13480,8 +13483,8 @@
 do
   case $ac_config_target in
     "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "gstdint.h") CONFIG_COMMANDS="$CONFIG_COMMANDS gstdint.h" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "backtrace-supported.h") CONFIG_FILES="$CONFIG_FILES backtrace-supported.h" ;;
@@ -14070,6 +14073,14 @@
 
 
   case $ac_file$ac_mode in
+    "default-1":C)
+# Only add multilib support code if we just rebuilt the top-level
+# Makefile.
+case " $CONFIG_FILES " in
+ *" Makefile "*)
+   ac_file=Makefile . ${multi_basedir}/config-ml.in
+   ;;
+esac ;;
     "libtool":C)
 
     # See if we are running on zsh, and set the options which allow our
@@ -14709,14 +14720,6 @@
   chmod +x "$ofile"
 
  ;;
-    "default-1":C)
-# Only add multilib support code if we just rebuilt the top-level
-# Makefile.
-case " $CONFIG_FILES " in
- *" Makefile "*)
-   ac_file=Makefile . ${multi_basedir}/config-ml.in
-   ;;
-esac ;;
     "gstdint.h":C)
 if test "$GCC" = yes; then
   echo "/* generated for " `$CC --version | sed 1q` "*/" > tmp-stdint.h
Index: libbacktrace/ChangeLog
===================================================================
--- a/src/libbacktrace/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libbacktrace/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2015-01-26  Matthias Klose  <doko@ubuntu.com>
+
+	* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC.
+	* configure: Regenerate.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libbacktrace/configure.ac
===================================================================
--- a/src/libbacktrace/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/libbacktrace/configure.ac	(.../branches/gcc-4_9-branch)
@@ -34,6 +34,10 @@
 AC_CONFIG_SRCDIR(backtrace.h)
 AC_CONFIG_HEADER(config.h)
 
+if test -n "${with_target_subdir}"; then
+  AM_ENABLE_MULTILIB(, ..)
+fi
+
 AC_CANONICAL_SYSTEM
 target_alias=${target_alias-$host_alias}
 
@@ -83,7 +87,6 @@
 if test -n "${with_target_subdir}"; then
   # We are compiling a GCC library.  We can assume that the unwind
   # library exists.
-  AM_ENABLE_MULTILIB(, ..)
   BACKTRACE_FILE="backtrace.lo simple.lo"
 else
   AC_CHECK_HEADER([unwind.h],
Index: configure
===================================================================
--- a/src/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/configure	(.../branches/gcc-4_9-branch)
@@ -6024,6 +6024,55 @@
   fi
 
 
+      if test "${gcc_cv_isl}" = no ; then
+
+  if test "${ENABLE_ISL_CHECK}" = yes ; then
+    _isl_saved_CFLAGS=$CFLAGS
+    _isl_saved_LDFLAGS=$LDFLAGS
+    _isl_saved_LIBS=$LIBS
+
+    CFLAGS="${_isl_saved_CFLAGS} ${islinc} ${gmpinc}"
+    LDFLAGS="${_isl_saved_LDFLAGS} ${isllibs}"
+    LIBS="${_isl_saved_LIBS} -lisl"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for version 0.14 of ISL" >&5
+$as_echo_n "checking for version 0.14 of ISL... " >&6; }
+    if test "$cross_compiling" = yes; then :
+  gcc_cv_isl=yes
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <isl/version.h>
+   #include <string.h>
+int
+main ()
+{
+if (strncmp (isl_version (), "isl-0.14", strlen ("isl-0.14")) != 0)
+     return 1;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  gcc_cv_isl=yes
+else
+  gcc_cv_isl=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_isl" >&5
+$as_echo "$gcc_cv_isl" >&6; }
+
+    CFLAGS=$_isl_saved_CFLAGS
+    LDFLAGS=$_isl_saved_LDFLAGS
+    LIBS=$_isl_saved_LIBS
+  fi
+
+
+      fi
     fi
   fi
 
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,83 @@
+2015-02-26  Matthew Fortune  <matthew.fortune@imgtec.com>
+
+	Backported from mainline r213870
+
+	* config/mips/mips16.S: Do not build for soft-float.
+
+2015-02-17  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Backported from mainline
+	2015-02-17  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* config/arm/bpabi.S (test_div_by_zero): Make label names
+	consistent between thumb2 and arm mode cases.  Separate the
+	signed comparison on the high word of the numerator from the
+	unsigned comparison on the low word.
+	* config/arm/bpabi-v6m.S (test_div_by_zero): Similarly separate
+	signed comparison.
+
+2015-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2015-01-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/cpuinfo.c (processor_subtypes): Add
+	INTEL_COREI7_BROADWELL.
+	(get_intel_cpu): Support new Silvermont, Haswell and Broadwell
+	model numbers.
+
+2015-01-31  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (__kernel_cmpxchg2): Change declaration of
+	oldval and newval to const void *.  Fix typo.
+	(FETCH_AND_OP_2): Use __atomic_load_n to load value.
+	(FETCH_AND_OP_WORD): Likewise.
+	(OP_AND_FETCH_WORD): Likewise.
+	(COMPARE_AND_SWAP_2): Likewise.
+	(__sync_val_compare_and_swap_4): Likewise.
+	(__sync_lock_test_and_set_4): Likewise.
+	(SYNC_LOCK_RELEASE_2): Likewise.
+	Remove support for long long atomic operations.
+
+2015-01-20  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	Backport from mainline
+	* config/nios2/linux-unwind.h (nios2_fallback_frame_state):
+	Update rt_sigframe format and address for current Nios II
+	Linux conventions.
+
+2014-12-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (ABORT_INSTRUCTION): Use __builtin_trap()
+	instead.
+
+	2014-11-21  Guy Martin  <gmsoft@tuxicoman.be>
+	            John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (__kernel_cmpxchg2): New.
+	(FETCH_AND_OP_2): New.  Use for subword and double word operations.
+	(OP_AND_FETCH_2): Likewise.
+	(COMPARE_AND_SWAP_2): Likewise.
+	(SYNC_LOCK_TEST_AND_SET_2): Likewise.
+	(SYNC_LOCK_RELEASE_2): Likewise.
+	(SUBWORD_SYNC_OP): Remove.
+	(SUBWORD_VAL_CAS): Likewise.
+	(SUBWORD_BOOL_CAS): Likewise.
+	(FETCH_AND_OP_WORD): Update.
+	Consistently use signed types.
+
+2014-12-09  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-30  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/55351
+	* config/sh/lib1funcs.S: Check value of __SHMEDIA__ instead of checking
+	whether it's defined.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libgcc/config/i386/cpuinfo.c
===================================================================
--- a/src/libgcc/config/i386/cpuinfo.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/i386/cpuinfo.c	(.../branches/gcc-4_9-branch)
@@ -75,6 +75,7 @@
   AMDFAM15H_BDVER4,
   INTEL_COREI7_IVYBRIDGE,
   INTEL_COREI7_HASWELL,
+  INTEL_COREI7_BROADWELL,
   CPU_SUBTYPE_MAX
 };
 
@@ -184,7 +185,10 @@
 	      __cpu_model.__cpu_type = INTEL_BONNELL;
 	      break;
 	    case 0x37:
+	    case 0x4a:
 	    case 0x4d:
+	    case 0x5a:
+	    case 0x5d:
 	      /* Silvermont.  */
 	      __cpu_model.__cpu_type = INTEL_SILVERMONT;
 	      break;
@@ -216,6 +220,7 @@
 	      __cpu_model.__cpu_subtype = INTEL_COREI7_IVYBRIDGE;
 	      break;
 	    case 0x3c:
+	    case 0x3f:
 	    case 0x45:
 	    case 0x46:
 	      /* Haswell.  */
@@ -222,6 +227,13 @@
 	      __cpu_model.__cpu_type = INTEL_COREI7;
 	      __cpu_model.__cpu_subtype = INTEL_COREI7_HASWELL;
 	      break;
+	    case 0x3d:
+	    case 0x4f:
+	    case 0x56:
+	      /* Broadwell.  */
+	      __cpu_model.__cpu_type = INTEL_COREI7;
+	      __cpu_model.__cpu_subtype = INTEL_COREI7_BROADWELL;
+	      break;
 	    case 0x17:
 	    case 0x1d:
 	      /* Penryn.  */
Index: libgcc/config/sh/lib1funcs.S
===================================================================
--- a/src/libgcc/config/sh/lib1funcs.S	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/sh/lib1funcs.S	(.../branches/gcc-4_9-branch)
@@ -1278,7 +1278,7 @@
 #endif
 	ENDFUNC(GLOBAL(sdivsi3_2))
 #endif
-#elif defined __SHMEDIA__
+#elif __SHMEDIA__
 /* m5compact-nofpu */
  // clobbered: r18,r19,r20,r21,r25,tr0,tr1,tr2
 	.mode	SHmedia
@@ -1683,7 +1683,7 @@
  add.l r18,r25,r0
  blink tr0,r63
 #endif
-#elif defined (__SHMEDIA__)
+#elif __SHMEDIA__
 /* m5compact-nofpu - more emphasis on code size than on speed, but don't
    ignore speed altogether - div1 needs 9 cycles, subc 7 and rotcl 4.
    So use a short shmedia loop.  */
@@ -1707,7 +1707,7 @@
  bnei r25,-32,tr1
  add.l r20,r63,r0
  blink tr2,r63
-#else /* ! defined (__SHMEDIA__) */
+#else /* ! __SHMEDIA__ */
 LOCAL(div8):
  div1 r5,r4
 LOCAL(div7):
@@ -1773,7 +1773,7 @@
 #endif /* L_udivsi3 */
 
 #ifdef L_udivdi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -1901,7 +1901,7 @@
 #endif /* L_udivdi3 */
 
 #ifdef L_divdi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -1925,7 +1925,7 @@
 #endif /* L_divdi3 */
 
 #ifdef L_umoddi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -2054,7 +2054,7 @@
 #endif /* L_umoddi3 */
 
 #ifdef L_moddi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -3142,7 +3142,7 @@
 
 #ifdef L_div_table
 #if __SH5__
-#if defined(__pic__) && defined(__SHMEDIA__)
+#if defined(__pic__) && __SHMEDIA__
 	.global	GLOBAL(sdivsi3)
 	FUNC(GLOBAL(sdivsi3))
 #if __SH5__ == 32
@@ -3215,7 +3215,7 @@
 #else /* ! __pic__ || ! __SHMEDIA__ */
 	.section	.rodata
 #endif /* __pic__ */
-#if defined(TEXT_DATA_BUG) && defined(__pic__) && defined(__SHMEDIA__)
+#if defined(TEXT_DATA_BUG) && defined(__pic__) && __SHMEDIA__
 	.balign 2
 	.type	Local_div_table,@object
 	.size	Local_div_table,128
Index: libgcc/config/arm/bpabi-v6m.S
===================================================================
--- a/src/libgcc/config/arm/bpabi-v6m.S	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/arm/bpabi-v6m.S	(.../branches/gcc-4_9-branch)
@@ -85,10 +85,10 @@
 	cmp	yyl, #0
 	bne	7f
 	cmp	xxh, #0
+	.ifc	\signed, unsigned
 	bne	2f
 	cmp	xxl, #0
 2:
-	.ifc	\signed, unsigned
 	beq	3f
 	mov	xxh, #0
 	mvn	xxh, xxh		@ 0xffffffff
@@ -95,9 +95,11 @@
 	mov	xxl, xxh
 3:
 	.else
+	blt	6f
+	bgt	4f
+	cmp	xxl, #0
 	beq	5f
-	blt	6f
-	mov	xxl, #0
+4:	mov	xxl, #0
 	mvn	xxl, xxl		@ 0xffffffff
 	lsr	xxh, xxl, #1		@ 0x7fffffff
 	b	5f
Index: libgcc/config/arm/bpabi.S
===================================================================
--- a/src/libgcc/config/arm/bpabi.S	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/arm/bpabi.S	(.../branches/gcc-4_9-branch)
@@ -78,26 +78,29 @@
 /* Tail-call to divide-by-zero handlers which may be overridden by the user,
    so unwinding works properly.  */
 #if defined(__thumb2__)
-	cbnz	yyh, 1f
-	cbnz	yyl, 1f
+	cbnz	yyh, 2f
+	cbnz	yyl, 2f
 	cmp	xxh, #0
+	.ifc \signed, unsigned
 	do_it	eq
 	cmpeq	xxl, #0
-	.ifc \signed, unsigned
-	beq	2f
-	mov	xxh, #0xffffffff
-	mov	xxl, xxh
-2:
+	do_it	ne, t
+	movne	xxh, #0xffffffff
+	movne	xxl, #0xffffffff
 	.else
-	do_it	lt, t
+	do_it	lt, tt
 	movlt	xxl, #0
 	movlt	xxh, #0x80000000
-	do_it	gt, t
-	movgt	xxh, #0x7fffffff
-	movgt	xxl, #0xffffffff
+	blt	1f
+	do_it	eq
+	cmpeq	xxl, #0
+	do_it	ne, t
+	movne	xxh, #0x7fffffff
+	movne	xxl, #0xffffffff
 	.endif
+1:	
 	b	SYM (__aeabi_ldiv0) __PLT__
-1:
+2:
 #else
 	/* Note: Thumb-1 code calls via an ARM shim on processors which
 	   support ARM mode.  */
@@ -105,16 +108,19 @@
 	cmpeq	yyl, #0
 	bne	2f
 	cmp	xxh, #0
+	.ifc \signed, unsigned
 	cmpeq	xxl, #0
-	.ifc \signed, unsigned
 	movne	xxh, #0xffffffff
 	movne	xxl, #0xffffffff
 	.else
 	movlt	xxh, #0x80000000
 	movlt	xxl, #0
-	movgt	xxh, #0x7fffffff
-	movgt	xxl, #0xffffffff
+	blt	1f
+	cmpeq	xxl, #0
+	movne	xxh, #0x7fffffff
+	movne	xxl, #0xffffffff
 	.endif
+1:
 	b	SYM (__aeabi_ldiv0) __PLT__
 2:
 #endif
Index: libgcc/config/pa/linux-atomic.c
===================================================================
--- a/src/libgcc/config/pa/linux-atomic.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/pa/linux-atomic.c	(.../branches/gcc-4_9-branch)
@@ -41,11 +41,8 @@
    using the kernel helper defined below.  There is no support for
    64-bit operations yet.  */
 
-/* A privileged instruction to crash a userspace program with SIGILL.  */
-#define ABORT_INSTRUCTION asm ("iitlbp %r0,(%sr0, %r0)")
-
 /* Determine kernel LWS function call (0=32-bit, 1=64-bit userspace).  */
-#define LWS_CAS (sizeof(unsigned long) == 4 ? 0 : 1)
+#define LWS_CAS (sizeof(long) == 4 ? 0 : 1)
 
 /* Kernel helper for compare-and-exchange a 32-bit value.  */
 static inline long
@@ -64,7 +61,7 @@
 	: "r1", "r20", "r22", "r23", "r29", "r31", "memory"
   );
   if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
-    ABORT_INSTRUCTION;
+    __builtin_trap ();
 
   /* If the kernel LWS call succeeded (lws_errno == 0), lws_ret contains
      the old value from memory.  If this value is equal to OLDVAL, the
@@ -75,6 +72,31 @@
   return lws_errno;
 }
 
+static inline long
+__kernel_cmpxchg2 (const void *oldval, const void *newval, void *mem,
+		   int val_size)
+{
+  register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
+  register long lws_ret   asm("r28");
+  register long lws_errno asm("r21");
+  register unsigned long lws_old asm("r25") = (unsigned long) oldval;
+  register unsigned long lws_new asm("r24") = (unsigned long) newval;
+  register int lws_size asm("r23") = val_size;
+  asm volatile (	"ble	0xb0(%%sr2, %%r0)	\n\t"
+			"ldi	%2, %%r20		\n\t"
+	: "=r" (lws_ret), "=r" (lws_errno)
+	: "i" (2), "r" (lws_mem), "r" (lws_old), "r" (lws_new), "r" (lws_size)
+	: "r1", "r20", "r22", "r29", "r31", "fr4", "memory"
+  );
+  if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
+    __builtin_trap ();
+
+  /* If the kernel LWS call fails, return EBUSY */
+  if (!lws_errno && lws_ret)
+    lws_errno = -EBUSY;
+
+  return lws_errno;
+}
 #define HIDDEN __attribute__ ((visibility ("hidden")))
 
 /* Big endian masks  */
@@ -84,69 +106,87 @@
 #define MASK_1 0xffu
 #define MASK_2 0xffffu
 
-#define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
-  int HIDDEN								\
-  __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
+#define FETCH_AND_OP_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
+  TYPE HIDDEN								\
+  __sync_fetch_and_##OP##_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
-    int failure, tmp;							\
+    TYPE tmp, newval;							\
+    int failure;							\
 									\
     do {								\
-      tmp = *ptr;							\
-      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);	\
+      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      newval = PFX_OP (tmp INF_OP val);					\
+      failure = __kernel_cmpxchg2 (&tmp, &newval, ptr, INDEX);		\
     } while (failure != 0);						\
 									\
     return tmp;								\
   }
 
-FETCH_AND_OP_WORD (add,   , +)
-FETCH_AND_OP_WORD (sub,   , -)
-FETCH_AND_OP_WORD (or,    , |)
-FETCH_AND_OP_WORD (and,   , &)
-FETCH_AND_OP_WORD (xor,   , ^)
-FETCH_AND_OP_WORD (nand, ~, &)
+FETCH_AND_OP_2 (add,   , +, short, 2, 1)
+FETCH_AND_OP_2 (sub,   , -, short, 2, 1)
+FETCH_AND_OP_2 (or,    , |, short, 2, 1)
+FETCH_AND_OP_2 (and,   , &, short, 2, 1)
+FETCH_AND_OP_2 (xor,   , ^, short, 2, 1)
+FETCH_AND_OP_2 (nand, ~, &, short, 2, 1)
 
-#define NAME_oldval(OP, WIDTH) __sync_fetch_and_##OP##_##WIDTH
-#define NAME_newval(OP, WIDTH) __sync_##OP##_and_fetch_##WIDTH
+FETCH_AND_OP_2 (add,   , +, signed char, 1, 0)
+FETCH_AND_OP_2 (sub,   , -, signed char, 1, 0)
+FETCH_AND_OP_2 (or,    , |, signed char, 1, 0)
+FETCH_AND_OP_2 (and,   , &, signed char, 1, 0)
+FETCH_AND_OP_2 (xor,   , ^, signed char, 1, 0)
+FETCH_AND_OP_2 (nand, ~, &, signed char, 1, 0)
 
-/* Implement both __sync_<op>_and_fetch and __sync_fetch_and_<op> for
-   subword-sized quantities.  */
-
-#define SUBWORD_SYNC_OP(OP, PFX_OP, INF_OP, TYPE, WIDTH, RETURN)	\
+#define OP_AND_FETCH_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
-  NAME##_##RETURN (OP, WIDTH) (TYPE *ptr, TYPE val)			\
+  __sync_##OP##_and_fetch_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
-    int *wordptr = (int *) ((unsigned long) ptr & ~3);			\
-    unsigned int mask, shift, oldval, newval;				\
+    TYPE tmp, newval;							\
     int failure;							\
 									\
-    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
-    mask = MASK_##WIDTH << shift;					\
+    do {								\
+      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      newval = PFX_OP (tmp INF_OP val);					\
+      failure = __kernel_cmpxchg2 (&tmp, &newval, ptr, INDEX);		\
+    } while (failure != 0);						\
 									\
+    return PFX_OP (tmp INF_OP val);					\
+  }
+
+OP_AND_FETCH_2 (add,   , +, short, 2, 1)
+OP_AND_FETCH_2 (sub,   , -, short, 2, 1)
+OP_AND_FETCH_2 (or,    , |, short, 2, 1)
+OP_AND_FETCH_2 (and,   , &, short, 2, 1)
+OP_AND_FETCH_2 (xor,   , ^, short, 2, 1)
+OP_AND_FETCH_2 (nand, ~, &, short, 2, 1)
+
+OP_AND_FETCH_2 (add,   , +, signed char, 1, 0)
+OP_AND_FETCH_2 (sub,   , -, signed char, 1, 0)
+OP_AND_FETCH_2 (or,    , |, signed char, 1, 0)
+OP_AND_FETCH_2 (and,   , &, signed char, 1, 0)
+OP_AND_FETCH_2 (xor,   , ^, signed char, 1, 0)
+OP_AND_FETCH_2 (nand, ~, &, signed char, 1, 0)
+
+#define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
+  int HIDDEN								\
+  __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
+  {									\
+    int failure, tmp;							\
+									\
     do {								\
-      oldval = *wordptr;						\
-      newval = ((PFX_OP (((oldval & mask) >> shift)			\
-                         INF_OP (unsigned int) val)) << shift) & mask;	\
-      newval |= oldval & ~mask;						\
-      failure = __kernel_cmpxchg (oldval, newval, wordptr);		\
+      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);	\
     } while (failure != 0);						\
 									\
-    return (RETURN & mask) >> shift;					\
+    return tmp;								\
   }
 
-SUBWORD_SYNC_OP (add,   , +, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (or,    , |, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (and,   , &, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, oldval)
+FETCH_AND_OP_WORD (add,   , +)
+FETCH_AND_OP_WORD (sub,   , -)
+FETCH_AND_OP_WORD (or,    , |)
+FETCH_AND_OP_WORD (and,   , &)
+FETCH_AND_OP_WORD (xor,   , ^)
+FETCH_AND_OP_WORD (nand, ~, &)
 
-SUBWORD_SYNC_OP (add,   , +, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (or,    , |, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (and,   , &, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, oldval)
-
 #define OP_AND_FETCH_WORD(OP, PFX_OP, INF_OP)				\
   int HIDDEN								\
   __sync_##OP##_and_fetch_4 (int *ptr, int val)				\
@@ -154,7 +194,7 @@
     int tmp, failure;							\
 									\
     do {								\
-      tmp = *ptr;							\
+      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
       failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);	\
     } while (failure != 0);						\
 									\
@@ -168,20 +208,41 @@
 OP_AND_FETCH_WORD (xor,   , ^)
 OP_AND_FETCH_WORD (nand, ~, &)
 
-SUBWORD_SYNC_OP (add,   , +, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (or,    , |, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (and,   , &, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, newval)
+typedef unsigned char bool;
 
-SUBWORD_SYNC_OP (add,   , +, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (or,    , |, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (and,   , &, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, newval)
+#define COMPARE_AND_SWAP_2(TYPE, WIDTH, INDEX)				\
+  TYPE HIDDEN								\
+  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
+				       TYPE newval)			\
+  {									\
+    TYPE actual_oldval;							\
+    int fail;								\
+									\
+    while (1)								\
+      {									\
+	actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);	\
+									\
+	if (__builtin_expect (oldval != actual_oldval, 0))		\
+	  return actual_oldval;						\
+									\
+	fail = __kernel_cmpxchg2 (&actual_oldval, &newval, ptr, INDEX);	\
+									\
+	if (__builtin_expect (!fail, 1))				\
+	  return actual_oldval;						\
+      }									\
+  }									\
+									\
+  bool HIDDEN								\
+  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
+					TYPE newval)			\
+  {									\
+    int failure = __kernel_cmpxchg2 (&oldval, &newval, ptr, INDEX);	\
+    return (failure != 0);						\
+  }
 
+COMPARE_AND_SWAP_2 (short, 2, 1)
+COMPARE_AND_SWAP_2 (char, 1, 0)
+
 int HIDDEN
 __sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
@@ -189,7 +250,7 @@
     
   while (1)
     {
-      actual_oldval = *ptr;
+      actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
 
       if (__builtin_expect (oldval != actual_oldval, 0))
 	return actual_oldval;
@@ -201,41 +262,6 @@
     }
 }
 
-#define SUBWORD_VAL_CAS(TYPE, WIDTH)					\
-  TYPE HIDDEN								\
-  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
-				       TYPE newval)			\
-  {									\
-    int *wordptr = (int *)((unsigned long) ptr & ~3), fail;		\
-    unsigned int mask, shift, actual_oldval, actual_newval;		\
-									\
-    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
-    mask = MASK_##WIDTH << shift;					\
-									\
-    while (1)								\
-      {									\
-	actual_oldval = *wordptr;					\
-									\
-	if (__builtin_expect (((actual_oldval & mask) >> shift)		\
-			      != (unsigned int) oldval, 0))		\
-	  return (actual_oldval & mask) >> shift;			\
-									\
-	actual_newval = (actual_oldval & ~mask)				\
-			| (((unsigned int) newval << shift) & mask);	\
-									\
-	fail = __kernel_cmpxchg (actual_oldval, actual_newval,		\
-				 wordptr);				\
-									\
-	if (__builtin_expect (!fail, 1))				\
-	  return (actual_oldval & mask) >> shift;			\
-      }									\
-  }
-
-SUBWORD_VAL_CAS (unsigned short, 2)
-SUBWORD_VAL_CAS (unsigned char,  1)
-
-typedef unsigned char bool;
-
 bool HIDDEN
 __sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
@@ -243,18 +269,23 @@
   return (failure == 0);
 }
 
-#define SUBWORD_BOOL_CAS(TYPE, WIDTH)					\
-  bool HIDDEN								\
-  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
-					TYPE newval)			\
+#define SYNC_LOCK_TEST_AND_SET_2(TYPE, WIDTH, INDEX)			\
+TYPE HIDDEN								\
+  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
   {									\
-    TYPE actual_oldval							\
-      = __sync_val_compare_and_swap_##WIDTH (ptr, oldval, newval);	\
-    return (oldval == actual_oldval);					\
+    TYPE oldval;							\
+    int failure;							\
+									\
+    do {								\
+      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      failure = __kernel_cmpxchg2 (&oldval, &val, ptr, INDEX);		\
+    } while (failure != 0);						\
+									\
+    return oldval;							\
   }
 
-SUBWORD_BOOL_CAS (unsigned short, 2)
-SUBWORD_BOOL_CAS (unsigned char,  1)
+SYNC_LOCK_TEST_AND_SET_2 (short, 2, 1)
+SYNC_LOCK_TEST_AND_SET_2 (signed char, 1, 0)
 
 int HIDDEN
 __sync_lock_test_and_set_4 (int *ptr, int val)
@@ -262,7 +293,7 @@
   int failure, oldval;
 
   do {
-    oldval = *ptr;
+    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
     failure = __kernel_cmpxchg (oldval, val, ptr);
   } while (failure != 0);
 
@@ -269,37 +300,28 @@
   return oldval;
 }
 
-#define SUBWORD_TEST_AND_SET(TYPE, WIDTH)				\
-  TYPE HIDDEN								\
-  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
-  {									\
-    int failure;							\
-    unsigned int oldval, newval, shift, mask;				\
-    int *wordptr = (int *) ((unsigned long) ptr & ~3);			\
-									\
-    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
-    mask = MASK_##WIDTH << shift;					\
-									\
-    do {								\
-      oldval = *wordptr;						\
-      newval = (oldval & ~mask)						\
-	       | (((unsigned int) val << shift) & mask);		\
-      failure = __kernel_cmpxchg (oldval, newval, wordptr);		\
-    } while (failure != 0);						\
-									\
-    return (oldval & mask) >> shift;					\
+#define SYNC_LOCK_RELEASE_2(TYPE, WIDTH, INDEX)			\
+  void HIDDEN							\
+  __sync_lock_release_##WIDTH (TYPE *ptr)			\
+  {								\
+    TYPE failure, oldval, zero = 0;				\
+								\
+    do {							\
+      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);		\
+      failure = __kernel_cmpxchg2 (&oldval, &zero, ptr, INDEX);	\
+    } while (failure != 0);					\
   }
 
-SUBWORD_TEST_AND_SET (unsigned short, 2)
-SUBWORD_TEST_AND_SET (unsigned char,  1)
+SYNC_LOCK_RELEASE_2 (short, 2, 1)
+SYNC_LOCK_RELEASE_2 (signed char, 1, 0)
 
-#define SYNC_LOCK_RELEASE(TYPE, WIDTH)					\
-  void HIDDEN								\
-  __sync_lock_release_##WIDTH (TYPE *ptr)				\
-  {									\
-    *ptr = 0;								\
-  }
+void HIDDEN
+__sync_lock_release_4 (int *ptr)
+{
+  int failure, oldval;
 
-SYNC_LOCK_RELEASE (int,   4)
-SYNC_LOCK_RELEASE (short, 2)
-SYNC_LOCK_RELEASE (char,  1)
+  do {
+    oldval = *ptr;
+    failure = __kernel_cmpxchg (oldval, 0, ptr);
+  } while (failure != 0);
+}
Index: libgcc/config/mips/mips16.S
===================================================================
--- a/src/libgcc/config/mips/mips16.S	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/mips/mips16.S	(.../branches/gcc-4_9-branch)
@@ -21,8 +21,12 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
-#ifdef __mips_micromips
-  /* DO NOTHING */
+#if defined(__mips_micromips) || defined(__mips_soft_float)
+  /* Do nothing because this code is only needed when linking
+     against mips16 hard-float objects.  Neither micromips code
+     nor soft-float code can be linked against mips16 hard-float
+     objects so we do not need these routines when building libgcc
+     for those cases.  */
 #else
 
 /* This file contains mips16 floating point support functions.  These
@@ -749,4 +753,4 @@
 #endif /* !__mips_single_float */
 
 #endif
-#endif /* __mips_micromips */
+#endif /* defined(__mips_micromips) || defined(__mips_soft_float) */
Index: libgcc/config/nios2/linux-unwind.h
===================================================================
--- a/src/libgcc/config/nios2/linux-unwind.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/nios2/linux-unwind.h	(.../branches/gcc-4_9-branch)
@@ -67,10 +67,9 @@
   if (pc[0] == (0x00800004 | (__NR_rt_sigreturn << 6)))
     {
       struct rt_sigframe {
-	char retcode[12];
 	siginfo_t info;
 	struct nios2_ucontext uc;
-      } *rt_ = context->ra;
+      } *rt_ = context->cfa;
       struct nios2_mcontext *regs = &rt_->uc.uc_mcontext;
       int i;
 
Index: gcc/tree-vrp.c
===================================================================
--- a/src/gcc/tree-vrp.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vrp.c	(.../branches/gcc-4_9-branch)
@@ -7172,7 +7172,7 @@
       tree type = TREE_TYPE (op0);
       value_range_t *vr0 = get_value_range (op0);
 
-      if (vr0->type != VR_VARYING
+      if (vr0->type == VR_RANGE
 	  && INTEGRAL_TYPE_P (type)
 	  && vrp_val_is_min (vr0->min)
 	  && vrp_val_is_max (vr0->max)
@@ -9377,8 +9377,10 @@
     }
   else
     {
-      tree r1 = int_const_binop (subcode, vr0.min, vr1.min);
-      tree r2 = int_const_binop (subcode, vr0.max, vr1.max);
+      tree r1 = int_const_binop (subcode, vr0.min,
+				 subcode == MINUS_EXPR ? vr1.max : vr1.min);
+      tree r2 = int_const_binop (subcode, vr0.max,
+				 subcode == MINUS_EXPR ? vr1.min : vr1.max);
       if (r1 == NULL_TREE || TREE_OVERFLOW (r1)
 	  || r2 == NULL_TREE || TREE_OVERFLOW (r2))
 	return false;
@@ -9728,7 +9730,7 @@
   substitute_and_fold (op_with_constant_singleton_value_range,
 		       vrp_fold_stmt, false);
 
-  if (warn_array_bounds)
+  if (warn_array_bounds && first_pass_instance)
     check_all_array_refs ();
 
   /* We must identify jump threading opportunities before we release
Index: gcc/tree-ssa-tail-merge.c
===================================================================
--- a/src/gcc/tree-ssa-tail-merge.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-tail-merge.c	(.../branches/gcc-4_9-branch)
@@ -314,7 +314,8 @@
 
   if (gimple_vdef (stmt) != NULL_TREE
       || gimple_has_side_effects (stmt)
-      || gimple_could_trap_p_1 (stmt, false, false))
+      || gimple_could_trap_p_1 (stmt, false, false)
+      || gimple_vuse (stmt) != NULL_TREE)
     return false;
 
   def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);
@@ -569,7 +570,7 @@
   if (!inverse_flags (e1, e2))
     {
       for (i = 0; i < e1->succ_flags.length (); ++i)
-	if (e1->succ_flags[i] != e1->succ_flags[i])
+	if (e1->succ_flags[i] != e2->succ_flags[i])
 	  return 0;
     }
 
@@ -1164,7 +1165,8 @@
 						 gimple_assign_rhs1 (s2)));
       else if (TREE_CODE (lhs1) == SSA_NAME
 	       && TREE_CODE (lhs2) == SSA_NAME)
-	return vn_valueize (lhs1) == vn_valueize (lhs2);
+	return operand_equal_p (gimple_assign_rhs1 (s1),
+				gimple_assign_rhs1 (s2), 0);
       return false;
 
     case GIMPLE_COND:
Index: gcc/c-family/c-opts.c
===================================================================
--- a/src/gcc/c-family/c-opts.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c-family/c-opts.c	(.../branches/gcc-4_9-branch)
@@ -1363,6 +1363,12 @@
 static void
 push_command_line_include (void)
 {
+  /* This can happen if disabled by -imacros for example.
+     Punt so that we don't set "<command-line>" as the filename for
+     the header.  */
+  if (include_cursor > deferred_count)
+    return;
+
   if (!done_preinclude)
     {
       done_preinclude = true;
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,45 @@
+2015-03-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/other/dump-ada-spec-3.C: Remove include and adjust.
+
+2015-03-06  Eric Botcazou  <ebotcazou@adacore.com>
+            Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	* c-ada-spec.c (dump_ada_double_name): Fix pasto.
+
+2015-03-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/65319
+	* c-ada-spec.c (print_destructor): Remove obsolete code.
+
+2015-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64824
+	PR c/64868
+	* c-omp.c (c_finish_omp_atomic): Use TRUNC_DIV_EXPR
+	instead of RDIV_EXPR.  Use build_binary_op instead of
+	build2_loc.
+
+2015-02-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-24  Marek Polacek  <polacek@redhat.com>
+
+	PR c/57653
+	* c-opts.c (c_finish_options): If -imacros is in effect, return.
+
+2015-01-20  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-06-23  Marek Polacek  <polacek@redhat.com>
+
+	PR c/61553
+	* c-common.c (get_atomic_generic_size): Don't segfault if the
+	type doesn't have a size.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/c-family/c-common.c
===================================================================
--- a/src/gcc/c-family/c-common.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c-family/c-common.c	(.../branches/gcc-4_9-branch)
@@ -10402,7 +10402,8 @@
 		    function);
 	  return 0;
 	}
-      size = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));
+      tree type_size = TYPE_SIZE_UNIT (TREE_TYPE (type));
+      size = type_size ? tree_to_uhwi (type_size) : 0;
       if (size != size_0)
 	{
 	  error_at (loc, "size mismatch in argument %d of %qE", x + 1,
Index: gcc/c-family/c-omp.c
===================================================================
--- a/src/gcc/c-family/c-omp.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c-family/c-omp.c	(.../branches/gcc-4_9-branch)
@@ -156,6 +156,9 @@
       return error_mark_node;
     }
 
+  if (opcode == RDIV_EXPR)
+    opcode = TRUNC_DIV_EXPR;
+
   /* ??? Validate that rhs does not overlap lhs.  */
 
   /* Take and save the address of the lhs.  From then on we'll reference it
@@ -190,7 +193,7 @@
      to do this, and then take it apart again.  */
   if (swapped)
     {
-      rhs = build2_loc (loc, opcode, TREE_TYPE (lhs), rhs, lhs);
+      rhs = build_binary_op (loc, opcode, rhs, lhs, 1);
       opcode = NOP_EXPR;
     }
   bool save = in_late_binary_op;
Index: gcc/c-family/c-ubsan.c
===================================================================
--- a/src/gcc/c-family/c-ubsan.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c-family/c-ubsan.c	(.../branches/gcc-4_9-branch)
@@ -98,19 +98,19 @@
   tree op1_utype = unsigned_type_for (type1);
   HOST_WIDE_INT op0_prec = TYPE_PRECISION (type0);
   tree uprecm1 = build_int_cst (op1_utype, op0_prec - 1);
-  tree precm1 = build_int_cst (type1, op0_prec - 1);
 
   t = fold_convert_loc (loc, op1_utype, op1);
   t = fold_build2 (GT_EXPR, boolean_type_node, t, uprecm1);
 
   /* For signed x << y, in C99/C11, the following:
-     (unsigned) x >> (precm1 - y)
+     (unsigned) x >> (uprecm1 - y)
      if non-zero, is undefined.  */
   if (code == LSHIFT_EXPR
       && !TYPE_UNSIGNED (type0)
       && flag_isoc99)
     {
-      tree x = fold_build2 (MINUS_EXPR, integer_type_node, precm1, op1);
+      tree x = fold_build2 (MINUS_EXPR, unsigned_type_node, uprecm1,
+			    fold_convert (op1_utype, op1));
       tt = fold_convert_loc (loc, unsigned_type_for (type0), op0);
       tt = fold_build2 (RSHIFT_EXPR, TREE_TYPE (tt), tt, x);
       tt = fold_build2 (NE_EXPR, boolean_type_node, tt,
@@ -118,13 +118,14 @@
     }
 
   /* For signed x << y, in C++11/C++14, the following:
-     x < 0 || ((unsigned) x >> (precm1 - y))
+     x < 0 || ((unsigned) x >> (uprecm1 - y))
      if > 1, is undefined.  */
   if (code == LSHIFT_EXPR
       && !TYPE_UNSIGNED (TREE_TYPE (op0))
       && (cxx_dialect == cxx11 || cxx_dialect == cxx1y))
     {
-      tree x = fold_build2 (MINUS_EXPR, integer_type_node, precm1, op1);
+      tree x = fold_build2 (MINUS_EXPR, unsigned_type_node, uprecm1,
+			    fold_convert (op1_utype, op1));
       tt = fold_convert_loc (loc, unsigned_type_for (type0), op0);
       tt = fold_build2 (RSHIFT_EXPR, TREE_TYPE (tt), tt, x);
       tt = fold_build2 (GT_EXPR, boolean_type_node, tt,
Index: gcc/c-family/c-ada-spec.c
===================================================================
--- a/src/gcc/c-family/c-ada-spec.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c-family/c-ada-spec.c	(.../branches/gcc-4_9-branch)
@@ -1392,7 +1392,7 @@
 
   pp_underscore (buffer);
 
-  if (DECL_NAME (t1))
+  if (DECL_NAME (t2))
     pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, false);
   else
     {
@@ -2538,18 +2538,9 @@
 print_destructor (pretty_printer *buffer, tree t)
 {
   tree decl_name = DECL_NAME (DECL_ORIGIN (t));
-  const char *s = IDENTIFIER_POINTER (decl_name);
 
-  if (*s == '_')
-    {
-      for (s += 2; *s != ' '; s++)
-	pp_character (buffer, *s);
-    }
-  else
-    {
-      pp_string (buffer, "Delete_");
-      pp_ada_tree_identifier (buffer, decl_name, t, false);
-    }
+  pp_string (buffer, "Delete_");
+  pp_ada_tree_identifier (buffer, decl_name, t, false);
 }
 
 /* Return the name of type T.  */
Index: gcc/tree-loop-distribution.c
===================================================================
--- a/src/gcc/tree-loop-distribution.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-loop-distribution.c	(.../branches/gcc-4_9-branch)
@@ -1342,6 +1342,7 @@
   for (int ii = 0; drs1.iterate (ii, &dr1); ++ii)
     for (int jj = 0; drs2.iterate (jj, &dr2); ++jj)
       {
+	data_reference_p saved_dr1 = dr1;
 	int this_dir = 1;
 	ddr_p ddr;
 	/* Re-shuffle data-refs to be in dominator order.  */
@@ -1387,6 +1388,8 @@
 	  dir = this_dir;
 	else if (dir != this_dir)
 	  return 2;
+	/* Shuffle "back" dr1.  */
+	dr1 = saved_dr1;
       }
   return dir;
 }
Index: gcc/c/ChangeLog
===================================================================
--- a/src/gcc/c/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,39 @@
+2015-02-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2015-02-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c/65228
+	* c-decl.c (start_decl): Return NULL_TREE if decl is an error node.
+
+2015-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64824
+	* c-parser.c (c_parser_binary_expression): Fix OpenMP stack[sp].prec
+	check in the POP macro.
+
+	Backported from mainline
+	2015-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64824
+	PR c/64868
+	* c-parser.c (c_parser_omp_atomic): Handle RDIV_EXPR.
+
+2015-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64766
+	* c-typeck.c (store_init_value): Don't overwrite DECL_INITIAL
+	of FUNCTION_DECLs with error_mark_node.
+
+	2015-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64778
+	* c-typeck.c (convert_arguments): Return -1 if there are
+	error_args, even if we've diagnosed too many arguments.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/c/c-parser.c
===================================================================
--- a/src/gcc/c/c-parser.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c/c-parser.c	(.../branches/gcc-4_9-branch)
@@ -6103,8 +6103,8 @@
     if (__builtin_expect (omp_atomic_lhs != NULL_TREE, 0) && sp == 1	      \
 	&& c_parser_peek_token (parser)->type == CPP_SEMICOLON		      \
 	&& ((1 << stack[sp].prec)					      \
-	    & (1 << (PREC_BITOR | PREC_BITXOR | PREC_BITAND | PREC_SHIFT      \
-		     | PREC_ADD | PREC_MULT)))				      \
+	    & ((1 << PREC_BITOR) | (1 << PREC_BITXOR) | (1 << PREC_BITAND)    \
+	       | (1 << PREC_SHIFT) | (1 << PREC_ADD) | (1 << PREC_MULT)))     \
 	&& stack[sp].op != TRUNC_MOD_EXPR				      \
 	&& stack[0].expr.value != error_mark_node			      \
 	&& stack[1].expr.value != error_mark_node			      \
@@ -11423,6 +11423,7 @@
 	    {
 	    case MULT_EXPR:
 	    case TRUNC_DIV_EXPR:
+	    case RDIV_EXPR:
 	    case PLUS_EXPR:
 	    case MINUS_EXPR:
 	    case LSHIFT_EXPR:
Index: gcc/c/c-typeck.c
===================================================================
--- a/src/gcc/c/c-typeck.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c/c-typeck.c	(.../branches/gcc-4_9-branch)
@@ -3085,7 +3085,7 @@
 	  else
 	    error_at (loc, "too many arguments to function %qE", function);
 	  inform_declaration (fundecl);
-	  return parmnum;
+	  return error_args ? -1 : (int) parmnum;
 	}
 
       if (selector && argnum > 2)
@@ -6249,7 +6249,8 @@
     warning (OPT_Wtraditional, "traditional C rejects automatic "
 	     "aggregate initialization");
 
-  DECL_INITIAL (decl) = value;
+  if (value != error_mark_node || TREE_CODE (decl) != FUNCTION_DECL)
+    DECL_INITIAL (decl) = value;
 
   /* ANSI wants warnings about out-of-range constant initializers.  */
   STRIP_TYPE_NOPS (value);
Index: gcc/c/c-decl.c
===================================================================
--- a/src/gcc/c/c-decl.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c/c-decl.c	(.../branches/gcc-4_9-branch)
@@ -4067,8 +4067,8 @@
   decl = grokdeclarator (declarator, declspecs,
 			 NORMAL, initialized, NULL, &attributes, &expr, NULL,
 			 deprecated_state);
-  if (!decl)
-    return 0;
+  if (!decl || decl == error_mark_node)
+    return NULL_TREE;
 
   if (expr)
     add_stmt (fold_convert (void_type_node, expr));
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-4_9-branch)
@@ -1 +1 @@
-20141030
+20150327
Index: gcc/tree-ssa-strlen.c
===================================================================
--- a/src/gcc/tree-ssa-strlen.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-strlen.c	(.../branches/gcc-4_9-branch)
@@ -1856,7 +1856,7 @@
 	    break;
 	  }
     }
-  else if (is_gimple_assign (stmt))
+  else if (is_gimple_assign (stmt) && !gimple_clobber_p (stmt))
     {
       tree lhs = gimple_assign_lhs (stmt);
 
Index: gcc/tree.c
===================================================================
--- a/src/gcc/tree.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree.c	(.../branches/gcc-4_9-branch)
@@ -1120,7 +1120,7 @@
   const_tree const t = (const_tree) x;
 
   return (TREE_INT_CST_HIGH (t) ^ TREE_INT_CST_LOW (t)
-	  ^ htab_hash_pointer (TREE_TYPE (t)));
+	  ^ TYPE_UID (TREE_TYPE (t)));
 }
 
 /* Return nonzero if the value represented by *X (an INTEGER_CST tree node)
@@ -6215,8 +6215,11 @@
       else if (TYPE_CANONICAL (type) != type)
 	/* Build the underlying canonical type, since it is different
 	   from TYPE. */
-	TYPE_CANONICAL (t) = build_qualified_type (TYPE_CANONICAL (type),
-						   type_quals);
+	{
+	  tree c = build_qualified_type (TYPE_CANONICAL (type),
+					 type_quals);
+	  TYPE_CANONICAL (t) = TYPE_CANONICAL (c);
+	}
       else
 	/* T is its own canonical type. */
 	TYPE_CANONICAL (t) = t;
Index: gcc/reload.c
===================================================================
--- a/src/gcc/reload.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/reload.c	(.../branches/gcc-4_9-branch)
@@ -1622,6 +1622,7 @@
 					       end_hard_regno (rel_mode,
 							       regno),
 					       PATTERN (this_insn), inloc)
+	    && ! find_reg_fusage (this_insn, USE, XEXP (note, 0))
 	    /* If this is also an output reload, IN cannot be used as
 	       the reload register if it is set in this insn unless IN
 	       is also OUT.  */
Index: gcc/rtlanal.c
===================================================================
--- a/src/gcc/rtlanal.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/rtlanal.c	(.../branches/gcc-4_9-branch)
@@ -873,6 +873,17 @@
 int
 reg_set_p (const_rtx reg, const_rtx insn)
 {
+  /* After delay slot handling, call and branch insns might be in a
+     sequence.  Check all the elements there.  */
+  if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)
+    {
+      for (int i = 0; i < XVECLEN (PATTERN (insn), 0); ++i)
+	if (reg_set_p (reg, XVECEXP (PATTERN (insn), 0, i)))
+	  return true;
+
+      return false;
+    }
+
   /* We can be passed an insn or part of one.  If we are passed an insn,
      check if a side-effect of the insn clobbers REG.  */
   if (INSN_P (insn)
@@ -884,7 +895,7 @@
 					       GET_MODE (reg), REGNO (reg)))
 		  || MEM_P (reg)
 		  || find_reg_fusage (insn, CLOBBER, reg)))))
-    return 1;
+    return true;
 
   return set_of (reg, insn) != NULL_RTX;
 }
Index: gcc/configure
===================================================================
--- a/src/gcc/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/configure	(.../branches/gcc-4_9-branch)
@@ -24158,6 +24158,39 @@
 fi
     ;;
 
+  avr-*-*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for -mrmw option" >&5
+$as_echo_n "checking assembler for -mrmw option... " >&6; }
+if test "${gcc_cv_as_avr_mrmw+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_avr_mrmw=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.text' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -mrmw -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_avr_mrmw=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_avr_mrmw" >&5
+$as_echo "$gcc_cv_as_avr_mrmw" >&6; }
+if test $gcc_cv_as_avr_mrmw = yes; then
+
+$as_echo "#define HAVE_AS_AVR_MRMW_OPTION 1" >>confdefs.h
+
+fi
+    ;;
+
   sparc*-*-*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for .register" >&5
 $as_echo_n "checking assembler for .register... " >&6; }
@@ -26140,6 +26173,38 @@
 
 fi
 
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for .module support" >&5
+$as_echo_n "checking assembler for .module support... " >&6; }
+if test "${gcc_cv_as_mips_dot_module+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_mips_dot_module=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.module mips2
+       .module fp=xx' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -32 -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_mips_dot_module=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_mips_dot_module" >&5
+$as_echo "$gcc_cv_as_mips_dot_module" >&6; }
+if test $gcc_cv_as_mips_dot_module = yes; then
+
+$as_echo "#define HAVE_AS_DOT_MODULE 1" >>confdefs.h
+
+fi
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for .micromips support" >&5
 $as_echo_n "checking assembler for .micromips support... " >&6; }
 if test "${gcc_cv_as_micromips_support+set}" = set; then :
@@ -27851,8 +27916,48 @@
 
 $as_echo "#define HAVE_cloog 1" >>confdefs.h
 
+
+  # Check whether isl_schedule_constraints_compute_schedule is available;
+  # it's new in ISL-0.13.
+  saved_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS $ISLINC"
+  saved_LIBS="$LIBS"
+  LIBS="$LIBS $CLOOGLIBS $ISLLIBS $GMPLIBS"
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking Checking for isl_schedule_constraints_compute_schedule" >&5
+$as_echo_n "checking Checking for isl_schedule_constraints_compute_schedule... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <isl/schedule.h>
+int
+main ()
+{
+isl_schedule_constraints_compute_schedule (NULL);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_has_isl_schedule_constraints_compute_schedule=yes
+else
+  ac_has_isl_schedule_constraints_compute_schedule=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_schedule_constraints_compute_schedule" >&5
+$as_echo "$ac_has_isl_schedule_constraints_compute_schedule" >&6; }
 
+  LIBS="$saved_LIBS"
+  CFLAGS="$saved_CFLAGS"
+
+  if test x"$ac_has_isl_schedule_constraints_compute_schedule" = x"yes"; then
+
+$as_echo "#define HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE 1" >>confdefs.h
+
+  fi
+fi
+
+
 # Check for plugin support
 # Check whether --enable-plugin was given.
 if test "${enable_plugin+set}" = set; then :
Index: gcc/builtins.c
===================================================================
--- a/src/gcc/builtins.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/builtins.c	(.../branches/gcc-4_9-branch)
@@ -369,13 +369,15 @@
       tree addr = TREE_OPERAND (exp, 0);
       unsigned ptr_align;
       unsigned HOST_WIDE_INT ptr_bitpos;
+      unsigned HOST_WIDE_INT ptr_bitmask = ~0;
 
+      /* If the address is explicitely aligned, handle that.  */
       if (TREE_CODE (addr) == BIT_AND_EXPR
 	  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)
 	{
-	  align = (TREE_INT_CST_LOW (TREE_OPERAND (addr, 1))
-		    & -TREE_INT_CST_LOW (TREE_OPERAND (addr, 1)));
-	  align *= BITS_PER_UNIT;
+	  ptr_bitmask = TREE_INT_CST_LOW (TREE_OPERAND (addr, 1));
+	  ptr_bitmask *= BITS_PER_UNIT;
+	  align = ptr_bitmask & -ptr_bitmask;
 	  addr = TREE_OPERAND (addr, 0);
 	}
 
@@ -383,6 +385,9 @@
 	= get_pointer_alignment_1 (addr, &ptr_align, &ptr_bitpos);
       align = MAX (ptr_align, align);
 
+      /* Re-apply explicit alignment to the bitpos.  */
+      ptr_bitpos &= ptr_bitmask;
+
       /* The alignment of the pointer operand in a TARGET_MEM_REF
 	 has to take the variable offset parts into account.  */
       if (TREE_CODE (exp) == TARGET_MEM_REF)
Index: gcc/fold-const.c
===================================================================
--- a/src/gcc/fold-const.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fold-const.c	(.../branches/gcc-4_9-branch)
@@ -8324,9 +8324,14 @@
 		    && integer_onep (TREE_OPERAND (arg0, 1)))
 		   || (TREE_CODE (arg0) == PLUS_EXPR
 		       && integer_all_onesp (TREE_OPERAND (arg0, 1)))))
-	return fold_build1_loc (loc, NEGATE_EXPR, type,
-			    fold_convert_loc (loc, type,
-					      TREE_OPERAND (arg0, 0)));
+	{
+	  /* Perform the negation in ARG0's type and only then convert
+	     to TYPE as to avoid introducing undefined behavior.  */
+	  tree t = fold_build1_loc (loc, NEGATE_EXPR,
+				    TREE_TYPE (TREE_OPERAND (arg0, 0)),
+				    TREE_OPERAND (arg0, 0));
+	  return fold_convert_loc (loc, type, t);
+	}
       /* Convert ~(X ^ Y) to ~X ^ Y or X ^ ~Y if ~X or ~Y simplify.  */
       else if (TREE_CODE (arg0) == BIT_XOR_EXPR
 	       && (tem = fold_unary_loc (loc, BIT_NOT_EXPR, type,
@@ -9024,7 +9029,8 @@
       /* If the constant operation overflowed this can be
 	 simplified as a comparison against INT_MAX/INT_MIN.  */
       if (TREE_CODE (lhs) == INTEGER_CST
-	  && TREE_OVERFLOW (lhs))
+	  && TREE_OVERFLOW (lhs)
+	  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0)))
 	{
 	  int const1_sgn = tree_int_cst_sgn (const1);
 	  enum tree_code code2 = code;
@@ -10810,8 +10816,8 @@
 
 	      /* Don't introduce overflows through reassociation.  */
 	      if (!any_overflows
-		  && ((lit0 && TREE_OVERFLOW (lit0))
-		      || (minus_lit0 && TREE_OVERFLOW (minus_lit0))))
+		  && ((lit0 && TREE_OVERFLOW_P (lit0))
+		      || (minus_lit0 && TREE_OVERFLOW_P (minus_lit0))))
 		return NULL_TREE;
 
 	      if (minus_lit0)
@@ -13295,7 +13301,7 @@
 	  tree itype = TREE_TYPE (arg00);
 	  if (TREE_INT_CST_HIGH (arg01) == 0
 	      && TREE_INT_CST_LOW (arg01)
-		 == (unsigned HOST_WIDE_INT) (TYPE_PRECISION (itype) - 1))
+		 == (unsigned HOST_WIDE_INT) (element_precision (itype) - 1))
 	    {
 	      if (TYPE_UNSIGNED (itype))
 		{
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-4_9-branch)
@@ -1483,7 +1483,8 @@
       layout_type (type);
     }
 
-  TREE_TYPE (ctx->receiver_decl) = build_pointer_type (type);
+  TREE_TYPE (ctx->receiver_decl)
+    = build_qualified_type (build_reference_type (type), TYPE_QUAL_RESTRICT);
 }
 
 /* Instantiate decls as necessary in CTX to satisfy the data sharing
@@ -1633,7 +1634,8 @@
 		 #pragma omp target data, there is nothing to map for
 		 those.  */
 	      if (gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_DATA
-		  && !POINTER_TYPE_P (TREE_TYPE (decl)))
+		  && !POINTER_TYPE_P (TREE_TYPE (decl))
+		  && !OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c))
 		break;
 	    }
 	  if (DECL_P (decl))
@@ -11105,9 +11107,11 @@
     }
 
   pp_underscore (&pp);
-  pp_string (&pp,
-	     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));
-  const char *str = pp_formatted_text (&pp);
+  const char *str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl));
+  if (*str == '*')
+    ++str;
+  pp_string (&pp, str);
+  str = pp_formatted_text (&pp);
 
   /* If there already is a SIMD clone with the same mangled name, don't
      add another one.  This can happen e.g. for
@@ -11181,24 +11185,24 @@
   if (orig_rettype == void_type_node)
     return NULL_TREE;
   TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));
-  if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl)))
-      || POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl))))
+  t = TREE_TYPE (TREE_TYPE (fndecl));
+  if (INTEGRAL_TYPE_P (t) || POINTER_TYPE_P (t))
     veclen = node->simdclone->vecsize_int;
   else
     veclen = node->simdclone->vecsize_float;
-  veclen /= GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))));
+  veclen /= GET_MODE_BITSIZE (TYPE_MODE (t));
   if (veclen > node->simdclone->simdlen)
     veclen = node->simdclone->simdlen;
+  if (POINTER_TYPE_P (t))
+    t = pointer_sized_int_node;
   if (veclen == node->simdclone->simdlen)
-    TREE_TYPE (TREE_TYPE (fndecl))
-      = build_vector_type (TREE_TYPE (TREE_TYPE (fndecl)),
-			   node->simdclone->simdlen);
+    t = build_vector_type (t, node->simdclone->simdlen);
   else
     {
-      t = build_vector_type (TREE_TYPE (TREE_TYPE (fndecl)), veclen);
+      t = build_vector_type (t, veclen);
       t = build_array_type_nelts (t, node->simdclone->simdlen / veclen);
-      TREE_TYPE (TREE_TYPE (fndecl)) = t;
     }
+  TREE_TYPE (TREE_TYPE (fndecl)) = t;
   if (!node->definition)
     return NULL_TREE;
 
@@ -11287,7 +11291,10 @@
 	  if (veclen > node->simdclone->simdlen)
 	    veclen = node->simdclone->simdlen;
 	  adj.arg_prefix = "simd";
-	  adj.type = build_vector_type (parm_type, veclen);
+	  if (POINTER_TYPE_P (parm_type))
+	    adj.type = build_vector_type (pointer_sized_int_node, veclen);
+	  else
+	    adj.type = build_vector_type (parm_type, veclen);
 	  node->simdclone->args[i].vector_type = adj.type;
 	  for (j = veclen; j < node->simdclone->simdlen; j += veclen)
 	    {
@@ -11328,7 +11335,10 @@
       veclen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));
       if (veclen > node->simdclone->simdlen)
 	veclen = node->simdclone->simdlen;
-      adj.type = build_vector_type (base_type, veclen);
+      if (POINTER_TYPE_P (base_type))
+	adj.type = build_vector_type (pointer_sized_int_node, veclen);
+      else
+	adj.type = build_vector_type (base_type, veclen);
       adjustments.safe_push (adj);
 
       for (j = veclen; j < node->simdclone->simdlen; j += veclen)
Index: gcc/ipa-inline-transform.c
===================================================================
--- a/src/gcc/ipa-inline-transform.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ipa-inline-transform.c	(.../branches/gcc-4_9-branch)
@@ -87,7 +87,6 @@
      the callgraph so references can point to it.  */
   return (!node->address_taken
 	  && !ipa_ref_has_aliases_p (&node->ref_list)
-	  && !node->used_as_abstract_origin
 	  && cgraph_can_remove_if_no_direct_calls_p (node)
 	  /* Inlining might enable more devirtualizing, so we want to remove
 	     those only after all devirtualizable virtual calls are processed.
@@ -185,6 +184,7 @@
 	  n = cgraph_clone_node (e->callee, e->callee->decl,
 				 e->count, freq_scale, update_original,
 				 vNULL, true, inlining_into, NULL);
+	  n->used_as_abstract_origin = e->callee->used_as_abstract_origin;
 	  cgraph_redirect_edge_callee (e, n);
 	}
     }
Index: gcc/cgraphunit.c
===================================================================
--- a/src/gcc/cgraphunit.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cgraphunit.c	(.../branches/gcc-4_9-branch)
@@ -1532,6 +1532,7 @@
 
       gimple call;
       gimple ret;
+      bool alias_is_noreturn = TREE_THIS_VOLATILE (alias);
 
       if (in_lto_p)
 	cgraph_get_body (node);
@@ -1566,15 +1567,22 @@
       bsi = gsi_start_bb (bb);
 
       /* Build call to the function being thunked.  */
-      if (!VOID_TYPE_P (restype))
+      if (!VOID_TYPE_P (restype) && !alias_is_noreturn)
 	{
 	  if (DECL_BY_REFERENCE (resdecl))
 	    restmp = gimple_fold_indirect_ref (resdecl);
 	  else if (!is_gimple_reg_type (restype))
 	    {
-	      restmp = resdecl;
-	      add_local_decl (cfun, restmp);
-	      BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;
+	      if (aggregate_value_p (resdecl, TREE_TYPE (thunk_fndecl)))
+		{
+		  restmp = resdecl;
+
+	      if (TREE_CODE (restmp) == VAR_DECL)
+		    add_local_decl (cfun, restmp);
+		  BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;
+		}
+	      else
+		restmp = create_tmp_var (restype, "retval");
 	    }
 	  else
 	    restmp = create_tmp_reg (restype, "retval");
@@ -1605,7 +1613,7 @@
       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);
       node->callees->call_stmt = call;
       gimple_call_set_from_thunk (call, true);
-      if (restmp)
+      if (restmp && !alias_is_noreturn)
 	{
           gimple_call_set_lhs (call, restmp);
 	  gcc_assert (useless_type_conversion_p (TREE_TYPE (restmp),
@@ -1612,7 +1620,7 @@
 						 TREE_TYPE (TREE_TYPE (alias))));
 	}
       gsi_insert_after (&bsi, call, GSI_NEW_STMT);
-      if (!(gimple_call_flags (call) & ECF_NORETURN))
+      if (!alias_is_noreturn)
 	{
 	  if (restmp && !this_adjusting
 	      && (fixed_offset || virtual_offset))
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,1533 @@
+2015-03-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/65561
+	* config/i386/sse.md (avx512f_vextract<shuffletype>32x4_1_maskm):
+	Check operand 6 and operand 0 for equality.
+	(vec_extract_lo_<mode>_maskm): Check operand 2 and operand 0
+	for equality.
+	(vec_extract_hi_<mode>_maskm): Ditto.
+
+2015-03-26  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport of r214242, r214254, and bug fix patches from mainline
+	* config/rs6000/rs6000.c (context.h): New #include.
+	(tree-pass.h): Likewise.
+	(make_pass_analyze_swaps): New declaration.
+	(rs6000_option_override): Register swap-optimization pass.
+	(swap_web_entry): New class.
+	(special_handling_values): New enum.
+	(union_defs): New function.
+	(union_uses): Likewise.
+	(insn_is_load_p): Likewise.
+	(insn_is_store_p): Likewise.
+	(insn_is_swap_p): Likewise.
+	(rtx_is_swappable_p): Likewise.
+	(insn_is_swappable_p): Likewise.
+	(chain_purpose): New enum.
+	(chain_contains_only_swaps): New function.
+	(mark_swaps_for_removal): Likewise.
+	(swap_const_vector_halves): Likewise.
+	(adjust_subreg_index): Likewise.
+	(permute_load): Likewise.
+	(permute_store): Likewise.
+	(adjust_extract): Likewise.
+	(adjust_splat): Likewise.
+	(handle_special_swappables): Likewise.
+	(replace_swap_with_copy): Likewise.
+	(dump_swap_insn_table): Likewise.
+	(rs6000_analyze_swaps): Likewise.
+	(pass_data_analyze_swaps): New pass_data.
+	(pass_analyze_swaps): New class.
+	(pass_analyze_swaps::gate): New method.
+	(pass_analyze_swaps::execute): New method.
+	(make_pass_analyze_swaps): New function.
+	* config/rs6000/rs6000.opt (moptimize-swaps): New option.
+	* df.h (web_entry_base): New class, replacing struct web_entry.
+	(web_entry_base::pred): New method.
+	(web_entry_base::set_pred): Likewise.
+	(web_entry_base::unionfind_root): Likewise.
+	(web_entry_base::unionfind_union): Likewise.
+	(unionfind_root): Delete external reference.
+	(unionfind_union): Likewise.
+	(union_defs): Likewise.
+	* web.c (web_entry_base::unionfind_root): Convert to method.
+	(web_entry_base::unionfind_union): Likewise.
+	(web_entry): New class.
+	(union_match_dups): Convert to use class structure.
+	(union_defs): Likewise.
+	(entry_register): Likewise.
+	(web_main): Likewise.
+
+2015-03-26  Alan Modra  <amodra@gmail.com>
+
+	PR target/63150
+	Backport from trunk 211857 and 221445.
+	2014-06-20  Maciej W. Rozycki  <macro@codesourcery.com>
+	* config/rs6000/rs6000.md: Append `DONE' to preparation
+	statements of `bswap' pattern splitters.
+
+	2015-03-16  Alan Modra  <amodra@gmail.com>
+	* config/rs6000/rs6000.md (bswapdi2): Remove one scratch reg.
+	Modify Z->r bswapdi splitter to use dest in place of scratch.
+	In r->Z and Z->r bswapdi splitter rename word_high, word_low
+	to word1, word2 and rearrange logic to suit.
+	(bswapdi2_64bit): Remove early clobber on Z->r alternative.
+	(bswapdi2_ldbrx): Likewise.  Remove '??' on r->r.
+	(bswapdi2_32bit): Remove early clobber on Z->r alternative.
+	Add one '?' on r->r.  Modify Z->r splitter to avoid need for
+	early clobber.
+
+2015-03-26  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2015-03-26  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	* config/sh/t-sh (MULTILIB_EXCEPTIONS): Handle default endian.
+
+2015-03-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/60851
+	* recog.c (constrain_operands): Accept a pseudo register before reload
+	for LRA enabled targets.
+
+2015-03-23  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from trunk r220616.
+	2015-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/64813
+	* cgraphunit.c (cgraph_node::expand_thunk): Do not create a return
+	value for call to a function that is noreturn.
+
+2015-03-23  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from trunk r216841.
+	2014-10-29  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/63587
+	* cgraphunit.c (cgraph_node::expand_thunk): Only VAR_DECLs are put
+	to local declarations.
+	* function.c (add_local_decl): Implementation moved from header file,
+	assert introduced for tree type.
+	* function.h: Likewise.
+
+2015-03-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-03-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR rtl-optimization/65235
+	* simplify-rtx.c (simplify_binary_operation_1, VEC_SELECT case):
+	When first element of vec_concat is const_int, calculate its size
+	using second element.
+
+2015-03-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/65409
+	* expr.c (store_field): Do not do a direct block copy if the source is
+	a PARALLEL with BLKmode.
+
+2015-03-12  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	* config/s390/s390.c (s390_reorg): Move code to output nops after label
+	to s390_reorg ().
+	(s390_asm_output_function_label): Likewise.
+	* config/s390/s390.c (s390_asm_output_function_label):
+	Fix function label alignment with -mhtopatch.
+	* config/s390/s390.md ("unspecv"): New values UNSPECV_NOP_2_BYTE,
+	UNSPECV_NOP_4_BYTE and UNSPECV_NOP_6_BYTE
+	("nop_2_byte"): New define_insn.
+	("nop_4_byte"): Likewise.
+	("nop_6_byte"): Likewise.
+	* doc/extend.texi (hotpatch): hotpatch attribute doc fixes.
+	* doc/invoke.texi (-mhotpatch): -mhotpatch doc fixes.
+
+2015-03-12  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2015-03-11  Marek Polacek  <polacek@redhat.com>
+
+	PR tree-optimization/65388
+	* tree-ssa-tail-merge.c (same_succ_def::equal): Fix typo in comparison.
+
+2015-03-11  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	* configure.ac [avr]: Check as for option -mrmw.
+	* configure: Regenerate.
+	* config.in: Regenerate.
+	* config/avr/driver-avr.c (avr_device_to_as): Don't add -mrmw to
+	assembler options if not HAVE_AS_AVR_MRMW_OPTION.
+
+2015-03-11  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2014-12-04  Marek Polacek  <polacek@redhat.com>
+
+	PR middle-end/56917
+	* fold-const.c (fold_unary_loc): Perform the negation in A's type
+	when transforming ~ (A - 1) or ~ (A + -1) to -A.
+
+2015-03-10  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from trunk r220489.
+	2015-02-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/64896
+	* cgraphunit.c (cgraph_node::expand_thunk): If
+	restype is not is_gimple_reg_type nor the thunk_fndecl
+	returns aggregate_value_p, set restmp to a temporary variable
+	instead of resdecl.
+
+2015-03-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/65286
+	* config/rs6000/t-linux: For powerpc64* target set
+	MULTILIB_OSDIRNAMES instead of MULTIARCH_DIRNAME.
+
+2015-03-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/53988
+	* config/sh/sh.md (*tst<mode>_t_zero): Remove insns.
+
+2015-03-10  Alan Modra  <amodra@gmail.com>
+
+	PR target/65286
+	* config.gcc (powerpc*-*-linux*): Arrange for powerpc64le-linux
+	to be single-arch by default.  Set cpu_is_64bit for powerpc64
+	given --with-cpu=native.
+	* config/rs6000/t-fprules: Do not set default MULTILIB vars.
+	* config/rs6000/t-linux (MULTIARCH_DIRNAME): Support powerpc64
+	and powerpc64le.
+	* config/rs6000/linux64.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Test
+	rs6000_isa_flags rather than TARGET_64BIT.
+
+2015-03-05  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from trunk
+	2015-03-03  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR 65138/target
+	* config/rs6000/rs6000-cpus.def (powerpc64le): Add new generic
+	processor type for 64-bit little endian PowerPC.
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): If
+	-mdebug=reg, print TARGET_DEFAULT.  Fix logic to use
+	TARGET_DEFAULT if there is no default cpu.  Fix -mdebug=reg
+	printing built-in mask so it does not pass NULL pointers.
+
+	* config/rs6000/rs6000-tables.opt: Regenerate.
+
+	* doc/invoke.texi (IBM RS/6000 and PowerPC options): Document
+	-mcpu=powerpc64le.
+
+	Backport from trunk
+	2015-01-19  David Edelsohn  <dje.gcc@gmail.com>
+
+	* config/rs6000/default64.h: Include rs6000-cpus.def.
+	(TARGET_DEFAULT) [LITTLE_ENDIAN]: Use ISA 2.7 (POWER8).
+	(TARGET_DEFAULT) [BIG_ENDIAN]: Use POWER4.
+	* config/rs6000/driver-rs6000.c (detect_processor_aix): Add POWER7
+	and POWER8.
+	* config/rs6000/linux64.h (PROCESSOR_DEFAULT64): Always default to
+	POWER8.
+	* config/rs6000/rs6000.c (rs6000_file_start): Emit .machine
+	pseudo-op to specify assembler dialect.
+
+2015-03-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-11-27  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/59593
+	* config/arm/arm.c (dump_minipool): dispatch to consttable pattern
+	based on mode size.
+	* config/arm/arm.md (consttable_1): Make it TARGET_EITHER.
+	(consttable_2): Make it TARGET_EITHER and move HFmode handling from
+	consttable_4 to it.
+	(consttable_4): Move HFmode handling to consttable_2 pattern.
+
+2015-03-03  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/65249
+	* config/sh/sh.md (symGOT_load): Use R0 reg for operands[2] when
+	called for __stack_chk_guard symbol.
+
+2015-03-03  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/64331
+	* config/avr/avr.c (context.h, tree-pass.h): Include them.
+	(avr_pass_data_recompute_notes): New static variable.
+	(avr_pass_recompute_notes): New class.
+	(avr_register_passes): New static function.
+	(avr_option_override): Call it.
+
+2015-03-03  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/ia64/ia64.c (expand_vec_perm_interleave_2): Use gen_raw_REG
+	to create a register in testing mode.
+
+2015-03-03  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2015-01-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/64453
+	* config/arm/arm.c (callee_saved_reg_p): Define.
+	(arm_compute_save_reg0_reg12_mask): Use callee_saved_reg_p to check if
+	register is callee saved instead of !call_used_regs[reg].
+	(thumb1_compute_save_reg_mask): Likewise.
+
+2015-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63175
+	* builtins.c (get_object_alignment_2): Make sure to re-apply
+	the ANDed mask after recursing to its operand gets us a new
+	misalignment bit position.
+
+2015-02-27  Andrew Pinski  <apinski@cavium.com>
+	    Naveen H.S  <Naveen.Hurugalawadi@caviumnetworks.com>
+
+	* config/aarch64/aarch64.c (*aarch64_load_symref_appropriately):
+	Check whether the destination of SYMBOL_SMALL_TPREL is Pmode.
+
+2015-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR lto/65193
+	Backport from mainline
+	2014-07-24  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto-streamer-out.c (tree_is_indexable): Consider IMPORTED_DECL
+	as non-indexable.
+
+2015-02-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2015-02-25  Adhemerval Zanella  <azanella@linux.vnet.ibm.com>
+
+	* config/rs6000/htm.md (tcheck): Fix assembly encoding.
+
+2015-02-26  Matthew Fortune  <matthew.fortune@imgtec.com>
+
+	PR target/64569
+	Backported from mainline: r213872, r217446, r217939, r219867
+
+	* config.in [!USED_FOR_TARGET] (HAVE_AS_DOT_MODULE): Undefine.
+	* config/mips/mips.h (FP_ASM_SPEC): New macro.
+	(ASM_SPEC): Use FP_ASM_SPEC.
+	* configure.ac (HAVE_AS_DOT_MODULE): Detect support for .module
+	and FPXX extensions.
+	* configure: Regenerate.
+
+2015-02-25  Jason Merrill  <jason@redhat.com>
+
+	* common.opt (-flifetime-dse): New.
+
+2015-02-25  Kai Tietz  <ktietz@redhat.com>
+
+	PR tree-optimization/61917
+	* tree-vect-loop.c (vectorizable_reduction): Handle obvious case
+	that reduc_def_stmt is null.
+
+	Merged from mainline
+	PR target/64212
+	* symtab.c (symtab::make_decl_local): Set DECL_IMPORT_P explicit to 0.
+	(symtab::noninterposable_alias): Likewise.
+
+2015-02-25  Richard Biener  <rguenther@suse.de>
+	Kai Tietz  <ktietz@redhat.com>
+
+	Backported from mainline
+	PR tree-optimization/61917
+	* tree-vect-loop.c (vectorizable_reduction): Allow
+	vect_internal_def without reduction to exit graceful.
+
+2015-02-25  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65196
+	* config/avr/avr.c (avr_adjust_insn_length): Call recog_memoized
+	only with NONDEBUG_INSN_P.
+
+2015-02-25  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline
+	2015-02-23  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/65153
+	* config/sh/sh.md (movsicc_true+3): Remove peephole.
+	* config/sh/sh-protos.h (replace_n_hard_rtx): Don't declare.
+	* config/sh/sh.c (replace_n_hard_rtx): Remove.
+
+2015-02-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-02-11  Richard Biener  <rguenther@suse.de>
+
+	PR lto/65015
+	* dwarf2out.c (gen_producer_string): Drop -fltrans-output-list
+	and -fresolution.
+
+	2015-02-13  Richard Biener  <rguenther@suse.de>
+
+	PR lto/65015
+	* dwarf2out.c (dwarf2out_finish): Use <artificial> as DW_AT_name
+	for LTO produced CUs.
+
+	2015-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR lto/65015
+	* varasm.c (default_file_start): For LTO produced units
+	emit <artificial> as file directive.
+
+	2015-01-17  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	* dwarf2out.c (gen_producer_string): Ignore also OPT_fpreprocessed.
+
+2015-02-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2015-02-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/65163
+	* config/sh/sh.md (swapbsi2, related peephole2): Use const_int -65536
+	instead of const_int 4294901760.
+
+2015-02-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-11-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63844
+	* omp-low.c (fixup_child_record_type): Use a restrict qualified
+	referece type for the receiver parameter.
+
+	2014-11-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61634
+	* tree-vect-slp.c: Include gimple-walk.h.
+	(vect_detect_hybrid_slp_stmts): Rewrite to propagate hybrid
+	down the SLP tree for one scalar statement.
+	(vect_detect_hybrid_slp_1): New walker function.
+	(vect_detect_hybrid_slp_2): Likewise.
+	(vect_detect_hybrid_slp): Properly handle pattern statements
+	in a pre-scan over all loop stmts.
+
+	2015-01-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/59354
+	* tree-vect-slp.c (vect_build_slp_tree_1): Treat loads from
+	groups larger than the slp group size as having gaps.
+
+	2015-02-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64909
+	* tree-vect-loop.c (vect_estimate_min_profitable_iters): Properly
+	pass a scalar-stmt count estimate to the cost model.
+	* tree-vect-data-refs.c (vect_peeling_hash_get_lowest_cost): Likewise.
+
+2015-02-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-02-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.md (*aarch64_lshr_sisd_or_int_<mode>3):
+	Mark operand 0 as earlyclobber in 2nd alternative.
+	(1st define_split below *aarch64_lshr_sisd_or_int_<mode>3):
+	Write negated shift amount into QI lowpart operand 0 and use it
+	in the shift step.
+	(2nd define_split below *aarch64_lshr_sisd_or_int_<mode>3): Likewise.
+
+2015-02-20  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2015-02-20 trunk r220847.
+
+	PR target/64452
+	* config/avr/avr.md (pushhi_insn): New insn.
+	(push<mode>1): Push virtual regs in one chunk using pushhi1_insn.
+
+2015-02-20  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-01-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64530
+	* tree-loop-distribution.c (pg_add_dependence_edges): Shuffle
+	back dr1.
+
+	2015-02-13  Richard Biener  <rguenther@suse.de>
+
+	PR lto/64373
+	* lto-streamer-out.c (tree_is_indexable): Guard for NULL
+	DECL_CONTEXT.
+
+	2015-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63593
+	* tree-predcom.c (execute_pred_commoning_chain): Delay removing
+	stmts and releasing SSA names until...
+	(execute_pred_commoning): ... after processing all chains.
+
+	2015-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/65063
+	* tree-predcom.c (determine_unroll_factor): Return 1 if we
+	have replaced looparound PHIs.
+
+2015-02-19  John David Anglin  <danlgin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_reloc_rw_mask): New function.
+	(TARGET_ASM_RELOC_RW_MASK): Define.
+	(pa_cannot_force_const_mem): Revert previous change.
+
+2015-02-19  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-12-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64199
+	* fold-const.c (fold_binary_loc): Use TREE_OVERFLOW_P.
+
+	2015-01-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64493
+	PR tree-optimization/64495
+	* tree-vect-loop.c (vect_finalize_reduction): For double-reductions
+	assign the proper vectorized PHI to the inner loop exit PHIs.
+
+	2015-01-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/56273
+	PR tree-optimization/59124
+	PR tree-optimization/64277
+	* tree-vrp.c (vrp_finalize): Emit array-bound warnings only
+	from the first VRP pass.
+
+	2015-02-19  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-01-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64365
+	* tree-data-ref.c (dr_analyze_indices): Make sure that accesses
+	for MEM_REF access functions with the same base can never partially
+	overlap.
+
+2015-02-17  Ilya Tocar  <ilya.tocar@intel.com>
+
+	Backported from mainline
+	2015-01-14  Ilya Tocar  <ilya.tocar@intel.com>
+
+	PR target/64387
+	* config/i386/sse.md (vec_unpacks_hi_v8sf): Fix predicate.
+	(vec_unpacks_hi_v16sf): Ditto.
+
+2015-02-15  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_secondary_reload): Request a secondary reload
+	for all floading point loads and stores except those using a register
+	index address.
+	* config/pa/pa.md: Add new patterns to load a lo_sum DLT operand
+	to a register.
+
+2015-02-13  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/constraints.md: Change "Q" and "T" constraints to memory
+	constraints.
+	* config/pa/pa.c (pa_cannot_force_const_mem): Don't allow constant
+	symbolic references to data to be forced to constant memory on the
+	SOM target.
+
+2015-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/64979
+	* tree-stdarg.c (pass_stdarg::execute): Scan phi node args for
+	va_list escapes.
+
+2015-02-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.md (reload_out<mode>_aligned): Make operands 2
+	and 3 earlyclobber operands.
+
+2015-02-09  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	* doc/extend.texi: s/390: Update documentation of hotpatch attribute.
+	* doc/invoke.texi (-mhotpatch): s/390: Update documentation of
+	-mhotpatch= option.
+	* config/s390/s390.opt (mhotpatch): s/390: Remove -mhotpatch and
+	-mno-hotpatch options.  Change syntax of -mhotpatch= option.
+	* config/s390/s390.c (s390_hotpatch_trampoline_halfwords_default):
+	Renamed.
+	(s390_hotpatch_trampoline_halfwords_max): Renamed.
+	(s390_hotpatch_hw_max): New name.
+	(s390_hotpatch_trampoline_halfwords): Renamed.
+	(s390_hotpatch_hw_before_label): New name.
+	(get_hotpatch_attribute): Removed.
+	(s390_hotpatch_hw_after_label): New name.
+	(s390_handle_hotpatch_attribute): Add second parameter to hotpatch
+	attribute.
+	(s390_attribute_table): Ditto.
+	(s390_function_num_hotpatch_trampoline_halfwords): Renamed.
+	(s390_function_num_hotpatch_hw): New name.
+	Remove special handling of inline functions and hotpatching.
+	Return number of nops before and after the function label.
+	(s390_can_inline_p): Removed.
+	(s390_asm_output_function_label): Emit a configurable number of nops
+	after the function label.
+	(s390_option_override): Update -mhotpatch= syntax and remove -mhotpatch.
+	(TARGET_CAN_INLINE_P) Removed.
+	(TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P): New.
+
+2015-02-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/64580
+	Backport from mainline
+	* config.rs6000/rs6000.c (compute_vrsave_mask): Reverse loop order.
+	(rs6000_stack_info): Add assert.
+	(rs6000_output_savres_externs): New function, split off from...
+	(rs6000_output_function_prologue): ... here.  Do not call it for
+	thunks.
+
+2015-02-04  Matthias Klose  <doko@ubuntu.com>
+
+	PR target/64938
+	Backport from mainline
+	2015-01-15  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/64068
+	PR ipa/64559
+	* ipa.c (symbol_table::remove_unreachable_nodes):
+	Do not put abstract origins into boundary.
+
+2015-02-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-01-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/64882
+	* config/i386/predicates.md (address_no_seg_operand): Reject
+	non-CONST_INT_P operands in invalid mode.
+
+	Backport from mainline
+	2015-01-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (*prefetch_prefetchw1): Remove mode of
+	address_operand 0.  Rename from *prefetch_prefetchwt1_<mode>.
+	* config/i386/predicates.md (address_no_seg_operand): Call
+	address_operand with VOIDmode.
+	(vsib_address_operand): Ditto.
+
+2015-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2015-01-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/driver-i386.c (host_detect_local_cpu): Check new
+	Silvermont, Haswell, Broadwell and Knights Landing model numbers.
+	* config/i386/i386.c (processor_model): Add
+	M_INTEL_COREI7_BROADWELL.
+	(arch_names_table): Add "broadwell".
+
+2015-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/61058
+	* jump.c (cleanup_barriers): Update basic block boundaries
+	if BLOCK_FOR_INSN is non-NULL on PREV.
+
+	2015-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64421
+	* omp-low.c (simd_clone_mangle): If DECL_ASSEMBLER_NAME starts
+	with asterisk, skip the first character.
+
+	* config/rs6000/rs6000-cpus.def (POWERPC_MASKS): Add
+	OPTION_MASK_QUAD_MEMORY_ATOMIC.
+
+	2015-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/63637
+	PR rtl-optimization/60663
+	* cse.c (merge_equiv_classes): Set new_elt->cost to MAX_COST
+	if elt->cost is MAX_COST for ASM_OPERANDS.
+	(find_sets_in_insn): Fix up comment typo.
+	(cse_insn): Don't set src_volatile for all non-volatile
+	ASM_OPERANDS in PARALLELs, but just those with multiple outputs
+	or with "memory" clobber.  Set elt->cost to MAX_COST
+	for ASM_OPERANDS in PARALLEL.  Set src_elt->cost to MAX_COST
+	if new_src is ASM_OPERANDS and elt->cost is MAX_COST.
+
+	PR debug/64511
+	* dwarf2out.c (struct dw_loc_descr_node): Add chain_next
+	GTY markup.
+
+	2015-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/64663
+	* dwarf2out.c (decl_piece_node): Don't put bitsize into
+	mode if bitsize <= 0.
+	(decl_piece_bitsize, adjust_piece_list, add_var_loc_to_decl,
+	dw_sra_loc_expr): Use HOST_WIDE_INT instead of int for bit
+	sizes and positions.
+
+2015-01-29  Ilya Tocar  <ilya.tocar@intel.com>
+
+	* config/i386/avx2intrin.h (_mm256_bslli_epi128,
+	_mm256_bsrli_epi128): New.
+	* config/i386/emmintrin.h (_mm_bsrli_si128, _mm_bslli_si128): Ditto.
+
+2015-01-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.c (s390_memory_move_cost): Increase costs for
+	memory accesses.
+
+2015-01-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.c (s390_register_move_cost): Increase costs for
+	FPR->GPR moves.
+
+2015-01-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-01-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/64795
+	* config/i386/i386.md (*movdi_internal): Also check operand 0
+	to determine TYPE_LEA operand.
+	(*movsi_internal): Ditto.
+
+	Backport from mainline
+	2015-01-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (sse2_loadld): Set attribute isa to sse2 for
+	alternative 1.
+
+2015-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64734
+	* omp-low.c (scan_sharing_clauses): Don't ignore
+	OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION GOMP_MAP_POINTER clauses
+	on target data/update constructs.
+
+2015-01-23  Wei Mi  <wmi@google.com>
+
+	Backported from trunk.
+	2015-01-22  Wei Mi  <wmi@google.com>
+
+	PR rtl-optimization/64557
+	* dse.c (record_store): Call get_addr for mem_addr.
+	(check_mem_read_rtx): Likewise.
+
+2015-01-22  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.md (atomic code attribute): Fix typo "ior" ->
+	"or".
+
+2015-01-21  Wei Mi  <wmi@google.com>
+
+	Backported from trunk.
+	2014-11-22  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/63970
+	* ipa.c (symbol_table::remove_unreachable_nodes): Mark all inline clones
+	as having abstract origin used.
+	* ipa-inline-transform.c (can_remove_node_now_p_1): Drop abstract
+	origin check.
+	(clone_inlined_nodes): Copy abstract originflag.
+	* lto-cgraph.c (compute_ltrans_boundary): Use get_create to get
+	abstract origin node.
+
+2015-01-20  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	Backport from mainline
+	* config/nios2/nios2.c (nios2_asm_file_end): Implement
+	TARGET_ASM_FILE_END hook for adding .note.GNU-stack section when
+	needed.
+	(TARGET_ASM_FILE_END): Define.
+
+2015-01-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2014-11-27  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63704
+	* alias.c (mems_in_disjoint_alias_sets_p): Remove assert
+	and instead return false when !fstrict-aliasing.
+
+2015-01-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* expr.c (expand_expr_real_1) <normal_inner_ref>: Use the expression to
+	set the memory attributes in all cases but clear MEM_EXPR if need be.
+
+2015-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-01-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/64513
+	* config/i386/i386.c (ix86_expand_prologue): Add
+	REG_FRAME_RELATED_EXPR to %rax and %r10 pushes.
+
+	2015-01-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/64286
+	* ree.c (combine_reaching_defs): Move part of comment earlier,
+	remove !SCALAR_INT_MODE_P check.
+	(add_removable_extension): Don't add vector mode
+	extensions if all uses of the source register aren't the same
+	vector extensions.
+
+	2015-01-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/64563
+	* tree-vrp.c (vrp_evaluate_conditional): Check for VR_RANGE
+	instead of != VR_VARYING.
+
+2015-01-14  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2015-01-13  Marek Polacek  <polacek@redhat.com>
+
+	PR middle-end/64391
+	* trans-mem.c (get_attrs_for): Return NULL_TREE if X is NULL_TREE.
+
+2015-01-13  Marc Glisse  <marc.glisse@inria.fr>
+
+	PR c++/54442
+	* tree.c (build_qualified_type): Use a canonical type for
+	TYPE_CANONICAL.
+
+2015-01-13  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline
+	2014-12-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/64358
+	* config/rs6000/rs6000.c (rs6000_split_logical_inner): Swap the
+	input operands if only the second is inverted.
+	* config/rs6000/rs6000.md (*boolc<mode>3_internal1 for BOOL_128):
+	Swap BOOL_REGS_OP1 and BOOL_REGS_OP2.  Correct arguments to
+	rs6000_split_logical.
+	(*boolc<mode>3_internal2 for TI2): Swap operands[1] and operands[2].
+
+2015-01-13  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline:
+	2014-11-19 Renlin Li <renlin.li@arm.com>
+
+	PR target/63424
+	* config/aarch64/aarch64-simd.md (<su><maxmin>v2di3): New.
+
+2015-01-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport form mainline
+	2015-01-13  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/64479
+	* rtlanal.c (set_reg_p): Handle SEQUENCE constructs.
+
+2015-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/64536
+	* cfgrtl.c (rtl_tidy_fallthru_edge): Handle removal of degenerate
+	tablejumps.
+
+2015-01-09  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2015-01-06  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/64505
+	* config/rs6000/rs6000.c (rs6000_secondary_reload): Return the
+	correct reload handler if -m32 -mpowerpc64 is used.
+
+2015-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline:
+	2015-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPP_OS_RTEMS_SPEC): Define __PPC_CPU_E6500__
+	for -mcpu=e6500.
+	* config/rs6000/t-rtems: Add e6500 multilibs.
+
+2015-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline:
+	2015-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/t-rtems: Add -mno-spe to soft-float multilib for
+	MPC8540.
+
+2015-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline:
+	2015-01-09  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/t-rtems: Use MULTILIB_REQUIRED instead of
+	MULTILIB_EXCEPTIONS.
+
+2015-01-09  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline:
+	2014-08-12 Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>
+
+	PR target/61413
+	* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Fix definition
+	of __ARM_SIZEOF_WCHAR_T.
+
+2015-01-08  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/64507
+	* config/sh/sh-mem.cc (sh_expand_cmpnstr): Check 0 length.
+
+2015-01-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (decrement_and_branch_until_zero): Use `Q' constraint
+	instead of `m' constraint.  Likewise for unnamed movb comparison
+	patterns using reg_before_reload_operand predicate.
+	* config/pa/predicates.md (reg_before_reload_operand): Tighten
+	predicate to reject register index and LO_SUM DLT memory forms
+	after reload.
+
+2014-12-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2014-12-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64409
+	* config/i386/i386.c (ix86_function_type_abi): Issue an error
+	when ms_abi attribute is used with x32.
+
+2014-12-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/mmx.md (*vec_extractv2sf_1): Do not emit unpckhps.
+	Emit movshdup for SSE3 and shufps otherwise.
+	(*vec_extractv2si_1): Do not emit punpckhdq and unpckhps.
+	Emit pshufd for SSE2 and shufps otherwise.
+
+2014-12-24  Nick Clifton  <nickc@redhat.com>
+
+	Backport from mainline:
+	2014-06-13  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.h (JUMP_ALIGN): Return the log value if user
+	requested alignment is active.
+	(LABEL_ALIGN): Likewise.
+	(LOOP_ALIGN): Likewise.
+
+	2014-03-25  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.c (rx_print_operand): Allow R operator to accept
+	SImode values.
+
+2014-12-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-12-03  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR rtl-optimization/64010
+	* reload.c (push_reload): Before reusing a register contained
+	in an operand as input reload register, ensure that it is not
+	used in CALL_INSN_FUNCTION_USAGE.
+
+2014-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/64265
+	* tsan.c (instrument_func_entry): Insert __tsan_func_entry
+	call on edge from entry block to single succ instead
+	of after labels of single succ of entry block.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* combine.c (setup_incoming_promotions): Pass the argument
+	before any promotions happen to promote_function_mode.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64200
+	* config/i386/i386.c (decide_alg): Don't assert "alg != libcall"
+	for TARGET_INLINE_STRINGOPS_DYNAMICALLY.
+
+2014-12-13  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/64269
+	* tree-ssa-forwprop.c (simplify_builtin_call): Bail out if
+	len2 or diff are too large.
+
+2014-12-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/md.texi (Insn Lengths): Fix description of (pc).
+
+2014-12-11  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2014-12-11  Renlin Li  <renlin.li@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_parse_cpu): Don't define
+	selected_tune.
+	(aarch64_override_options): Use selected_cpu's tuning.
+
+2014-12-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2014-09-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def (XVCVSXDDP_SCALE):  New
+	built-in definition.
+	(XVCVUXDDP_SCALE): Likewise.
+	(XVCVDPSXDS_SCALE): Likewise.
+	(XVCVDPUXDS_SCALE): Likewise.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins):  Add
+	entries for VSX_BUILTIN_XVCVSXDDP_SCALE,
+	VSX_BUILTIN_XVCVUXDDP_SCALE, VSX_BUILTIN_XVCVDPSXDS_SCALE, and
+	VSX_BUILTIN_XVCVDPUXDS_SCALE.
+	* config/rs6000/rs6000-protos.h (rs6000_scale_v2df): New
+	prototype.
+	* config/rs6000/rs6000.c (real.h): New include.
+	(rs6000_scale_v2df): New function.
+	* config/rs6000/vsx.md (UNSPEC_VSX_XVCVSXDDP): New unspec.
+	(UNSPEC_VSX_XVCVUXDDP): Likewise.
+	(UNSPEC_VSX_XVCVDPSXDS): Likewise.
+	(UNSPEC_VSX_XVCVDPUXDS): Likewise.
+	(vsx_xvcvsxddp_scale): New define_expand.
+	(vsx_xvcvsxddp): New define_insn.
+	(vsx_xvcvuxddp_scale): New define_expand.
+	(vsx_xvcvuxddp): New define_insn.
+	(vsx_xvcvdpsxds_scale): New define_expand.
+	(vsx_xvcvdpsxds): New define_insn.
+	(vsx_xvcvdpuxds_scale): New define_expand.
+	(vsx_xvcvdpuxds): New define_insn.
+	* doc/extend.texi (vec_ctf): Add new prototypes.
+	(vec_cts): Likewise.
+	(vec_ctu): Likewise.
+	(vec_splat): Likewise.
+	(vec_div): Likewise.
+	(vec_mul): Likewise.
+
+	Backport from mainline
+	2014-08-28  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_xl): New #define.
+	(vec_xst): Likewise.
+	* config/rs6000/rs6000-builtin.def (XXSPLTD_V2DF): New built-in.
+	(XXSPLTD_V2DI): Likewise.
+	(DIV_V2DI): Likewise.
+	(UDIV_V2DI): Likewise.
+	(MUL_V2DI): Likewise.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	entries for VSX_BUILTIN_XVRDPI, VSX_BUILTIN_DIV_V2DI,
+	VSX_BUILTIN_UDIV_V2DI, VSX_BUILTIN_MUL_V2DI,
+	VSX_BUILTIN_XXSPLTD_V2DF, and VSX_BUILTIN_XXSPLTD_V2DI).
+	* config/rs6000/vsx.md (UNSPEC_VSX_XXSPLTD): New unspec.
+	(UNSPEC_VSX_DIVSD): Likewise.
+	(UNSPEC_VSX_DIVUD): Likewise.
+	(UNSPEC_VSX_MULSD): Likewise.
+	(vsx_mul_v2di): New insn-and-split.
+	(vsx_div_v2di): Likewise.
+	(vsx_udiv_v2di): Likewise.
+	(vsx_xxspltd_<mode>): New insn.
+
+	Backport from mainline
+	2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_cpsgn): New #define.
+	(vec_mergee): Likewise.
+	(vec_mergeo): Likewise.
+	(vec_cntlz): Likewise.
+	* config/rs600/rs6000-c.c (altivec_overloaded_builtins): Add new
+	entries for VEC_AND, VEC_ANDC, VEC_MERGEH, VEC_MERGEL, VEC_NOR,
+	VEC_OR, VEC_PACKSU, VEC_XOR, VEC_PERM, VEC_SEL, VEC_VCMPGT_P,
+	VMRGEW, and VMRGOW.
+	* doc/extend.texi: Document various forms of vec_cpsgn,
+	vec_splats, vec_and, vec_andc, vec_mergeh, vec_mergel, vec_nor,
+	vec_or, vec_perm, vec_sel, vec_sub, vec_xor, vec_all_eq,
+	vec_all_ge, vec_all_gt, vec_all_le, vec_all_lt, vec_all_ne,
+	vec_any_eq, vec_any_ge, vec_any_gt, vec_any_le, vec_any_lt,
+	vec_any_ne, vec_mergee, vec_mergeo, vec_packsu, and vec_cntlz.
+
+	Backport from mainline
+	2014-07-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.md (unspec enum):  Fix typo in UNSPEC_VSLDOI.
+	(altivec_vsldoi_<mode>): Likewise.
+
+
+2014-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/62021
+	* omp-low.c (simd_clone_adjust_return_type): Use
+	vector of pointer_sized_int_node types instead vector of pointer
+	types.
+	(simd_clone_adjust_argument_types): Likewise.
+
+2014-12-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2014-12-09  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR middle-end/64225
+	* tree-ssa-reassoc.c (acceptable_pow_call): Disable transformation
+	for BUILT_IN_POW when flag_errno_math is present.
+
+2014-12-10  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-12-10  Marek Polacek  <polacek@redhat.com>
+
+	PR tree-optimization/61686
+	* tree-ssa-reassoc.c (range_entry_cmp): Use q->high instead of
+	p->high.
+
+2014-12-09  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2014-12-05  David Edelsohn  <dje.gcc@gmail.com>
+
+	* config/rs6000/xcoff.h (ASM_OUTPUT_ALIGNED_LOCAL): Append
+	alignment to section name. Increase default alignment to
+	word.
+
+2014-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR bootstrap/64213
+	Revert:
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* combine.c (setup_incoming_promotions): Pass the argument
+	before any promotions happen to promote_function_mode.
+
+2014-12-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64191
+	* tree-vect-stmts.c (vect_stmt_relevant_p): Clobbers are
+	not relevant (nor are their uses).
+
+2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/50751
+	* config/sh/sh.md (extendqihi2): Allow only for TARGET_SH1.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-12-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64108
+	* config/i386/i386.c (decide_alg): Stop only if there aren't
+	any usable algorithms.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* combine.c (setup_incoming_promotions): Pass the argument
+	before any promotions happen to promote_function_mode.
+
+2014-12-04  Tobias Burnus  <burnus@net-b.de>
+
+	* configure.ac
+	(ac_has_isl_schedule_constraints_compute_schedule):
+	New check.
+	* graphite-clast-to-gimple.c: For ISL 0.14, include deprecate headers.
+	* graphite-interchange.c: Ditto.
+	* graphite-poly.c: Ditto.
+	* graphite-sese-to-poly.c: Ditto.
+	* graphite-optimize-isl.c (getScheduleForBandList): Ditto.
+	Conditionally use ISL 0.13+ functions.
+	* config.in: Regenerate.
+	* configure: Regenerate.
+
+2014-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/56493
+	* convert.c (convert_to_real, convert_to_expr, convert_to_complex):
+	Handle COMPOUND_EXPR.
+
+2014-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/59708
+	* expmed.c (expand_widening_mult): Return const0_rtx if
+	coeff is 0.
+
+2014-12-03  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/64153
+	* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Check
+	type sizes before view_converting.
+
+2014-12-03  Shanyao Chen  <chenshanyao@huawei.com>
+
+	Backport from mainline
+	2014-11-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/59593
+	* config/arm/arm.md (*movhi_insn): Use right formatting
+	for immediate.
+
+	2014-11-19  Felix Yang  <felix.yang@huawei.com>
+		    Shanyao Chen  <chenshanyao@huawei.com>
+
+	PR target/59593
+	* config/arm/arm.md (define_attr "arch"): Add v6t2.
+	(define_attr "arch_enabled"): Add test for the above.
+	(*movhi_insn_arch4): Add new alternative.
+
+2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+
+	Backported from mainline
+	2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+
+	PR middle-end/63762
+	PR target/63661
+	* ira.c (ira): Update preferred class.
+
+2014-12-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/64113
+	* config/alpha/alpha.md (call_value_osf_tlsgd): Do not split insn
+	using post-reload splitter.  Use peephole2 pass instead.
+	(call_value_osf_tlsldm): Ditto.
+	(TLS_CALL): New int iterator.
+	(tls): New int attribute.
+	(call_value_osf_<tls>): Merge insn pattern from call_value_osf_tlsgd
+	and call_value_tlsldm using TLS_CALL int iterator.
+
+2014-12-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR target/64115
+	* config/rs6000/rs6000.c (rs6000_delegitimize_address): Remove
+	invalid UNSPEC_TOCREL sanity check under ENABLE_CHECKING.
+
+2014-12-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64111
+	* tree.c (int_cst_hash_hash): Use TYPE_UID instead of
+	htab_hash_pointer to not break PCH.
+
+2014-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/63551
+	* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Convert
+	value of the argument to the type of the value in the condition.
+
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64067
+	* expr.c (expand_expr_addr_expr_1) <case COMPOUND_LITERAL_EXPR>:
+	Handle it by returning address of COMPOUND_LITERAL_EXPR_DECL
+	not only if modifier is EXPAND_INITIALIZER, but whenever
+	COMPOUND_LITERAL_EXPR_DECL is non-NULL and TREE_STATIC.
+
+	2014-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63915
+	* tree-vect-stmts.c (vectorizable_simd_clone_call): Pass
+	true instead of false as last argument to gsi_replace.
+
+	PR sanitizer/63913
+	* ubsan.c: Include tree-eh.h.
+	(instrument_bool_enum_load): Handle loads that can throw.
+
+	2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/63659
+	* ree.c (update_reg_equal_equiv_notes): New function.
+	(combine_set_extension, transform_ifelse): Use it.
+
+2014-11-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2014-11-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* config/arm/t-aprofile (MULTILIB_MATCHES): New entry for
+	-march=armv8-a+crc.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63738
+	* tree-data-ref.c (split_constant_offset_1): Do not follow
+	SSA edges for SSA names with SSA_NAME_OCCURS_IN_ABNORMAL_PHI.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62238
+	* tree-predcom.c (ref_at_iteration): Unshare the expression
+	before gimplifying it.
+
+	2014-11-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61927
+	* tree-vect-loop.c (vect_analyze_loop_2): Revert ordering
+	of group and pattern analysis to the one in GCC 4.8.
+
+	2014-11-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63605
+	* fold-const.c (fold_binary_loc): Properly use element_precision
+	for types that may not be scalar.
+
+	2014-10-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63665
+	* fold-const.c (fold_comparison): Properly guard simplifying
+	against INT_MAX/INT_MIN with !TYPE_OVERFLOW_WRAPS.
+
+2014-11-25  Rohit  <rohitarulraj@freescale.com>
+
+	PR bootstrap/63703
+	* config/rs6000/darwin.h (REGISTER_NAMES): Update based on 32 newly
+	added GCC hard register numbers for SPE high registers.
+
+2014-11-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/53976
+	* config/sh/sh_optimize_sett_clrt.cc
+	(sh_optimize_sett_clrt::find_last_ccreg_values): Return bool instead
+	of void.  Abort at complex edges.
+	(sh_optimize_sett_clrt::execute): Do nothing if find_last_ccreg_values
+	returned false.
+
+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/63783
+	PR target/51244
+	* config/sh/sh_treg_combine.cc (sh_treg_combine::make_not_reg_insn):
+	Do not emit bitwise not insn.  Emit logical not insn sequence instead.
+	Adjust related comments throughout the file.
+
+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/60111
+	* config/sh/sh.c: Use signed char for signed field.
+
+2014-11-21  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/63673
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Allow
+	the base pointer of vec_vsx_ld and vec_vsx_st to take a pointer to
+	double.
+
+2014-11-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61750
+	* tree-ssa-forwprop.c (simplify_vce): Verify type sizes
+	match for the resulting VIEW_CONVERT_EXPR.
+
+2014-11-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63947
+	* config/i386/i386.c (put_condition_code) <case LTU, case GEU>:
+	Output "b" and "nb" suffix for FP mode.
+
+2014-11-19  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline
+	PR tree-optimization/62167
+	* tree-ssa-tail-merge.c (stmt_local_def): Handle statements with vuse
+	conservatively.
+	(gimple_equal_p): Don't use vn_valueize to compare for lhs equality of
+	assigns.
+
+2014-11-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/tm.texi.in (TARGET_FLAGS_REGNUM): Move around.
+	* doc/tm.texi: Regenerate.
+
+2014-11-14  Felix Yang  <felix.yang@huawei.com>
+
+	Backport from mainline
+	2014-11-14  Felix Yang  <felix.yang@huawei.com>
+		    Jiji Jiang  <jiangjiji@huawei.com>
+
+	* config/aarch64/aarch64-simd.md (*aarch64_simd_ld1r<mode>): Use
+	VALL mode iterator instead of VALLDI.
+
+2014-11-13  Teresa Johnson  <tejohnson@google.com>
+
+	PR tree-optimization/63841
+	* tree-ssa-strlen.c (strlen_optimize_stmt): Ignore clobbers.
+
+2014-11-13  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backport from mainline
+	2014-11-02  Michael Collison  <michael.collison@linaro.org>
+
+	* config/arm/arm.h (CLZ_DEFINED_VALUE_AT_ZERO) : Update
+	to support vector modes.
+	(CTZ_DEFINED_VALUE_AT_ZERO): Ditto.
+
+2014-11-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/tm.texi.in (SELECT_CC_MODE): Update example.
+	(REVERSIBLE_CC_MODE): Fix example.
+	(REVERSE_CONDITION): Fix typo.
+	* doc/tm.texi: Regenerate.
+
+2014-11-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/63838
+	* ipa-pure-const.c (propagate_nothrow): Walk w->indirect_calls
+	chain instead of node->indirect_calls.
+
+2014-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/61535
+	* config/sparc/sparc.c (function_arg_vector_value): Deal with vectors
+	smaller than 8 bytes.
+	(sparc_function_arg_1): Tweak.
+	(sparc_function_value_1): Tweak.
+
+2014-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/arm/arm.c (arm_set_return_address): Mark the store as frame
+	related, if any.
+	(thumb_set_return_address): Likewise.
+
+2014-11-07  Daniel Hellstrom  <daniel@gaisler.com>
+
+	* config.gcc (sparc-*-rtems*): Clean away unused t-elf.
+	* config/sparc/t-rtems: Add leon3v7 and muser-mode multilibs.
+
+2014-11-07  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2014-10-23  Marek Polacek  <polacek@redhat.com>
+
+	* c-ubsan.c (ubsan_instrument_shift): Perform the MINUS_EXPR
+	in unsigned type.
+
+2014-11-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (trap): New insn.  Add "trap" to attribute type.
+	Don't allow trap insn in in_branch_delay, in_nullified_branch_delay
+	or in_call_delay.
+
+2014-11-06  Daniel Hellstrom  <daniel@gaisler.com>
+
+	* config.gcc (sparc*-*-*): Accept mcpu=leon3v7 processor.
+	* doc/invoke.texi (SPARC options): Add mcpu=leon3v7 comment.
+	* config/sparc/leon.md (leon3_load, leon_store, leon_fp_*): Handle
+	leon3v7 as leon3.
+	* config/sparc/sparc-opts.h (enum processor_type): Add LEON3V7.
+	* config/sparc/sparc.c (sparc_option_override): Add leon3v7 support.
+	* config/sparc/sparc.h (TARGET_CPU_leon3v7): New define.
+	* config/sparc/sparc.md (cpu): Add leon3v7.
+	* config/sparc/sparc.opt (enum processor_type): Add leon3v7.
+
+2014-11-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63538
+	* config/i386/i386.c (in_large_data_p): Reject automatic variables.
+	(ix86_encode_section_info): Do not check for non-automatic varibles
+	when setting SYMBOL_FLAG_FAR_ADDR flag.
+	(x86_64_elf_select_section): Do not check ix86_cmodel here.
+	(x86_64_elf_unique_section): Ditto.
+	(x86_elf_aligned_common): Emit tab before .largecomm.
+
+2014-11-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2014-10-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	* varasm.c (const_alias_set): Remove.
+	(init_varasm_once): Remove initialization of const_alias_set.
+	(build_constant_desc): Do not set alias set to const_alias_set.
+
+	Backport from mainline:
+	2014-10-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/63475
+	* alias.c (true_dependence_1): Always use get_addr to extract
+	true address operands from x_addr and mem_addr.  Use extracted
+	address operands to check for references with alignment ANDs.
+	Use extracted address operands with find_base_term and
+	base_alias_check. For noncanonicalized operands call canon_rtx with
+	extracted address operand.
+	(write_dependence_1): Ditto.
+	(may_alias_p): Ditto.  Remove unused calls to canon_rtx.
+
+	Backport from mainline:
+	2014-10-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/63483
+	* alias.c (true_dependence_1): Do not exit early for MEM_READONLY_P
+	references when alignment ANDs are involved.
+	(write_dependence_p): Ditto.
+	(may_alias_p): Ditto.
+
+2014-10-31  DJ Delorie  <dj@redhat.com>
+
+	* expmed.c (strict_volatile_bitfield_p): Fix off-by-one error.
+
+2014-10-31  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-elf-raw.h (CA53_ERR_835769_SPEC): Define.
+	(LINK_SPEC): Include CA53_ERR_835769_SPEC.
+	* config/aarch64/aarch64-linux.h (CA53_ERR_835769_SPEC): Define.
+	(LINK_SPEC): Include CA53_ERR_835769_SPEC.
+
+2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/63697
+	* tree-vrp.c (simplify_internal_call_using_ranges): For subcode ==
+	MINUS_EXPR, check overflow on vr0.min - vr1.max and vr0.max - vr1.min
+	instead of vr0.min - vr1.min and vr0.max - vr1.max.
+
+2014-10-30  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR63633
+	* config/avr/avr-protos.h (regmask): New inline function.
+	(avr_fix_inputs, avr_emit3_fix_outputs): New protos.
+	* config/avr/avr.c (avr_fix_operands, avr_move_fixed_operands)
+	(avr_fix_inputs, avr_emit3_fix_outputs): New functions.
+	* config/avr/avr-fixed.md (mulqq3_nomul, muluqq3_nomul)
+	(mul<ALL2QA>3, mul<ALL4A>3, <usdiv><ALL1Q>3, <usdiv><ALL2QA>3)
+	(<usdiv><ALL4A>3, round<ALL124QA>3): Fix input operands.
+	* config/avr/avr-dimode.md (add<ALL8>3, sub<ALL8>3)
+	(<ss_addsub><ALL8S>3, <us_addsub><ALL8U>3, cbranch<ALL8>4)
+	(<di_shifts><ALL8>3, <any_extend>mulsidi3): Fix input operands.
+	* config/avr/avr.md (mulqi3_call, mulhi3_call, mulsi3, mulpsi3)
+	(mulu<QIHI>si3, muls<QIHI>si3, mulohisi3, <any_extend>mulhisi3)
+	(usmulhisi3, <any_extend>mulhi3_highpart, mulsqipsi3)
+	(fmul, fmuls, fmulsu): Fix operands.  Turn insn into expander as
+	needed.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
@@ -150,8 +1685,8 @@
 	Backport from mainline
 	2014-06-24  Max Ostapenko  <m.ostapenko@partner.samsung.com>
 
-	* asan.c (instrument_strlen_call): Do not instrument first byte in strlen
-	if already instrumented.
+	* asan.c (instrument_strlen_call): Do not instrument first byte in
+	strlen if already instrumented.
 
 2014-10-16  Yury Gribov  <y.gribov@samsung.com>
 
@@ -314,7 +1849,7 @@
 
 	Backport from mainline
 	2014-10-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
-	            Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+		    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
 
 	* config/aarch64/aarch64.h (FINAL_PRESCAN_INSN): Define.
 	(ADJUST_INSN_LENGTH): Define.
@@ -649,7 +2184,7 @@
 	* cgraphunit.c: (analyze_function): Remove forward declaration,
 	rename to cgraph_analyze_function, made external.
 	* cgraphclones.c (duplicate_thunk_for_node): Copy arguments of the
-        new decl properly.  Analyze the new thunk if it is expanded.
+	new decl properly.  Analyze the new thunk if it is expanded.
 
 2014-09-11  H.J. Lu  <hongjiu.lu@intel.com>
 
@@ -837,8 +2372,8 @@
 	Backport from mainline
 	2014-08-27  Kaz Kojima  <kkojima@gcc.gnu.org>
 
-        PR target/62261
-        * config/sh/sh.md (ashlsi3): Handle negative shift count for
+	PR target/62261
+	* config/sh/sh.md (ashlsi3): Handle negative shift count for
 	TARGET_SHMEDIA.
 	(ashldi3, ashrsi3, ashrdi3, lshrsi3, lshrdi3): Likewise.
 
@@ -1231,16 +2766,16 @@
 2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
 
 	Backport from mainline
-	2014-08-04  Ganesh Gopalasubramanian 
+	2014-08-04  Ganesh Gopalasubramanian
 		    <Ganesh.Gopalasubramanian@amd.com>
 
-	* config/i386/driver-i386.c (host_detect_local_cpu): Handle AMD's extended
-	family information. Handle BTVER2 cpu with cpuid family value.
+	* config/i386/driver-i386.c (host_detect_local_cpu): Handle AMD's
+	extended family information. Handle BTVER2 cpu with cpuid family value.
 
 2014-08-12  Ganesh Gopalasubramanian <Ganesh.Gopalasubramanian@amd.com>
 
 	Backport from mainline
-	2014-06-16  Ganesh Gopalasubramanian 
+	2014-06-16  Ganesh Gopalasubramanian
 		    <Ganesh.Gopalasubramanian@amd.com>
 
 	* config/i386/i386.c (ix86_expand_sse2_mulvxdi3): Issue
@@ -1343,7 +2878,7 @@
 
 2014-07-24  Kyle McMartin  <kyle@redhat.com>
 
-        * config/aarch64/aarch64-linux.h (TARGET_ASM_FILE_END): Define.
+	* config/aarch64/aarch64-linux.h (TARGET_ASM_FILE_END): Define.
 
 2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
 
@@ -1504,7 +3039,7 @@
 	* omp-low.c (create_omp_child_function): Don't set DECL_NAMELESS
 	on the FUNCTION_DECL.
 
-	* BASE-VER: Set to 4.9.1.
+	* BASE-VER: Set to 4.9.2.
 	* DEV-PHASE: Set to prerelease.
 
 2014-07-16  Release Manager
@@ -1944,7 +3479,7 @@
 	Backport from mainline
 
 	2014-06-20  Julian Brown  <julian@codesourcery.com>
-	            Chung-Lin Tang  <cltang@codesourcery.com>
+		    Chung-Lin Tang  <cltang@codesourcery.com>
 
 	* config/arm/arm.c (arm_output_mi_thunk): Fix offset for
 	TARGET_THUMB1_ONLY. Add comments.
@@ -2070,7 +3605,7 @@
 
 	PR tree-optimization/61289
 	* tree-ssa-threadedge.c (invalidate_equivalences): Remove SRC_MAP and
-	DST_MAP parameters.   Invalidate by walking all the SSA_NAME_VALUES
+	DST_MAP parameters.  Invalidate by walking all the SSA_NAME_VALUES
 	looking for those which match LHS.  All callers changed.
 	(record_temporary_equivalences_from_phis): Remove SRC_MAP and DST_MAP
 	parameters and code which manipulated them.  All callers changed.
@@ -3074,10 +4609,10 @@
 	* tree-ssa-propagate.c (valid_gimple_rhs_p): Only allow effective
 	boolean results for comparisons.
 
-2014-04-22   Richard Biener  <rguenther@suse.de>
+2014-04-22  Richard Biener  <rguenther@suse.de>
 
 	Backport from mainline
-	2014-04-17   Richard Biener  <rguenther@suse.de>
+	2014-04-17  Richard Biener  <rguenther@suse.de>
 
 	PR tree-optimization/60841
 	* tree-vect-data-refs.c (vect_analyze_data_refs): Count stmts.
@@ -5078,7 +6613,7 @@
 	PR ipa/60306
 
 	Revert:
-	2013-12-14   Jan Hubicka  <jh@suse.cz>
+	2013-12-14  Jan Hubicka  <jh@suse.cz>
 	PR middle-end/58477
 	* ipa-prop.c (stmt_may_be_vtbl_ptr_store): Skip clobbers.
 
@@ -7970,7 +9505,7 @@
 	* Makefile.in: Add vec.o to OBJS-libcommon
 
 2014-01-23  Kirill Yukhin  <kirill.yukhin@intel.com>
-	    Ilya Tocar     <ilya.tocar@intel.com>
+	    Ilya Tocar  <ilya.tocar@intel.com>
 
 	* config/i386/avx512fintrin.h (_mm512_kmov): New.
 	* config/i386/i386.c (IX86_BUILTIN_KMOV16): Ditto.
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-12.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-12.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,56 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler-not "xxpermdi" } } */
+
+#include "altivec.h"
+void abort ();
+
+#define N 4096
+int ca[N] __attribute__((aligned(16)));
+int cb[N] __attribute__((aligned(16)));
+int cc[N] __attribute__((aligned(16)));
+int cd[N] __attribute__((aligned(16)));
+int hey;
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  vector int va, vb, vc, vd, tmp;
+  vector unsigned int threes = vec_splat_u32(3);
+  for (i = 0; i < N; i+=4) {
+    vb = vec_vsx_ld (0, &cb[i]);
+    vc = vec_vsx_ld (0, &cc[i]);
+    vd = vec_vsx_ld (0, &cd[i]);
+    tmp = vec_add (vb, vc);
+    tmp = vec_sub (tmp, vd);
+    tmp = vec_sra (tmp, threes);
+    hey = tmp[3];
+    vec_vsx_st (tmp, 0, &ca[i]);
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = 3 * i - 2048;
+    cc[i] = -5 * i + 93;
+    cd[i] = i + 14;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (ca[i] != (-3 * i - 1969) >> 3)
+      abort ();
+  if (hey != ca[N-1])
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-5.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-5.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,45 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler-not "xxpermdi" } } */
+
+void abort ();
+
+#define N 4096
+int ca[N] __attribute__((aligned(16)));
+int cb[N] __attribute__((aligned(16)));
+int cc[N] __attribute__((aligned(16)));
+int cd[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = 3 * i - 2048;
+    cc[i] = -5 * i + 93;
+    cd[i] = i % 2 ? 1 : -1;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)
+      abort ();
+    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-13.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-13.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,54 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+
+#include <altivec.h>
+void abort ();
+
+#define N 4096
+long long ca[N] __attribute__((aligned(16)));
+long long cb[N] __attribute__((aligned(16)));
+long long cc[N] __attribute__((aligned(16)));
+long long cd[N] __attribute__((aligned(16)));
+long long x;
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  vector long long va, vb, vc, vd, tmp;
+  volatile unsigned long long three = 3;
+  vector unsigned long long threes = vec_splats (three);
+  for (i = 0; i < N; i+=2) {
+    vb = vec_vsx_ld (0, (vector long long *)&cb[i]);
+    vc = vec_vsx_ld (0, (vector long long *)&cc[i]);
+    vd = vec_vsx_ld (0, (vector long long *)&cd[i]);
+    tmp = vec_add (vb, vc);
+    tmp = vec_sub (tmp, vd);
+    tmp = vec_sra (tmp, threes);
+    x = vec_extract (tmp, 0);
+    vec_vsx_st (tmp, 0, (vector long long *)&ca[i]);
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = 3 * i - 2048;
+    cc[i] = -5 * i + 93;
+    cd[i] = i + 14;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (ca[i] != (-3 * i - 1969) >> 3)
+      abort ();
+  if (x != ca[N-1])
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-6.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,32 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+
+void abort();
+
+#define N 16
+
+signed char ca[N] __attribute__((aligned(16)));
+signed char cb[] __attribute__((aligned(16)))
+  = {8, 7, 6, 5, 4, 3, 2,  1,  0, -1, -2, -3, -4, -5, -6, -7};
+signed char cc[] __attribute__((aligned(16)))
+  = {1, 1, 2, 2, 3, 3, 2,  2,  1,  1,  0,  0, -1, -1, -2, -2};
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = cb[i] - cc[i];
+  }
+}
+
+int main ()
+{
+  signed char cd[] = {7, 6, 4, 3, 1, 0, 0, -1, -1, -2, -2, -3, -3, -4, -4, -5};
+  int i;
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (ca[i] != cd[i])
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-14.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-14.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler "stxsdx" } } */
+/* { dg-final { scan-assembler-times "xxpermdi" 1 } } */
+
+/* The only xxpermdi expected is for the vec_splats.  */
+
+#include <altivec.h>
+void abort ();
+
+#define N 4096
+long long ca[N] __attribute__((aligned(16)));
+long long cb[N] __attribute__((aligned(16)));
+long long cc[N] __attribute__((aligned(16)));
+long long cd[N] __attribute__((aligned(16)));
+long long x;
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  vector long long va, vb, vc, vd, tmp;
+  volatile unsigned long long three = 3;
+  vector unsigned long long threes = vec_splats (three);
+  for (i = 0; i < N; i+=2) {
+    vb = vec_vsx_ld (0, (vector long long *)&cb[i]);
+    vc = vec_vsx_ld (0, (vector long long *)&cc[i]);
+    vd = vec_vsx_ld (0, (vector long long *)&cd[i]);
+    tmp = vec_add (vb, vc);
+    tmp = vec_sub (tmp, vd);
+    tmp = vec_sra (tmp, threes);
+    x = vec_extract (tmp, 0);
+    vec_vsx_st (tmp, 0, (vector long long *)&ca[i]);
+  }
+}
+
+int main ()
+{
+  foo ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr64505.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr64505.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr64505.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,231 @@
+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-options "-O2 -mpowerpc64" } */
+
+/*
+ * (below is inlined and simplified from previously included headers)
+ */
+
+struct fltcom_st {
+    short fltbuf[950];
+} fltcom_  __attribute__((common))  ;
+#define CM_PLIBOR (*(((double *)&fltcom_ + 1)))
+#define CM_QMRG (*(((double *)&fltcom_ + 2)))
+
+struct fltcom2_st {
+    short fltbuf2[56];
+} fltcom2_  __attribute__((common))  ;
+#define CM_FLPRV ((short *)&fltcom2_ + 17)
+#define CM_FLNXT ((short *)&fltcom2_ + 20)
+#define CM_FLCPN (*(((double *)&fltcom2_)))
+#define CM_FLCNT (*(((short *)&fltcom2_ + 12)))
+
+struct aidatcm_st {
+    double cm_aid, cm_ext, cm_basis;
+    short cm_aiday, cm_exday, cm_dperd, cm_aiexf, cm_aidex, cm_aiok,
+            cm_aigdo, cm_aildo, cm_prev[3], cm_next[3], cm_aid_pad[2];
+    double cm_rvgfact, cm_ai1st, cm_ai2nd;
+    int cm_aieurok;
+} aidatcm_  __attribute__((common))  ;
+#define CM_EXDAY aidatcm_.cm_exday
+#define CM_BASIS aidatcm_.cm_basis
+#define CM_PREV aidatcm_.cm_prev
+
+struct cshfcm_st {
+    short bufff[10862];
+} cshfcm_  __attribute__((common))  ;
+#define CM_FNUM (*(((short *)&cshfcm_ + 9038)))
+#define CM_FIFLX ((double *)&cshfcm_ + 1)
+#define CM_FEXTX ((double *)&cshfcm_ + 1201)
+#define CM_FSHDT ((short *)&cshfcm_ + 7230)
+
+struct calctsdb_st {
+    short calctsdbbuff[115];
+} calctsdb_  __attribute__((common))  ;
+#define CM_CTUP_GOOD_TO_GO (*(((short *)&calctsdb_ + 16)))
+#define CM_PAYMENT_FREQUENCY (*(((short *)&calctsdb_ + 61)))
+#define CM_DISCOUNTING_DAYTYP (*(((short *)&calctsdb_ + 59)))
+
+struct cf600cm_st {
+    short bufcf[14404];
+} cf600cm_  __attribute__((common)) ;
+#define CM_FLT_RFIXRATES ((double *)&cf600cm_ + 600)
+
+typedef struct { int id; int type; const char *name; } bregdb_bitinfo_t;
+
+int
+bregdb_eval_bbitcxt_bool_rv(const bregdb_bitinfo_t * const bbit,
+                            const int bbit_default,
+                            const void * const bregucxt);
+
+static const bregdb_bitinfo_t bbit_calc_dr_d33 =
+  { 160667, 5, "bbit_calc_dr_d33" };
+#define bbit_calc_dr_d33__value() \
+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d33, 0, 0)
+static const bregdb_bitinfo_t bbit_calc_sx_b24 =
+  { 158854, 5, "bbit_calc_sx_b24" };
+#define bbit_calc_sx_b24__value() \
+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_sx_b24, 0, 0)
+static const bregdb_bitinfo_t bbit_calc_dr_d36 =
+  { 161244, 5, "bbit_calc_dr_d36" };
+#define bbit_calc_dr_d36__value() \
+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d36, 0, 0)
+static const bregdb_bitinfo_t bbit_calc_dr_d37 =
+  { 161315, 5, "bbit_calc_dr_d37" };
+#define bbit_calc_dr_d37__value() \
+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d37, 0, 0)
+static const bregdb_bitinfo_t bbit_calc_dr_d47 =
+  { 163259, 5, "bbit_calc_dr_d47" };
+#define bbit_calc_dr_d47__value() \
+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d47, 0, 0)
+static const bregdb_bitinfo_t bbit_calc_dr_d46 =
+  { 163239, 5, "bbit_calc_dr_d46" };
+#define bbit_calc_dr_d46__value() \
+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d46, 0, 0)
+static const bregdb_bitinfo_t bbit_calc_dr_d62 =
+  { 166603, 5, "bbit_calc_dr_d62" };
+#define bbit_calc_dr_d62__value() \
+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d62, 0, 0)
+
+
+
+int dtyp_is_actact_(short *daytyp);
+double rnd_trunc_numb(double in, short num_digits, short rnd_or_trunc);
+void datetrn_(const short* dt, short* dt2);
+short difday_(short* daytyp_in, short* srtdti, short* enddti, short* ercode);
+
+
+double pow(double x, double y);
+
+
+/*
+ * (above is inlined and simplified from previously included headers)
+ */
+
+
+void calc_1566(
+  short  sCalcType,
+  short  sDayType,
+  short  sFreq,
+  short  asSettleDt[3],
+  short  asMtyDt[3],
+  short  asIssueDt[3],
+  short  asFCpnDt[3],
+  double dCpn,
+  short  *psNoPer,
+  double *pdExt,
+  double *pdAI,
+  double *pdAI2,
+  double *pdFCpn,
+  short  *psRcode)
+{
+
+    short ercode = 0;
+    int isactact;
+    short days_to_next_cpn = 0;
+    const short discDaytype = CM_DISCOUNTING_DAYTYP;
+    int j;
+
+    if(bbit_calc_sx_b24__value())
+        isactact = (dtyp_is_actact_(&sDayType) != 0);
+    else
+        isactact = (sDayType == 1 || sDayType == 10);
+
+    short days_in_current_period = difday_(&sDayType,CM_FLPRV,CM_FLNXT,&ercode);
+    const short sfreq1 = (CM_CTUP_GOOD_TO_GO == 1 && CM_PAYMENT_FREQUENCY == 1);
+
+    for (j = 0; j < CM_FNUM; j++) {
+
+        if(j == 0) {
+            days_to_next_cpn = difday_(&sDayType,asSettleDt,CM_FLNXT,&ercode);
+
+            if(isactact) {
+                CM_FIFLX[j] = CM_FLCPN / sFreq;
+                CM_FEXTX[j] = (double)days_to_next_cpn / (double)days_in_current_period;
+            }
+            else {
+                CM_FIFLX[j] = CM_FLCPN * days_in_current_period;
+                CM_FEXTX[j] = (double)days_to_next_cpn / (double)(1/sfreq1);
+            }
+
+            if(CM_FNUM == 1) {
+                CM_FEXTX[j] = (double)days_to_next_cpn / ((double)1/sfreq1);
+            }
+        }
+        else {
+
+            short days_from_settle, days_in_period;
+
+            if(bbit_calc_dr_d46__value()){
+             days_from_settle = difday_(&sDayType,asSettleDt,
+                                             &CM_FSHDT[j*3],&ercode);
+             days_in_period =  difday_(&sDayType,&CM_FSHDT[(j-1)*3],
+                                            &CM_FSHDT[j*3],&ercode);
+            }
+
+            double cpn_rate = CM_PLIBOR;
+
+            if(bbit_calc_dr_d62__value()) {
+              if(j < CM_FLCNT && CM_FLT_RFIXRATES[j] != 0) cpn_rate = CM_FLT_RFIXRATES[j];
+            }
+            else {
+              if(j < CM_FLCNT ) cpn_rate = CM_FLT_RFIXRATES[j];
+            }
+
+            if(bbit_calc_dr_d37__value()&& j >= CM_FLCNT && sCalcType == 1570) {
+                cpn_rate = CM_PLIBOR + CM_QMRG;
+
+                if(bbit_calc_dr_d36__value()){
+                double projected_rate = pow((1 + CM_PLIBOR/100.0),
+                                            (days_in_period)) - 1;
+
+                projected_rate = projected_rate + CM_QMRG/100.0 * days_in_period;
+                cpn_rate = 100 * projected_rate * (1/days_in_period);
+                }
+            }
+
+
+            if(isactact) {
+                CM_FIFLX[j] = cpn_rate / sFreq;
+                CM_FEXTX[j] = CM_FEXTX[j-1] + 1;
+
+                if(bbit_calc_dr_d46__value() && discDaytype != 0) {
+                    CM_FEXTX[j] = (double)days_from_settle / (double)(1/sfreq1);
+                }
+            }
+            else {
+                if(!bbit_calc_dr_d46__value()){
+                days_from_settle = difday_(&sDayType,asSettleDt,
+                                               &CM_FSHDT[j*3],&ercode);
+                days_in_period =  difday_(&sDayType,&CM_FSHDT[(j-1)*3],
+                                               &CM_FSHDT[j*3],&ercode);
+
+                }
+
+                CM_FIFLX[j] = cpn_rate * days_in_period;
+                CM_FEXTX[j] = (double)days_from_settle / (double)(1/sfreq1);
+            }
+
+        }
+
+        if(bbit_calc_dr_d33__value() && CM_CTUP_GOOD_TO_GO != 0) {
+            CM_FIFLX[j] = rnd_trunc_numb (CM_FIFLX[j], 0, 0);
+        }
+
+    }
+
+
+    short accrued_days = difday_(&sDayType,CM_FLPRV,asSettleDt,&ercode);
+
+    if(!bbit_calc_dr_d47__value()) {
+    if(isactact) {
+        *pdAI = (CM_FLCPN / sFreq)* accrued_days / ((double)days_in_current_period);
+    }
+    else{
+        *pdAI = (CM_FLCPN / sFreq)* accrued_days / ((double)1/sFreq);
+    }
+    }
+
+    CM_EXDAY = days_to_next_cpn;
+    CM_BASIS = days_in_current_period;
+    datetrn_(CM_FLPRV,CM_PREV);
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-7.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,38 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+
+void abort ();
+
+#define N 256
+signed char ca[N] __attribute__((aligned(16)));
+signed char cb[N] __attribute__((aligned(16)));
+signed char cc[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = cb[i] - cc[i];
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = i - 128;
+    cc[i] = i/2 - 64;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (ca[i] != i - i/2 - 64)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-15.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-15.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-15.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,51 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler "xxspltw" } } */
+
+/* Currently the analyze_swaps phase cannot optimize this loop because
+   of the presence of an UNSPEC_VSX_CVDPSPN.  At such time as this is 
+   handled, we need to add a 'scan-assembler-not "xxpermdi"' directive to
+   this test.  */
+#include <altivec.h>
+void abort();
+
+#define N 4096
+#define M 10000000
+vector float ca[N][4] = {0};
+vector float cb[N][4] = {0};
+vector float cc[N][4] = {0};
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    cc[i][0] = vec_mul(vec_splats(cb[i][0][0]), ca[i][0]);
+    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][1]), ca[i][1]);
+    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][2]), ca[i][2]);
+    cc[i][0] = vec_madd(cc[i][0],vec_splats(cb[i][0][3]), ca[i][3]);
+
+    cc[i][1] = vec_mul(vec_splats(cb[i][1][0]), ca[i][0]);
+    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][1]), ca[i][1]);
+    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][2]), ca[i][2]);
+    cc[i][1] = vec_madd(cc[i][0],vec_splats(cb[i][1][3]), ca[i][3]);
+    
+    cc[i][2] = vec_mul(vec_splats(cb[i][2][0]), ca[i][0]);
+    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][1]), ca[i][1]);
+    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][2]), ca[i][2]);
+    cc[i][2] = vec_madd(cc[i][0],vec_splats(cb[i][2][3]), ca[i][3]);
+    
+    cc[i][3] = vec_mul(vec_splats(cb[i][3][0]), ca[i][0]);
+    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][1]), ca[i][1]);
+    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][2]), ca[i][2]);
+    cc[i][3] = vec_madd(cc[i][0],vec_splats(cb[i][3][3]), ca[i][3]);
+  }
+}
+
+int main ()
+{
+  foo ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,166 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-options "-mcpu=power8 -O0" } */
+
+/* Test that a number of newly added builtin overloads are accepted
+   by the compiler.  */
+
+#include <altivec.h>
+
+vector double y = { 2.0, 4.0 };
+vector double z;
+
+int main ()
+{
+  vector float fa = {1.0, 2.0, 3.0, -4.0};
+  vector float fb = {-2.0, -3.0, -4.0, -5.0};
+  vector float fc = vec_cpsgn (fa, fb);
+
+  vector long long la = {5L, 14L};
+  vector long long lb = {3L, 86L};
+  vector long long lc = vec_and (la, lb);
+  vector bool long long ld = {0, -1};
+  vector long long le = vec_and (la, ld);
+  vector long long lf = vec_and (ld, lb);
+
+  vector unsigned long long ua = {5L, 14L};
+  vector unsigned long long ub = {3L, 86L};
+  vector unsigned long long uc = vec_and (ua, ub);
+  vector bool long long ud = {0, -1};
+  vector unsigned long long ue = vec_and (ua, ud);
+  vector unsigned long long uf = vec_and (ud, ub);
+
+  vector long long lg = vec_andc (la, lb);
+  vector long long lh = vec_andc (la, ld);
+  vector long long li = vec_andc (ld, lb);
+
+  vector unsigned long long ug = vec_andc (ua, ub);
+  vector unsigned long long uh = vec_andc (ua, ud);
+  vector unsigned long long ui = vec_andc (ud, ub);
+
+  vector double da = {1.0, -4.0};
+  vector double db = {-2.0, 5.0};
+  vector double dc = vec_cpsgn (da, db);
+
+  vector long long lj = vec_mergeh (la, lb);
+  vector long long lk = vec_mergeh (la, ld);
+  vector long long ll = vec_mergeh (ld, la);
+
+  vector unsigned long long uj = vec_mergeh (ua, ub);
+  vector unsigned long long uk = vec_mergeh (ua, ud);
+  vector unsigned long long ul = vec_mergeh (ud, ua);
+
+  vector long long lm = vec_mergel (la, lb);
+  vector long long ln = vec_mergel (la, ld);
+  vector long long lo = vec_mergel (ld, la);
+
+  vector unsigned long long um = vec_mergel (ua, ub);
+  vector unsigned long long un = vec_mergel (ua, ud);
+  vector unsigned long long uo = vec_mergel (ud, ua);
+
+  vector long long lp = vec_nor (la, lb);
+  vector long long lq = vec_nor (la, ld);
+  vector long long lr = vec_nor (ld, la);
+
+  vector unsigned long long up = vec_nor (ua, ub);
+  vector unsigned long long uq = vec_nor (ua, ud);
+  vector unsigned long long ur = vec_nor (ud, ua);
+
+  vector long long ls = vec_or (la, lb);
+  vector long long lt = vec_or (la, ld);
+  vector long long lu = vec_or (ld, la);
+
+  vector unsigned long long us = vec_or (ua, ub);
+  vector unsigned long long ut = vec_or (ua, ud);
+  vector unsigned long long uu = vec_or (ud, ua);
+
+  vector unsigned char ca = {0,4,8,1,5,9,2,6,10,3,7,11,15,12,14,13};
+  vector long long lv = vec_perm (la, lb, ca);
+  vector unsigned long long uv = vec_perm (ua, ub, ca);
+
+  vector long long lw = vec_sel (la, lb, lc);
+  vector long long lx = vec_sel (la, lb, uc);
+  vector long long ly = vec_sel (la, lb, ld);
+
+  vector unsigned long long uw = vec_sel (ua, ub, lc);
+  vector unsigned long long ux = vec_sel (ua, ub, uc);
+  vector unsigned long long uy = vec_sel (ua, ub, ld);
+
+  vector long long lz = vec_xor (la, lb);
+  vector long long l0 = vec_xor (la, ld);
+  vector long long l1 = vec_xor (ld, la);
+
+  vector unsigned long long uz = vec_xor (ua, ub);
+  vector unsigned long long u0 = vec_xor (ua, ud);
+  vector unsigned long long u1 = vec_xor (ud, ua);
+
+  int ia = vec_all_eq (ua, ub);
+  int ib = vec_all_ge (ua, ub);
+  int ic = vec_all_gt (ua, ub);
+  int id = vec_all_le (ua, ub);
+  int ie = vec_all_lt (ua, ub);
+  int ig = vec_all_ne (ua, ub);
+
+  int ih = vec_any_eq (ua, ub);
+  int ii = vec_any_ge (ua, ub);
+  int ij = vec_any_gt (ua, ub);
+  int ik = vec_any_le (ua, ub);
+  int il = vec_any_lt (ua, ub);
+  int im = vec_any_ne (ua, ub);
+
+  vector int sia = {9, 16, 25, 36};
+  vector int sib = {-8, -27, -64, -125};
+  vector int sic = vec_mergee (sia, sib);
+  vector int sid = vec_mergeo (sia, sib);
+
+  vector unsigned int uia = {9, 16, 25, 36};
+  vector unsigned int uib = {8, 27, 64, 125};
+  vector unsigned int uic = vec_mergee (uia, uib);
+  vector unsigned int uid = vec_mergeo (uia, uib);
+
+  vector bool int bia = {0, -1, -1, 0};
+  vector bool int bib = {-1, -1, 0, -1};
+  vector bool int bic = vec_mergee (bia, bib);
+  vector bool int bid = vec_mergeo (bia, bib);
+
+  vector unsigned int uie = vec_packsu (ua, ub);
+
+  vector long long l2 = vec_cntlz (la);
+  vector unsigned long long u2 = vec_cntlz (ua);
+  vector int sie = vec_cntlz (sia);
+  vector unsigned int uif = vec_cntlz (uia);
+  vector short ssa = {20, -40, -60, 80, 100, -120, -140, 160};
+  vector short ssb = vec_cntlz (ssa);
+  vector unsigned short usa = {81, 72, 63, 54, 45, 36, 27, 18};
+  vector unsigned short usb = vec_cntlz (usa);
+  vector signed char sca = {-4, 3, -9, 15, -31, 31, 0, 0,
+		            1, 117, -36, 99, 98, 97, 96, 95};
+  vector signed char scb = vec_cntlz (sca);
+  vector unsigned char cb = vec_cntlz (ca);
+
+  vector double dd = vec_xl (0, &y);
+  vec_xst (dd, 0, &z);
+
+  vector double de = vec_round (dd);
+
+  vector double df = vec_splat (de, 0);
+  vector double dg = vec_splat (de, 1);
+  vector long long l3 = vec_splat (l2, 0);
+  vector long long l4 = vec_splat (l2, 1);
+  vector unsigned long long u3 = vec_splat (u2, 0);
+  vector unsigned long long u4 = vec_splat (u2, 1);
+  vector bool long long l5 = vec_splat (ld, 0);
+  vector bool long long l6 = vec_splat (ld, 1);
+
+  vector long long l7 = vec_div (l3, l4);
+  vector unsigned long long u5 = vec_div (u3, u4);
+
+  vector long long l8 = vec_mul (l3, l4);
+  vector unsigned long long u6 = vec_mul (u3, u4);
+
+  vector double dh = vec_ctf (la, -2);
+  vector double di = vec_ctf (ua, 2);
+  vector long long l9 = vec_cts (dh, -2);
+  vector unsigned long long u7 = vec_ctu (di, 2);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-8.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-8.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,40 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+
+void abort ();
+
+#define N 4096
+signed char ca[N] __attribute__((aligned(16)));
+signed char cb[N] __attribute__((aligned(16)));
+signed char cc[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = cb[i] - cc[i];
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i, ii;
+  for (i = 0, ii = 0; i < N; ++i, ii = (ii + 1) % 128) {
+    cb[i] = ii - 128;
+    cc[i] = ii/2 - 64;
+  }
+}
+
+int main ()
+{
+  int i, ii;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i) {
+    ii = i % 128;
+    if (ca[i] != ii - ii/2 - 64)
+      abort ();
+  }
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-16.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-16.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,57 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler "vspltw" } } */
+/* { dg-final { scan-assembler-not "xxpermdi" } } */
+
+#include <altivec.h>
+void abort();
+
+typedef struct xx {vector double l; vector double h;} xx;
+
+#define N 4096
+#define M 10000000
+vector float ca[N][4] = {0};
+vector float cb[N][4] = {0};
+vector float cc[N][4] = {0};
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  vector float brow;
+
+  for (i = 0; i < N; i++) {
+
+    brow = cb[i][0];
+    cc[i][0] = vec_mul(vec_splats(brow[0]), ca[i][0]);
+    cc[i][0] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
+    cc[i][0] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
+    cc[i][0] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
+
+    brow = cb[i][1];
+    cc[i][1] = vec_mul(vec_splats(brow[0]), ca[i][0]);
+    cc[i][1] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
+    cc[i][1] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
+    cc[i][1] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
+    
+    brow = cb[i][2];
+    cc[i][2] = vec_mul(vec_splats(brow[0]), ca[i][0]);
+    cc[i][2] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
+    cc[i][2] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
+    cc[i][2] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
+    
+    brow = cb[i][3];
+    cc[i][3] = vec_mul(vec_splats(brow[0]), ca[i][0]);
+    cc[i][3] = vec_madd(cc[i][0],vec_splats(brow[1]), ca[i][1]);
+    cc[i][3] = vec_madd(cc[i][0],vec_splats(brow[2]), ca[i][2]);
+    cc[i][3] = vec_madd(cc[i][0],vec_splats(brow[3]), ca[i][3]);
+  }
+}
+
+int main ()
+{
+  foo ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-options "-mcpu=power8 " } */
+
+#include <altivec.h>
+
+void abort (void);
+
+int main ()
+{
+  vector long long sa = {27L, -14L};
+  vector long long sb = {-9L, -2L};
+
+  vector unsigned long long ua = {27L, 14L};
+  vector unsigned long long ub = {9L, 2L};
+
+  vector long long sc = vec_div (sa, sb);
+  vector unsigned long long uc = vec_div (ua, ub);
+
+  if (sc[0] != -3L || sc[1] != 7L || uc[0] != 3L || uc[1] != 7L)
+    abort ();
+
+  vector long long sd = vec_mul (sa, sb);
+  vector unsigned long long ud = vec_mul (ua, ub);
+
+  if (sd[0] != -243L || sd[1] != 28L || ud[0] != 243L || ud[1] != 28L)
+    abort ();
+
+  vector long long se = vec_splat (sa, 0);
+  vector long long sf = vec_splat (sa, 1);
+  vector unsigned long long ue = vec_splat (ua, 0);
+  vector unsigned long long uf = vec_splat (ua, 1);
+
+  if (se[0] != 27L || se[1] != 27L || sf[0] != -14L || sf[1] != -14L
+      || ue[0] != 27L || ue[1] != 27L || uf[0] != 14L || uf[1] != 14L)
+    abort ();
+
+  vector double da = vec_ctf (sa, -2);
+  vector double db = vec_ctf (ua, 2);
+  vector long long sg = vec_cts (da, -2);
+  vector unsigned long long ug = vec_ctu (db, 2);
+
+  if (da[0] != 108.0 || da[1] != -56.0 || db[0] != 6.75 || db[1] != 3.5
+      || sg[0] != 27L || sg[1] != -14L || ug[0] != 27L || ug[1] != 14L)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler-not "xxpermdi" } } */
+
+void abort();
+
+#define N 16
+
+signed char ca[N] __attribute__((aligned(16)));
+signed char cb[] __attribute__((aligned(16)))
+  = {8, 7, 6, 5, 4, 3, 2,  1,  0, -1, -2, -3, -4, -5, -6, -7};
+signed char cc[] __attribute__((aligned(16)))
+  = {1, 1, 2, 2, 3, 3, 2,  2,  1,  1,  0,  0, -1, -1, -2, -2};
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = cb[i] - cc[i];
+  }
+}
+
+int main ()
+{
+  signed char cd[] = {7, 6, 4, 3, 1, 0, 0, -1, -1, -2, -2, -3, -3, -4, -4, -5};
+  int i;
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (ca[i] != cd[i])
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-9.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-9.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,42 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+
+void abort ();
+
+#define N 4096
+int ca[N] __attribute__((aligned(16)));
+int cb[N] __attribute__((aligned(16)));
+int cc[N] __attribute__((aligned(16)));
+int cd[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = (cb[i] + cc[i]) * cd[i];
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = 3 * i - 2048;
+    cc[i] = -5 * i + 93;
+    cd[i] = i % 2 ? 1 : -1;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (i % 2 == 1 && ca[i] != -2 * i - 1955)
+      abort ();
+    else if (i % 2 == 0 && ca[i] != 1955 + 2 * i)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-17.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-17.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-17.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O1" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "xxpermdi" } } */
+
+/* Verify that we don't try to do permute removal in the presence of
+   vec_ste.  This used to ICE.  */
+#include <altivec.h>
+
+void f (void *p)
+{
+  vector unsigned int u32 = vec_vsx_ld (1, (const unsigned int *)p);
+  vec_ste (u32, 1, (unsigned int *)p);
+}
Index: gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/htm-builtin-1.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
-/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-do assemble { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target powerpc_htm_ok } */
-/* { dg-options "-O2 -mhtm" } */
+/* { dg-options "-O2 -mhtm -save-temps" } */
 
 /* { dg-final { scan-assembler-times "tbegin\\." 1 } } */
 /* { dg-final { scan-assembler-times "tend\\." 2 } } */
@@ -10,7 +10,7 @@
 /* { dg-final { scan-assembler-times "tabortdci\\." 1 } } */
 /* { dg-final { scan-assembler-times "tabortwc\\." 1 } } */
 /* { dg-final { scan-assembler-times "tabortwci\\." 2 } } */
-/* { dg-final { scan-assembler-times "tcheck\\." 1 } } */
+/* { dg-final { scan-assembler-times "tcheck" 1 } } */
 /* { dg-final { scan-assembler-times "trechkpt\\." 1 } } */
 /* { dg-final { scan-assembler-times "treclaim\\." 1 } } */
 /* { dg-final { scan-assembler-times "tsr\\." 3 } } */
@@ -49,3 +49,4 @@
   __builtin_set_tfhar (a[22]);
   __builtin_set_tfiar (a[23]);
 }
+/* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,41 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler-not "xxpermdi" } } */
+
+void abort ();
+
+#define N 256
+signed char ca[N] __attribute__((aligned(16)));
+signed char cb[N] __attribute__((aligned(16)));
+signed char cc[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = cb[i] - cc[i];
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = i - 128;
+    cc[i] = i/2 - 64;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (ca[i] != i - i/2 - 64)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-10.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-10.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-10.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,42 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+
+void abort ();
+
+#define N 4096
+int ca[N] __attribute__((aligned(16)));
+int cb[N] __attribute__((aligned(16)));
+int cc[N] __attribute__((aligned(16)));
+int cd[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = 3 * i - 2048;
+    cc[i] = -5 * i + 93;
+    cd[i] = i % 2 ? 1 : -1;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)
+      abort ();
+    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-3.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler-not "xxpermdi" } } */
+
+void abort ();
+
+#define N 4096
+signed char ca[N] __attribute__((aligned(16)));
+signed char cb[N] __attribute__((aligned(16)));
+signed char cc[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = cb[i] - cc[i];
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i, ii;
+  for (i = 0, ii = 0; i < N; ++i, ii = (ii + 1) % 128) {
+    cb[i] = ii - 128;
+    cc[i] = ii/2 - 64;
+  }
+}
+
+int main ()
+{
+  int i, ii;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i) {
+    ii = i % 128;
+    if (ca[i] != ii - ii/2 - 64)
+      abort ();
+  }
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr53199.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr53199.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr53199.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-options "-O2 -mcpu=power6 -mavoid-indexed-addresses" } */
-/* { dg-final { scan-assembler-times "lwbrx" 6 } } */
+/* { dg-final { scan-assembler-times "lwbrx" 12 } } */
 /* { dg-final { scan-assembler-times "stwbrx" 6 } } */
 
 /* PR 51399: bswap gets an error if -mavoid-indexed-addresses was used in
@@ -25,6 +25,24 @@
   return __builtin_bswap64 (p[i]);
 }
 
+long long
+load64_reverse_4 (long long dummy __attribute__ ((unused)), long long *p)
+{
+  return __builtin_bswap64 (*p);
+}
+
+long long
+load64_reverse_5 (long long dummy __attribute__ ((unused)), long long *p)
+{
+  return __builtin_bswap64 (p[1]);
+}
+
+long long
+load64_reverse_6 (long long dummy __attribute__ ((unused)), long long *p, int i)
+{
+  return __builtin_bswap64 (p[i]);
+}
+
 void
 store64_reverse_1 (long long *p, long long x)
 {
@@ -44,7 +62,13 @@
 }
 
 long long
-reg_reverse (long long x)
+reg_reverse_1 (long long x)
 {
   return __builtin_bswap64 (x);
 }
+
+long long
+reg_reverse_2 (long long dummy __attribute__ ((unused)), long long x)
+{
+  return __builtin_bswap64 (x);
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-11.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-11.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-11.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+
+#include <altivec.h>
+void abort ();
+
+#define N 4096
+int ca[N] __attribute__((aligned(16)));
+int cb[N] __attribute__((aligned(16)));
+int cc[N] __attribute__((aligned(16)));
+int cd[N] __attribute__((aligned(16)));
+int hey;
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  vector int va, vb, vc, vd, tmp;
+  vector unsigned int threes = vec_splat_u32(3);
+  for (i = 0; i < N; i+=4) {
+    vb = vec_vsx_ld (0, &cb[i]);
+    vc = vec_vsx_ld (0, &cc[i]);
+    vd = vec_vsx_ld (0, &cd[i]);
+    tmp = vec_add (vb, vc);
+    tmp = vec_sub (tmp, vd);
+    tmp = vec_sra (tmp, threes);
+    hey = tmp[3];
+    vec_vsx_st (tmp, 0, &ca[i]);
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = 3 * i - 2048;
+    cc[i] = -5 * i + 93;
+    cd[i] = i + 14;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (ca[i] != (-3 * i - 1969) >> 3)
+      abort ();
+  if (hey != ca[N-1])
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/swaps-p8-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,45 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-final { scan-assembler "lxvd2x" } } */
+/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler-not "xxpermdi" } } */
+
+void abort ();
+
+#define N 4096
+int ca[N] __attribute__((aligned(16)));
+int cb[N] __attribute__((aligned(16)));
+int cc[N] __attribute__((aligned(16)));
+int cd[N] __attribute__((aligned(16)));
+
+__attribute__((noinline)) void foo ()
+{
+  int i;
+  for (i = 0; i < N; i++) {
+    ca[i] = (cb[i] + cc[i]) * cd[i];
+  }
+}
+
+__attribute__((noinline)) void init ()
+{
+  int i;
+  for (i = 0; i < N; ++i) {
+    cb[i] = 3 * i - 2048;
+    cc[i] = -5 * i + 93;
+    cd[i] = i % 2 ? 1 : -1;
+  }
+}
+
+int main ()
+{
+  int i;
+  init ();
+  foo ();
+  for (i = 0; i < N; ++i)
+    if (i % 2 == 1 && ca[i] != -2 * i - 1955)
+      abort ();
+    else if (i % 2 == 0 && ca[i] != 1955 + 2 * i)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/divzero.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/divzero.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/arm/divzero.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,85 @@
+/* { dg-require-effective-target arm_eabi } */
+/* { dg-options "" } */
+/* { dg-do run } */
+
+/* Check that long long divmod functions pass the right argument to
+   __aeabi_ldiv0 on divide by zero.  */
+
+#ifdef DEBUGME
+#include <stdio.h>
+#else
+extern void abort (void);
+#endif
+
+/* Override div zero handler and simply return the provided value.  */
+long long __aeabi_ldiv0 (long long r)
+{
+  return r;
+}
+
+long long lldiv (long long a, long long b)
+{
+  return a / b;
+}
+
+unsigned long long ulldiv (unsigned long long a, unsigned long long b)
+{
+  return a / b;
+}
+
+void check (long long num, long long expected)
+{
+  long long res = lldiv (num, 0LL);
+  if (res != expected)
+#ifdef DEBUGME
+    {
+      printf ("num=%08X:%08X\n", (unsigned)(num >> 32), (unsigned)num);
+      printf ("res=%08X:%08X\n", (unsigned)(res >> 32), (unsigned)res);
+    }
+#else
+    abort ();
+#endif
+}
+
+void ucheck (unsigned long long num, unsigned long long expected)
+{
+  unsigned long long res = ulldiv (num, 0ULL);
+  if (res != expected)
+#ifdef DEBUGME
+    {
+      printf ("num=%08X:%08X\n", (unsigned)(num >> 32), (unsigned)num);
+      printf ("res=%08X:%08X\n", (unsigned)(res >> 32), (unsigned)res);
+    }
+#else
+    abort ();
+#endif
+}
+
+#define POS_BIG 0x7fffffffffffffffLL
+#define NEG_BIG 0x8000000000000000LL
+#define UNS_BIG 0xffffffffffffffffULL
+
+int main ()
+{
+  check (0LL, 0LL);
+  check (1LL, POS_BIG);
+  check (0x000000007fffffffLL, POS_BIG);
+  check (0x00000000ffffffffLL, POS_BIG);
+  check (0x0000000100000000LL, POS_BIG);
+  check (POS_BIG, POS_BIG);
+  check (-1LL, NEG_BIG);
+  check (-0x000000007fffffffLL, NEG_BIG);
+  check (-0x00000000ffffffffLL, NEG_BIG);
+  check (-0x0000000100000000LL, NEG_BIG);
+  check (NEG_BIG, NEG_BIG);
+
+  ucheck (0ULL, 0ULL);
+  ucheck (1ULL, UNS_BIG);
+  ucheck (0x000000007fffffffULL, UNS_BIG);
+  ucheck (0x00000000ffffffffULL, UNS_BIG);
+  ucheck (0x0000000100000000ULL, UNS_BIG);
+  ucheck ((unsigned long long)POS_BIG, UNS_BIG);
+  ucheck (UNS_BIG, UNS_BIG);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/pr64453.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr64453.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr64453.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mthumb -Os " }  */
+/* { dg-require-effective-target arm_thumb1_ok } */
+
+void save_regs () {
+  __asm volatile ("" ::: "r8");
+}
+
+/* { dg-final { scan-assembler "\tmov\tr., r8" } } */
Index: gcc/testsuite/gcc.target/arm/constant-pool.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/constant-pool.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/arm/constant-pool.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+unsigned short v = 0x5678;
+int i;
+int j = 0;
+int *ptr = &j;
+
+int
+func (void)
+{
+  for (i = 0; i < 1; ++i)
+    {
+      *ptr = -1;
+      v = 0x1234;
+    }
+  return v;
+}
+
+int
+main (void)
+{
+  func ();
+  if (v != 0x1234)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/aarch64/pr63424.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr63424.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr63424.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+#include <stdint.h>
+
+uint32_t
+truncate_int (const unsigned long long value)
+{
+  if ( value < 0 )
+    {
+      return 0;
+    }
+  else if ( value > UINT32_MAX )
+    {
+      return UINT32_MAX;
+    }
+  else
+    return (uint32_t)value;
+}
+
+uint32_t
+mul (const unsigned long long x, const unsigned long long y)
+{
+  uint32_t value = truncate_int (x * y);
+  return value;
+}
+
+uint32_t *
+test(unsigned size, uint32_t *a, uint32_t s)
+{
+  unsigned i;
+
+  for (i = 0; i < size; i++)
+    {
+      a[i] = mul (a[i], s);
+    }
+
+  return a;
+}
Index: gcc/testsuite/gcc.target/aarch64/pr65235_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr65235_1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr65235_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#include "arm_neon.h"
+
+int
+main (int argc, char** argv)
+{
+  int64x1_t val1;
+  int64x1_t val2;
+  int64x1_t val3;
+  uint64x1_t val13;
+  uint64x2_t val14;
+  uint64_t got;
+  uint64_t exp;
+  val1 = vcreate_s64(UINT64_C(0xffffffff80008000));
+  val2 = vcreate_s64(UINT64_C(0x0000f38d00000000));
+  val3 = vcreate_s64(UINT64_C(0xffff7fff0000809b));
+  /* Expect: "val13" = 8000000000001553.  */
+  val13 = vcreate_u64 (UINT64_C(0x8000000000001553));
+  /* Expect: "val14" = 0010 0000 0000 0002 0000 0000 0000 0000.  */
+  val14 = vcombine_u64(vcgt_s64(vqrshl_s64(val1, val2),
+				vshr_n_s64(val3, 18)),
+		       vshr_n_u64(val13, 11));
+  /* Should be 0000000000000000.  */
+  got = vgetq_lane_u64(val14, 0);
+  exp = 0;
+  if(exp != got)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.target/aarch64/sisd-shft-neg_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/sisd-shft-neg_1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/sisd-shft-neg_1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,38 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-inline" } */
+
+extern void abort (void);
+
+#define force_simd_si(v) asm volatile ("mov %s0, %1.s[0]" :"=w" (v) :"w" (v) :)
+
+unsigned int
+shft_add (unsigned int a, unsigned int b)
+{
+  unsigned int c;
+
+  force_simd_si (a);
+  force_simd_si (b);
+  c = a >> b;
+  force_simd_si (c);
+
+  return c + b;
+}
+
+int
+main (void)
+{
+  unsigned int i = 0;
+  unsigned int a = 0xdeadbeef;
+
+  for (i = 0; i < 32; i++)
+  {
+    unsigned int exp = (a / (1 << i) + i);
+    unsigned int got = shft_add (a, i);
+
+    if (exp != got)
+      abort ();
+  }
+
+  return 0;
+}
+
Index: gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,37 @@
+/* { dg-do compile } */
+
+void ice_mult32 (int x)
+{
+  register long reg __asm ("22");
+  __asm volatile (" " :: "r" (reg = 0x12345 * x));
+}
+
+void ice_mult24 (int x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = 0x12345 * x));
+}
+
+void ice_sh24 (__int24 x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = x << 3));
+}
+
+void ice_sh24b (__int24 x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = x << 22));
+}
+
+void ice_s16s16 (int x)
+{
+  register long reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = (long) x*x));
+}
+
+void ice_u16s16 (int x)
+{
+  register long reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = (long) x*0x1234u));
+}
Index: gcc/testsuite/gcc.target/avr/torture/pr64331.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/torture/pr64331.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/avr/torture/pr64331.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+
+typedef struct
+{
+  unsigned a, b;
+} T2;
+
+
+__attribute__((__noinline__, __noclone__))
+void foo2 (T2 *t, int x)
+{
+  if (x != t->a)
+    {
+      t->a = x;
+  
+      if (x && x == t->b)
+	t->a = 20;
+    }
+}
+
+
+T2 t;
+
+int main (void)
+{
+  t.a = 1;
+  t.b = 1234;
+
+  foo2 (&t, 1234);
+
+  if (t.a != 20)
+    __builtin_abort();
+
+  __builtin_exit (0);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/avr/torture/pr64452.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/torture/pr64452.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/avr/torture/pr64452.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c99" } */
+
+struct A
+{
+    char str[8];
+    void* v;
+};
+
+int varf (char* fmt, ...);
+
+void foo (struct A a, struct A b)
+{
+    varf ("%s%s", b.str, b.str);
+}
+
+long long x64;
+
+void foo2 (long long j0,
+           struct A a, struct A b, struct A c, struct A d,
+           struct A e, struct A f, struct A g, struct A h, struct A i,
+           long long j1)
+{
+    varf ("%s%s", i.str, i.str, x64, j1+j0);
+}
+
+
+void foo3 (long long j0,
+           struct A a, struct A b, struct A c, struct A d,
+           struct A e, struct A f, struct A g, struct A h, struct A i,
+           long long j1)
+{
+    varf ("%s%s", &i.str, &b.str, x64, j1+j0);
+}
Index: gcc/testsuite/gcc.target/i386/pr63637-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63637-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63637-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a) : "r" (0) : "eax");
+  asm ("# Magic instruction" : "=r" (b) : "r" (0) : "edx");
+  asm ("# Magic instruction" : "=r" (c) : "r" (0) : "ecx");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 1 } } */
Index: gcc/testsuite/gcc.target/i386/memcpy-strategy-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/memcpy-strategy-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/memcpy-strategy-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+/* PR target/64200 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=atom -mmemcpy-strategy=libcall:-1:align -minline-stringops-dynamically" } */
+
+#include <stdarg.h>
+
+extern void bar(char *x);
+
+void foo (int size, ...)
+{
+  struct
+  {
+    char x[size];
+  } d;
+
+  va_list ap;
+  va_start(ap, size);
+  d = va_arg(ap, typeof (d));
+  va_end(ap);
+  bar(d.x);
+}
Index: gcc/testsuite/gcc.target/i386/pr63637-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63637-6.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63637-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c, d, e, f;
+  asm ("# Magic instruction" : "=r" (a), "=r" (d) : "r" (0) : "eax");
+  asm ("# Magic instruction" : "=r" (b), "=r" (e) : "r" (0) : "edx");
+  asm ("# Magic instruction" : "=r" (c), "=r" (f) : "r" (0) : "ecx");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.target/i386/pr64409.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr64409.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr64409.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,6 @@
+/* { dg-do compile { target { ! { ia32 } } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-O0 -mx32" } */
+
+int a;
+int* __attribute__ ((ms_abi)) fn1 () { return &a; } /* { dg-error "X32 does not support ms_abi attribute" } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-store-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-7.c	(.../branches/gcc-4_9-branch)
@@ -29,13 +29,13 @@
   ap = ep;
   bp = fp;
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       *ap++ = str;
       *bp++ = str;
     }
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       if (strcmp (*--ap, "STR") != 0)
 	abort ();
Index: gcc/testsuite/gcc.target/i386/pr63661.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63661.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63661.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,80 @@
+/* PR target/63661 */
+/* { dg-do run } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-mtune=nehalem -fPIC -O2" } */
+
+static void __attribute__((noinline,noclone,hot))
+foo (double a, double q, double *ff, double *gx, int e, int ni)
+{
+  union
+    {
+      double n;
+      unsigned long long o;
+    } punner;
+  double d;
+
+  punner.n = q;
+   __builtin_printf("B: 0x%016llx ---- %g\n", punner.o, q);
+
+  d = q - 5;
+  if(d < 0)
+    d = -d;
+  if (d > 0.1)
+    __builtin_abort();
+}
+
+static int __attribute__((noinline,noclone,hot))
+bar (int order, double q, double c[])
+{
+  int ni, nn, i, e;
+  double g2, x2, de, s, ratio, ff;
+
+  nn = 0;
+  e = order & 1;
+  s = 0;
+  ratio = 0;
+  x2 = 0;
+  g2 = 0;
+
+  if(q == 0.0)
+    return 0;
+
+  if (order < 5)
+    {
+      ratio = 1.0 / q;
+      nn = order;
+    }
+
+  ni = -nn;
+
+  while(1)
+    {
+      de = ratio - g2 - x2;
+
+      foo (0, q, &ff, &g2, e, ni);
+
+      if((int)de == 0)
+        break;
+    }
+
+  s += 2 * nn * c[nn];
+
+  for (i = 0; i < 1; i++)
+    {
+      c[0] = nn;
+      for (; i < 10; i++)
+        c[i] = 0.0;
+      c[0] /= s;
+    }
+
+  return 0;
+}
+
+int
+main ()
+{
+  double c[1000];
+
+  bar (1, 5.0, c);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr63538.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63538.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63538.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* PR target/63538 */
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O2 -mcmodel=medium -mlarge-data-threshold=0" } */
+
+static char *str = "Hello World";
+
+char *foo ()
+{
+  return str;
+}
+
+/* { dg-final { scan-assembler "movabs" } } */
Index: gcc/testsuite/gcc.target/i386/sse-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse-14.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse-14.c	(.../branches/gcc-4_9-branch)
@@ -600,6 +600,8 @@
 
 /* emmintrin.h */
 test_2 (_mm_shuffle_pd, __m128d, __m128d, __m128d, 1)
+test_1 (_mm_bsrli_si128, __m128i, __m128i, 1)
+test_1 (_mm_bslli_si128, __m128i, __m128i, 1)
 test_1 (_mm_srli_si128, __m128i, __m128i, 1)
 test_1 (_mm_slli_si128, __m128i, __m128i, 1)
 test_1 (_mm_extract_epi16, int, __m128i, 1)
Index: gcc/testsuite/gcc.target/i386/pr57003.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr57003.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr57003.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* PR rtl-optimization/57003 */
-/* { dg-do run } */
+/* { dg-do run { target { ! x32 } } } */
 /* { dg-options "-O2" } */
 
 #define N 2001
Index: gcc/testsuite/gcc.target/i386/pr63637-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63637-3.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63637-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a) : : "eax", "memory");
+  asm ("# Magic instruction" : "=r" (b) : : "edx", "memory");
+  asm ("# Magic instruction" : "=r" (c) : : "ecx", "memory");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.target/i386/pr64387.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr64387.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr64387.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-vectorize -ffloat-store -mavx512er" } */
+
+float x[256];
+
+double *
+foo (void)
+{
+  double *z = __builtin_malloc (sizeof (double) * 256);
+  int i;
+  for (i = 0; i < 256; ++i)
+    z[i] = x[i] + 1.0f;
+  foo ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/builtin_target.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/builtin_target.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/builtin_target.c	(.../branches/gcc-4_9-branch)
@@ -30,6 +30,14 @@
 	      /* Atom.  */
 	      assert (__builtin_cpu_is ("atom"));
 	      break;
+	    case 0x37:
+	    case 0x4a:
+	    case 0x4d:
+	    case 0x5a:
+	    case 0x5d:
+	      /* Silvermont.  */
+	      assert (__builtin_cpu_is ("silvermont"));
+	      break;
 	    case 0x1a:
 	    case 0x1e:
 	    case 0x1f:
@@ -46,10 +54,32 @@
 	      assert (__builtin_cpu_is ("westmere"));
 	      break;
 	    case 0x2a:
+	    case 0x2d:
 	      /* Sandy Bridge.  */
 	      assert (__builtin_cpu_is ("corei7"));
 	      assert (__builtin_cpu_is ("sandybridge"));
 	      break;
+	    case 0x3a:
+	    case 0x3e:
+	      /* Ivy Bridge.  */
+	      assert (__builtin_cpu_is ("corei7"));
+	      assert (__builtin_cpu_is ("ivybridge"));
+	      break;
+	    case 0x3c:
+	    case 0x3f:
+	    case 0x45:
+	    case 0x46:
+	      /* Haswell.  */
+	      assert (__builtin_cpu_is ("corei7"));
+	      assert (__builtin_cpu_is ("haswell"));
+	      break;
+	    case 0x3d:
+	    case 0x4f:
+	    case 0x56:
+	      /* Broadwell.  */
+	      assert (__builtin_cpu_is ("corei7"));
+	      assert (__builtin_cpu_is ("broadwell"));
+	      break;
 	    case 0x17:
 	    case 0x1d:
 	      /* Penryn.  */
Index: gcc/testsuite/gcc.target/i386/sse-22.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/sse-22.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/sse-22.c	(.../branches/gcc-4_9-branch)
@@ -137,6 +137,8 @@
 #endif
 #include <emmintrin.h>
 test_2 (_mm_shuffle_pd, __m128d, __m128d, __m128d, 1)
+test_1 (_mm_bsrli_si128, __m128i, __m128i, 1)
+test_1 (_mm_bslli_si128, __m128i, __m128i, 1)
 test_1 (_mm_srli_si128, __m128i, __m128i, 1)
 test_1 (_mm_slli_si128, __m128i, __m128i, 1)
 test_1 (_mm_extract_epi16, int, __m128i, 1)
@@ -268,6 +270,8 @@
 test_1 ( _mm256_shuffle_epi32, __m256i, __m256i, 1)
 test_1 ( _mm256_shufflehi_epi16, __m256i, __m256i, 1)
 test_1 ( _mm256_shufflelo_epi16, __m256i, __m256i, 1)
+test_1 ( _mm256_bslli_epi128, __m256i, __m256i, 8)
+test_1 ( _mm256_bsrli_epi128, __m256i, __m256i, 8)
 test_1 ( _mm256_slli_si256, __m256i, __m256i, 8)
 test_1 ( _mm256_srli_si256, __m256i, __m256i, 8)
 test_2 ( _mm_blend_epi32, __m128i, __m128i, __m128i, 1)
Index: gcc/testsuite/gcc.target/i386/pr60516.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr60516.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr60516.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* PR target/60516 */
-/* { dg-do compile } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-O2" } */
 
 struct S { char c[65536]; };
Index: gcc/testsuite/gcc.target/i386/pr63637-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63637-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63637-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a) : "r" (0) : "eax", "memory");
+  asm ("# Magic instruction" : "=r" (b) : "r" (0) : "edx", "memory");
+  asm ("# Magic instruction" : "=r" (c) : "r" (0) : "ecx", "memory");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-load-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-7.c	(.../branches/gcc-4_9-branch)
@@ -33,7 +33,7 @@
   cp = mp;
   dp = lp;
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       *cp++ = str;
       *dp++ = str;
@@ -44,13 +44,13 @@
   cp = mp;
   dp = lp;
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       *ap++ = *cp++;
       *bp++ = *dp++;
     }
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       if (strcmp (*--ap, "STR") != 0)
 	abort ();
Index: gcc/testsuite/gcc.target/i386/pr59927.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr59927.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr59927.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* PR target/59927 */
-/* { dg-do compile } */
+/* { dg-do compile { target { ! x32 } } } */
 /* { dg-options "-O2 -g" } */
 
 extern void baz (int) __attribute__ ((__ms_abi__));
Index: gcc/testsuite/gcc.target/i386/pr63637-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63637-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63637-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a) : : "eax");
+  asm ("# Magic instruction" : "=r" (b) : : "edx");
+  asm ("# Magic instruction" : "=r" (c) : : "ecx");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pr63637-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63637-5.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63637-5.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c, d, e, f;
+  asm ("# Magic instruction" : "=r" (a), "=r" (d) : : "eax");
+  asm ("# Magic instruction" : "=r" (b), "=r" (e) : : "edx");
+  asm ("# Magic instruction" : "=r" (c), "=r" (f) : : "ecx");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.target/i386/pr63947.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63947.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63947.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR target/63947 */
+/* { dg-do assemble } */
+/* { dg-options "-Os" } */
+/* { dg-additional-options "-march=i686" { target ia32 } } */
+
+long double foo (unsigned a, unsigned b)
+{
+  return a + b < a;
+}
Index: gcc/testsuite/gcc.target/i386/pr64513.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr64513.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr64513.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* PR target/64513 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mstack-arg-probe" } */
+
+struct A {};
+struct B { struct A y; };
+int foo (struct A);
+
+int
+bar (int x)
+{
+  struct B b;
+  int c;
+  while (x--)
+    c = foo (b.y);
+  return c;
+}
Index: gcc/testsuite/gcc.target/i386/pr60851.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr60851.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr60851.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -flive-range-shrinkage -mtune=bdver4 -mdispatch-scheduler" } */
+
+long double ld (char c)
+{
+  return c;
+}
Index: gcc/testsuite/gcc.target/i386/avx2-pr64286.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx2-pr64286.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx2-pr64286.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,37 @@
+/* PR rtl-optimization/64286 */
+/* { dg-do run } */
+/* { dg-options "-O2 -mavx2" } */
+/* { dg-require-effective-target avx2 } */
+
+#include <string.h>
+#include <stdlib.h>
+#include <x86intrin.h>
+#include "avx2-check.h"
+
+__m128i v;
+__m256i w;
+
+__attribute__((noinline, noclone)) void
+foo (__m128i *p, __m128i *q)
+{
+  __m128i a = _mm_loadu_si128 (p);
+  __m128i b = _mm_xor_si128 (a, v);
+  w = _mm256_cvtepu8_epi16 (a);
+  *q = b;
+}
+
+static void
+avx2_test (void)
+{
+  v = _mm_set1_epi8 (0x40);
+  __m128i c = _mm_set_epi8 (16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);
+  __m128i d;
+  foo (&c, &d);
+  __m128i e = _mm_set_epi8 (0x50, 0x4f, 0x4e, 0x4d, 0x4c, 0x4b, 0x4a, 0x49,
+			    0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41);
+  __m256i f = _mm256_set_epi16 (16, 15, 14, 13, 12, 11, 10, 9,
+				8, 7, 6, 5, 4, 3, 2, 1);
+  if (memcmp (&w, &f, sizeof (w)) != 0
+      || memcmp (&d, &e, sizeof (d)) != 0)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/memset-strategy-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/memset-strategy-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/memset-strategy-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR target/64108 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=atom -mmemset-strategy=libcall:-1:align -minline-all-stringops" } */
+
+char a[2048];
+void t (void)
+{
+  __builtin_memset (a, 1, 2048);
+}
+
Index: gcc/testsuite/gcc.target/s390/hotpatch-16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-16.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-16.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,0" } */
+
+#include <stdio.h>
+
+__attribute__ ((hotpatch(1,2)))
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
+/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-1.c	(.../branches/gcc-4_9-branch)
@@ -1,27 +1,5 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch" } */
-
-#include <stdio.h>
-
-void hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-inline void hp2(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((always_inline))
-void hp3(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp3' with the 'always_inline' attribute is not hotpatchable" } */
-
-int main (void)
-{
-  return 0;
-}
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=-1,0" } */
+/* { dg-error "arguments to .-mhotpatch=n,m. should be non-negative integers" "" { target *-*-* } 1 } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-18.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-18.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-18.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=1,2 -mhotpatch=0,0" } */
+
+#include <stdio.h>
+
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-3.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-3.c	(.../branches/gcc-4_9-branch)
@@ -1,27 +1,5 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch=1" } */
-
-#include <stdio.h>
-
-void hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-inline void hp2(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((always_inline))
-void hp3(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp3' with the 'always_inline' attribute is not hotpatchable" } */
-
-int main (void)
-{
-  return 0;
-}
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0" } */
+/* { dg-error "arguments to .-mhotpatch=n,m. should be non-negative integers" "" { target *-*-* } 1 } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-5.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-5.c	(.../branches/gcc-4_9-branch)
@@ -1,28 +1,5 @@
 /* Functional tests for the function hotpatching feature.  */
 
 /* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -mhotpatch=1000000" } */
-
-#include <stdio.h>
-
-void hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch(1000000)))
-void hp2(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch(1000001)))
-void hp3(void)
-{ /* { dg-error "requested 'hotpatch' attribute is not a non-negative integer constant or too large .max. 1000000." } */
-  printf("hello, world!\n");
-}
-
-int main (void)
-{
-  return 0;
-}
+/* { dg-options "-O3 -mzarch -mhotpatch=a,0" } */
+/* { dg-error "arguments to .-mhotpatch=n,m. should be non-negative integers" "" { target *-*-* } 1 } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-7.c	(.../branches/gcc-4_9-branch)
@@ -1,68 +1,10 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mno-hotpatch" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
 
-#include <stdio.h>
-
-__attribute__ ((hotpatch))
-void hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch))
-inline void hp2(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch))
-__attribute__ ((always_inline))
-void hp3(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp3' with the 'always_inline' attribute is not hotpatchable" } */
-
-__attribute__ ((hotpatch(0)))
-void hp4(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch(0)))
-inline void hp5(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch(0)))
-__attribute__ ((always_inline))
-void hp6(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp6' with the 'always_inline' attribute is not hotpatchable" } */
-
-__attribute__ ((hotpatch(1)))
-void hp7(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch(1)))
-inline void hp8(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((hotpatch(1)))
-__attribute__ ((always_inline))
-void hp9(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp9' with the 'always_inline' attribute is not hotpatchable" } */
-
+__attribute__((hotpatch(-1,0)))
 int main (void)
-{
+{/* { dg-error "attribute is not a comma separated pair of non-negative integer constants or too large" } */
   return 0;
 }
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-9.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-9.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+__attribute__((hotpatch(0)))
+int main (void)
+{/* { dg-error "wrong number of arguments specified" } */
+  return 0;
+}
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-10.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-10.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-10.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+__attribute__((hotpatch(0,0,0)))
+int main (void)
+{/* { dg-error "wrong number of arguments specified" } */
+  return 0;
+}
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-12.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-12.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+int a;
+
+__attribute__((hotpatch(0,a)))
+int main (void)
+{ /* { dg-error "attribute is not a comma separated pair of non-negative integer constants or too large" } */
+  return 0;
+}
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-14.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-14.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=1000001,1000000" } */
+
+viod main(void)
+{
+  return 0;
+}
+
+/* { dg-error "argument to .-mhotpatch=n,m. is too large" "" { target *-*-* } 1 } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+/* A warning will be issued when requesting hotpatching on a nested function.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+typedef int (*fn_t)(void);
+
+fn_t hp1(void)
+{
+  __attribute__((hotpatch(0,0)))
+  int nested1(void)
+  { return 1; }
+
+  return nested1;
+}
+
+fn_t hp2(void)
+{
+  __attribute__ ((hotpatch(1,2)))
+  int nested2(void) /* { dg-warning "hotpatching is not compatible with nested functions" } */
+  { return 2; }
+
+  return nested2;
+}
Index: gcc/testsuite/gcc.target/s390/hotpatch-21.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-21.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-21.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,1" } */
+
+#include <stdio.h>
+
+void __attribute__ ((aligned(512))) hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "\.align\t512" 2 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-23.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-23.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-23.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,1 -falign-functions=4096" } */
+
+#include <stdio.h>
+
+void __attribute__ ((aligned(2048))) hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "\.align\t2048" 2 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-1.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
 
 #include <stdio.h>
 
@@ -10,11 +10,7 @@
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-times "nopr\t%r7" 12 } } */
-/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-3.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-3.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch=0 --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,2" } */
 
 #include <stdio.h>
 
@@ -10,11 +10,7 @@
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-5.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-5.c	(.../branches/gcc-4_9-branch)
@@ -1,21 +1,16 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,4" } */
 
 #include <stdio.h>
 
-__attribute__ ((hotpatch))
 void hp1(void)
 {
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-times "nopr\t%r7" 12 } } */
-/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-times "brcl\t0, 0" 1 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-7.c	(.../branches/gcc-4_9-branch)
@@ -1,21 +1,16 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,6" } */
 
 #include <stdio.h>
 
-__attribute__ ((hotpatch(0)))
 void hp1(void)
 {
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
-/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-times "brcl\t0, 0" 2 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-9.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-9.c	(.../branches/gcc-4_9-branch)
@@ -1,21 +1,16 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch=1 --save-temps" } */
+/* { dg-do compile { target { ! lp64 } } } */
+/* { dg-options "-O3 -mesa -march=g5 -mhotpatch=0,4" } */
 
 #include <stdio.h>
 
-__attribute__ ((hotpatch(2)))
 void hp1(void)
 {
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-times "nopr\t%r7" 2 } } */
-/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
+/* { dg-final { scan-assembler-times "nop\t0" 2 } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-11.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-11.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-11.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch -mno-hotpatch --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=1,0" } */
 
 #include <stdio.h>
 
@@ -10,11 +10,7 @@
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-13.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-13.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+#include <stdio.h>
+
+__attribute__ ((hotpatch(1,0)))
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-15.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-15.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-15.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+#include <stdio.h>
+
+__attribute__ ((hotpatch(1,2)))
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
+/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-17.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-17.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-17.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=1,2" } */
+
+#include <stdio.h>
+
+__attribute__ ((hotpatch(0,0)))
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-2.c	(.../branches/gcc-4_9-branch)
@@ -1,27 +1,5 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch=0" } */
-
-#include <stdio.h>
-
-void hp1(void)
-{
-  printf("hello, world!\n");
-}
-
-inline void hp2(void)
-{
-  printf("hello, world!\n");
-}
-
-__attribute__ ((always_inline))
-void hp3(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp3' with the 'always_inline' attribute is not hotpatchable" } */
-
-int main (void)
-{
-  return 0;
-}
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,-1" } */
+/* { dg-error "arguments to .-mhotpatch=n,m. should be non-negative integers" "" { target *-*-* } 1 } */
Index: gcc/testsuite/gcc.target/s390/pr57559.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/pr57559.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/pr57559.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* PR rtl-optimization/57559  */
 
 /* { dg-do compile } */
-/* { dg-options "-march=z10 -m64 -mzarch  -O1" } */
+/* { dg-options "-march=z10 -mzarch  -O1" } */
 
 typedef int int32_t;
 typedef unsigned char uint8_t;
Index: gcc/testsuite/gcc.target/s390/20140327-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/20140327-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/20140327-1.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
-/* { dg-do compile } */
-/* { dg-options "-O3 -m31 -mzarch" } */
+/* { dg-do compile { target { ! lp64 } } } */
+/* { dg-options "-O3 -mzarch" } */
 
 void
 foo ()
Index: gcc/testsuite/gcc.target/s390/hotpatch-19.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-19.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-19.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=1,2" } */
+
+#include <stdio.h>
+
+/* { dg-prune-output "always_inline function might not be inlinable" } */
+__attribute__ ((always_inline))
+static void hp2(void)
+{
+  printf("hello, world!\n");
+}
+
+void hp1(void)
+{
+  hp2();
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
+/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-4.c	(.../branches/gcc-4_9-branch)
@@ -1,11 +1,5 @@
 /* Functional tests for the function hotpatching feature.  */
 
 /* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -mhotpatch=-1" } */
-
-int main (void)
-{
-  return 0;
-}
-
-/* { dg-excess-errors "argument to '-mhotpatch=' should be a non-negative integer" } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,0,0" } */
+/* { dg-error "arguments to .-mhotpatch=n,m. should be non-negative integers" "" { target *-*-* } 1 } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-6.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-6.c	(.../branches/gcc-4_9-branch)
@@ -1,11 +1,5 @@
 /* Functional tests for the function hotpatching feature.  */
 
 /* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -mhotpatch=1000001" } */
-
-int main (void)
-{
-  return 0;
-}
-
-/* { dg-excess-errors "argument to '-mhotpatch=' is too large .max. 1000000." } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,a" } */
+/* { dg-error "arguments to .-mhotpatch=n,m. should be non-negative integers" "" { target *-*-* } 1 } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-8.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-8.c	(.../branches/gcc-4_9-branch)
@@ -1,23 +1,10 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
 
-#include <stdio.h>
-
-int hp1(void)
-{
-  int nested1(void) /* { dg-warning "hotpatching is not compatible with nested functions" } */
-  { return 1; }
-
-  __attribute__ ((hotpatch))
-  int nested2(void) /* { dg-warning "hotpatching is not compatible with nested functions" } */
-  { return 1; }
-
-  return nested1() - nested2();
-}
-
+__attribute__((hotpatch(0,-1)))
 int main (void)
-{
-  return hp1();
+{/* { dg-error "attribute is not a comma separated pair of non-negative integer constants or too large" } */
+  return 0;
 }
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-11.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-11.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-11.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+int a;
+
+__attribute__((hotpatch(a,0)))
+int main (void)
+{ /* { dg-error "attribute is not a comma separated pair of non-negative integer constants or too large" } */
+  return 0;
+}
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-13.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-13.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=1000000,1000000" } */
+
+#include <stdio.h>
+
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+__attribute__ ((hotpatch(1000000,1000000)))
+void hp2(void)
+{
+  printf("hello, world!\n");
+}
+
+__attribute__ ((hotpatch(1000001,1000000)))
+void hp3(void)
+{ /* { dg-error " requested .hotpatch. attribute is not a comma separated pair" } */
+  printf("hello, world!\n");
+}
+
+__attribute__ ((hotpatch(1000000,1000001)))
+void hp4(void)
+{ /* { dg-error " requested .hotpatch. attribute is not a comma separated pair" } */
+  printf("hello, world!\n");
+}
Index: gcc/testsuite/gcc.target/s390/hotpatch-compile-15.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-15.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-compile-15.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+/* { dg-prune-output "always_inline function might not be inlinable" } */
+/* { dg-prune-output "called from here" } */
+
+#include <stdio.h>
+
+__attribute__ ((hotpatch(1,2)))
+static void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+__attribute__ ((hotpatch(1,2)))
+static inline void hp2(void)
+{
+  printf("hello, world!\n");
+}
+
+__attribute__ ((hotpatch(0,0)))
+__attribute__ ((always_inline))
+static void hp3(void)
+{
+  printf("hello, world!\n");
+}
+
+__attribute__ ((hotpatch(1,2)))
+__attribute__ ((always_inline))
+static void hp4(void)
+{
+  printf("hello, world!\n");
+}
+
+void main(void)
+{
+  hp1();
+  hp2();
+  hp3();
+  hp4();
+}
Index: gcc/testsuite/gcc.target/s390/htm-nofloat-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/htm-nofloat-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/htm-nofloat-1.c	(.../branches/gcc-4_9-branch)
@@ -48,3 +48,4 @@
 /* Make sure no FPR saves/restores are emitted.  */
 /* { dg-final { scan-assembler-not "\tstd\t" } } */
 /* { dg-final { scan-assembler-not "\tld\t" } } */
+/* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-20.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-20.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-20.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,20 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+#include <stdio.h>
+
+/* { dg-prune-output "always_inline function might not be inlinable" } */
+__attribute__ ((hotpatch(1,2)))
+__attribute__ ((always_inline))
+static void hp2(void)
+{
+  printf("hello, world!\n");
+}
+
+/* { dg-prune-output "called from here" } */
+void hp1(void)
+{
+  hp2();
+}
Index: gcc/testsuite/gcc.target/s390/hotpatch-22.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-22.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-22.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,1 -falign-functions=1024" } */
+
+#include <stdio.h>
+
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "\.align\t1024" 2 } } */
Index: gcc/testsuite/gcc.target/s390/pr57960.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/pr57960.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/pr57960.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* PR rtl-optimization/57960  */
 
 /* { dg-do compile } */
-/* { dg-options "-march=z10 -m64 -mzarch  -O1" } */
+/* { dg-options "-march=z10 -mzarch  -O1" } */
 
 typedef union
 {
Index: gcc/testsuite/gcc.target/s390/hotpatch-24.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-24.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-24.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,1 -falign-functions=2048" } */
+
+#include <stdio.h>
+
+void __attribute__ ((aligned(4096))) hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-times "\.align\t4096" 2 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-2.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch=1 --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,1" } */
 
 #include <stdio.h>
 
@@ -10,11 +10,8 @@
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
 /* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
-/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
+/* { dg-final { scan-assembler-times "\.align\t8" 2 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-4.c	(.../branches/gcc-4_9-branch)
@@ -1,26 +1,16 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,3" } */
 
 #include <stdio.h>
 
-inline void hp1(void)
+void hp1(void)
 {
   printf("hello, world!\n");
 }
 
-__attribute__ ((always_inline))
-void hp2(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp2' with the 'always_inline' attribute is not hotpatchable" } */
-
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
 /* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-times "brcl\t0, 0" 1 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-6.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-6.c	(.../branches/gcc-4_9-branch)
@@ -1,21 +1,16 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,5" } */
 
 #include <stdio.h>
 
-__attribute__ ((hotpatch(1)))
 void hp1(void)
 {
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
+/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
 /* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-times "brcl\t0, 0" 1 } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-8.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-8.c	(.../branches/gcc-4_9-branch)
@@ -1,28 +1,16 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mhotpatch --save-temps" } */
+/* { dg-do compile { target { ! lp64 } } } */
+/* { dg-options "-O3 -mesa -march=g5 -mhotpatch=0,3" } */
 
 #include <stdio.h>
 
-__attribute__ ((hotpatch))
-inline void hp1(void)
+void hp1(void)
 {
   printf("hello, world!\n");
 }
 
-__attribute__ ((hotpatch))
-__attribute__ ((always_inline))
-void hp2(void) /* { dg-warning "always_inline function might not be inlinable" } */
-{
-  printf("hello, world!\n");
-} /* { dg-warning "function 'hp2' with the 'always_inline' attribute is not hotpatchable" } */
-
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
-/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
+/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-10.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-10.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-10.c	(.../branches/gcc-4_9-branch)
@@ -1,21 +1,16 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mno-hotpatch --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=0,0" } */
 
 #include <stdio.h>
 
-__attribute__ ((hotpatch(2)))
 void hp1(void)
 {
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-times "nopr\t%r7" 2 } } */
-/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-12.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-12.c	(.../branches/gcc-4_9-branch)
@@ -1,7 +1,7 @@
 /* Functional tests for the function hotpatching feature.  */
 
-/* { dg-do run } */
-/* { dg-options "-O3 -mzarch -mno-hotpatch -mhotpatch=1 --save-temps" } */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -mhotpatch=999,0" } */
 
 #include <stdio.h>
 
@@ -10,11 +10,7 @@
   printf("hello, world!\n");
 }
 
-int main (void)
-{
-  return 0;
-}
-
 /* Check number of occurences of certain instructions.  */
-/* { dg-final { scan-assembler-times "nopr\t%r7" 1 } } */
-/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-times "nopr\t%r7" 999 } } */
+/* { dg-final { scan-assembler-not "nop\t0" } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/s390/hotpatch-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/hotpatch-14.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/s390/hotpatch-14.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* Functional tests for the function hotpatching feature.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch" } */
+
+#include <stdio.h>
+
+__attribute__ ((hotpatch(0,2)))
+void hp1(void)
+{
+  printf("hello, world!\n");
+}
+
+/* Check number of occurences of certain instructions.  */
+/* { dg-final { scan-assembler-not "nopr\t%r7" } } */
+/* { dg-final { scan-assembler-times "nop\t0" 1 } } */
+/* { dg-final { scan-assembler-not "brcl\t0, 0" } } */
Index: gcc/testsuite/gcc.target/h8300/pragma-isr.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/h8300/pragma-isr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/h8300/pragma-isr.c	(.../branches/gcc-4_9-branch)
@@ -18,23 +18,3 @@
 {
   foo ();
 }
-/* Check whether rte is generated for two ISRs.  */
-/* { dg-do compile { target h8300-*-* } }  */
-/* { dg-options "-O3" }  */
-/* { dg-final { scan-assembler-times "rte" 2} }  */
-
-extern void foo (void);
-
-#pragma interrupt
-void
-isr1 (void)
-{
-  foo ();
-}
-
-#pragma interrupt
-void
-isr2 (void)
-{
-  foo ();
-}
Index: gcc/testsuite/gcc.target/h8300/pragma-isr2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/h8300/pragma-isr2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/h8300/pragma-isr2.c	(.../branches/gcc-4_9-branch)
@@ -19,24 +19,3 @@
 {
   return 0;
 }
-/* Check whether rte is generated only for an ISR.  */
-/* { dg-do compile { target h8300-*-* } }  */
-/* { dg-options "-O" }  */
-/* { dg-final { scan-assembler-times "rte" 1 } }  */
-
-#pragma interrupt
-void
-isr (void)
-{
-}
-
-void
-delay (int a)
-{
-}
-
-int
-main (void)
-{
-  return 0;
-}
Index: gcc/testsuite/gcc.target/h8300/h8300.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/h8300/h8300.exp	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/h8300/h8300.exp	(.../branches/gcc-4_9-branch)
@@ -39,44 +39,3 @@
 
 # All done.
 dg-finish
-# Copyright (C) 2013-2014 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
-# (at your option) any later version.
-# 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with GCC; see the file COPYING3.  If not see
-# <http://www.gnu.org/licenses/>.
-
-# GCC testsuite that uses the `dg.exp' driver.
-
-# Exit immediately if this isn't a h8300 target.
-if ![istarget h8300*-*-*] then {
-  return
-}
-
-# Load support procs.
-load_lib gcc-dg.exp
-
-# If a testcase doesn't have special options, use these.
-global DEFAULT_CFLAGS
-if ![info exists DEFAULT_CFLAGS] then {
-    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
-}
-
-# Initialize `dg'.
-dg-init
-
-# Main loop.
-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] \
-	"" $DEFAULT_CFLAGS
-
-# All done.
-dg-finish
Index: gcc/testsuite/gcc.target/sh/pr53988.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/pr53988.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/pr53988.c	(.../branches/gcc-4_9-branch)
@@ -5,9 +5,9 @@
 /* { dg-do compile }  */
 /* { dg-options "-O1" } */
 /* { dg-skip-if "" { "sh*-*-*" } { "-m5*"} { "" } }  */
-/* { dg-final { scan-assembler-times "tst\tr" 8 } } */
-/* { dg-final { scan-assembler-not "tst\t#255" } } */
-/* { dg-final { scan-assembler-not "exts|extu|and|movu" } } */
+/* { dg-final { scan-assembler-times "tst\tr" 8 { xfail *-*-*} } }  */
+/* { dg-final { scan-assembler-not "tst\t#255" { xfail *-*-*} } }  */
+/* { dg-final { scan-assembler-not "exts|extu|and|movu" { xfail *-*-*} } }  */
 
 int
 test00 (char* a, char* b, int c, int d)
Index: gcc/testsuite/gcc.target/sh/pr64507.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/pr64507.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/pr64507.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,25 @@
+/* Check that the __builtin_strnlen returns 0 with with 
+   non-constant 0 length.  */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern int snprintf(char *, int, const char *, ...);
+extern void abort (void);
+
+int main()
+ {
+   int i;
+   int cmp = 0;
+   char buffer[1024];
+   const char* s = "the string";
+
+   snprintf(buffer, 4, "%s", s);
+
+   for (i = 1; i < 4; i++)
+     cmp += __builtin_strncmp(buffer, s, i - 1);
+
+  if (cmp)
+    abort();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c	(.../branches/gcc-4_9-branch)
@@ -3,12 +3,12 @@
 /* { dg-do compile }  */
 /* { dg-options "-O2" } */
 /* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m2a*" } } */
-/* { dg-final { scan-assembler-times "tst" 5 } } */
-/* { dg-final { scan-assembler-times "movt" 0 } } */
+/* { dg-final { scan-assembler-times "tst" 6 } } */
+/* { dg-final { scan-assembler-times "movt" 1 } } */
 /* { dg-final { scan-assembler-times "nott" 1 } } */
 /* { dg-final { scan-assembler-times "cmp/eq" 2 } } */
 /* { dg-final { scan-assembler-times "cmp/hi" 4 } } */
 /* { dg-final { scan-assembler-times "cmp/gt" 3 } } */
-/* { dg-final { scan-assembler-times "not\t" 1 } } */
+/* { dg-final { scan-assembler-not "not\t" } } */
 
 #include "pr51244-20.c"
Index: gcc/testsuite/gcc.target/sh/pr51244-20.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/pr51244-20.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/pr51244-20.c	(.../branches/gcc-4_9-branch)
@@ -1,15 +1,15 @@
 /* Check that the SH specific sh_treg_combine RTL optimization pass works as
    expected.  On SH2A the expected insns are slightly different, see
-   pr51244-21.c.  */
+   pr51244-20-sh2a.c.  */
 /* { dg-do compile }  */
 /* { dg-options "-O2" } */
 /* { dg-skip-if "" { "sh*-*-*" } { "-m5*" "-m2a*" } { "" } } */
-/* { dg-final { scan-assembler-times "tst" 6 } } */
-/* { dg-final { scan-assembler-times "movt" 1 } } */
+/* { dg-final { scan-assembler-times "tst" 7 } } */
+/* { dg-final { scan-assembler-times "movt" 2 } } */
 /* { dg-final { scan-assembler-times "cmp/eq" 2 } } */
 /* { dg-final { scan-assembler-times "cmp/hi" 4 } } */
 /* { dg-final { scan-assembler-times "cmp/gt" 2 } } */
-/* { dg-final { scan-assembler-times "not\t" 1 } } */
+/* { dg-final { scan-assembler-not "not\t" } } */
 
 
 /* non-SH2A: 2x tst, 1x movt, 2x cmp/eq, 1x cmp/hi
@@ -81,7 +81,7 @@
 }
 
 
-/* 2x tst, 1x cmp/hi, 1x not  */
+/* 3x tst, 1x movt, 1x cmp/hi, 1x not  */
 static inline int
 blk_oversized_queue_5 (int* q)
 {
Index: gcc/testsuite/gcc.target/sh/torture/pr63783-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/torture/pr63783-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/torture/pr63783-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* { dg-do run }  */
+/* { dg-additional-options "-std=c99" }  */
+
+#include <assert.h>
+
+int decision_result;
+int val;
+int truecount = 0;
+
+static void __attribute__((noinline))
+buggy (int flag)
+{
+  int condition;
+  if(flag == 0)
+    condition = val != 0;
+  else
+    condition = !decision_result;
+  if (condition)
+     truecount++;
+}
+
+int
+main (void)
+{
+  decision_result = 1;
+  buggy(1);
+  assert (truecount == 0);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/sh/torture/pr63783-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/torture/pr63783-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/torture/pr63783-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* { dg-do run }  */
+/* { dg-additional-options "-std=c99" }  */
+
+#include <assert.h>
+
+long long decision_result;
+long long val;
+int truecount = 0;
+
+static void __attribute__((noinline))
+buggy (int flag)
+{
+  int condition;
+  if(flag == 0)
+    condition = val != 0;
+  else
+    condition = !decision_result;
+  if (condition)
+     truecount++;
+}
+
+int
+main (void)
+{
+  decision_result = 1;
+  buggy(1);
+  assert (truecount == 0);
+  return 0;
+}
Index: gcc/testsuite/go.test/go-test.exp
===================================================================
--- a/src/gcc/testsuite/go.test/go-test.exp	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/go.test/go-test.exp	(.../branches/gcc-4_9-branch)
@@ -241,7 +241,11 @@
 	    if [check_effective_target_ilp32] {
 		set goarch "ppc"
 	    } else {
-		set goarch "ppc64"
+		if [istarget "powerpc64le-*-*"] {
+		    set goarch "ppc64le"
+		} else {
+		    set goarch "ppc64"
+		}
 	    }
 	}
 	"sparc*-*-*" {
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_9-branch)
@@ -41,6 +41,14 @@
     global tool
     verbose "check_compile tool: $tool for $basename" 
 
+    # Save additional_sources to avoid compiling testsuite's sources
+    # against check_compile's source.
+    global additional_sources
+    if [info exists additional_sources] {
+	set tmp_additional_sources "$additional_sources"
+	set additional_sources ""
+    }
+
     if { [llength $args] > 0 } {
 	set options [list "additional_flags=[lindex $args 0]"]
     } else {
@@ -86,6 +94,11 @@
 	file delete $output
     }
 
+    # Restore additional_sources.
+    if [info exists additional_sources] {
+	set additional_sources "$tmp_additional_sources"
+    }
+
     return [list $lines $scan_output]
 }
 
Index: gcc/testsuite/gfortran.dg/pointer_remapping_9.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_remapping_9.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_remapping_9.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+! { dg-do run }
+!
+! PR fortran/61138
+! Wrong code with pointer-bounds remapping
+!
+! Contributed by Tobias Burnus <burnus@net-b.de>
+
+implicit none
+integer, target :: tgt(10)
+integer, target, allocatable :: tgt2(:)
+integer, pointer :: ptr(:)
+
+tgt = [1,2,3,4,5,6,7,8,9,10]
+tgt2 = [1,2,3,4,5,6,7,8,9,10]
+
+
+ptr(-5:) => tgt(5:)  ! Okay
+
+if (size(ptr) /= 6 .or. lbound(ptr,1) /= -5) call abort()
+if (any (ptr /= [5,6,7,8,9,10])) call abort()
+
+
+ptr(-5:) => tgt2(5:)  ! wrongly associates the whole array
+
+print '(*(i4))', size(ptr), lbound(ptr)
+print '(*(i4))', ptr
+
+if (size(ptr) /= 6 .or. lbound(ptr,1) /= -5) call abort()
+if (any (ptr /= [5,6,7,8,9,10])) call abort()
+end
+
Index: gcc/testsuite/gfortran.dg/allocate_with_mold_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocate_with_mold_1.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocate_with_mold_1.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+! { dg-do run }
+!
+! Fixes a bug that emerged from the fix of PR62044 - see the PR. When
+! there was no default initializer, code-expr3 was set null and so the
+! vpointer was set to the vtable of the declared type, rather than that
+! of the MOLD expression.
+!
+! Contributed by but based on the original PR62044 testcase by
+! Paul Thomas  <pault@gcc.gnu.org>
+!
+module GridImageSilo_Template
+  implicit none
+  type, public, abstract :: GridImageSiloTemplate
+  end type GridImageSiloTemplate
+end module GridImageSilo_Template
+
+module UnstructuredGridImageSilo_Form
+  use GridImageSilo_Template
+  implicit none
+  type, public, extends ( GridImageSiloTemplate ) :: &
+    UnstructuredGridImageSiloForm
+  end type UnstructuredGridImageSiloForm
+end module UnstructuredGridImageSilo_Form
+
+module UnstructuredGridImages
+  use UnstructuredGridImageSilo_Form
+! 5.0 branch contains    UnstructuredGridImageForm => UnstructuredGridImageSiloForm
+contains
+  subroutine foo
+    class (GridImageSiloTemplate), allocatable :: a
+    type (UnstructuredGridImageSiloForm) :: b
+    integer :: i = 0
+    allocate (a, mold = b)
+    select type (a)
+      type is (UnstructuredGridImageSiloForm)
+        i = 1
+      class default
+        i = 2
+    end select
+    if (i .ne. 1) call abort
+  end subroutine
+end module UnstructuredGridImages
+
+  use UnstructuredGridImages
+  call foo
+end
+
Index: gcc/testsuite/gfortran.dg/entry_20.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/entry_20.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/entry_20.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,148 @@
+! { dg-do compile }
+!
+! PR fortran/50898
+! A symbol was freed prematurely during resolution,
+! despite remaining reachable
+!
+! Original testcase from <shaojuncycle@gmail.com>
+
+MODULE MODULE_pmat2
+
+IMPLICIT NONE
+
+INTERFACE cad1b;  MODULE PROCEDURE cad1b;          END INTERFACE
+INTERFACE csb1b;  MODULE PROCEDURE csb1b;          END INTERFACE
+INTERFACE copbt;  MODULE PROCEDURE copbt;          END INTERFACE
+INTERFACE conbt;  MODULE PROCEDURE conbt;          END INTERFACE
+INTERFACE copmb;  MODULE PROCEDURE copmb;          END INTERFACE
+INTERFACE conmb;  MODULE PROCEDURE conmb;          END INTERFACE
+INTERFACE copbm;  MODULE PROCEDURE copbm;          END INTERFACE
+INTERFACE conbm;  MODULE PROCEDURE conbm;          END INTERFACE
+INTERFACE mulvb;  MODULE PROCEDURE mulvb;          END INTERFACE
+INTERFACE madvb;  MODULE PROCEDURE madvb;          END INTERFACE
+INTERFACE msbvb;  MODULE PROCEDURE msbvb;          END INTERFACE
+INTERFACE mulxb;  MODULE PROCEDURE mulxb;          END INTERFACE
+INTERFACE madxb;  MODULE PROCEDURE madxb;          END INTERFACE
+INTERFACE msbxb;  MODULE PROCEDURE msbxb;          END INTERFACE
+
+integer, parameter :: i_kind=4
+integer, parameter :: r_kind=4
+real(r_kind), parameter :: zero=0.0
+real(r_kind), parameter :: one=1.0
+real(r_kind), parameter :: two=2.0
+
+CONTAINS
+
+SUBROUTINE cad1b(a,m1,mah1,mah2,mirror2)
+implicit none
+INTEGER(i_kind),  INTENT(IN   ) :: m1,mah1,mah2,mirror2
+REAL(r_kind),     INTENT(INOUT) :: a(0:m1-1,-mah1:mah2)
+RETURN
+ENTRY     csb1b(a,m1,mah1,mah2,mirror2)
+END SUBROUTINE cad1b
+
+SUBROUTINE copbt(a,b,m1,m2,mah1,mah2)
+implicit none
+INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
+REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2)
+REAL(r_kind),     INTENT(  OUT) :: b(m2,-mah2:mah1)
+RETURN
+ENTRY    conbt(a,b,m1,m2,mah1,mah2)
+END SUBROUTINE copbt
+
+SUBROUTINE copmb(afull,aband,m1,m2,mah1,mah2)
+implicit none
+INTEGER(i_kind),                           INTENT(IN   ) :: m1, m2, mah1, mah2
+REAL(r_kind),     DIMENSION(m1,m2),        INTENT(IN   ) :: afull
+REAL(r_kind),     DIMENSION(m1,-mah1:mah2),INTENT(  OUT) :: aband
+RETURN
+ENTRY      conmb(afull,aband,m1,m2,mah1,mah2)
+END SUBROUTINE copmb
+
+SUBROUTINE copbm(aband,afull,m1,m2,mah1,mah2)
+implicit none
+INTEGER(i_kind),                           INTENT(IN   ) :: m1, m2, mah1, mah2
+REAL(r_kind),     DIMENSION(m1,-mah1:mah2),INTENT(IN   ) :: aband
+REAL(r_kind),     DIMENSION(m1,m2),        INTENT(  OUT) :: afull
+RETURN
+ENTRY      conbm(aband,afull,m1,m2,mah1,mah2)
+END SUBROUTINE copbm
+
+SUBROUTINE mulbb(a,b,c,m1,m2,mah1,mah2,mbh1,mbh2,mch1,mch2)
+implicit none
+INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mbh1, mbh2, mch1, mch2
+REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2), b(m2,-mbh1:mbh2)
+REAL(r_kind),     INTENT(INOUT) :: c(m1,-mch1:mch2)
+INTEGER(i_kind)                :: nch1, nch2, j, k, jpk, i1,i2
+c=zero
+ENTRY      madbb(a,b,c,m1,m2,mah1,mah2,mbh1,mbh2,mch1,mch2)
+nch1=mah1+mbh1; nch2=mah2+mbh2
+IF(nch1 /= mch1 .OR. nch2 /= mch2)STOP 'In MULBB, dimensions inconsistent'
+DO j=-mah1,mah2
+   DO k=-mbh1,mbh2; jpk=j+k; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
+      c(i1:i2,jpk)=c(i1:i2,jpk)+a(i1:i2,j)*b(j+i1:j+i2,k)
+   ENDDO
+ENDDO
+END SUBROUTINE mulbb
+
+SUBROUTINE MULVB(v1,a,v2, m1,m2,mah1,mah2)
+implicit none
+INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
+REAL(r_kind),     INTENT(IN   ) :: v1(m1), a(m1,-mah1:mah2)
+REAL(r_kind),     INTENT(  OUT) :: v2(m2)
+INTEGER(i_kind)                 :: j, i1,i2
+v2=zero
+ENTRY    madvb(v1,a,v2, m1,m2,mah1,mah2)
+DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
+   v2(j+i1:j+i2)=v2(j+i1:j+i2)+v1(i1:i2)*a(i1:i2,j)
+ENDDO
+RETURN
+ENTRY    msbvb(v1,a,v2, m1,m2,mah1,mah2)
+DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
+   v2(j+i1:j+i2)=v2(j+i1:j+i2)-v1(i1:i2)*a(i1:i2,j)
+ENDDO
+END SUBROUTINE mulvb
+
+SUBROUTINE mulxb(v1,a,v2, m1,m2,mah1,mah2,my)
+implicit none
+INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, my
+REAL(r_kind),     INTENT(IN   ) :: v1(m1,my), a(m1,-mah1:mah2)
+REAL(r_kind),     INTENT(  OUT) :: v2(m2,my)
+INTEGER(i_kind)                 :: i,j
+v2=zero
+ENTRY    madxb(v1,a,v2, m1,m2,mah1,mah2,my)
+DO j=-mah1,mah2
+   DO i=MAX(1,1-j),MIN(m1,m2-j); v2(j+i,:)=v2(j+i,:)+v1(i,:)*a(i,j); ENDDO
+ENDDO
+RETURN
+ENTRY    msbxb(v1,a,v2, m1,m2,mah1,mah2,my)
+DO j=-mah1,mah2
+   DO i=MAX(1,1-j),MIN(m1,m2-j); v2(j+i,:)=v2(j+i,:)-v1(i,:)*a(i,j); ENDDO
+ENDDO
+END SUBROUTINE mulxb
+
+SUBROUTINE mulyb(v1,a,v2, m1,m2,mah1,mah2,mx)
+implicit none
+INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mx
+REAL(r_kind),     INTENT(IN   ) :: v1(mx,m1), a(m1,-mah1:mah2)
+REAL(r_kind),     INTENT(  OUT) :: v2(mx,m2)
+INTEGER(i_kind)                 :: i,j
+v2=zero
+ENTRY    madyb(v1,a,v2, m1,m2,mah1,mah2,mx)
+DO j=-mah1,mah2
+    DO i=MAX(1,1-j),MIN(m1,m2-j)
+      v2(:,j+i)=v2(:,j+i)+v1(:,i)*a(i,j)
+    ENDDO
+ENDDO
+RETURN
+ENTRY    msbyb(v1,a,v2, m1,m2,mah1,mah2,mx)
+ DO j=-mah1,mah2
+    DO i=MAX(1,1-j),MIN(m1,m2-j)
+       v2(:,j+i)=v2(:,j+i)-v1(:,i)*a(i,j)
+    ENDDO
+ ENDDO
+RETURN
+END SUBROUTINE mulyb
+
+END MODULE MODULE_pmat2
+
Index: gcc/testsuite/gfortran.dg/pr64528.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr64528.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr64528.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,20 @@
+! PR fortran/64528
+! { dg-do compile }
+! { dg-options "-O -fno-tree-dce -fno-tree-ccp" }
+
+program pr64528
+  interface
+     subroutine foo(x)
+       integer, value :: x
+     end subroutine foo
+  end interface
+  integer :: x
+  x = 10
+  call foo(x)
+  if(x .ne. 10) then
+  endif
+end program pr64528
+subroutine foo(x)
+  integer, value :: x
+  x = 11
+end subroutine foo
Index: gcc/testsuite/gfortran.dg/coarray_36.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_36.f	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_36.f	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,347 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+!
+! PR fortran/64771
+!
+! Contributed by Alessandro Fanfarill
+!
+! Reduced version of the full NAS CG benchmark
+!
+
+!-------------------------------------------------------------------------!
+!                                                                         !
+!        N  A  S     P A R A L L E L     B E N C H M A R K S  3.3         !
+!                                                                         !
+!                                   C G                                   !
+!                                                                         !
+!-------------------------------------------------------------------------!
+!                                                                         !
+!    This benchmark is part of the NAS Parallel Benchmark 3.3 suite.      !
+!    It is described in NAS Technical Reports 95-020 and 02-007           !
+!                                                                         !
+!    Permission to use, copy, distribute and modify this software         !
+!    for any purpose with or without fee is hereby granted.  We           !
+!    request, however, that all derived work reference the NAS            !
+!    Parallel Benchmarks 3.3. This software is provided "as is"           !
+!    without express or implied warranty.                                 !
+!                                                                         !
+!    Information on NPB 3.3, including the technical report, the          !
+!    original specifications, source code, results and information        !
+!    on how to submit new results, is available at:                       !
+!                                                                         !
+!           http://www.nas.nasa.gov/Software/NPB/                         !
+!                                                                         !
+!    Send comments or suggestions to  npb@nas.nasa.gov                    !
+!                                                                         !
+!          NAS Parallel Benchmarks Group                                  !
+!          NASA Ames Research Center                                      !
+!          Mail Stop: T27A-1                                              !
+!          Moffett Field, CA   94035-1000                                 !
+!                                                                         !
+!          E-mail:  npb@nas.nasa.gov                                      !
+!          Fax:     (650) 604-3957                                        !
+!                                                                         !
+!-------------------------------------------------------------------------!
+
+
+c---------------------------------------------------------------------
+c
+c Authors: M. Yarrow
+c          C. Kuszmaul
+c          R. F. Van der Wijngaart
+c          H. Jin
+c
+c---------------------------------------------------------------------
+
+
+c---------------------------------------------------------------------
+c---------------------------------------------------------------------
+      program cg
+c---------------------------------------------------------------------
+c---------------------------------------------------------------------
+      implicit none
+
+      integer            na, nonzer, niter
+      double precision   shift, rcond
+      parameter(  na=75000,
+     >     nonzer=13,
+     >     niter=75,
+     >     shift=60.,
+     >     rcond=1.0d-1 )
+
+
+
+      integer num_proc_rows, num_proc_cols
+      parameter( num_proc_rows = 2, num_proc_cols = 2)
+      integer    num_procs
+      parameter( num_procs = num_proc_cols * num_proc_rows )
+
+      integer    nz
+      parameter( nz = na*(nonzer+1)/num_procs*(nonzer+1)+nonzer
+     >              + na*(nonzer+2+num_procs/256)/num_proc_cols )
+
+      common / partit_size  /  naa, nzz,
+     >                         npcols, nprows,
+     >                         proc_col, proc_row,
+     >                         firstrow,
+     >                         lastrow,
+     >                         firstcol,
+     >                         lastcol,
+     >                         exch_proc,
+     >                         exch_recv_length,
+     >                         send_start,
+     >                         send_len
+      integer                  naa, nzz,
+     >                         npcols, nprows,
+     >                         proc_col, proc_row,
+     >                         firstrow,
+     >                         lastrow,
+     >                         firstcol,
+     >                         lastcol,
+     >                         exch_proc,
+     >                         exch_recv_length,
+     >                         send_start,
+     >                         send_len
+
+
+      common / main_int_mem /  colidx,     rowstr,
+     >                         iv,         arow,     acol
+      integer                  colidx(nz), rowstr(na+1),
+     >                         iv(2*na+1), arow(nz), acol(nz)
+
+
+c---------------------------------
+c     Coarray Decalarations
+c---------------------------------
+      double precision         v(na+1)[0:*], aelt(nz)[0:*], a(nz)[0:*],
+     >                         x(na/num_proc_rows+2)[0:*],
+     >                         z(na/num_proc_rows+2)[0:*],
+     >                         p(na/num_proc_rows+2)[0:*],
+     >                         q(na/num_proc_rows+2)[0:*],
+     >                         r(na/num_proc_rows+2)[0:*],
+     >                         w(na/num_proc_rows+2)[0:*]
+
+
+      common /urando/          amult, tran
+      double precision         amult, tran
+
+
+
+      integer            l2npcols
+      integer            reduce_exch_proc(num_proc_cols)
+      integer            reduce_send_starts(num_proc_cols)
+      integer            reduce_send_lengths(num_proc_cols)
+      integer            reduce_recv_lengths(num_proc_cols)
+      integer            reduce_rrecv_starts(num_proc_cols)
+c---------------------------------
+c     Coarray Decalarations
+c---------------------------------
+      integer            reduce_recv_starts(num_proc_cols)[0:*]
+
+      integer            i, j, k, it, me, nprocs, root
+
+      double precision   zeta, randlc
+      external           randlc
+      double precision   rnorm
+c---------------------------------
+c     Coarray Decalarations
+c---------------------------------
+      double precision   norm_temp1(2)[0:*], norm_temp2(2)[0:*]
+
+      double precision   t, tmax, mflops
+      double precision   u(1), umax(1)
+      external           timer_read
+      double precision   timer_read
+      character          class
+      logical            verified
+      double precision   zeta_verify_value, epsilon, err
+
+c---------------------------------------------------------------------
+c  Explicit interface for conj_grad, due to coarray args
+c---------------------------------------------------------------------
+      interface
+
+      subroutine conj_grad ( colidx,
+     >                       rowstr,
+     >                       x,
+     >                       z,
+     >                       a,
+     >                       p,
+     >                       q,
+     >                       r,
+     >                       w,
+     >                       rnorm,
+     >                       l2npcols,
+     >                       reduce_exch_proc,
+     >                       reduce_send_starts,
+     >                       reduce_send_lengths,
+     >                       reduce_recv_starts,
+     >                       reduce_recv_lengths,
+     >                       reduce_rrecv_starts )
+
+      common / partit_size  /  naa, nzz,
+     >                         npcols, nprows,
+     >                         proc_col, proc_row,
+     >                         firstrow,
+     >                         lastrow,
+     >                         firstcol,
+     >                         lastcol,
+     >                         exch_proc,
+     >                         exch_recv_length,
+     >                         send_start,
+     >                         send_len
+
+      integer                  naa, nzz,
+     >                         npcols, nprows,
+     >                         proc_col, proc_row,
+     >                         firstrow,
+     >                         lastrow,
+     >                         firstcol,
+     >                         lastcol,
+     >                         exch_proc,
+     >                         exch_recv_length,
+     >                         send_start,
+     >                         send_len
+
+      double precision   x(*),
+     >                   z(*),
+     >                   a(nzz)
+      integer            colidx(nzz), rowstr(naa+1)
+
+      double precision   p(*),
+     >                   q(*)[0:*],
+     >                   r(*)[0:*],
+     >                   w(*)[0:*]        ! used as work temporary
+
+      integer   l2npcols
+      integer   reduce_exch_proc(l2npcols)
+      integer   reduce_send_starts(l2npcols)
+      integer   reduce_send_lengths(l2npcols)
+      integer   reduce_recv_starts(l2npcols)[0:*]
+      integer   reduce_recv_lengths(l2npcols)
+      integer   reduce_rrecv_starts(l2npcols)
+
+      double precision   rnorm
+
+      end subroutine
+
+      end interface
+
+c---------------------------------------------------------------------
+c  The call to the conjugate gradient routine:
+c---------------------------------------------------------------------
+         call conj_grad ( colidx,
+     >                    rowstr,
+     >                    x,
+     >                    z,
+     >                    a,
+     >                    p,
+     >                    q,
+     >                    r,
+     >                    w,
+     >                    rnorm,
+     >                    l2npcols,
+     >                    reduce_exch_proc,
+     >                    reduce_send_starts,
+     >                    reduce_send_lengths,
+     >                    reduce_recv_starts,
+     >                    reduce_recv_lengths,
+     >                    reduce_rrecv_starts ) 
+
+
+      sync all
+
+      end                              ! end main
+
+c---------------------------------------------------------------------
+c---------------------------------------------------------------------
+      subroutine conj_grad ( colidx,
+     >                       rowstr,
+     >                       x,
+     >                       z,
+     >                       a,
+     >                       p,
+     >                       q,
+     >                       r,
+     >                       w,
+     >                       rnorm,
+     >                       l2npcols,
+     >                       reduce_exch_proc,
+     >                       reduce_send_starts,
+     >                       reduce_send_lengths,
+     >                       reduce_recv_starts,
+     >                       reduce_recv_lengths,
+     >                       reduce_rrecv_starts )
+c---------------------------------------------------------------------
+c---------------------------------------------------------------------
+
+c---------------------------------------------------------------------
+c  Floaging point arrays here are named as in NPB1 spec discussion of
+c  CG algorithm
+c---------------------------------------------------------------------
+
+      implicit none
+
+c      include 'cafnpb.h'
+
+      common / partit_size  /  naa, nzz,
+     >                         npcols, nprows,
+     >                         proc_col, proc_row,
+     >                         firstrow,
+     >                         lastrow,
+     >                         firstcol,
+     >                         lastcol,
+     >                         exch_proc,
+     >                         exch_recv_length,
+     >                         send_start,
+     >                         send_len
+      integer                  naa, nzz,
+     >                         npcols, nprows,
+     >                         proc_col, proc_row,
+     >                         firstrow,
+     >                         lastrow,
+     >                         firstcol,
+     >                         lastcol,
+     >                         exch_proc,
+     >                         exch_recv_length,
+     >                         send_start,
+     >                         send_len
+
+
+
+      double precision   x(*),
+     >                   z(*),
+     >                   a(nzz)
+      integer            colidx(nzz), rowstr(naa+1)
+
+      double precision   p(*),
+     >                   q(*)[0:*],
+     >                   r(*)[0:*],
+     >                   w(*)[0:*]        ! used as work temporary
+
+      integer   l2npcols
+      integer   reduce_exch_proc(l2npcols)
+      integer   reduce_send_starts(l2npcols)
+      integer   reduce_send_lengths(l2npcols)
+      integer   reduce_recv_starts(l2npcols)[0:*]
+      integer   reduce_recv_lengths(l2npcols)
+      integer   reduce_rrecv_starts(l2npcols)
+
+      integer   recv_start_idx, recv_end_idx, send_start_idx,
+     >          send_end_idx, recv_length
+
+      integer   i, j, k, ierr
+      integer   cgit, cgitmax
+
+      double precision, save :: d[0:*], rho[0:*]
+      double precision   sum, rho0, alpha, beta, rnorm
+
+      external         timer_read
+      double precision timer_read
+
+      data      cgitmax / 25 /
+
+
+      return
+      end                       ! end of routine conj_grad
+
Index: gcc/testsuite/gfortran.dg/finalize_28.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR64932.
+!
+! Reported by Daniel Shapiro  <shapero@uw.edu>
+!
+module coo_graphs
+  implicit none
+  type :: dynamic_array
+    integer :: length, capacity, min_capacity
+    integer, allocatable :: array(:)
+  end type
+  type :: coo_graph
+    type(dynamic_array) :: edges(2)
+    integer, private :: ne
+  end type coo_graph
+contains
+  subroutine coo_dump_edges(g, edges)
+    class(coo_graph), intent(in) :: g
+    integer, intent(out) :: edges(:,:)
+  end subroutine coo_dump_edges
+end module coo_graphs
+! { dg-final { scan-tree-dump-times "__builtin_free" 3 "original" } }
Index: gcc/testsuite/gfortran.dg/use_rename_8.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/use_rename_8.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/use_rename_8.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+! { dg-do compile }
+!
+! PR fortran/63744
+! duplicate use rename used to be rejected when the target name
+! was that of the current program unit 
+!
+! Original testcase from Roger Ferrer Ibanez <roger.ferrer@bsc.es>
+
+MODULE MOO
+    INTEGER :: A, B, C, D, E, F, G, H, I
+END MODULE MOO
+
+SUBROUTINE S
+    USE MOO, ONLY: X => A, X => A
+END SUBROUTINE S
+
+SUBROUTINE T
+    USE MOO, ONLY: X => B
+    USE MOO, ONLY: X => B
+END SUBROUTINE T
+
+SUBROUTINE C
+    USE MOO, ONLY: C  ! { dg-error "is also the name of the current program unit" }
+END SUBROUTINE C
+
+SUBROUTINE D
+    USE MOO, ONLY: X => D
+END SUBROUTINE D
+
+SUBROUTINE E
+    USE MOO, ONLY: X => E, X => E
+END SUBROUTINE E
+
+SUBROUTINE F
+    USE MOO, ONLY: X => F
+    USE MOO, ONLY: X => F
+END SUBROUTINE F
+
+SUBROUTINE X
+    USE MOO, ONLY: X => G ! { dg-error "is also the name of the current program unit" }
+END SUBROUTINE X
+
+SUBROUTINE Y
+    USE MOO, ONLY: Y => H ! { dg-error "is also the name of the current program unit" }
+END SUBROUTINE Y
+
+SUBROUTINE Z
+    USE MOO, ONLY: Z => I, Z => I ! { dg-error "is also the name of the current program unit" }
+END SUBROUTINE Z
+
Index: gcc/testsuite/gfortran.dg/typebound_operator_20.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/typebound_operator_20.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/typebound_operator_20.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+! { dg-do run }
+!
+! PR 63733: [4.8/4.9/5 Regression] [OOP] wrong resolution for OPERATOR generics
+!
+! Original test case from Alberto F. Martn Huertas <amartin@cimne.upc.edu>
+! Slightly modified by Salvatore Filippone <sfilippone@uniroma2.it>
+! Further modified by Janus Weil <janus@gcc.gnu.org>
+
+module overwrite
+  type parent
+   contains
+     procedure :: sum => sum_parent
+     generic   :: operator(+) => sum
+  end type
+
+  type, extends(parent) ::  child
+  contains
+    procedure :: sum => sum_child
+  end type
+
+contains
+
+  integer function sum_parent(op1,op2)
+    implicit none
+    class(parent), intent(in) :: op1, op2
+    sum_parent = 0
+  end function
+
+  integer function sum_child(op1,op2)
+    implicit none
+    class(child) , intent(in) :: op1
+    class(parent), intent(in) :: op2
+    sum_child = 1
+  end function
+
+end module
+
+program drive
+  use overwrite
+  implicit none
+
+  type(parent) :: m1, m2
+  class(parent), pointer :: mres
+  type(child)  :: h1, h2
+  class(parent), pointer :: hres
+
+  if (m1 + m2 /= 0) call abort()
+  if (h1 + m2 /= 1) call abort()
+  if (h1%sum(h2) /= 1) call abort()
+
+end
+
+! { dg-final { cleanup-modules "overwrite" } }
Index: gcc/testsuite/gfortran.dg/typebound_call_26.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/typebound_call_26.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/typebound_call_26.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+! { dg-do compile }
+!
+! PR 64244: [4.8/4.9/5 Regression] ICE at class.c:236 when using non_overridable
+!
+! Contributed by Ondej ertk <ondrej.certik@gmail.com>
+
+module m
+  implicit none
+
+  type :: A
+  contains
+    generic :: f => g
+    procedure, non_overridable :: g
+  end type
+
+contains
+
+  subroutine g(this)
+    class(A), intent(in) :: this
+  end subroutine
+
+end module
+
+
+program test_non_overridable
+  use m, only: A
+  implicit none
+  class(A), allocatable :: h
+  call h%f()
+end
Index: gcc/testsuite/gfortran.dg/unlimited_polymorphic_23.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_23.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_23.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+! {dg-do run }
+!
+! Test the fix for PR65024, in which the structure for the 'info'
+! component of type 'T' was not being converted into TREE_SSA and
+! so caused an ICE in trans-expr.c:gfc_conv_component_ref.
+!
+! Reported by  <matt@gneilson.plus.com>
+!
+MODULE X
+  TYPE T
+    CLASS(*), pointer :: info
+  END TYPE
+END MODULE
+
+PROGRAM P
+  call bug
+CONTAINS
+  SUBROUTINE BUG
+    USE X
+    CLASS(T), pointer :: e
+    integer, target :: i = 42
+    allocate(e)
+    e%info => NULL ()      ! used to ICE
+    if (.not.associated(e%info)) e%info => i      ! used to ICE
+    select type (z => e%info)
+      type is (integer)
+        if (z .ne.i) call abort
+    end select
+  END SUBROUTINE
+
+  SUBROUTINE NEXT
+    USE X
+    CLASS (T), pointer :: e
+  END SUBROUTINE
+END
Index: gcc/testsuite/gfortran.dg/proc_ptr_comp_44.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/proc_ptr_comp_44.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/proc_ptr_comp_44.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,71 @@
+! { dg-do compile }
+! Test the fix for PR59198, where the field for the component 'term' in
+! the derived type 'decay_gen_t' was not being built.
+!
+! Contributed by Juergen Reuter  <juergen.reuter@desy.de>
+!
+module decays
+  abstract interface
+     function obs_unary_int ()
+     end function obs_unary_int
+  end interface
+
+  type, abstract :: any_config_t
+   contains
+     procedure (any_config_final), deferred :: final
+  end type any_config_t
+
+  type :: decay_term_t
+     type(unstable_t), dimension(:), pointer :: unstable_product => null ()
+  end type decay_term_t
+
+  type, abstract :: decay_gen_t
+     type(decay_term_t), dimension(:), allocatable :: term
+     procedure(obs_unary_int),   nopass, pointer :: obs1_int  => null ()
+  end type decay_gen_t
+
+  type, extends (decay_gen_t) :: decay_root_t
+   contains
+     procedure :: final => decay_root_final
+  end type decay_root_t
+
+  type, abstract :: rng_t
+  end type rng_t
+
+  type, extends (decay_gen_t) :: decay_t
+     class(rng_t), allocatable :: rng
+   contains
+     procedure :: final => decay_final
+  end type decay_t
+
+  type, extends (any_config_t) :: unstable_config_t
+   contains
+     procedure :: final => unstable_config_final
+  end type unstable_config_t
+
+  type :: unstable_t
+     type(unstable_config_t), pointer :: config => null ()
+     type(decay_t), dimension(:), allocatable :: decay
+  end type unstable_t
+
+  interface
+     subroutine any_config_final (object)
+       import
+       class(any_config_t), intent(inout) :: object
+     end subroutine any_config_final
+  end interface
+
+contains
+  subroutine decay_root_final (object)
+    class(decay_root_t), intent(inout) :: object
+  end subroutine decay_root_final
+
+  recursive subroutine decay_final (object)
+    class(decay_t), intent(inout) :: object
+  end subroutine decay_final
+
+  recursive subroutine unstable_config_final (object)
+    class(unstable_config_t), intent(inout) :: object
+  end subroutine unstable_config_final
+
+end module decays
Index: gcc/testsuite/gfortran.dg/class_allocate_18.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/class_allocate_18.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/class_allocate_18.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+! { dg-do run }
+!
+! PR 64230: [4.9/5 Regression] Invalid memory reference in a compiler-generated finalizer for allocatable component
+!
+! Contributed by Mat Cross <mathewc@nag.co.uk>
+
+Program main
+  Implicit None
+  Type :: t1
+  End Type
+  Type, Extends (t1) :: t2
+    Integer, Allocatable :: i
+  End Type
+  Type, Extends (t2) :: t3
+    Integer, Allocatable :: j
+  End Type
+  Class (t1), Allocatable :: t
+  Allocate (t3 :: t)
+  print *,"allocated!"
+  Deallocate (t)
+End
Index: gcc/testsuite/gfortran.dg/pr64530.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr64530.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr64530.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,38 @@
+! { dg-do run }
+
+program bug
+  ! Bug triggered with at least three elements
+  integer, parameter :: asize = 3
+
+  double precision,save :: ave(asize)
+  double precision,save :: old(asize)
+  double precision,save :: tmp(asize)
+
+  ave(:) = 10.d0
+  old(:) = 3.d0
+  tmp(:) = 0.d0
+
+  call buggy(2.d0,asize,ave,old,tmp)
+  if (any (tmp(:) .ne. 3.5)) call abort
+end
+
+subroutine buggy(scale_factor, asize, ave, old, tmp)
+
+  implicit none
+  ! Args
+  double precision scale_factor
+  integer asize
+  double precision ave(asize)
+  double precision old(asize)
+  double precision tmp(asize)
+
+  ! Local 
+  integer i
+
+  do i = 1, asize
+    tmp(i) = ave(i) - old(i)
+    old(i) = ave(i)
+    tmp(i) = tmp(i) / scale_factor
+  end do
+
+end subroutine buggy
Index: gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03	(.../branches/gcc-4_9-branch)
@@ -1,80 +1,80 @@
-! { dg-do compile }
-!
-! Test the most important constraints unlimited polymorphic entities
-!
-! Contributed by Paul Thomas  <pault@gcc.gnu.org>
-!            and Tobias Burnus <burnus@gcc.gnu.org>
-!
-  CHARACTER(:), allocatable, target :: chr ! { dg-error "TODO: Deferred character length variable" }
-! F2008: C5100
-  integer :: i(2)
-  logical :: flag
-  class(*), pointer :: u1, u2(:) ! { dg-error "cannot appear in COMMON" }
-  common u1
-  u1 => chr
-! F2003: C625
-  allocate (u1) ! { dg-error "requires either a type-spec or SOURCE tag" }
-  allocate (real :: u1)
-  Allocate (u1, source = 1.0)
-
-! F2008: C4106
-  u2 = [u1] ! { dg-error "shall not be unlimited polymorphic" }
-
-  i = u2 ! { dg-error "Can\\'t convert CLASS\\(\\*\\)" }
-
-! Repeats same_type_as_1.f03 for unlimited polymorphic u2
-  flag = same_type_as (i, u2) ! { dg-error "cannot be of type INTEGER" }
-  flag = extends_type_of (i, u2) ! { dg-error "cannot be of type INTEGER" }
-
-contains
-
-! C717 (R735) If data-target is unlimited polymorphic,
-! data-pointer-object shall be unlimited polymorphic, of a sequence
-! derived type, or of a type with the BIND attribute.
-!
-  subroutine bar
-
-    type sq
-      sequence
-      integer :: i
-    end type sq
-
-    type(sq), target :: x
-    class(*), pointer :: y
-    integer, pointer :: tgt
-
-    x%i = 42
-    y => x
-    call foo (y)
-
-    y => tgt ! This is OK, of course.
-    tgt => y ! { dg-error "must be unlimited polymorphic" }
-
-    select type (y) ! This is the correct way to accomplish the previous
-      type is (integer)
-        tgt => y
-    end select
-
-  end subroutine bar
-
-
-  subroutine foo(tgt)
-    class(*), pointer, intent(in) :: tgt
-    type t
-      sequence
-      integer :: k
-    end type t
-
-    type(t), pointer :: ptr
-
-    ptr => tgt ! C717 allows this.
-
-    select type (tgt)
-! F03:C815 or F08:C839
-      type is (t) ! { dg-error "shall not specify a sequence derived type" }
-        ptr => tgt ! { dg-error "Expected TYPE IS" }
-    end select
-
-    print *, ptr%k
-  end subroutine foo
-END
+! { dg-do compile }
+!
+! Test the most important constraints unlimited polymorphic entities
+!
+! Contributed by Paul Thomas  <pault@gcc.gnu.org>
+!            and Tobias Burnus <burnus@gcc.gnu.org>
+!
+  CHARACTER(:), allocatable, target :: chr
+! F2008: C5100
+  integer :: i(2)
+  logical :: flag
+  class(*), pointer :: u1, u2(:) ! { dg-error "cannot appear in COMMON" }
+  common u1
+  u1 => chr
+! F2003: C625
+  allocate (u1) ! { dg-error "requires either a type-spec or SOURCE tag" }
+  allocate (real :: u1)
+  Allocate (u1, source = 1.0)
+
+! F2008: C4106
+  u2 = [u1] ! { dg-error "shall not be unlimited polymorphic" }
+
+  i = u2 ! { dg-error "Can\\'t convert CLASS\\(\\*\\)" }
+
+! Repeats same_type_as_1.f03 for unlimited polymorphic u2
+  flag = same_type_as (i, u2) ! { dg-error "cannot be of type INTEGER" }
+  flag = extends_type_of (i, u2) ! { dg-error "cannot be of type INTEGER" }
+
+contains
+
+! C717 (R735) If data-target is unlimited polymorphic,
+! data-pointer-object shall be unlimited polymorphic, of a sequence
+! derived type, or of a type with the BIND attribute.
+!
+  subroutine bar
+
+    type sq
+      sequence
+      integer :: i
+    end type sq
+
+    type(sq), target :: x
+    class(*), pointer :: y
+    integer, pointer :: tgt
+
+    x%i = 42
+    y => x
+    call foo (y)
+
+    y => tgt ! This is OK, of course.
+    tgt => y ! { dg-error "must be unlimited polymorphic" }
+
+    select type (y) ! This is the correct way to accomplish the previous
+      type is (integer)
+        tgt => y
+    end select
+
+  end subroutine bar
+
+
+  subroutine foo(tgt)
+    class(*), pointer, intent(in) :: tgt
+    type t
+      sequence
+      integer :: k
+    end type t
+
+    type(t), pointer :: ptr
+
+    ptr => tgt ! C717 allows this.
+
+    select type (tgt)
+! F03:C815 or F08:C839
+      type is (t) ! { dg-error "shall not specify a sequence derived type" }
+        ptr => tgt ! { dg-error "Expected TYPE IS" }
+    end select
+
+    print *, ptr%k
+  end subroutine foo
+END
Index: gcc/testsuite/gfortran.dg/coarray_37.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_37.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_37.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=single" }
+!
+      program cg
+        implicit none
+        integer reduce_recv_starts(2)[1,0:*]
+        interface
+          subroutine conj_grad (reduce_recv_starts) ! { dg-warning "Interface mismatch in global procedure 'conj_grad' at \\(1\\): Corank mismatch in argument 'reduce_recv_starts' \\(2/1\\)" }
+            integer   reduce_recv_starts(2)[2, 2:*]
+          end subroutine
+        end interface
+        call conj_grad (reduce_recv_starts) ! Corank mismatch is okay
+      end
+
+      subroutine conj_grad (reduce_recv_starts)
+        implicit none
+        integer reduce_recv_starts(2)[2:*]
+      end
Index: gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f03	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f03	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,104 @@
+! { dg-do run }
+!
+! Testing fix for PR fortran/60255
+!
+! Author: Andre Vehreschild <vehre@gmx.de>
+!
+MODULE m
+
+contains
+  subroutine bar (arg, res)
+    class(*) :: arg
+    character(100) :: res
+    select type (w => arg)
+      type is (character(*))
+        write (res, '(I2)') len(w)
+    end select
+  end subroutine
+
+END MODULE
+
+program test
+    use m;
+    implicit none
+    character(LEN=:), allocatable, target :: S
+    character(LEN=100) :: res
+    class(*), pointer :: ucp
+    call sub1 ("long test string", 16)
+    call sub2 ()
+    S = "test"
+    ucp => S
+    call sub3 (ucp)
+    call sub4 (S, 4)
+    call sub4 ("This is a longer string.", 24)
+    call bar (S, res)
+    if (trim (res) .NE. " 4") call abort ()
+    call bar(ucp, res)
+    if (trim (res) .NE. " 4") call abort ()
+
+contains
+
+    subroutine sub1(dcl, ilen)
+        character(len=*), target :: dcl
+        integer(4) :: ilen
+        character(len=:), allocatable :: hlp
+        class(*), pointer :: ucp
+
+        ucp => dcl
+
+        select type (ucp)
+        type is (character(len=*))
+            if (len(dcl) .NE. ilen) call abort ()
+            if (len(ucp) .NE. ilen) call abort ()
+            hlp = ucp
+            if (len(hlp) .NE. ilen) call abort ()
+        class default
+            call abort()
+        end select
+    end subroutine
+
+    subroutine sub2
+        character(len=:), allocatable, target :: dcl
+        class(*), pointer :: ucp
+
+        dcl = "ttt"
+        ucp => dcl
+
+        select type (ucp)
+        type is (character(len=*))
+            if (len(ucp) .ne. 3) call abort ()
+        class default
+            call abort()
+        end select
+    end subroutine
+
+    subroutine sub3(ucp)
+        character(len=:), allocatable :: hlp
+        class(*), pointer :: ucp
+
+        select type (ucp)
+        type is (character(len=*))
+            if (len(ucp) .ne. 4) call abort ()
+            hlp = ucp
+            if (len(hlp) .ne. 4) call abort ()
+        class default
+            call abort()
+        end select
+    end subroutine
+
+    subroutine sub4(ucp, ilen)
+        character(len=:), allocatable :: hlp
+        integer(4) :: ilen
+        class(*) :: ucp
+
+        select type (ucp)
+        type is (character(len=*))
+            if (len(ucp) .ne. ilen) call abort ()
+            hlp = ucp
+            if (len(hlp) .ne. ilen) call abort ()
+        class default
+            call abort()
+        end select
+    end subroutine
+end program
+
Index: gcc/testsuite/gfortran.dg/dependency_45.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dependency_45.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/dependency_45.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+! { dg-do run }
+! { dg-options "-Warray-temporaries" }
+! PR 56867 - substrings were not checked for dependency.
+program main
+  character(len=4) :: a
+  character(len=4) :: c(3)
+  c(1) = 'abcd'
+  c(2) = '1234'
+  c(3) = 'wxyz'
+  c(:)(1:2) = c(2)(2:3)   ! { dg-warning "array temporary" }
+  if (c(3) .ne. '23yz') call abort
+end program main
Index: gcc/testsuite/gfortran.dg/internal_pack_15.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/internal_pack_15.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/internal_pack_15.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,77 @@
+! { dg-do run }
+! { dg-options "-Warray-temporaries" }
+! PR 57023
+! This used to cause wrong packing because a(1:n,1:n) was
+! assumed to be a full array.
+module mymod
+  implicit none
+contains
+  subroutine foo1(a,n)
+    integer, dimension(n,n), intent(inout) :: a
+    integer :: n
+    n = n - 1
+    call baz(a(1:n,1:n),n)  ! { dg-warning "array temporary" }
+  end subroutine foo1
+
+  subroutine foo2(a,n)
+    integer, dimension(n,n), intent(inout) :: a
+    integer :: n
+    call decrement(n)
+    call baz(a(1:n,1:n),n)  ! { dg-warning "array temporary" }
+  end subroutine foo2
+
+  subroutine foo3(a,n)
+    integer, dimension(n,n), intent(inout) :: a
+    integer :: n, m
+    m = n - 1
+    call baz(a(1:m,1:m),m)  ! { dg-warning "array temporary" }
+  end subroutine foo3
+
+  subroutine foo4(a,n)
+    integer, dimension(n,n), intent(inout) :: a
+    integer, intent(in) :: n
+    a(1:n,1:n) = 1
+  end subroutine foo4
+
+  subroutine baz(a,n)
+    integer, dimension(n,n), intent(inout) :: a
+    integer, intent(in) :: n
+    a = 1
+  end subroutine baz
+
+  subroutine decrement(n)
+    integer, intent(inout) :: n
+    n = n - 1
+  end subroutine decrement
+
+end module mymod
+
+program main
+  use mymod
+  implicit none
+  integer, dimension(5,5) :: a, b
+  integer :: n
+
+  b = 0
+  b(1:4,1:4) = 1
+
+  n = 5
+  a = 0
+  call foo1(a,n)
+  if (any(a /= b)) call abort
+
+  n = 5
+  a = 0
+  call foo2(a,n)
+  if (any(a /= b)) call abort
+
+  n = 5
+  a = 0
+  call foo3(a,n)
+  if (any(a /= b)) call abort
+
+  n = 5
+  a = 0
+  call foo4(a,n)
+  if (any(a /= 1)) call abort
+end program main
Index: gcc/testsuite/gfortran.dg/class_allocate_17.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/class_allocate_17.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/class_allocate_17.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+! PR 60922: [4.9/5 regression] Memory leak with allocatable CLASS components
+!
+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>
+
+program test_leak
+  implicit none
+
+  type d_base_vect_type
+  end type
+
+  type d_vect_type
+    class(d_base_vect_type), allocatable :: v
+  end type
+
+  call test()
+
+contains
+
+  subroutine test()
+    class(d_vect_type), allocatable :: x
+    allocate(x)
+    allocate(x%v)
+    print *,"allocated!"
+  end subroutine
+
+end
+
+! { dg-final { scan-tree-dump-times "fini_coarray" 1 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
Index: gcc/testsuite/gfortran.dg/proc_ptr_comp_45.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/proc_ptr_comp_45.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gfortran.dg/proc_ptr_comp_45.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,49 @@
+! { dg-do run }
+! Test the fix for PR59198, where the field for the component 'term' in
+! the derived type 'decay_gen_t' was not being built.
+!
+! Contributed by Paul Thomas and based on the original testcase by
+! Juergen Reuter  <juergen.reuter@desy.de>
+!
+module decays
+
+  implicit none
+
+  interface
+    real elemental function iface (arg)
+      real, intent(in) :: arg
+    end function
+  end interface
+
+  type :: decay_term_t
+     type(decay_t), pointer :: unstable_product
+     integer :: i
+  end type
+
+  type :: decay_gen_t
+     procedure(iface), nopass, pointer :: obs1_int
+     type(decay_term_t), allocatable :: term
+  end type
+
+  type :: rng_t
+    integer :: i
+  end type
+
+  type, extends (decay_gen_t) :: decay_t
+     class(rng_t), allocatable :: rng
+  end type
+
+  class(decay_t), allocatable :: object
+
+end
+
+  use decays
+  type(decay_t), pointer :: template
+  real, parameter :: arg = 1.570796327
+  allocate (template)
+  allocate (template%rng)
+  template%obs1_int => cos
+  if (abs (template%obs1_int (arg) - cos (arg)) .gt. 1e-4) call abort
+  allocate (object, source = template)
+  if (abs (object%obs1_int (arg) - cos (arg)) .gt. 1e-4) call abort
+end
Index: gcc/testsuite/gcc.c-torture/execute/pr63659.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr63659.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr63659.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* PR rtl-optimization/63659 */
+
+int a, b, c, *d = &b, g, h, i;
+unsigned char e;
+char f;
+
+int
+main ()
+{
+  while (a)
+    {
+      for (a = 0; a; a++)
+	for (; c; c++)
+	  ;
+      if (i)
+	break;
+    }
+
+  char j = c, k = -1, l;
+  l = g = j >> h;
+  f = l == 0 ? k : k % l;
+  e = 0 ? 0 : f;
+  *d = e;
+
+  if (b != 255)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr64979.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr64979.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr64979.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+/* PR target/64979 */
+
+#include <stdarg.h>
+
+void __attribute__((noinline, noclone))
+bar (int x, va_list *ap)
+{
+  if (ap)
+    {
+      int i;
+      for (i = 0; i < 10; i++)
+	if (i != va_arg (*ap, int))
+	  __builtin_abort ();
+      if (va_arg (*ap, double) != 0.5)
+	__builtin_abort ();
+    }
+}
+
+void __attribute__((noinline, noclone))
+foo (int x, ...)
+{
+  va_list ap;
+  int n;
+
+  va_start (ap, x);
+  n = va_arg (ap, int);
+  bar (x, (va_list *) ((n == 0) ? ((void *) 0) : &ap));
+  va_end (ap);
+}
+
+int
+main ()
+{
+  foo (100, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0.5);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr64067.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr64067.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr64067.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR middle-end/64067 */
+
+struct S { int s; };
+int *const v[1] = { &((struct S) { .s = 42 }).s };
+
+int *
+foo (void)
+{
+  return v[0];
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr65163.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr65163.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr65163.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* PR target/65163  */
+
+typedef unsigned int uint32_t;
+typedef unsigned short uint16_t;
+union unaligned_32 { uint32_t l; } __attribute__((packed));
+union unaligned_16 { uint16_t l; } __attribute__((packed));
+
+int
+test_00 (unsigned char* buf, int bits_per_component)
+{
+  (((union unaligned_32*)(buf))->l) =
+    __builtin_bswap32 (bits_per_component == 10 ? 1 : 0);
+  return 0;
+}
+
+int
+test_01 (unsigned char* buf, int bits_per_component)
+{
+  (((union unaligned_16*)(buf))->l) =
+    __builtin_bswap16 (bits_per_component == 10 ? 1 : 0);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr64269.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr64269.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr64269.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR tree-optimization/64269 */
+
+void
+foo (char *p)
+{
+  __SIZE_TYPE__ s = ~(__SIZE_TYPE__)0;
+  *p = 0;
+  __builtin_memset (p + 1, 0, s);
+}
Index: gcc/testsuite/gnat.dg/opt45.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt45.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gnat.dg/opt45.adb	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,38 @@
+-- { dg-do compile }
+-- { dg-options "-O3" }
+
+procedure Opt45 is
+
+  type Index_T is mod 2 ** 32;
+  for Index_T'Size use 32;
+  for Index_T'Alignment use 1;
+
+  type Array_T is array (Index_T range <>) of Natural;
+  type Array_Ptr_T is access all Array_T;
+
+  My_Array_1 : aliased Array_T := (1, 2);
+  My_Array_2 : aliased Array_T := (3, 4);
+
+  Array_Ptr : Array_Ptr_T := null;
+  Index : Index_T := Index_T'First;
+
+  My_Value : Natural := Natural'First;
+
+  procedure Proc (Selection : Positive) is
+  begin
+    if Selection = 1 then
+      Array_Ptr := My_Array_1'Access;
+      Index := My_Array_1'First;
+    else
+      Array_Ptr := My_Array_2'Access;
+      Index := My_Array_2'First;
+    end if;
+
+    if My_Value = Natural'First then
+      My_Value := Array_Ptr.all (Index);
+    end if;
+  end;
+
+begin
+  Proc (2);
+end;
Index: gcc/testsuite/gnat.dg/unchecked_convert1.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/unchecked_convert1.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gnat.dg/unchecked_convert1.adb	(.../branches/gcc-4_9-branch)
@@ -4,6 +4,7 @@
 with Ada.Unchecked_Conversion;
 
 procedure Unchecked_Convert1 is
+
   type Byte is mod 2**8;
 
   type Stream is array (Natural range <>) of Byte;
@@ -24,9 +25,10 @@
     return Do_Sum (To_Chunk (S(S'First ..  S'First + Rec'Size / 8 - 1)));
   end;
 
-  A : Stream (1..9);
+  A : Stream (1..9) := (others => 0);
   I : Integer;
 
 begin
+  A (9) := 1;
   I := Sum (A(1..8));
 end;
Index: gcc/testsuite/gnat.dg/opt47.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt47.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gnat.dg/opt47.adb	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+-- { dg-do run { target i?86-*-* x86_64-*-* alpha*-*-* ia64-*-* } }
+-- { dg-options "-O2" }
+
+with Ada.Characters.Handling;   use Ada.Characters.Handling;
+with Interfaces;                use Interfaces;
+with Ada.Unchecked_Conversion;
+
+procedure Opt47 is
+
+   subtype String4 is String (1 .. 4);
+   function To_String4 is new Ada.Unchecked_Conversion (Unsigned_32, String4);
+   type Arr is array (Integer range <>) of Unsigned_32;
+   Leaf : Arr (1 .. 4) := (1349478766, 1948272498, 1702436946, 1702061409);
+   Value : Unsigned_32;
+   Result : String (1 .. 32);
+   Last : Integer := 0;
+
+begin
+   for I in 1 .. 4 loop
+      Value := Leaf (I);
+      for J in reverse String4'Range loop
+         if Is_Graphic (To_String4 (Value)(J)) then
+            Last := Last + 1;
+            Result (Last) := To_String4 (Value)(J);
+         end if;
+      end loop;
+   end loop;
+   if Result (1) /= 'P' then
+      raise Program_Error;
+   end if;
+end;
Index: gcc/testsuite/gnat.dg/loop_optimization18_pkg.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/loop_optimization18_pkg.ads	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gnat.dg/loop_optimization18_pkg.ads	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+with Unchecked_Conversion;
+
+package Loop_Optimization18_Pkg is
+
+   type Arr is array (Integer range <>) of Natural;
+
+   type Rec (UB : Integer) is record
+      L : Arr (1 .. UB);
+   end record;
+
+   type Byte_Array_Type is new String (1..4);
+
+   function Conv is new Unchecked_Conversion (Byte_Array_Type, Integer);
+
+end Loop_Optimization18_Pkg;
Index: gcc/testsuite/gnat.dg/loop_optimization18.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/loop_optimization18.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gnat.dg/loop_optimization18.adb	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+-- { dg-do compile }
+-- { dg-options "-O3" }
+
+package body Loop_Optimization18 is
+
+   procedure Proc (Message : Byte_Array_Type) is
+
+      R : Rec (Conv (Message));
+
+   begin
+      for Division in 1 .. R.UB loop
+         R.L (Division) := 0;
+      end loop;
+  end;
+
+end Loop_Optimization18;
Index: gcc/testsuite/gnat.dg/loop_optimization18.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/loop_optimization18.ads	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gnat.dg/loop_optimization18.ads	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+with Loop_Optimization18_Pkg; use Loop_Optimization18_Pkg;
+
+package Loop_Optimization18 is
+
+   procedure Proc (Message : Byte_Array_Type);
+
+end Loop_Optimization18;
Index: gcc/testsuite/gcc.dg/pr63762.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63762.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63762.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,77 @@
+/* PR middle-end/63762 */
+/* { dg-do assemble } */
+/* { dg-options "-O2" } */
+
+#include <stdlib.h>
+
+void *astFree ();
+void *astMalloc ();
+void astNegate (void *);
+int astGetNegated (void *);
+void astGetRegionBounds (void *, double *, double *);
+int astResampleF (void *, ...);
+
+extern int astOK;
+
+int
+MaskF (int inside, int ndim, const int lbnd[], const int ubnd[],
+       float in[], float val)
+{
+
+  void *used_region;
+  float *c, *d, *out, *tmp_out;
+  double *lbndgd, *ubndgd;
+  int *lbndg, *ubndg, idim, ipix, nax, nin, nout, npix, npixg, result = 0;
+  if (!astOK) return result;
+  lbndg = astMalloc (sizeof (int)*(size_t) ndim);
+  ubndg = astMalloc (sizeof (int)*(size_t) ndim);
+  lbndgd = astMalloc (sizeof (double)*(size_t) ndim);
+  ubndgd = astMalloc (sizeof (double)*(size_t) ndim);
+  if (astOK)
+    {
+      astGetRegionBounds (used_region, lbndgd, ubndgd);
+      npix = 1;
+      npixg = 1;
+      for (idim = 0; idim < ndim; idim++)
+        {
+          lbndg[ idim ] = lbnd[ idim ];
+          ubndg[ idim ] = ubnd[ idim ];
+          npix *= (ubnd[ idim ] - lbnd[ idim ] + 1);
+          if (npixg >= 0) npixg *= (ubndg[ idim ] - lbndg[ idim ] + 1);
+        }
+      if (npixg <= 0 && astOK)
+        {
+          if ((inside != 0) == (astGetNegated( used_region ) != 0))
+            {
+              c = in;
+              for (ipix = 0; ipix < npix; ipix++) *(c++) = val;
+              result = npix;
+            }
+        }
+      else if (npixg > 0 && astOK)
+        {
+          if ((inside != 0) == (astGetNegated (used_region) != 0))
+            {
+              tmp_out = astMalloc (sizeof (float)*(size_t) npix);
+              if (tmp_out)
+                {
+                  c = tmp_out;
+                  for (ipix = 0; ipix < npix; ipix++) *(c++) = val;
+                  result = npix - npixg;
+                }
+              out = tmp_out;
+            }
+          else
+            {
+              tmp_out = NULL;
+              out = in;
+            }
+          if (inside) astNegate (used_region);
+          result += astResampleF (used_region, ndim, lbnd, ubnd, in, NULL,
+                                  NULL, NULL, 0, 0.0, 100, val, ndim,
+                                  lbnd, ubnd, lbndg, ubndg, out, NULL);
+          if (inside) astNegate (used_region);
+        }
+    }
+  return result;
+}
Index: gcc/testsuite/gcc.dg/pr63637-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63637-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63637-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a) : "r" (0));
+  asm ("# Magic instruction" : "=r" (b) : "r" (0));
+  asm ("# Magic instruction" : "=r" (c) : "r" (0));
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 1 } } */
Index: gcc/testsuite/gcc.dg/pr61058.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr61058.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr61058.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR rtl-optimization/61058 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+/* { dg-additional-options "-fno-asynchronous-unwind-tables -mtune=atom" { target i?86-*-* x86_64-*-* } } */
+
+void
+foo (void)
+{
+  __builtin_unreachable ();
+}
Index: gcc/testsuite/gcc.dg/pr51879-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr51879-12.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr51879-12.c	(.../branches/gcc-4_9-branch)
@@ -24,6 +24,6 @@
   baz (a);
 }
 
-/* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre"} } */
-/* { dg-final { scan-tree-dump-times "bar2 \\(" 1 "pre"} } */
+/* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump-times "bar2 \\(" 1 "pre" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/pr63637-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63637-6.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63637-6.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c, d, e, f;
+  asm ("# Magic instruction" : "=r" (a), "=r" (d) : "r" (0));
+  asm ("# Magic instruction" : "=r" (b), "=r" (e) : "r" (0));
+  asm ("# Magic instruction" : "=r" (c), "=r" (f) : "r" (0));
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.dg/pr64536.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr64536.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr64536.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,67 @@
+/* PR rtl-optimization/64536 */
+/* { dg-do link } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-fPIC" { target fpic } } */
+
+struct S { long q; } *h;
+long a, b, g, j, k, *c, *d, *e, *f, *i;
+long *baz (void)
+{
+  asm volatile ("" : : : "memory");
+  return e;
+}
+
+void
+bar (int x)
+{
+  int y;
+  for (y = 0; y < x; y++)
+    {
+      switch (b)
+	{
+	case 0:
+	case 2:
+	  a++;
+	  break;
+	case 3:
+	  a++;
+	  break;
+	case 1:
+	  a++;
+	}
+      if (d)
+	{
+	  f = baz ();
+	  g = k++;
+	  if (&h->q)
+	    {
+	      j = *f;
+	      h->q = *f;
+	    }
+	  else
+	    i = (long *) (h->q = *f);
+	  *c++ = (long) f;
+	  e += 6;
+	}
+      else
+	{
+	  f = baz ();
+	  g = k++;
+	  if (&h->q)
+	    {
+	      j = *f;
+	      h->q = *f;
+	    }
+	  else
+	    i = (long *) (h->q = *f);
+	  *c++ = (long) f;
+	  e += 6;
+	}
+    }
+}
+
+int
+main ()
+{
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr63665.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63665.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63665.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+/* { dg-options "-O -fno-tree-ccp -fno-tree-fre -fno-tree-copy-prop -fwrapv" } */
+
+static inline int
+test5 (int x)
+{
+  int y = 0x80000000;
+  return x + y;
+}
+
+int
+main ()
+{
+  if (test5 (0x80000000) != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr63637-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63637-3.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63637-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a) : : "memory");
+  asm ("# Magic instruction" : "=r" (b) : : "memory");
+  asm ("# Magic instruction" : "=r" (c) : : "memory");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.dg/pr64663.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr64663.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr64663.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+/* PR debug/64663 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -g -w" } */
+
+void
+foo (void)
+{
+  int a[9];
+  a[-8] = 0;
+}
+
+void
+bar (void)
+{
+  int a[9];
+  a[-9] = 0;
+}
Index: gcc/testsuite/gcc.dg/pr62167-run.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62167-run.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62167-run.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-tail-merge" } */
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+int
+main ()
+{
+  struct node *p;
+
+  node.next = (void*)0;
+
+  node.prev = (void *)head;
+
+  head->first = &node;
+
+  struct node *n = head->first;
+
+  struct head *h = &heads[k];
+
+  heads[2].first = n->next;
+
+  if ((void*)n->prev == (void *)h)
+    p = h->first;
+  else
+    /* Dead tbaa-unsafe load from ((struct node *)&heads[2])->next.  */
+    p = n->prev->next;
+
+  return !(p == (void*)0);
+}
Index: gcc/testsuite/gcc.dg/pr63593.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63593.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63593.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fno-tree-vectorize" } */
+
+int in[2 * 4][4];
+int out[4];
+
+void
+foo (void)
+{
+  int sum;
+  int i, j, k;
+  for (k = 0; k < 4; k++)
+    {
+      sum = 1;
+      for (j = 0; j < 4; j++)
+	for (i = 0; i < 4; i++)
+	  sum *= in[i + k][j];
+      out[k] = sum;
+    }
+}
Index: gcc/testsuite/gcc.dg/pr52769.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr52769.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr52769.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+/* PR c/52769 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+typedef struct
+{
+  int should_be_zero;
+  char s[6];
+  int x;
+} foo_t;
+
+int
+main (void)
+{
+  volatile foo_t foo = {
+    .s = "123456",
+    .x = 2
+  };
+
+  if (foo.should_be_zero != 0)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr63637-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63637-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63637-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a) : "r" (0) : "memory");
+  asm ("# Magic instruction" : "=r" (b) : "r" (0) : "memory");
+  asm ("# Magic instruction" : "=r" (c) : "r" (0) : "memory");
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.dg/Warray-bounds-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/Warray-bounds-12.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/Warray-bounds-12.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -Warray-bounds" } */
+/* { dg-additional-options "-mssse3" { target x86_64-*-* i?86-*-* } } */
+
+void foo(short a[], short m)
+{
+  int i, j;
+  int f1[10];
+  short nc;
+
+  nc = m + 1;
+  if (nc > 3)
+    {
+      for (i = 0; i <= nc; i++)
+	{
+	  f1[i] = f1[i] + 1;
+	}
+    }
+
+  for (i = 0, j = m; i < nc; i++, j--)
+    {
+      a[i] = f1[i]; /* { dg-bogus "above array bounds" } */
+      a[j] = i;
+    }
+  return;
+}
Index: gcc/testsuite/gcc.dg/pr62167.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62167.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62167.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-tail-merge -fdump-tree-pre" } */
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+int
+main ()
+{
+  struct node *p;
+
+  node.next = (void*)0;
+
+  node.prev = (void *)head;
+
+  head->first = &node;
+
+  struct node *n = head->first;
+
+  struct head *h = &heads[k];
+
+  heads[2].first = n->next;
+
+  if ((void*)n->prev == (void *)h)
+    p = h->first;
+  else
+    /* Dead tbaa-unsafe load from ((struct node *)&heads[2])->next.  */
+    p = n->prev->next;
+
+  return !(p == (void*)0);
+}
+
+/* { dg-final { scan-tree-dump-not "Removing basic block" "pre"} } */
+/* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/pr64766.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr64766.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr64766.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR c/64766 */
+/* { dg-do compile } */
+
+void
+foo ()
+{
+}
+
+void foo () = 0; /* { dg-error "is initialized like a variable|invalid initializer" } */
Index: gcc/testsuite/gcc.dg/pr65063.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr65063.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr65063.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-tree-loop-ivcanon -fno-tree-vectorize" } */
+
+static int in[8][4];
+static int out[4];
+static const int check_result[] = {0, 16, 256, 4096};
+
+static inline void foo ()
+{
+  int sum;
+  int i, j, k;
+  for (k = 0; k < 4; k++)
+    {
+      sum = 1;
+      for (j = 0; j < 4; j++)
+	for (i = 0; i < 4; i++)
+	  sum *= in[i + k][j];
+      out[k] = sum;
+    }
+}
+
+int main ()
+{
+  int i, j, k;
+  for (i = 0; i < 8; i++)
+    for (j = 0; j < 4; j++)
+      in[i][j] = (i + 2) / 3;
+  foo ();
+  for (k = 0; k < 4; k++)
+    if (out[k] != check_result[k])
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/lto/pr64373_0.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/lto/pr64373_0.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/lto/pr64373_0.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* { dg-lto-do assemble } */
+
+extern void b(int L, float (*data)[L]);
+
+void a(void)
+{
+  float* p = 0;
+  int i = 0;
+  b(10, (float (*)[10])(p + i));
+}
Index: gcc/testsuite/gcc.dg/torture/pr63738.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr63738.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr63738.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+/*  { dg-do compile } */
+
+#include <setjmp.h>
+
+struct longjmp_buffer {
+  jmp_buf buf;
+};
+
+void plouf();
+
+extern long interprete()
+{
+  long * sp;
+  int i;
+  long *args;
+  int n;
+
+  struct longjmp_buffer raise_buf;
+  setjmp (raise_buf.buf);
+
+  plouf();
+  sp -= 4;
+  for (i = 0; i < n; i++)
+    args[i] = sp[10-i];
+  plouf();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr64199.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr64199.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr64199.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-ffast-math -frounding-math" } */
+
+float
+foo (void)
+{
+  return 1.1f + 2.2f + 2.2f;
+}
Index: gcc/testsuite/gcc.dg/torture/pr62238.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr62238.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr62238.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+
+int a[4], b, c, d; 
+
+int
+fn1 (int p)
+{
+  for (; d; d++)
+    {
+      unsigned int h;
+      for (h = 0; h < 3; h++)
+	{
+	  if (a[c+c+h])
+	    {
+	      if (p)
+		break;
+	      return 0;
+	    }
+	  b = 0;
+	}
+    }
+  return 0;
+}
+
+int
+main ()
+{
+  fn1 (0);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr64365.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr64365.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr64365.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+extern void abort (void);
+extern int memcmp (const void * , const void *, __SIZE_TYPE__);
+
+void __attribute__((noinline,noclone))
+foo(int *in)
+{
+  int i;
+  for (i = 62; i >= 10; i--)
+    {
+      in[i - 8] -= in[i];
+      in[i - 5] += in[i] * 2;
+      in[i - 4] += in[i];
+    }
+}
+
+int main()
+{
+  int x[64];
+  int y[64] = { 0, 1, -2380134, -1065336, -1026376, 3264240, 3113534, 2328130, 3632054, 3839634, 2380136, 1065339, 1026380, 1496037, 1397286, 789976, 386408, 450984, 597112, 497464, 262008, 149184, 194768, 231519, 173984, 87753, 60712, 82042, 87502, 60014, 30050, 25550, 33570, 32386, 20464, 10675, 10868, 13329, 11794, 6892, 3988, 4564, 5148, 4228, 2284, 1568, 1848, 1943, 1472, 741, 628, 702, 714, 474, 230, 234, 238, 242, 120, 59, 60, 61, 62, 63 };
+  int i;
+
+  for (i = 0; i < 64; ++i)
+    {
+      x[i] = i;
+      __asm__ volatile ("");
+    }
+
+  foo (x);
+
+  if (memcmp (x, y, sizeof (x)) != 0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/stdarg-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/stdarg-7.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* PR target/64979 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-stdarg" } */
+
+#include <stdarg.h>
+
+void bar (int x, va_list *ap);
+
+void
+foo (int x, ...)
+{
+  va_list ap;
+  int n;
+
+  va_start (ap, x);
+  n = va_arg (ap, int);
+  bar (x, (va_list *) ((n == 0) ? ((void *) 0) : &ap));
+  va_end (ap);
+}
+
+/* { dg-final { scan-tree-dump "foo: va_list escapes 1, needs to save all GPR units and all FPR units" "stdarg" } } */
+/* { dg-final { cleanup-tree-dump "stdarg" } } */
Index: gcc/testsuite/gcc.dg/pr63637-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63637-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63637-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c;
+  asm ("# Magic instruction" : "=r" (a));
+  asm ("# Magic instruction" : "=r" (b));
+  asm ("# Magic instruction" : "=r" (c));
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 1 } } */
Index: gcc/testsuite/gcc.dg/pr64563.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr64563.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr64563.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* PR tree-optimization/64563 */
+/* { dg-do compile } */
+/* { dg-options "-Os -Wtype-limits" } */
+
+int a, b, c, d, f;
+unsigned int e;
+
+void
+foo (void)
+{
+  d = b = (a != (e | 4294967288UL));
+  if (!d)
+    c = f || b;
+}
Index: gcc/testsuite/gcc.dg/ipa/pr64041.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr64041.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr64041.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,64 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+int printf (const char *, ...);
+
+int a, b = 1, d;
+
+union U1
+{
+  unsigned int f0;
+  int f1;
+};
+
+union U2
+{
+  int f2;
+  int f3;
+} c;
+
+int
+fn1 (int p)
+{
+  int t = p && a || p && a && p; 
+  return t ? t : a;
+}
+
+unsigned
+fn2 (union U1 p1, union U2 p2)
+{
+  if (p1.f1 <= 0)
+    {
+      for (; p2.f2;)
+	c.f2 = 0;
+      p2.f2 = fn1 (d);
+    }
+  return p2.f3;
+}
+
+int g = 0;
+
+int
+foo ()
+{
+  if (b)
+    {
+      union U1 f = { 0xFFFFFFFFU }; 
+
+      fn2 (f, c);
+    }
+  g = 1;
+  return 0; 
+}
+
+
+int
+main ()
+{
+  foo ();
+
+  if (g == 0)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/ipa/PR64559.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/PR64559.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/PR64559.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-Os"  } */
+
+int a, b, c, d;
+
+struct S
+{
+  int f0;
+};
+
+static int
+fn1 (int p)
+{
+  return p == 0 || a;
+}
+
+static int
+fn2 ()
+{
+  d = fn1 (c);
+  return 0;
+}
+
+static int
+fn3 (struct S p)
+{
+  p.f0 || fn2 ();
+  if (fn1 (1))
+    b = 0;
+  return 0;
+}
+
+int
+main ()
+{
+  struct S e = { 1 };
+  fn3 (e);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/ipa/pr63551.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr63551.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr63551.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-Os" } */
+
+union U
+{
+  unsigned int f0;
+  int f1;
+};
+
+int a, d;
+
+void
+fn1 (union U p)
+{
+  if (p.f1 <= 0)
+    if (a)
+      d = 0;
+}
+
+void
+fn2 ()
+{
+  d = 0;
+  union U b = { 4294967286U };
+  fn1 (b);
+}
+
+int
+main ()
+{
+  fn2 ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr63637-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63637-5.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63637-5.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* PR rtl-optimization/63637 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int
+foo (void)
+{
+  int a, b, c, d, e, f;
+  asm ("# Magic instruction" : "=r" (a), "=r" (d));
+  asm ("# Magic instruction" : "=r" (b), "=r" (e));
+  asm ("# Magic instruction" : "=r" (c), "=r" (f));
+  return a + b + c;
+}
+
+/* { dg-final { scan-assembler-times "# Magic instruction" 3 } } */
Index: gcc/testsuite/gcc.dg/Warray-bounds-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/Warray-bounds-13.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/Warray-bounds-13.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -Warray-bounds" } */
+
+extern char *bar[17];
+
+int foo(int argc, char **argv)
+{
+  int i;
+  int n = 0;
+
+  for (i = 0; i < argc; i++)
+    n++;
+
+  for (i = 0; i < argc; i++)
+    argv[i] = bar[i + n]; /* { dg-bogus "above array bounds" } */
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr64778.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr64778.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr64778.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR c/64778 */
+/* { dg-do compile } */
+
+int
+foo (int p)
+{
+  int a;
+  a ^= foo (,);	/* { dg-error "expected expression before|too many arguments" } */
+  return a;
+}
Index: gcc/testsuite/gcc.dg/pr65228.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr65228.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr65228.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,11 @@
+/* PR c/65228 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+__auto_type a = b; /* { dg-error "undeclared" } */
+
+void
+f (void)
+{
+  __auto_type c = d; /* { dg-error "undeclared" } */
+}
Index: gcc/testsuite/gcc.dg/tm/pr64391.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tm/pr64391.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/tm/pr64391.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR middle-end/64391 */
+/* { dg-do compile } */
+/* { dg-options "-fgnu-tm" } */
+
+void
+foo (void)
+{
+#pragma GCC ivdep
+  while (1);
+}
Index: gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-require-effective-target vect_int } */
+/* { dg-do compile } */
+
+#define N 16 
+
+const unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
+unsigned int out[N];
+
+__attribute__ ((noinline)) int
+main1 (void)
+{
+  const unsigned int *pin = &in[1];
+  unsigned int *pout = &out[0];
+
+  /* Misaligned load.  */
+  *pout++ = *pin++;
+  *pout++ = *pin++;
+  *pout++ = *pin++;
+  *pout++ = *pin++;
+
+  return 0;
+}
+
+/* Verify that the assembly contains vector instructions alone
+   with no word loads (lw, lwu, lwz, lwzu, or their indexed forms)
+   or word stores (stw, stwu, stwx, stwux, or their indexed forms).  */
+
+/* { dg-final { scan-assembler "\t\(lxv|lvsr|stxv\)" } } */
+/* { dg-final { scan-assembler-not "\tlwz?u?x? " } } */
+/* { dg-final { scan-assembler-not "\tstwu?x? " } } */
Index: gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,5 @@
 /* { dg-require-effective-target vect_int } */
 
-#include <stdarg.h>
 #include "../../tree-vect.h"
 
 #define N 16 
@@ -9,12 +8,10 @@
 unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
 
 __attribute__ ((noinline)) int
-main1 (unsigned int x, unsigned int y)
+main1 (void)
 {
-  int i;
   unsigned int *pin = &in[1];
   unsigned int *pout = &out[0];
-  unsigned int a0, a1, a2, a3;
 
   /* Misaligned load.  */
   *pout++ = *pin++;
@@ -22,13 +19,6 @@
   *pout++ = *pin++;
   *pout++ = *pin++;
 
-  /* Check results.  */
-  if (out[0] != in[1]
-      || out[1] != in[2]
-      || out[2] != in[3]
-      || out[3] != in[4])
-    abort();
-
   return 0;
 }
 
@@ -36,11 +26,18 @@
 {
   check_vect ();
 
-  main1 (2, 3);
+  main1 ();
 
+  /* Check results.  */
+  if (out[0] != in[1]
+      || out[1] != in[2]
+      || out[2] != in[3]
+      || out[3] != in[4])
+    abort();
+
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { xfail  vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "basic block vectorized" 1 "slp"  { xfail  vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
Index: gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr64909.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr64909.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr64909.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
+/* { dg-additional-options "-mtune=bdver1" } */
+
+unsigned short a[32];
+unsigned int b[32];
+void t()
+{
+  int i;
+  for (i=0;i<12;i++)
+    b[i]=a[i];
+}
+
+/* { dg-final { scan-tree-dump "vectorized 1 loops in function" "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/vect-pr61917.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/vect-pr61917.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-pr61917.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O3" } */
+
+int a, b, c, d;
+
+int
+fn1 ()
+{
+  for (; c; c++)
+    for (b = 0; b < 2; b++)
+      d = a - d;
+  return d; 
+}
Index: gcc/testsuite/gcc.dg/vect/pr64493.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr64493.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64493.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+int a, b, c, d, e, f, g, h;
+
+int
+main ()
+{
+  check_vect ();
+
+  for (; a; a--)
+    for (d = 1; d <= 0; d++)
+      for (; d;)
+	if (h)
+	  {
+	    if (!g) __builtin_abort ();
+	    if (!0) __builtin_abort ();
+	  }
+
+  for (f = 4; f; f--)
+    {
+      for (b = 0; b < 2; b++)
+	c |= 1;
+      e |= c;
+    }
+
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr64495.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr64495.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64495.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+/* { dg-do run } */
+
+#include <assert.h>
+#include "tree-vect.h"
+
+int a, b, c, d, e, f, g, i, j;
+static int *h = &e;
+
+int
+main ()
+{
+  check_vect ();
+
+  for (; a;)
+    for (; g; g++)
+      for (; f; f++)
+	if (j)
+	  {
+	    assert(b); 
+	    assert(0);
+	  }
+  for (i = 24; i; i--)
+    {
+      for (c = 0; c < 6; c++)
+	d |= 1;
+      *h |= d;
+    }
+
+  if (e != 1) 
+    __builtin_abort (); 
+
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr59354.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr59354.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr59354.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-additional-options "-O3" } */
+
+#include "tree-vect.h"
+
+void abort (void);
+
+unsigned int a[256];
+unsigned char b[256];
+
+__attribute__ ((noinline)) void
+main1()
+{
+  int i, z, x, y;
+
+  for(i = 0; i < 256; i++)
+    {
+      a[i] = i % 5;
+      __asm__ volatile ("");
+    }
+
+  for (z = 0; z < 16; z++)
+    for (y = 0; y < 4; y++)
+      for (x = 0; x < 4; x++)
+	b[y*64 + z*4 + x] = a[z*16 + y*4 + x];
+
+  if (b[4] != 1)
+    abort ();
+}
+
+int main (void)
+{
+  check_vect ();
+
+  main1 ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "vectorized 1 loop" "vect" { target { vect_pack_trunc } } } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr64421.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr64421.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr64421.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,36 @@
+/* PR middle-end/64421 */
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-additional-options "-fopenmp-simd" } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+
+#include "tree-vect.h"
+
+#pragma omp declare simd linear (y) notinbranch
+int foo (int x, int y) __asm ("bar");
+
+#pragma omp declare simd linear (y) notinbranch
+int
+foo (int x, int y)
+{
+  return x + y;
+}
+
+int a[1024] = { 1, 2 };
+
+int
+main ()
+{
+  int i;
+  check_vect ();
+  #pragma omp simd
+  for (i = 0; i < 1024; i++)
+    a[i] = foo (a[i], i);
+  if (a[0] != 1 || a[1] != 3)
+    abort ();
+  for (i = 2; i < 1024; i++)
+    if (a[i] != i)
+      abort ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr61634.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr61634.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr61634.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+
+int a, b, c, d;
+short *e;
+void fn1 (int p1[], int p2, int p3[], int p4[], int p5[], int *p6)
+{
+  int f;
+  c = *p1;
+  d = *p5;
+  (void)p6;
+  for (; a; a--)
+    {
+      f = *e >> 2;
+      *e++ = f;
+      b += f * f;
+      f = *e >> 2;
+      *e++ = f;
+    }
+  p4[0] = p3[0];
+  for (;; p2--)
+    ;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr63605.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr63605.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63605.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+extern void abort (void);
+
+int a, b[8] = { 2, 0, 0, 0, 0, 0, 0, 0 }, c[8];
+
+int
+main ()
+{
+  int d;
+  check_vect ();
+  for (; a < 8; a++)
+    {
+      d = b[a] >> 1;
+      c[a] = d != 0;
+    }
+  if (c[0] != 1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr62021.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr62021.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62021.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-additional-options "-fopenmp-simd" } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+
+#pragma omp declare simd linear(y)
+__attribute__((noinline)) int *
+foo (int *x, int y)
+{
+  return x + y;
+}
+
+int a[1024];
+int *b[1024] = { &a[0] };
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 1024; i++)
+    b[i] = &a[1023 - i];
+  #pragma omp simd
+  for (i = 0; i < 1024; i++)
+    b[i] = foo (b[i], i);
+  for (i = 0; i < 1024; i++)
+    if (b[i] != &a[1023])
+      __builtin_abort ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/20141029-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/20141029-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/20141029-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-fstrict-volatile-bitfields -fdump-rtl-final" } */
+
+#define PERIPH (*(volatile struct system_periph *)0x81234)
+
+struct system_periph {
+  union {
+    unsigned short WORD;
+    struct {
+      unsigned short a:1;
+      unsigned short b:1;
+      unsigned short  :5;
+      unsigned short c:1;
+      unsigned short  :8;
+    } BIT;
+  } ALL;
+};
+
+void
+foo()
+{
+  while (1)
+    {
+      PERIPH.ALL.BIT.a = 1;
+    }
+}
+/* { dg-final { scan-rtl-dump-times "mem/v(/.)*:HI" 4 "final" } } */
+/* { dg-final { cleanup-rtl-dump "final" } } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,984 @@
+2015-03-26  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport r214254 and related tests from mainline
+	* gcc.target/powerpc/swaps-p8-1.c: New test.
+	* gcc.target/powerpc/swaps-p8-2.c: New test.
+	* gcc.target/powerpc/swaps-p8-3.c: New test.
+	* gcc.target/powerpc/swaps-p8-4.c: New test.
+	* gcc.target/powerpc/swaps-p8-5.c: New test.
+	* gcc.target/powerpc/swaps-p8-6.c: New test.
+	* gcc.target/powerpc/swaps-p8-7.c: New test.
+	* gcc.target/powerpc/swaps-p8-8.c: New test.
+	* gcc.target/powerpc/swaps-p8-9.c: New test.
+	* gcc.target/powerpc/swaps-p8-10.c: New test.
+	* gcc.target/powerpc/swaps-p8-11.c: New test.
+	* gcc.target/powerpc/swaps-p8-12.c: New test.
+	* gcc.target/powerpc/swaps-p8-13.c: New test.
+	* gcc.target/powerpc/swaps-p8-14.c: New test.
+	* gcc.target/powerpc/swaps-p8-15.c: New test.
+	* gcc.target/powerpc/swaps-p8-16.c: New test.
+	* gcc.target/powerpc/swaps-p8-17.c: New test.
+
+2015-03-26  Alan Modra  <amodra@gmail.com>
+
+	* gcc.target/powerpc/pr53199.c: Add extra functions.  Revert
+	2014-12-05 change.
+
+2015-03-24  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+
+	Backport from mainline:
+
+	2015-02-19  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+	PR testsuite/65116
+	* lib/target-supports.exp (check_compile): Check whether
+	additional_sources is defined before using it.
+
+	2015-02-19  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+	* lib/target-supports.exp (check_compile): Save/restore
+	additional_sources that may belong to an actual test.
+
+2015-03-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/60851
+	* gcc.target/i386/pr60851.c: New test.
+
+2015-03-23  Andre Vehreschild  <vehre@gmx.de>
+
+	Backport from mainline
+	PR fortran/60255
+	* gfortran.dg/unlimited_polymorphic_2.f03: Removed error.
+	Converted from dos to unix line endings.
+	* gfortran.dg/unlimited_polymorphic_20.f03: New test.
+
+2015-03-23  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from trunk r216841.
+	2014-10-29  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/63587
+	* g++.dg/ipa/pr63587-1.C: New test.
+	* g++.dg/ipa/pr63587-2.C: New test.
+
+2015-03-21  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/61138
+	* gfortran.dg/pointer_remapping_9.f90: New.
+
+2015-03-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/59198
+	* gfortran.dg/proc_ptr_comp_44.f90 : New test
+	* gfortran.dg/proc_ptr_comp_45.f90 : New test
+
+2015-03-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-03-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR rtl-optimization/65235
+	* gcc.target/aarch64/pr65235_1.c: New test.
+
+2015-03-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* testsuite/g++.dg/pr65049.C: New test.
+
+2015-03-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/loop_optimization18.ad[sb]: New test.
+	* gnat.dg/loop_optimization18_pkg.ads: New helper.
+
+2015-03-12  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/60898
+	* gfortran.dg/entry_20.f90: New.
+
+2015-03-12  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	* gcc.target/s390/hotpatch-21.c: New test for hotpatch alignment.
+	* gcc.target/s390/hotpatch-22.c: Likewise.
+	* gcc.target/s390/hotpatch-23.c: Likewise.
+	* gcc.target/s390/hotpatch-24.c: Likewise.
+	* gcc.target/s390/hotpatch-2.c: Also check hotpatch alignment.
+	* gcc.target/s390/hotpatch-1.c: Update expected output.
+	* gcc.target/s390/hotpatch-2.c: Likewise.
+	* gcc.target/s390/hotpatch-3.c: Likewise.
+	* gcc.target/s390/hotpatch-4.c: Likewise.
+	* gcc.target/s390/hotpatch-5.c: Likewise.
+	* gcc.target/s390/hotpatch-6.c: Likewise.
+	* gcc.target/s390/hotpatch-7.c: Likewise.
+	* gcc.target/s390/hotpatch-8.c: Likewise.
+	* gcc.target/s390/hotpatch-9.c: Likewise.
+	* gcc.target/s390/hotpatch-10.c: Likewise.
+	* gcc.target/s390/hotpatch-11.c: Likewise.
+	* gcc.target/s390/hotpatch-12.c: Likewise.
+	* gcc.target/s390/hotpatch-13.c: Likewise.
+	* gcc.target/s390/hotpatch-14.c: Likewise.
+	* gcc.target/s390/hotpatch-15.c: Likewise.
+	* gcc.target/s390/hotpatch-16.c: Likewise.
+	* gcc.target/s390/hotpatch-17.c: Likewise.
+	* gcc.target/s390/hotpatch-18.c: Likewise.
+	* gcc.target/s390/hotpatch-19.c: Likewise.
+
+2015-03-12  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	Backport from mainline
+	2015-02-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* gcc.target/s390/20140327-1.c: Remove -m31 and guard with ! lp64.
+	* gcc.target/s390/hotpatch-8.c: Likewise.
+	* gcc.target/s390/hotpatch-9.c: Likewise.
+	* gcc.target/s390/pr57960.c: Remove -m64.
+	* gcc.target/s390/pr57559.c: Likewise.
+
+2015-03-11  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2014-12-04  Marek Polacek  <polacek@redhat.com>
+
+	PR middle-end/56917
+	* c-c++-common/ubsan/pr56917.c: New test.
+
+2015-03-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from mainline
+	PR fortran/65024
+	* gfortran.dg/unlimited_polymorphic_23.f90: New test
+
+2015-03-10  Martin Sebor  <msebor@redhat.com>
+
+	PR testsuite/63175
+	* gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c (main1): Move
+	checking of results into main to prevent it from getting optimized
+	away.
+	* gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a-pr63175.c: New test.
+
+2015-03-10  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from trunk r220489.
+	2015-02-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/64896
+	* g++.dg/ipa/pr64896.C: New test
+
+2015-03-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/53988
+	* gcc.target/sh/pr53988.c: Mark tests as xfail.
+
+2015-03-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/other/dump-ada-spec-3.C: Remove include and adjust.
+
+2015-03-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/other/dump-ada-spec-3.C: New test.
+
+2015-03-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-11-27  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/59593
+	* gcc.target/arm/constant-pool.c: New test.
+
+2015-03-03  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/64331
+	* gcc.target/avr/torture/pr64331.c: New test.
+
+2015-03-03  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2015-01-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/64453
+	* gcc.target/arm/pr64453.c: New.
+
+2015-02-27  Pat Haugen <pthaugen@us.ibm.com>
+
+	* gcc.dg/vect/pr59354.c: Move vector producing code to
+	separate function.
+
+2015-02-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2015-02-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c/65228
+	* gcc.dg/pr65228.c: New test.
+
+2015-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR lto/65193
+	* g++.dg/lto/pr65193_0.C: New testcase.
+
+2015-02-26  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2015-02-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* gcc.target/powerpc/htm-builtin-1.c (dg-do) Change to assemble.
+	(dg-options): Add -save-temps.
+	(dg-final): Add cleanup-saved-temps.
+
+	2015-02-25  Adhemerval Zanella  <azanella@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/htm-builtin-1.c: Fix tcheck expect value.
+
+2015-02-25  Kai Tietz  <ktietz@redhat.com>
+
+	Backported from mainline
+	PR tree-optimization/61917
+	* gcc.dg/vect/vect-pr61917.c: New file.
+
+2015-02-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2015-02-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/65163
+	* gcc.c-torture/compile/pr65163.c: New.
+
+2015-02-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-11-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61634
+	* gcc.dg/vect/pr61634.c: New testcase.
+
+	2015-01-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/59354
+	* gcc.dg/vect/pr59354.c: New testcase.
+
+	2015-02-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64909
+	* gcc.dg/vect/costmodel/x86_64/costmodel-pr64909.c: New testcase.
+
+2015-02-23  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	Backport from mainline
+	2015-02-23  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+	* gcc.target/s390/hotpatch-1.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-10.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-11.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-12.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-13.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-14.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-15.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-16.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-17.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-18.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-19.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-2.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-20.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-3.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-4.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-5.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-6.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-7.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-8.c: Remove --save-temps option.
+	* gcc.target/s390/hotpatch-9.c: Remove --save-temps option.
+	* gcc.target/s390/htm-nofloat-1.c: Cleanup --save-temps files.
+
+2015-02-23  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	Backport from mainline
+	2015-02-23  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+	* gcc.target/s390/hotpatch-8.c: Add -march=g5.
+	* gcc.target/s390/hotpatch-9.c: Add -march=g5.
+	* gcc.target/s390/hotpatch-compile-1.c: Fix error message.
+	* gcc.target/s390/hotpatch-compile-10.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-11.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-12.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-13.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-14.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-2.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-3.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-4.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-5.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-6.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-7.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-8.c: Likewise.
+	* gcc.target/s390/hotpatch-compile-9.c: Likewise.
+
+2015-02-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2015-02-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/aarch64/sisd-shft-neg_1.c: New test.
+
+2015-02-20  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2015-02-20 trunk r220847.
+
+	PR target/64452
+	* gcc.target/avr/torture/pr64452.c: New test.
+
+2015-02-20  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-01-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64530
+	* gfortran.dg/pr64530.f90: New testcase.
+
+	2015-02-13  Richard Biener  <rguenther@suse.de>
+
+	PR lto/64373
+	* gcc.dg/lto/pr64373_0.c: New testcase.
+
+	2015-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63593
+	* gcc.dg/pr63593.c: New testcase.
+
+	2015-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/65063
+	* gcc.dg/pr65063.c: New testcase.
+
+2015-02-19  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-12-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64199
+	* gcc.dg/torture/pr64199.c: New testcase.
+
+	2015-01-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64493
+	PR tree-optimization/64495
+	* gcc.dg/vect/pr64493.c: New testcase.
+	* gcc.dg/vect/pr64495.c: Likewise.
+
+	2015-01-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/56273
+	PR tree-optimization/59124
+	PR tree-optimization/64277
+	* g++.dg/warn/Warray-bounds-6.C: New testcase.
+	* gcc.dg/Warray-bounds-12.c: Likewise.
+	* gcc.dg/Warray-bounds-13.c: Likewise.
+
+	2015-02-19  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2015-01-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64365
+	* gcc.dg/torture/pr64365.c: New testcase.
+
+2015-02-19  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+
+	Revert:
+
+	2015-02-19  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+	Backport from mainline
+	2015-02-19  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+
+	* lib/target-supports.exp (check_compile): Save/restore
+	additional_sources that may belong to an actual test.
+
+2015-02-19  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+
+	Backport from mainline
+	2015-02-19  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>
+
+	* lib/target-supports.exp (check_compile): Save/restore
+	additional_sources that may belong to an actual test.
+
+2015-02-17  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Backported from mainline
+	2015-02-17  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* gcc.target/arm/divzero.c: New test case.
+
+2015-02-17  Ilya Tocar  <ilya.tocar@intel.com>
+
+	Backport from mainline
+	2015-01-14  Ilya Tocar  <ilya.tocar@intel.com>
+
+	PR target/64387
+	* gcc.target/i386/pr64387.c: New test.
+
+2015-02-13  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/63744
+	gfortran.dg/use_rename_8.f90: New.
+
+2015-02-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from mainline
+	2015-02-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/64932
+	* gfortran.dg/finalize_28.f90: New test
+
+2015-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/64979
+	* gcc.dg/tree-ssa/stdarg-7.c: New test.
+	* gcc.c-torture/execute/pr64979.c: New test.
+
+2015-02-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-07-24  Marek Polacek  <polacek@redhat.com>
+
+	PR c/57653
+	* c-c++-common/pr57653.c: New test.
+	* c-c++-common/pr57653.h: New file.
+	* c-c++-common/pr57653-2.c: New test.
+	* c-c++-common/pr57653-2.h: New file.
+
+2015-02-09  Dominik Vogt  <vogt@linux.vnet.ibm.com>
+
+	* gcc/testsuite/gcc.target/s390/hotpatch-13.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-14.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-15.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-16.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-17.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-18.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-19.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-20.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-10.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-11.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-12.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-13.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-14.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-15.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-16.c: New testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-9.c: New
+	testcase.
+	* gcc/testsuite/gcc.target/s390/hotpatch-1.c: Testcase adjusted to
+	new -mhotpatch.
+	* gcc/testsuite/gcc.target/s390/hotpatch-10.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-11.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-12.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-2.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-3.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-4.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-5.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-6.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-7.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-8.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-9.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-1.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-2.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-3.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-4.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-5.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-6.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-7.c: Likewise.
+	* gcc/testsuite/gcc.target/s390/hotpatch-compile-8.c: Likewise.
+
+2015-02-04  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline
+	2015-01-15  Martin Liska  <mliska@suse.cz>
+
+	* g++.dg/ipa/pr64068.C: New test.
+	* gcc.dg/ipa/PR64559.c: New test.
+
+2015-02-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2015-01-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/64882
+	* gcc.dg/torture/pr64882.c: New test.
+
+2015-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2015-01-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.target/i386/builtin_target.c (check_intel_cpu_model): Add
+	Silvermont, Ivy Bridge, Haswell and Broadwell tests.  Update Sandy
+	Bridge test.
+
+2015-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/61058
+	* gcc.dg/pr61058.c: New test.
+
+	PR c/64766
+	* gcc.dg/pr64766.c: New test.
+
+	2015-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64778
+	* gcc.dg/pr64778.c: New test.
+
+	PR middle-end/64421
+	* gcc.dg/vect/pr64421.c: New test.
+
+	2015-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/63637
+	PR rtl-optimization/60663
+	* gcc.dg/pr63637-1.c: New test.
+	* gcc.dg/pr63637-2.c: New test.
+	* gcc.dg/pr63637-3.c: New test.
+	* gcc.dg/pr63637-4.c: New test.
+	* gcc.dg/pr63637-5.c: New test.
+	* gcc.dg/pr63637-6.c: New test.
+	* gcc.target/i386/pr63637-1.c: New test.
+	* gcc.target/i386/pr63637-2.c: New test.
+	* gcc.target/i386/pr63637-3.c: New test.
+	* gcc.target/i386/pr63637-4.c: New test.
+	* gcc.target/i386/pr63637-5.c: New test.
+	* gcc.target/i386/pr63637-6.c: New test.
+
+	2015-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/64663
+	* gcc.dg/pr64663.c: New test.
+
+2015-01-29  Ilya Tocar  <ilya.tocar@intel.com>
+
+	* gcc.target/i386/sse-14.c: Test new intrinsic.
+	* gcc.target/i386/sse-22.c: Ditto.
+
+2015-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/62044
+	* gfortran.dg/allocate_with_mold_1.f90: New test
+
+2015-01-27  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/64230
+	* gfortran.dg/class_allocate_18.f90: Remove -fsanitize option to
+	prevent linking errors.
+
+2015-01-27  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/64771
+	* gfortran.dg/coarray_36.f: New.
+	* gfortran.dg/coarray_37.f90: New.
+
+2015-01-26  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/64230
+	* gfortran.dg/class_allocate_18.f90: New.
+
+2015-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR testsuite/64712
+	* gnat.dg/unchecked_convert1.adb (Unchecked_Convert1): Initialize A.
+
+2015-01-24  Thomas Koenig  <tkoenig@netcologne.de>
+
+	Backport from trunk
+	PR fortran/57023
+	* gfortran.dg/internal_pack_15.f90:  New test.
+
+2015-01-24  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/60922
+	* gfortran.dg/class_allocate_17.f90: New.
+
+2015-01-20  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-06-23  Marek Polacek  <polacek@redhat.com>
+
+	PR c/61553
+	* c-c++-common/pr61553.c: New test.
+
+2015-01-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	* c-c++-common/tsan/tsan_barrier.h: New.
+	* c-c++-common/tsan/atomic_stack.c: Reworked to not depend on sleep.
+	* c-c++-common/tsan/fd_pipe_race.c: Likewise.
+	* c-c++-common/tsan/mutexset1.c: Likewise.
+	* c-c++-common/tsan/race_on_barrier.c: Likewise.
+	* c-c++-common/tsan/race_on_mutex.c: Likewise.
+	* c-c++-common/tsan/race_on_mutex2.c: Likewise.
+	* c-c++-common/tsan/simple_race.c: Likewise.
+	* c-c++-common/tsan/simple_stack.c: Likewise.
+	* c-c++-common/tsan/sleep_sync.c: Likewise.
+	* c-c++-common/tsan/tiny_race.c: Likewise.
+	* c-c++-common/tsan/tls_race.c: Likewise.
+	* c-c++-common/tsan/write_in_reader_lock.c: Likewise.
+	* g++.dg/tsan/atomic_free.C: Likewise.
+	* g++.dg/tsan/atomic_free2.C: Likewise.
+	* g++.dg/tsan/cond_race.C: Likewise.
+	* g++.dg/tsan/tsan_barrier.h: Copied from c-c++-common/tsan.
+
+2015-01-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt47.adb: New test.
+
+2015-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-01-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/64513
+	* gcc.target/i386/pr64513.c: New test.
+
+	2015-01-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/64286
+	* gcc.target/i386/avx2-pr64286.c: New test.
+
+	PR fortran/64528
+	* gfortran.dg/pr64528.f90: New test.
+
+	2015-01-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/64563
+	* gcc.dg/pr64563.c: New test.
+
+2015-01-14  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2015-01-13  Marek Polacek  <polacek@redhat.com>
+
+	PR middle-end/64391
+	* gcc.dg/tm/pr64391.c: New test.
+
+2015-01-13  Marc Glisse  <marc.glisse@inria.fr>
+
+	PR c++/54442
+	* g++.dg/pr54442.C: New file.
+
+2015-01-13  Renlin Li  <renlin.li@arm.com>
+
+	Backported from mainline
+	2014-11-19 Renlin Li <renlin.li@arm.com>
+
+	PR target/63424
+	* gcc.target/aarch64/pr63424.c: New Test.
+
+2015-01-12  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/63733
+	* gfortran.dg/typebound_operator_20.f90: New.
+
+2015-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/64536
+	* gcc.dg/pr64536.c: New test.
+
+2015-01-09  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2015-01-06  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/64505
+	* gcc.target/powerpc/pr64505.c: New file to test -m32 -mpowerpc64
+	fix is correct.
+
+2014-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/56867
+	* gfortran.dg/dependency_45.f90:  New test.
+
+2015-01-08  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/64507
+	* gcc.target/sh/pr64507.c: New test.
+
+2015-01-05  Ian Lance Taylor  <iant@google.com>
+
+	Backport from mainline:
+	2014-11-21  Lynn Boger  <laboger@linux.vnet.ibm.com>
+
+	* go.test/go-test.exp (go-set-goarch): Add case for ppc64le goarch
+	value for go testing.
+
+2014-12-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2014-12-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.target/i386/pr57003.c: Skip on x32.
+	* gcc.target/i386/pr59927.c: Likewise.
+	* gcc.target/i386/pr60516.c: Likewise.
+
+2014-12-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2014-12-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64409
+	* gcc.target/i386/pr64409.c: New test.
+
+2014-12-23  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/64244
+	* gfortran.dg/typebound_call_26.f90: New.
+
+2014-12-19  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/60955
+	* g++.dg/warn/register-parm-1.C: New.
+
+2014-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63551
+	* gcc.dg/ipa/pr63551.c (fn2): Use 4294967286U instead of
+	4294967286 to avoid warnings.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* g++.dg/pr64037.C: New test.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64200
+	* gcc.target/i386/memcpy-strategy-4.c: New test.
+
+2014-12-13  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/64269
+	* gcc.c-torture/compile/pr64269.c: New test.
+
+2014-12-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2014-09-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/builtins-1.c: Add tests for vec_ctf,
+	vec_cts, and vec_ctu.
+	* gcc.target/powerpc/builtins-2.c: Likewise.
+
+	Backport from mainline
+	2014-08-28  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/builtins-1.c: Add tests for vec_xl, vec_xst,
+	vec_round, vec_splat, vec_div, and vec_mul.
+	* gcc.target/powerpc/builtins-2.c: New test.
+
+	Backport from mainline
+	2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* testsuite/gcc.target/powerpc/builtins-1.c: New test.
+
+2014-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/62021
+	* gcc.dg/vect/pr62021.c: New test.
+
+2014-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR bootstrap/64213
+	Revert:
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* g++.dg/pr64037.C: New test.
+
+2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	* gcc.target/h8300/h8300.exp: Fix duplicated text.
+	* gcc.target/h8300/pragma-isr.c: Likewise.
+	* gcc.target/h8300/pragma-isr2.c: Likewise.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-12-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64108
+	* gcc.target/i386/memset-strategy-2.c: New test.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* g++.dg/pr64037.C: New test.
+
+2014-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/56493
+	* c-c++-common/pr56493.c: New test.
+
+2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+
+	Backported from mainline
+	2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+
+	 PR middle-end/63762
+	 PR target/63661
+	 * gcc.dg/pr63762.c: New test.
+	 * gcc.target/i386/pr63661.c: New test.
+
+2014-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/63551
+	* gcc.dg/ipa/pr63551.c: New test.
+	* gcc.dg/ipa/pr64041.c: Likewise.
+
+2014-12-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63738
+	* gcc.dg/torture/pr63738.c: Fix call to setjmp.
+
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64067
+	* gcc.c-torture/compile/pr64067.c: New test.
+
+	2014-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63915
+	* c-c++-common/gomp/pr60823-4.c: New test.
+
+	PR sanitizer/63913
+	* g++.dg/ubsan/pr63913.C: New test.
+
+	2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/63659
+	* gcc.c-torture/execute/pr63659.c: New test.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63738
+	* gcc.dg/torture/pr63738.c: New testcase.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62238
+	* gcc.dg/torture/pr62238.c: New testcase.
+
+	2014-11-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63605
+	* gcc.dg/vect/pr63605.c: New testcase.
+
+	2014-10-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63665
+	* gcc.dg/pr63665.c: New testcase.
+
+2014-11-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt45.adb: New test.
+
+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/63783
+	PR target/51244
+	* gcc.target/sh/torture/pr63783-1.c: New.
+	* gcc.target/sh/torture/pr63783-2.c: New.
+	* gcc.target/sh/pr51244-20.c: Adjust.
+	* gcc.target/sh/pr51244-20-sh2a.c: Adjust.
+
+2014-11-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63947
+	* gcc.target/i386/pr63947.c: New test.
+
+2014-11-19  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline
+	PR tree-optimization/62167
+	* gcc.dg/pr51879-12.c: Add xfails.
+	* gcc.dg/pr62167-run.c: New test.
+	* gcc.dg/pr62167.c: New test.
+
+2014-11-13  Teresa Johnson  <tejohnson@google.com>
+
+	PR tree-optimization/63841
+	* g++.dg/tree-ssa/pr63841.C: New test.
+
+2014-11-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/63838
+	* g++.dg/ipa/pr63838.C: New test.
+
+2014-11-11  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/63265
+	* g++.dg/cpp0x/constexpr-63265.C: New.
+
+2014-11-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-11-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR testsuite/63305
+	* gcc.target/i386/avx256-unaligned-load-7.c (avx_test): Fix
+	buffer overflow.
+	* gcc.target/i386/avx256-unaligned-store-7.c (avx_test): Likewise.
+
+2014-11-07  Marek Polacek  <polacek@redhat.com>
+
+	* c-c++-common/ubsan/undefined-2.c: New test.
+
+2014-11-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63538
+	* gcc.target/i386/pr63538.c: New test.
+
+2014-11-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c/52769
+	* gcc.dg/pr52769.c: New test.
+
+2014-10-31  DJ Delorie  <dj@redhat.com>
+
+	* gcc.dg/20141029-1.c: New.
+
+2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/63697
+	* c-c++-common/ubsan/overflow-sub-3.c: New test.
+
+2014-10-30  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR63633
+	* gcc.target/avr/torture/pr63633-ice-mult.c: New test.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
@@ -18,7 +999,7 @@
 2014-10-25  Yury Gribov  <y.gribov@samsung.com>
 
 	PR sanitizer/63638
-    	* c-c++-common/asan/pr63638.c: New test.
+	* c-c++-common/asan/pr63638.c: New test.
 
 2014-10-24  Markus Trippelsdorf  <markus@trippelsdorf.de>
 
@@ -200,7 +1181,7 @@
 	2014-10-11  Christophe Lyon  <christophe.lyon@linaro.org>
 	* lib/target-supports.exp (check_effective_target_shared): New
 	function.
-        * g++.dg/ipa/devirt-28a.C: Check if -shared is supported.
+	* g++.dg/ipa/devirt-28a.C: Check if -shared is supported.
 
 2014-10-10  Jakub Jelinek  <jakub@redhat.com>
 
@@ -368,7 +1349,7 @@
 2014-09-12  Martin Jambor  <mjambor@suse.cz>
 
 	PR ipa/61654
-        * g++.dg/ipa/pr61654.C: New test.
+	* g++.dg/ipa/pr61654.C: New test.
 
 2014-09-11  Alan Lawrence  <alan.lawrence@arm.com>
 
@@ -1629,10 +2610,10 @@
 	PR middle-end/60849
 	* g++.dg/opt/pr60849.C: New testcase.
 
-2014-04-22   Richard Biener  <rguenther@suse.de>
+2014-04-22  Richard Biener  <rguenther@suse.de>
 
 	Backport from mainline
-	2014-04-17   Richard Biener  <rguenther@suse.de>
+	2014-04-17  Richard Biener  <rguenther@suse.de>
 
 	PR tree-optimization/60841
 	* gcc.dg/vect/pr60841.c: New testcase.
Index: gcc/testsuite/g++.dg/opt/flifetime-dse1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/flifetime-dse1.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/opt/flifetime-dse1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,23 @@
+// { dg-options "-O3 -fno-lifetime-dse" }
+// { dg-do run }
+
+typedef __SIZE_TYPE__ size_t;
+inline void * operator new (size_t, void *p) { return p; }
+
+struct A
+{
+  int i;
+  A() {}
+  ~A() {}
+};
+
+int main()
+{
+  int ar[1];
+
+  A* ap = new(ar) A;
+  ap->i = 42;
+  ap->~A();
+
+  if (ar[0] != 42) __builtin_abort();
+}
Index: gcc/testsuite/g++.dg/pr54442.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr54442.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/pr54442.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+
+struct S
+{
+  void s (int) const throw ();
+  void s (int) throw ();
+};
+
+typedef int index_t;
+
+void (S::*f) (index_t)       = &S::s;
+void (S::*g) (index_t) const = &S::s;
Index: gcc/testsuite/g++.dg/tsan/atomic_free2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tsan/atomic_free2.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/tsan/atomic_free2.C	(.../branches/gcc-4_9-branch)
@@ -1,19 +1,24 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
+
 void *Thread(void *a) {
-  sleep(1);
+  barrier_wait(&barrier);
   __atomic_fetch_add((int*)a, 1, __ATOMIC_SEQ_CST);
   return 0;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   int *a = new int(0);
   pthread_t t;
   pthread_create(&t, 0, Thread, a);
   delete a;
+  barrier_wait(&barrier);
   pthread_join(t, 0);
 }
 
Index: gcc/testsuite/g++.dg/tsan/tsan_barrier.h
===================================================================
--- a/src/gcc/testsuite/g++.dg/tsan/tsan_barrier.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/tsan/tsan_barrier.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* TSAN-invisible barriers.  Link with -ldl.  */
+#include <pthread.h>
+#include <dlfcn.h>
+
+static __typeof(pthread_barrier_wait) *barrier_wait;
+
+static
+void barrier_init (pthread_barrier_t *barrier, unsigned count)
+{
+  void *h = dlopen ("libpthread.so.0", RTLD_LAZY);
+  barrier_wait = (__typeof (pthread_barrier_wait) *)
+	 	 dlsym (h, "pthread_barrier_wait");
+  pthread_barrier_init (barrier, NULL, count);
+}
Index: gcc/testsuite/g++.dg/tsan/atomic_free.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tsan/atomic_free.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/tsan/atomic_free.C	(.../branches/gcc-4_9-branch)
@@ -1,18 +1,23 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
+
 void *Thread(void *a) {
   __atomic_fetch_add((int*)a, 1, __ATOMIC_SEQ_CST);
+  barrier_wait(&barrier);
   return 0;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   int *a = new int(0);
   pthread_t t;
   pthread_create(&t, 0, Thread, a);
-  sleep(1);
+  barrier_wait(&barrier);
   delete a;
   pthread_join(t, 0);
 }
Index: gcc/testsuite/g++.dg/tsan/cond_race.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tsan/cond_race.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/tsan/cond_race.C	(.../branches/gcc-4_9-branch)
@@ -1,11 +1,13 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 /* { dg-output "ThreadSanitizer: data race.*" } */
 /* { dg-output "pthread_cond_signal.*" } */
 
-#include <stdio.h>
-#include <stdlib.h>
 #include <pthread.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
+
 struct Ctx {
   pthread_mutex_t m;
   pthread_cond_t c;
@@ -18,10 +20,12 @@
   c->done = true;
   pthread_mutex_unlock(&c->m);
   pthread_cond_signal(&c->c);
+  barrier_wait(&barrier);
   return 0;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   Ctx *c = new Ctx();
   pthread_mutex_init(&c->m, 0);
   pthread_cond_init(&c->c, 0);
@@ -31,6 +35,7 @@
   while (!c->done)
     pthread_cond_wait(&c->c, &c->m);
   pthread_mutex_unlock(&c->m);
+  barrier_wait(&barrier);
   delete c;
   pthread_join(th, 0);
 }
Index: gcc/testsuite/g++.dg/abi/anon4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/abi/anon4.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/abi/anon4.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,41 @@
+// PR c++/65209
+// { dg-final { scan-assembler-not "comdat" } }
+
+// Everything involving the anonymous namespace bits should be private, not
+// COMDAT.
+
+struct Bar
+{
+  static Bar *self();
+  char pad[24];
+};
+
+template <Bar *(&holderFunction)()>
+struct BarGlobalStatic
+{
+  Bar *operator()() { return holderFunction(); }
+};
+
+namespace {
+  namespace Q_QGS_s_self {
+    inline Bar *innerFunction() {
+      static struct Holder {
+	Bar value;
+	~Holder() {}
+      } holder;
+      return &holder.value;
+    }
+  }
+}
+static BarGlobalStatic<Q_QGS_s_self::innerFunction> s_self;
+
+Bar *Bar::self()
+{
+  return s_self();
+}
+
+int main(int argc, char *argv[])
+{
+  Bar* bar = Bar::self();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/init/array39.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/array39.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/init/array39.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,46 @@
+// PR c++/65154
+// { dg-do run { target c++11 } }
+
+int cnt1 = 0,
+    cnt2 = 0;
+
+struct S_empty
+{
+    S_empty () {
+	cnt1++;
+    };
+};
+
+struct C1
+{
+  S_empty s;
+};
+
+struct S_init
+{
+  S_init () : i(42)
+  {
+    cnt2++;
+  };
+  int i;
+};
+
+struct C2
+{
+  S_init a, b;
+};
+
+int
+main ()
+{
+  C1 c1[5]{};
+  C2 c2[1]{};
+
+  if (c2[0].a.i != 42 || c2[0].b.i != 42)
+    return 1;
+
+  if (cnt1 != 5 || cnt2 != 2)
+    return 1;
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/pr64037.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr64037.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/pr64037.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+// { dg-options "-std=c++11 -Os" }
+
+enum class X : unsigned char {
+  V = 2,
+};
+
+static void
+__attribute__((noinline,noclone))
+foo(unsigned &out, unsigned a, X b)
+{
+  out = static_cast<unsigned>(b);
+}
+
+int main()
+{
+  unsigned deadbeef = 0xDEADBEEF;
+  asm volatile ("" : "+d" (deadbeef), "+c" (deadbeef));
+
+  unsigned out;
+  foo(out, 2, X::V);
+
+  if (out != 2)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/ubsan/pr63913.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ubsan/pr63913.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ubsan/pr63913.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+// PR sanitizer/63913
+// { dg-do compile }
+// { dg-options "-fsanitize=bool -fnon-call-exceptions" }
+
+struct B { B (); ~B (); };
+
+double
+foo (bool *x)
+{
+  B b;
+  return *x;
+}
Index: gcc/testsuite/g++.dg/pr65049.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr65049.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/pr65049.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+// PR middle-end/65409
+// Reported by Ignacy Gawedzki <bugs@qult.net>
+
+struct Foo
+{
+  Foo() {}
+  int  a;
+  int  b;
+  char c;
+};
+
+Foo copy_foo(Foo);
+
+struct Bar : Foo
+{
+  Bar(Foo t) : Foo(copy_foo(t)) {}
+};
+
+Bar a = Foo();
Index: gcc/testsuite/g++.dg/other/dump-ada-spec-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/dump-ada-spec-3.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/other/dump-ada-spec-3.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-fdump-ada-spec" } */
+
+using namespace std;
+
+class Base {
+   public:
+     int My_V;
+     virtual void Primitive ();
+
+     Base ();
+};
+
+void Base::Primitive () {
+}
+
+Base::Base () {
+}
+
+void Dispatch (Base * B) {
+  B->Primitive ();
+}
+
+/* { dg-final { cleanup-ada-spec } } */
Index: gcc/testsuite/g++.dg/tree-ssa/pr63841.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr63841.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr63841.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#include <string>
+
+std::string __attribute__ ((noinline)) comp_test_write() {
+  std::string data;
+
+  for (int i = 0; i < 2; ++i) {
+    char b = 1 >> (i * 8);
+    data.append(&b, 1);
+  }
+
+  return data;
+}
+
+std::string __attribute__ ((noinline)) comp_test_write_good() {
+  std::string data;
+
+  char b;
+  for (int i = 0; i < 2; ++i) {
+    b = 1 >> (i * 8);
+    data.append(&b, 1);
+  }
+
+  return data;
+}
+
+int main() {
+  std::string good = comp_test_write_good();
+  std::string bad = comp_test_write();
+
+  if (good != bad)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/lto/pr65193_0.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lto/pr65193_0.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/lto/pr65193_0.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,71 @@
+/* { dg-lto-do link } */
+/* { dg-require-effective-target fpic } */
+/* { dg-lto-options {{-fPIC -r -nostdlib -flto -O2 -g}} } */
+
+void frexp (int, int *);
+namespace std
+{
+  int ldexp (int, int);
+  struct A
+    {
+    };
+  template <class T> T get_min_shift_value ();
+  template <class> struct min_shift_initializer
+    {
+      struct B
+	{
+	  B () { get_min_shift_value<long double> (); }
+	} static const b;
+      static void
+	  m_fn1 ()
+	    {
+	      b;
+	    }
+    };
+  template <class T>
+      const typename min_shift_initializer<T>::B min_shift_initializer<T>::b;
+  template <class T>
+      inline T
+      get_min_shift_value ()
+	{
+	  using std::ldexp;
+	  static T c = ldexp (0, 0);
+	  min_shift_initializer<T>::m_fn1;
+	}
+  template <class T, class Policy>
+      void
+      float_next_imp (T p1, Policy p2)
+	{
+	  using std::ldexp;
+	  int d;
+	  float_next (0, p2);
+	  frexp (p1, &d);
+	}
+  template <class T, class Policy>
+      int
+      float_next (const T &p1, Policy &p2)
+	{
+	  float_next_imp (p1, p2);
+	}
+  template <class T, class Policy> void float_prior_imp (T, Policy)
+    {
+      get_min_shift_value<T> ();
+    }
+  template <class T, class Policy> int float_prior (T, Policy)
+    {
+      float_prior_imp (static_cast<T> (0), 0);
+    }
+  template <class T, class U, class Policy>
+      void
+      nextafter (T p1, U p2, Policy p3)
+	{
+	  p2 ? float_next (0, p3) : float_prior (p1, 0);
+	}
+  long double e;
+  int f;
+  void
+      nextafter ()
+	{
+	  nextafter (e, f, A ());
+	}
+}
Index: gcc/testsuite/g++.dg/warn/Wunused-var-22.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/Wunused-var-22.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/warn/Wunused-var-22.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+// PR c++/63657
+// { dg-options "-Wunused-variable" }
+
+class Bar
+{
+  virtual ~Bar() {}
+};
+Bar& getbar();
+void bar()
+{
+  Bar& b = getbar();		// { dg-warning "unused" }
+}
Index: gcc/testsuite/g++.dg/warn/Warray-bounds-6.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/Warray-bounds-6.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/warn/Warray-bounds-6.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+// { dg-do compile }
+// { dg-options "-O3 -Warray-bounds" }
+
+struct type {
+    bool a, b;
+    bool get_b() { return b; }
+};
+
+type stuff[9u];
+
+void bar();
+
+void foo()
+{
+  for(unsigned i = 0u; i < 9u; i++)
+    {
+      if(!stuff[i].a)
+	continue;
+
+      bar();
+
+      for(unsigned j = i + 1u; j < 9u; j++)
+	if(stuff[j].a && stuff[j].get_b()) // { dg-bogus "above array bounds" }
+	  return;
+    }
+}
Index: gcc/testsuite/g++.dg/warn/register-parm-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/register-parm-1.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/warn/register-parm-1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+// PR c++/60955
+// { dg-options "-Wextra" }
+
+unsigned int erroneous_warning(register int a) {
+    if ((a) & 0xff) return 1; else return 0;
+}
+unsigned int no_erroneous_warning(register int a) {
+    if (a & 0xff) return 1; else return 0;
+}
Index: gcc/testsuite/g++.dg/cpp0x/variadic165.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/variadic165.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/variadic165.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,17 @@
+// PR c++/64514
+// { dg-do compile { target c++11 } }
+
+template<typename... T>
+struct Functor
+{
+    template <T...>
+    struct Inner
+    {};
+};
+
+template struct Functor<>::Inner<>;
+
+int main()
+{
+
+}
Index: gcc/testsuite/g++.dg/cpp0x/override1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/override1.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/override1.C	(.../branches/gcc-4_9-branch)
@@ -4,8 +4,11 @@
   virtual void f() final {}
   virtual void g() {}
   virtual void x() const {}
+  virtual void y() final;
 };
 
+void B::y() {} // { dg-error "overriding" }
+
 struct B2
 {
   virtual void h() {}
@@ -14,6 +17,7 @@
 struct D : B
 {
   virtual void g() override final {} // { dg-error "overriding" }
+  virtual void y() override final {} // { dg-error "virtual" }
 };
 
 template <class T> struct D2 : T
Index: gcc/testsuite/g++.dg/cpp0x/ref-qual16.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/ref-qual16.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/ref-qual16.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+// PR c++/64297
+// { dg-do compile { target c++11 } }
+
+struct A {
+  typedef int X;
+  template <int> X m_fn1() const;
+};
+template <typename> struct is_function {};
+is_function<int() const &> i;
+struct D {
+  template <typename Y, typename = is_function<Y>> D(Y);
+} b(&A::m_fn1<0>);
Index: gcc/testsuite/g++.dg/cpp0x/initlist89.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/initlist89.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/initlist89.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,4 @@
+// PR c++/64029
+// { dg-do compile { target c++11 } }
+
+const int (&in)[]{1,2,3,4,5};
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-63265.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-63265.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-63265.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+// PR c++/63265
+// { dg-do compile { target c++11 } }
+
+#define LSHIFT (sizeof(unsigned int) * __CHAR_BIT__)
+
+template <int lshift>
+struct SpuriouslyWarns1 {
+    static constexpr unsigned int v = lshift < LSHIFT ? 1U << lshift : 0;
+};
+
+static_assert(SpuriouslyWarns1<LSHIFT>::v == 0, "Impossible occurred");
+
+template <int lshift>
+struct SpuriouslyWarns2 {
+    static constexpr bool okay = lshift < LSHIFT;
+    static constexpr unsigned int v = okay ? 1U << lshift : 0;
+};
+
+static_assert(SpuriouslyWarns2<LSHIFT>::v == 0, "Impossible occurred");
Index: gcc/testsuite/g++.dg/cpp0x/alias-decl-44.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/alias-decl-44.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/alias-decl-44.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+// PR c++/63849
+// { dg-do compile { target c++11 } }
+
+template <class _T, class...>
+using First = _T;            // we should not use this
+                             // alias with only
+                             // one pack parameter (?)
+
+template <template <class...> class _Successor,
+          int,
+          class... _Xs>
+struct Overlay
+{
+    using O = _Successor<_Xs...>;
+};
+
+template <class... _Pack>
+struct List
+{
+    template <int _s>
+    using O = typename Overlay<List, _s, _Pack...>::O;
+
+    template <template <class...> class _S>
+    using Pass = _S<_Pack...>;
+
+    template <int _i>
+    using At = typename O<_i>
+    ::template Pass<First>;
+};
+
+template <int _i>
+using At = typename List<int, char>
+::template At<_i>;
+
+template <int _i>
+void func_crash(At<_i>&) {}
+
+int main(int argc, char *argv[])
+{
+    char ccc;
+    int iii;
+    func_crash<0>(iii);
+}
Index: gcc/testsuite/g++.dg/cpp0x/deleted9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/deleted9.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/deleted9.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+// PR c++/64352
+// { dg-do compile { target c++11 } }
+
+template<bool B> struct bool_type
+{ static constexpr bool value = B; };
+
+using true_type = bool_type<true>;
+using false_type = bool_type<false>;
+
+template<typename T> T&& declval();
+
+template<typename...> struct void_ { using type = void; };
+template<typename... I> using void_t = typename void_<I...>::type;
+
+template<typename _Tp, typename = void>
+struct _Has_addressof_free: false_type { };
+
+template<typename _Tp>
+struct _Has_addressof_free
+<_Tp, void_t<decltype( operator&(declval<const _Tp&>()) )>>
+: true_type { };
+
+struct foo {};
+void operator&(foo) = delete;
+
+int main()
+{
+    static_assert( !_Has_addressof_free<int>::value, "" );
+    // error: use of deleted function 'void operator&(foo)'
+    static_assert( !_Has_addressof_free<foo>::value, "" );
+}
Index: gcc/testsuite/g++.dg/ipa/pr64068.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr64068.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr64068.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,49 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef int PROV_ENUMALGS_EX, PCCRYPT_OID_INFO;
+class A {
+  int m_fn2();
+  virtual bool m_fn1(PCCRYPT_OID_INFO);
+};
+int fn1();
+void fn2();
+int A::m_fn2() { m_fn1(0); }
+
+bool fn3() {
+  for (;;) {
+    if (fn1()) {
+      if (fn1() != 259)
+        fn2();
+      break;
+    }
+    return 1;
+  }
+  return 0;
+}
+
+class B {
+public:
+  B() { fn3(); }
+};
+class C : A {
+  bool m_fn1(PCCRYPT_OID_INFO) { m_fn3(); }
+  int isSupportedByProvider_algId;
+  PROV_ENUMALGS_EX isSupportedByProvider_outEnumAlgs;
+  PROV_ENUMALGS_EX isSupportedByProvider_enumAlgs;
+  bool m_fn3() {
+    while (1) {
+      if (fn1()) {
+        if (fn1() != 259)
+          fn2();
+        break;
+      }
+      if (isSupportedByProvider_algId)
+        isSupportedByProvider_outEnumAlgs = isSupportedByProvider_enumAlgs;
+      return 1;
+    }
+    return 0;
+  }
+};
+
+void fn4() { B(); }
Index: gcc/testsuite/g++.dg/ipa/pr63587-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr63587-1.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63587-1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,92 @@
+// PR ipa/63587
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2 -fno-strict-aliasing" }
+
+template <class> struct A
+{
+};
+template <typename> struct B
+{
+  template <typename> struct C;
+};
+class D;
+template <typename> class F;
+struct G
+{
+  void operator()(const D &, D);
+};
+class D
+{
+public:
+  D (int);
+};
+struct H
+{
+  H (int);
+};
+template <typename _Key, typename, typename, typename _Compare, typename>
+class I
+{
+  typedef _Key key_type;
+  template <typename _Key_compare> struct J
+  {
+    _Key_compare _M_key_compare;
+  };
+  J<_Compare> _M_impl;
+
+public:
+  A<int> _M_get_insert_unique_pos (const key_type &);
+  A<int> _M_get_insert_hint_unique_pos (H &);
+  template <typename... _Args> int _M_emplace_hint_unique (H, _Args &&...);
+};
+template <typename _Key, typename _Tp, typename _Compare = G,
+	  typename _Alloc = F<A<_Tp> > >
+class K
+{
+  typedef _Key key_type;
+  typedef _Key value_type;
+  typedef typename B<_Alloc>::template C<value_type> _Pair_alloc_type;
+  I<key_type, value_type, int, _Compare, _Pair_alloc_type> _M_t;
+
+public:
+  void operator[](key_type)
+  {
+    _M_t._M_emplace_hint_unique (0);
+  }
+};
+template <typename _Key, typename _Val, typename _KeyOfValue,
+	  typename _Compare, typename _Alloc>
+A<int>
+I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_unique_pos (
+  const key_type &p1)
+{
+  _M_impl._M_key_compare (p1, 0);
+}
+template <typename _Key, typename _Val, typename _KeyOfValue,
+	  typename _Compare, typename _Alloc>
+A<int>
+I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_unique_pos (
+  H &)
+{
+  _M_get_insert_unique_pos (0);
+}
+template <typename _Key, typename _Val, typename _KeyOfValue,
+	  typename _Compare, typename _Alloc>
+template <typename... _Args>
+int
+I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_emplace_hint_unique (
+  H p1, _Args &&...)
+{
+  _M_get_insert_hint_unique_pos (p1);
+}
+namespace {
+struct L;
+}
+void
+fn1 ()
+{
+  K<D, L> a;
+  a[0];
+  K<D, int> b;
+  b[0];
+}
Index: gcc/testsuite/g++.dg/ipa/pr64896.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr64896.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr64896.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// PR ipa/64896
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct A { int a, b; };
+struct B { A c; int d; };
+struct C { virtual B fn1 () const; };
+struct D { B fn2 () const; int fn3 () const; C *fn4 () const; };
+
+int
+D::fn3 () const
+{
+  fn4 ()->fn1 ();
+}
+
+B
+D::fn2 () const
+{
+  return B ();
+}
+
+class F : C
+{
+  B
+  fn1 () const
+  {
+    return B ();
+  }
+};
Index: gcc/testsuite/g++.dg/ipa/pr63838.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr63838.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63838.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,56 @@
+// PR ipa/63838
+// { dg-do run }
+// { dg-options "-O2 -fdump-ipa-pure-const" }
+// { dg-final { scan-ipa-dump-not "Function found to be nothrow: void foo" "pure-const" } }
+// { dg-final { scan-ipa-dump-not "Function found to be nothrow: void bar" "pure-const" } }
+// { dg-final { cleanup-ipa-dump "pure-const" } }
+
+__attribute__((noinline, noclone)) static void bar (int);
+volatile int v;
+void (*fn) ();
+struct S { S () { v++; } ~S () { v++; } };
+
+__attribute__((noinline, noclone)) static void
+foo (int x)
+{
+  v++;
+  if (x == 5)
+    bar (x);
+}
+
+__attribute__((noinline, noclone)) static void
+bar (int x)
+{
+  v++;
+  if (x == 6)
+    foo (x);
+  else if (x == 5)
+    fn ();
+}
+
+__attribute__((noinline, noclone)) int
+baz (int x)
+{
+  S s;
+  foo (x);
+}
+
+void
+throw0 ()
+{
+  throw 0;
+}
+
+int
+main ()
+{
+  fn = throw0;
+  asm volatile ("" : : : "memory");
+  try
+    {
+      baz (5);
+    }
+  catch (int)
+    {
+    }
+}
Index: gcc/testsuite/g++.dg/ipa/pr63587-2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr63587-2.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63587-2.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,250 @@
+// PR ipa/63587
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2" }
+
+namespace boost {
+class basic_cstring
+{
+public:
+  basic_cstring (char *);
+};
+template <typename> struct identity
+{
+};
+struct make_identity;
+struct function_buffer
+{
+};
+template <typename FunctionObj> struct function_obj_invoker0
+{
+  static int
+  invoke (function_buffer &)
+  {
+    FunctionObj f;
+    f ();
+  }
+};
+template <typename FunctionObj> struct get_function_obj_invoker0
+{
+  typedef function_obj_invoker0<FunctionObj> type;
+};
+template <typename FunctionObj> struct apply
+{
+  typedef typename get_function_obj_invoker0<FunctionObj>::type invoker_type;
+};
+struct basic_vtable0
+{
+  typedef int (*invoker_type)(function_buffer &);
+  template <typename F> void assign_to (F, function_buffer);
+  invoker_type invoker;
+};
+class function0
+{
+public:
+  template <typename Functor> function0 (Functor)
+  {
+    typedef typename apply<Functor>::invoker_type invoker_type;
+    basic_vtable0 stored_vtable { invoker_type::invoke };
+    stored_vtable.assign_to (0, functor);
+  }
+  function_buffer functor;
+};
+class function : function0
+{
+public:
+  template <typename Functor> function (Functor f) : function0 (f) {}
+};
+class test_unit_generator
+{
+};
+class test_case
+{
+public:
+  test_case (basic_cstring, basic_cstring, int, function);
+};
+struct auto_test_unit_registrar
+{
+  auto_test_unit_registrar (test_unit_generator);
+};
+template <typename F> F unwrap (F, int);
+struct for_each_impl
+{
+  template <typename Iterator, typename LastIterator, typename TransformFunc,
+	    typename F>
+  static void
+  execute (Iterator, LastIterator, TransformFunc, F f)
+  {
+    identity<char> __trans_tmp_1;
+    unwrap (f, 0)(__trans_tmp_1);
+  }
+};
+template <typename, typename, typename F>
+void
+for_each (F f)
+{
+  for_each_impl::execute (0, 0, 0, f);
+}
+template <typename TestCaseTemplate> class test_case_template_invoker
+{
+public:
+  void operator()()
+  {
+    TestCaseTemplate::run (0);
+  }
+};
+template <typename Generator, typename TestCaseTemplate>
+struct generate_test_case_4_type
+{
+  generate_test_case_4_type (basic_cstring, basic_cstring, int, Generator G)
+    : m_test_case_name (0), m_test_case_file (0), m_holder (G)
+  {
+  }
+  template <typename TestType> void operator()(identity<TestType>)
+  {
+    test_case (0, 0, 0, test_case_template_invoker<TestCaseTemplate> ());
+  }
+  basic_cstring m_test_case_name;
+  basic_cstring m_test_case_file;
+  Generator m_holder;
+};
+template <typename TestCaseTemplate>
+class template_test_case_gen : public test_unit_generator
+{
+public:
+  template_test_case_gen (basic_cstring, basic_cstring, int)
+  {
+    for_each<int, make_identity> (
+      generate_test_case_4_type<template_test_case_gen, TestCaseTemplate> (
+	0, 0, 0, *this));
+  }
+};
+class attribute_name
+{
+  int m_id;
+
+public:
+  attribute_name (char);
+};
+template <typename> struct term;
+namespace exprns_ {
+template <typename> struct expr;
+}
+using exprns_::expr;
+template <typename T> struct Trans_NS_proto_terminal
+{
+  typedef expr<term<T> > type;
+};
+namespace exprns_ {
+template <typename Arg0> struct expr<term<Arg0> >
+{
+  Arg0 child0;
+};
+}
+template <typename Expr> struct actor
+{
+  typename Trans_NS_proto_terminal<Expr>::type proto_expr_;
+};
+template <template <typename> class Actor = actor> struct terminal
+{
+  typedef Actor<int> type;
+};
+namespace log {
+struct to_log_fun
+{
+};
+class value_extractor;
+template <typename, typename = value_extractor, typename = void,
+	  template <typename> class = actor>
+class attribute_actor;
+class attribute_terminal
+{
+public:
+  attribute_name m_name;
+  attribute_name
+  get_name ()
+  {
+    return m_name;
+  }
+};
+template <typename, typename, typename, template <typename> class ActorT>
+class attribute_actor : ActorT<attribute_terminal>
+{
+public:
+  typedef int value_type;
+  attribute_name
+  get_name ()
+  {
+    return this->proto_expr_.child0.get_name ();
+  }
+};
+template <typename AttributeValueT>
+attribute_actor<AttributeValueT> attr (attribute_name);
+terminal<>::type stream;
+template <typename LeftT, typename ImplT> class attribute_output_terminal
+{
+public:
+  template <typename U>
+  attribute_output_terminal (LeftT, attribute_name, ImplT, U);
+};
+template <typename LeftT> struct make_output_expression
+{
+  typedef attribute_output_terminal<LeftT, to_log_fun> type;
+  template <typename RightT>
+  static type
+  make (LeftT left, RightT &right)
+  {
+    type (left, right.get_name (), to_log_fun (), 0);
+  }
+};
+template <typename, typename RightT, typename = typename RightT::value_type>
+struct make_output_actor;
+template <template <typename> class ActorT, typename LeftExprT,
+	  typename RightT, typename ValueT>
+struct make_output_actor<ActorT<LeftExprT>, RightT, ValueT>
+{
+  typedef make_output_expression<ActorT<LeftExprT> > make_expression;
+  typedef ActorT<typename make_expression::type> type;
+  static type
+  make (ActorT<LeftExprT> left, RightT &right)
+  {
+    type { make_expression::make (left, right) };
+  }
+};
+template <typename LeftExprT, typename T, typename FallbackPolicyT,
+	  typename TagT>
+typename make_output_actor<actor<LeftExprT>, attribute_actor<TagT> >::type
+operator<<(actor<LeftExprT> left,
+	   attribute_actor<T, FallbackPolicyT, TagT> right)
+{
+  make_output_actor<actor<LeftExprT>, attribute_actor<T> >::make (left, right);
+}
+}
+}
+namespace logging = boost::log;
+namespace expr = logging;
+namespace {
+class my_class;
+}
+template <typename> struct default_formatting
+{
+  void test_method ();
+};
+struct default_formatting_invoker
+{
+  static void
+  run (void *)
+  {
+    default_formatting<int> t;
+    t.test_method ();
+  }
+};
+boost::auto_test_unit_registrar default_formatting_registrar56 (
+  boost::template_test_case_gen<default_formatting_invoker> (0, 0, 0));
+template <typename CharT>
+void
+default_formatting<CharT>::test_method ()
+{
+  expr::stream << expr::attr<my_class> (0);
+  expr::stream << expr::attr<int> (0) << expr::attr<int> (0)
+	       << expr::attr<int> (0);
+}
Index: gcc/testsuite/g++.dg/template/offsetof3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/offsetof3.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/template/offsetof3.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+// PR c++/64487
+
+struct foo {
+      int member;
+};
+
+template < int N>
+struct bar {};
+
+template <int N>
+struct qux {
+        static bar<N+__builtin_offsetof(foo,member)> static_member;
+};
+
+template <int N>
+bar<N+__builtin_offsetof(foo,member)> qux<N>::static_member;
+
+int main() { }
Index: gcc/testsuite/g++.dg/template/ref9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/ref9.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/template/ref9.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,15 @@
+// PR c++/63658
+
+struct Descriptor {};
+
+template <Descriptor & D>
+struct foo
+{
+  void size ();
+};
+
+Descriptor g_descriptor = {};
+
+template<> void foo<g_descriptor>::size()
+{
+}
Index: gcc/testsuite/g++.dg/template/recurse4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/recurse4.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/template/recurse4.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+// PR c++/62255
+
+// It's not clear whether this is well-formed; instantiating the
+// initializer of 'value' causes the instantiation of Derived, which in
+// turn requires the value of 'value', but the recursion ends there, so it
+// seems reasonable to allow it.
+
+template <typename T> struct Test {
+  template<typename X> static int check(typename X::Type*);
+  template<typename> static char check(...);
+  static const bool value = (sizeof(check<T>(0)) == sizeof(int));
+};
+template <int> struct Sink { };
+template <typename T> struct Derived : Sink<Test<Derived<T> >::value> {
+  typedef int Type;
+};
+
+Sink<Test<Derived<int> >::value> s;
Index: gcc/testsuite/g++.dg/template/non-dependent14.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/non-dependent14.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/template/non-dependent14.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+// PR c++/64251
+
+class DictionaryValue {};
+template <typename T> void CreateValue(T) {
+  DictionaryValue(0);
+  CreateValue(0);
+}
Index: gcc/testsuite/g++.dg/template/repo11.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/template/repo11.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/template/repo11.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,31 @@
+// PR c++/64521
+// { dg-options "-frepo -std=c++11" }
+// { dg-require-host-local "" }
+// { dg-skip-if "dkms are not final links" { vxworks_kernel } }
+// { dg-final cleanup-repo-files }
+
+template <typename H> struct J { J(H) {} };
+template <unsigned long, typename...> struct K;
+template <unsigned long I> struct K<I> {};
+template <unsigned long I, typename H, typename... T>
+struct K<I, H, T...> : K<I + 1, T...>, J<H> {
+  K(const H &p1, const T &... p2) : K<I + 1, T...>(p2...), J<H>(p1) {}
+};
+template <typename... E> struct C : K<0, E...> {
+  C(const E &... p1) : K<0, E...>(p1...) {}
+};
+template <typename> struct A {
+  A() = default;
+};
+struct M;
+template <typename> struct L {
+  struct B {
+    template <typename> static M *__test(...);
+    typedef A<int> _Del;
+    typedef decltype(__test<_Del>()) type;
+  };
+  C<typename B::type, A<M>> _M_t;
+  L(typename B::type) : _M_t(0, A<M>()) {}
+};
+struct M {};
+int main() { L<int>(new M); }
Index: gcc/testsuite/c-c++-common/tsan/mutexset1.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/mutexset1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/mutexset1.c	(.../branches/gcc-4_9-branch)
@@ -1,14 +1,15 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stdio.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 int Global;
 pthread_mutex_t mtx;
 
 void *Thread1(void *x) {
-  sleep(1);
+  barrier_wait(&barrier);
   pthread_mutex_lock(&mtx);
   Global++;
   pthread_mutex_unlock(&mtx);
@@ -17,11 +18,13 @@
 
 void *Thread2(void *x) {
   Global--;
+  barrier_wait(&barrier);
   return NULL;/* { dg-output ".*" } */
 
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_mutex_init(&mtx, 0);
   pthread_t t[2];
   pthread_create(&t[0], NULL, Thread1, NULL);
Index: gcc/testsuite/c-c++-common/tsan/fd_pipe_race.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/fd_pipe_race.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/fd_pipe_race.c	(.../branches/gcc-4_9-branch)
@@ -1,18 +1,21 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stdio.h>
 #include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 int fds[2];
 
 void *Thread1(void *x) {
   write(fds[1], "a", 1);
+  barrier_wait(&barrier);
   return NULL;
 }
 
 void *Thread2(void *x) {
-  sleep(1);
+  barrier_wait(&barrier);
   close(fds[0]);
   close(fds[1]);
   return NULL;
@@ -19,6 +22,7 @@
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pipe(fds);
   pthread_t t[2];
   pthread_create(&t[0], NULL, Thread1, NULL);
@@ -25,6 +29,7 @@
   pthread_create(&t[1], NULL, Thread2, NULL);
   pthread_join(t[0], NULL);
   pthread_join(t[1], NULL);
+  return 0;
 }
 
 /* { dg-output "WARNING: ThreadSanitizer: data race.*\n" } */
Index: gcc/testsuite/c-c++-common/tsan/atomic_stack.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/atomic_stack.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/atomic_stack.c	(.../branches/gcc-4_9-branch)
@@ -1,12 +1,14 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 int Global;
 
 void *Thread1(void *x) {
-  sleep(1);
+  barrier_wait(&barrier);
   __atomic_fetch_add(&Global, 1, __ATOMIC_RELAXED);
   return NULL;
 }
@@ -13,10 +15,12 @@
 
 void *Thread2(void *x) {
   Global++;
+  barrier_wait(&barrier);
   return NULL;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_t t[2];
   pthread_create(&t[0], NULL, Thread1, NULL);
   pthread_create(&t[1], NULL, Thread2, NULL);
Index: gcc/testsuite/c-c++-common/tsan/sleep_sync.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/sleep_sync.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/sleep_sync.c	(.../branches/gcc-4_9-branch)
@@ -1,8 +1,11 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
 #include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 int X = 0;
 
 void MySleep() {
@@ -10,6 +13,7 @@
 }
 
 void *Thread(void *p) {
+  barrier_wait(&barrier);
   MySleep();  // Assume the main thread has done the write.
   X = 42;
   return 0;
@@ -16,9 +20,11 @@
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_t t;
   pthread_create(&t, 0, Thread, 0);
   X = 43;
+  barrier_wait(&barrier);
   pthread_join(t, 0);
   return 0;
 }
Index: gcc/testsuite/c-c++-common/tsan/write_in_reader_lock.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/write_in_reader_lock.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/write_in_reader_lock.c	(.../branches/gcc-4_9-branch)
@@ -1,8 +1,10 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 pthread_rwlock_t rwlock;
 int GLOB;
 
@@ -10,7 +12,7 @@
  (void)p;
   pthread_rwlock_rdlock(&rwlock);
   // Write under reader lock.
-  sleep(1);
+  barrier_wait(&barrier);
   GLOB++;
   pthread_rwlock_unlock(&rwlock);
   return 0;
@@ -17,6 +19,7 @@
 }
 
 int main(int argc, char *argv[]) {
+  barrier_init(&barrier, 2);
   pthread_rwlock_init(&rwlock, NULL);
   pthread_rwlock_rdlock(&rwlock);
   pthread_t t;
@@ -24,6 +27,7 @@
   volatile int x = GLOB;
  (void)x;
   pthread_rwlock_unlock(&rwlock);
+  barrier_wait(&barrier);
   pthread_join(t, 0);
   pthread_rwlock_destroy(&rwlock);
   return 0;
Index: gcc/testsuite/c-c++-common/tsan/race_on_mutex2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/race_on_mutex2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/race_on_mutex2.c	(.../branches/gcc-4_9-branch)
@@ -1,22 +1,25 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stdio.h>
-#include <stddef.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
+
 void *Thread(void *x) {
   pthread_mutex_lock((pthread_mutex_t*)x);
   pthread_mutex_unlock((pthread_mutex_t*)x);
+  barrier_wait(&barrier);
   return 0;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_mutex_t Mtx;
   pthread_mutex_init(&Mtx, 0);
   pthread_t t;
   pthread_create(&t, 0, Thread, &Mtx);
-  sleep(1);
+  barrier_wait(&barrier);
   pthread_mutex_destroy(&Mtx);
   pthread_join(t, 0);
   return 0;
Index: gcc/testsuite/c-c++-common/tsan/race_on_barrier.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/race_on_barrier.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/race_on_barrier.c	(.../branches/gcc-4_9-branch)
@@ -1,26 +1,28 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stdio.h>
-#include <stddef.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 pthread_barrier_t B;
 int Global;
 
 void *Thread1(void *x) {
   pthread_barrier_init(&B, 0, 2);
+  barrier_wait(&barrier);
   pthread_barrier_wait(&B);
   return NULL;
 }
 
 void *Thread2(void *x) {
-  sleep(1);
+  barrier_wait(&barrier);
   pthread_barrier_wait(&B);
   return NULL;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_t t;
   pthread_create(&t, NULL, Thread1, NULL);
   Thread2(0);
Index: gcc/testsuite/c-c++-common/tsan/tiny_race.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/tiny_race.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/tiny_race.c	(.../branches/gcc-4_9-branch)
@@ -1,20 +1,24 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 int Global;
 
 void *Thread1(void *x) {
-  sleep(1);
+  barrier_wait(&barrier);
   Global = 42;
   return x;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_t t;
   pthread_create(&t, 0, Thread1, 0);
   Global = 43;
+  barrier_wait(&barrier);
   pthread_join(t, 0);
   return Global;
 }
Index: gcc/testsuite/c-c++-common/tsan/simple_stack.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/simple_stack.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/simple_stack.c	(.../branches/gcc-4_9-branch)
@@ -1,9 +1,10 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stdio.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 int Global;
 
 void __attribute__((noinline)) foo1() {
@@ -25,7 +26,7 @@
 }
 
 void *Thread1(void *x) {
-  sleep(1);
+  barrier_wait(&barrier);
   bar1();
   return NULL;
 }
@@ -32,6 +33,7 @@
 
 void *Thread2(void *x) {
   bar2();
+  barrier_wait(&barrier);
   return NULL;
 }
 
@@ -40,6 +42,7 @@
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_t t[2];
   StartThread(&t[0], Thread1);
   StartThread(&t[1], Thread2);
@@ -50,16 +53,16 @@
 
 /* { dg-output "WARNING: ThreadSanitizer: data race.*" } */
 /* { dg-output "  Write of size 4 at .* by thread T1:(\n|\r\n|\r)" } */
-/* { dg-output "    #0 foo1.* .*(simple_stack.c:10|\\?{2}:0) (.*)" } */
-/* { dg-output "    #1 bar1.* .*(simple_stack.c:15|\\?{2}:0) (.*)" } */
-/* { dg-output "    #2 Thread1.* .*(simple_stack.c:29|\\?{2}:0) (.*)" } */
+/* { dg-output "    #0 foo1.* .*(simple_stack.c:11|\\?{2}:0) (.*)" } */
+/* { dg-output "    #1 bar1.* .*(simple_stack.c:16|\\?{2}:0) (.*)" } */
+/* { dg-output "    #2 Thread1.* .*(simple_stack.c:30|\\?{2}:0) (.*)" } */
 /* { dg-output "  Previous read of size 4 at .* by thread T2:(\n|\r\n|\r)" } */
-/* { dg-output "    #0 foo2.* .*(simple_stack.c:19|\\?{2}:0) (.*)" } */
-/* { dg-output "    #1 bar2.* .*(simple_stack.c:24|\\?{2}:0) (.*)" } */
-/* { dg-output "    #2 Thread2.* .*(simple_stack.c:34|\\?{2}:0) (.*)" } */
+/* { dg-output "    #0 foo2.* .*(simple_stack.c:20|\\?{2}:0) (.*)" } */
+/* { dg-output "    #1 bar2.* .*(simple_stack.c:25|\\?{2}:0) (.*)" } */
+/* { dg-output "    #2 Thread2.* .*(simple_stack.c:35|\\?{2}:0) (.*)" } */
 /* { dg-output "  Thread T1 \\(tid=.*, running\\) created by main thread at:(\n|\r\n|\r)" } */
 /* { dg-output "    #0 pthread_create .* (.*)" } */
-/* { dg-output "    #1 StartThread.* .*(simple_stack.c:39|\\?{2}:0) (.*)" } */
+/* { dg-output "    #1 StartThread.* .*(simple_stack.c:41|\\?{2}:0) (.*)" } */
 /* { dg-output "  Thread T2 (.*) created by main thread at:(\n|\r\n|\r)" } */
 /* { dg-output "    #0 pthread_create .* (.*)" } */
-/* { dg-output "    #1 StartThread.* .*(simple_stack.c:39|\\?{2}:0) (.*)" } */
+/* { dg-output "    #1 StartThread.* .*(simple_stack.c:41|\\?{2}:0) (.*)" } */
Index: gcc/testsuite/c-c++-common/tsan/tsan_barrier.h
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/tsan_barrier.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/tsan_barrier.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+/* TSAN-invisible barriers.  Link with -ldl.  */
+#include <pthread.h>
+#include <dlfcn.h>
+
+static __typeof(pthread_barrier_wait) *barrier_wait;
+
+static
+void barrier_init (pthread_barrier_t *barrier, unsigned count)
+{
+  void *h = dlopen ("libpthread.so.0", RTLD_LAZY);
+  barrier_wait = (__typeof (pthread_barrier_wait) *)
+	 	 dlsym (h, "pthread_barrier_wait");
+  pthread_barrier_init (barrier, NULL, count);
+}
Index: gcc/testsuite/c-c++-common/tsan/simple_race.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/simple_race.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/simple_race.c	(.../branches/gcc-4_9-branch)
@@ -1,13 +1,15 @@
 /* { dg-set-target-env-var TSAN_OPTIONS "halt_on_error=1" } */
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stdio.h>
 #include <unistd.h>
+#include "tsan_barrier.h"
 
-#define MAX_ITERATIONS_NUMBER 100
-#define SLEEP_STEP 128000 
+#define MAX_ITERATIONS_NUMBER 1
+#define SLEEP_STEP 128000
 
+static pthread_barrier_t barrier;
 unsigned int delay_time = 1000;
 
 static inline void delay () {
@@ -17,6 +19,7 @@
 extern int main_1();
 
 int main() {
+  barrier_init(&barrier, 2);
   int i;
   for (i = 0; i < MAX_ITERATIONS_NUMBER; i++) {
     main_1();
@@ -28,6 +31,7 @@
 int Global;
 
 void *Thread1(void *x) {
+  barrier_wait(&barrier);
   delay();
   Global = 42;
   return NULL;
@@ -35,6 +39,7 @@
 
 void *Thread2(void *x) {
   Global = 43;
+  barrier_wait(&barrier);
   return NULL;
 }
 
Index: gcc/testsuite/c-c++-common/tsan/race_on_mutex.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c	(.../branches/gcc-4_9-branch)
@@ -1,10 +1,10 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stdio.h>
-#include <stddef.h>
-#include <unistd.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
 pthread_mutex_t Mtx;
 int Global;
 
@@ -13,11 +13,12 @@
   pthread_mutex_lock(&Mtx);
   Global = 42;
   pthread_mutex_unlock(&Mtx);
+  barrier_wait(&barrier);
   return NULL;
 }
 
 void *Thread2(void *x) {
-  sleep(1);
+  barrier_wait(&barrier);
   pthread_mutex_lock(&Mtx);
   Global = 43;
   pthread_mutex_unlock(&Mtx);
@@ -25,6 +26,7 @@
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   pthread_t t[2];
   pthread_create(&t[0], NULL, Thread1, NULL);
   pthread_create(&t[1], NULL, Thread2, NULL);
@@ -37,7 +39,7 @@
 /* { dg-output "WARNING: ThreadSanitizer: data race.*(\n|\r\n|\r)" } */
 /* { dg-output "  Atomic read of size 1 at .* by thread T2:(\n|\r\n|\r)" } */
 /* { dg-output "    #0 pthread_mutex_lock.*" } */
-/* { dg-output "    #1 Thread2.* .*(race_on_mutex.c:21|\\?{2}:0) (.*)" } */
+/* { dg-output "    #1 Thread2.* .*(race_on_mutex.c:22|\\?{2}:0) (.*)" } */
 /* { dg-output "  Previous write of size 1 at .* by thread T1:(\n|\r\n|\r)" } */
 /* { dg-output "    #0 pthread_mutex_init .* (.)*" } */
 /* { dg-output "    #1 Thread1.* .*(race_on_mutex.c:12|\\?{2}:0) .*" } */
Index: gcc/testsuite/c-c++-common/tsan/tls_race.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/tsan/tls_race.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/tsan/tls_race.c	(.../branches/gcc-4_9-branch)
@@ -1,18 +1,24 @@
 /* { dg-shouldfail "tsan" } */
+/* { dg-additional-options "-ldl" } */
 
 #include <pthread.h>
-#include <stddef.h>
+#include "tsan_barrier.h"
 
+static pthread_barrier_t barrier;
+
 void *Thread(void *a) {
+  barrier_wait(&barrier);
   *(int*)a = 43;
   return 0;
 }
 
 int main() {
+  barrier_init(&barrier, 2);
   static __thread int Var = 42;
   pthread_t t;
   pthread_create(&t, 0, Thread, &Var);
   Var = 43;
+  barrier_wait(&barrier);
   pthread_join(t, 0);
 }
 
Index: gcc/testsuite/c-c++-common/pr61553.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr61553.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/pr61553.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,8 @@
+/* PR c/61553 */
+/* { dg-do compile } */
+
+void
+foo (char *s)
+{
+  __atomic_store (s, (void *) 0, __ATOMIC_SEQ_CST); /* { dg-error "size mismatch" } */
+}
Index: gcc/testsuite/c-c++-common/ubsan/overflow-sub-3.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/ubsan/overflow-sub-3.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/ubsan/overflow-sub-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-fsanitize=signed-integer-overflow" } */
+
+__attribute__((noinline, noclone)) int
+foo1 (int x, int y)
+{
+  return x - y;
+}
+
+__attribute__((noinline, noclone)) int
+foo2 (int x, int y)
+{
+  unsigned int xa = (unsigned int) x - (__INT_MAX__ - 3);
+  xa &= 3;
+  x = __INT_MAX__ - 3 + xa;
+  unsigned int ya = y + 1U;
+  ya &= 1;
+  y = ya - 1;
+  return x - y;
+}
+
+int
+main ()
+{
+  int xm1, y;
+  for (xm1 = __INT_MAX__ - 4; xm1 < __INT_MAX__; xm1++)
+    for (y = -1; y <= 0; y++)
+      if (foo1 (xm1 + 1, y) != (int) (xm1 + 1U - y)
+	  || foo2 (xm1 + 1, y) != (int) (xm1 + 1U - y))
+	__builtin_abort ();
+  return 0;
+}
+/* { dg-output ":7:\[0-9]\[^\n\r]*signed integer overflow: 2147483647 - -1 cannot be represented in type 'int'\[^\n\r]*(\n|\r\n|\r)" } */
+/* { dg-output "\[^\n\r]*:19:\[0-9]\[^\n\r]*signed integer overflow: 2147483647 - -1 cannot be represented in type 'int'" } */
Index: gcc/testsuite/c-c++-common/ubsan/pr56917.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/ubsan/pr56917.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/ubsan/pr56917.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+/* PR middle-end/56917 */
+/* { dg-do run } */
+/* { dg-options "-fsanitize=undefined" } */
+
+#include <stdio.h>
+
+#define INT_MIN (-__INT_MAX__ - 1)
+#define LONG_MIN (-__LONG_MAX__ - 1L)
+#define LLONG_MIN (-__LONG_LONG_MAX__ - 1LL)
+
+int __attribute__ ((noinline,noclone))
+fn1 (unsigned int u)
+{
+  return (-(int) (u - 1U)) - 1;
+}
+
+long __attribute__ ((noinline,noclone))
+fn2 (unsigned long int ul)
+{
+  return (-(long) (ul - 1UL)) - 1L;
+}
+
+long long __attribute__ ((noinline,noclone))
+fn3 (unsigned long long int ull)
+{
+  return (-(long long) (ull - 1ULL)) - 1LL;
+}
+
+int
+main (void)
+{
+  fputs ("UBSAN TEST START\n", stderr);
+
+  if (fn1 (__INT_MAX__ + 1U) != INT_MIN
+      || fn2 (__LONG_MAX__ + 1UL) != LONG_MIN
+      || fn3 (__LONG_LONG_MAX__ + 1ULL) != LLONG_MIN)
+    __builtin_abort ();
+
+  fputs ("UBSAN TEST END\n", stderr);
+  return 0;
+}
+
+/* { dg-output "UBSAN TEST START(\n|\r\n|\r)UBSAN TEST END" } */
Index: gcc/testsuite/c-c++-common/ubsan/undefined-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/ubsan/undefined-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/ubsan/undefined-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-fsanitize=undefined" } */
+/* { dg-additional-options "-std=gnu11" { target c } } */
+/* { dg-additional-options "-std=c++11" { target c++ } } */
+
+#include <stdio.h>
+
+volatile int w, z;
+
+__attribute__ ((noinline, noclone)) int
+foo (int x, int y)
+{
+  z++;
+  return x << y;
+}
+
+int
+main ()
+{
+  fputs ("1st\n", stderr);
+  w = foo (0, -__INT_MAX__);
+  return 0;
+}
+
+/* { dg-output "1st(\n|\r\n|\r)" } */
+/* { dg-output "\[^\n\r]*shift exponent -\[^\n\r]* is negative\[^\n\r]*(\n|\r\n|\r)" } */
Index: gcc/testsuite/c-c++-common/pr57653-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr57653-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/pr57653-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,4 @@
+/* { dg-do preprocess } */
+/* { dg-options "-imacros ${srcdir}/c-c++-common/pr57653-2.h" } */
+
+/* Empty.  */
Index: gcc/testsuite/c-c++-common/pr57653-2.h
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr57653-2.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/pr57653-2.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1 @@
+
Index: gcc/testsuite/c-c++-common/pr56493.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr56493.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/pr56493.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* PR c++/56493 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-gimple" } */
+
+unsigned long long bar (void);
+int x;
+
+void
+foo (void)
+{
+  x += bar ();
+}
+
+/* Verify we narrow the addition from unsigned long long to unsigned int type.  */
+/* { dg-final { scan-tree-dump "  (\[a-zA-Z._0-9]*) = \\(unsigned int\\) \[^;\n\r]*;.*  (\[a-zA-Z._0-9]*) = \\(unsigned int\\) \[^;\n\r]*;.* = \\1 \\+ \\2;" "gimple" { target { ilp32 || lp64 } } } } */
+/* { dg-final { cleanup-tree-dump "gimple" } } */
Index: gcc/testsuite/c-c++-common/gomp/pr60823-4.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr60823-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr60823-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+/* PR tree-optimization/63915 */
+/* { dg-do run } */
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-options "-O2 -fopenmp-simd" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+#include "pr60823-2.c"
Index: gcc/testsuite/c-c++-common/pr57653.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr57653.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/pr57653.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-imacros ${srcdir}/c-c++-common/pr57653.h" } */
+
+__attribute__((used)) static const char s[] = F;
+
+/* { dg-final { scan-assembler-not "command-line" } } */
Index: gcc/testsuite/c-c++-common/pr57653.h
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr57653.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/pr57653.h	(.../branches/gcc-4_9-branch)
@@ -0,0 +1 @@
+#define F __FILE__
Index: gcc/cp/typeck.c
===================================================================
--- a/src/gcc/cp/typeck.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/typeck.c	(.../branches/gcc-4_9-branch)
@@ -8881,6 +8881,12 @@
   /* This should really have a different TYPE_MAIN_VARIANT, but that gets
      complex.  */
   tree result = build_qualified_type (type, memfn_quals);
+  if (tree canon = TYPE_CANONICAL (result))
+    if (canon != result)
+      /* check_qualified_type doesn't check the ref-qualifier, so make sure
+	 TYPE_CANONICAL is correct.  */
+      TYPE_CANONICAL (result)
+	= build_ref_qualified_type (canon, type_memfn_rqual (result));
   result = build_exception_variant (result, TYPE_RAISES_EXCEPTIONS (type));
   return build_ref_qualified_type (result, rqual);
 }
Index: gcc/cp/init.c
===================================================================
--- a/src/gcc/cp/init.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/init.c	(.../branches/gcc-4_9-branch)
@@ -3734,11 +3734,7 @@
 	{
 	  if (cxx_dialect >= cxx11 && AGGREGATE_TYPE_P (type))
 	    {
-	      if (BRACE_ENCLOSED_INITIALIZER_P (init)
-		  && CONSTRUCTOR_NELTS (init) == 0)
-		/* Reuse it.  */;
-	      else
-		init = build_constructor (init_list_type_node, NULL);
+	      init = build_constructor (init_list_type_node, NULL);
 	      CONSTRUCTOR_IS_DIRECT_INIT (init) = true;
 	    }
 	  else
Index: gcc/cp/repo.c
===================================================================
--- a/src/gcc/cp/repo.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/repo.c	(.../branches/gcc-4_9-branch)
@@ -293,7 +293,11 @@
   int ret = 0;
   gcc_assert (TREE_PUBLIC (decl));
   gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));
-  gcc_assert (!DECL_REALLY_EXTERN (decl));
+  gcc_assert (!DECL_REALLY_EXTERN (decl)
+	      /* A clone might not have its linkage flags updated yet
+		 because we call import_export_decl before
+		 maybe_clone_body.  */
+	      || DECL_ABSTRACT_ORIGIN (decl));
 
   /* When not using the repository, emit everything.  */
   if (!flag_use_repository)
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-4_9-branch)
@@ -630,8 +630,7 @@
 	   push_local_binding where the list of decls returned by
 	   getdecls is built.  */
 	decl = TREE_CODE (d) == TREE_LIST ? TREE_VALUE (d) : d;
-	// See through references for improved -Wunused-variable (PR 38958).
-	tree type = non_reference (TREE_TYPE (decl));
+	tree type = TREE_TYPE (decl);
 	if (VAR_P (decl)
 	    && (! TREE_USED (decl) || !DECL_READ_P (decl))
 	    && ! DECL_IN_SYSTEM_HEADER (decl)
@@ -1789,6 +1788,8 @@
       DECL_PURE_VIRTUAL_P (newdecl) |= DECL_PURE_VIRTUAL_P (olddecl);
       DECL_VIRTUAL_P (newdecl) |= DECL_VIRTUAL_P (olddecl);
       DECL_INVALID_OVERRIDER_P (newdecl) |= DECL_INVALID_OVERRIDER_P (olddecl);
+      DECL_FINAL_P (newdecl) |= DECL_FINAL_P (olddecl);
+      DECL_OVERRIDE_P (newdecl) |= DECL_OVERRIDE_P (olddecl);
       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);
       if (DECL_OVERLOADED_OPERATOR_P (olddecl) != ERROR_MARK)
 	SET_OVERLOADED_OPERATOR_CODE
@@ -4792,11 +4793,26 @@
     init = build_x_compound_expr_from_list (init, ELK_INIT,
 					    tf_warning_or_error);
 
-  if (TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE
+  tree ttype = TREE_TYPE (type);
+  if (TREE_CODE (ttype) != ARRAY_TYPE
       && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)
     /* Note: default conversion is only called in very special cases.  */
     init = decay_conversion (init, tf_warning_or_error);
 
+  /* check_initializer handles this for non-reference variables, but for
+     references we need to do it here or the initializer will get the
+     incomplete array type and confuse later calls to
+     cp_complete_array_type.  */
+  if (TREE_CODE (ttype) == ARRAY_TYPE
+      && TYPE_DOMAIN (ttype) == NULL_TREE
+      && (BRACE_ENCLOSED_INITIALIZER_P (init)
+	  || TREE_CODE (init) == STRING_CST))
+    {
+      cp_complete_array_type (&ttype, init, false);
+      if (ttype != TREE_TYPE (type))
+	type = cp_build_reference_type (ttype, TYPE_REF_IS_RVALUE (type));
+    }
+
   /* Convert INIT to the reference type TYPE.  This may involve the
      creation of a temporary, whose lifetime must be the same as that
      of the reference.  If so, a DECL_EXPR for the temporary will be
@@ -13651,13 +13667,19 @@
       initialize_vtbl_ptrs (current_class_ptr);
       finish_compound_stmt (compound_stmt);
 
-      /* Insert a cleanup to let the back end know that the object is dead
-	 when we exit the destructor, either normally or via exception.  */
-      tree clobber = build_constructor (current_class_type, NULL);
-      TREE_THIS_VOLATILE (clobber) = true;
-      tree exprstmt = build2 (MODIFY_EXPR, current_class_type,
-			      current_class_ref, clobber);
-      finish_decl_cleanup (NULL_TREE, exprstmt);
+      if (flag_lifetime_dse)
+	{
+	  /* Insert a cleanup to let the back end know that the object is dead
+	     when we exit the destructor, either normally or via exception.  */
+	  tree btype = CLASSTYPE_AS_BASE (current_class_type);
+	  tree clobber = build_constructor (btype, NULL);
+	  TREE_THIS_VOLATILE (clobber) = true;
+	  tree bref = build_nop (build_reference_type (btype),
+				 current_class_ptr);
+	  bref = convert_from_reference (bref);
+	  tree exprstmt = build2 (MODIFY_EXPR, btype, bref, clobber);
+	  finish_decl_cleanup (NULL_TREE, exprstmt);
+	}
 
       /* And insert cleanups for our bases and members so that they
 	 will be properly destroyed if we throw.  */
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,106 @@
+2015-03-26  Mikhail Maltsev  <maltsevm@gmail.com>
+
+	PR c++/65154
+	* init.c (build_vec_init): Fix initializing aggregates
+	with empty init list.
+
+2015-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65209
+	PR c++/65309
+	* decl2.c (constrain_visibility_for_template): Handle reference
+	arguments.
+
+2015-02-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/62255
+	* pt.c (instantiate_decl): Handle recursive instantiation of
+	static data member.
+
+	* decl.c (begin_destructor_body): Condition clobber on
+	-flifetime-dse.
+
+2015-02-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/62017
+	* decl.c (begin_destructor_body): Only clobber the as-base part of
+	*this.
+
+2015-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/64824
+	PR c/64868
+	* parser.c (cp_parser_omp_atomic): Handle RDIV_EXPR.
+
+2015-02-04  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR c++/64901
+	* decl.c (duplicate_decls): Also duplicate DECL_FINAL_P and
+	DECL_OVERRIDE_P.
+
+2015-01-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/64521
+	* repo.c (repo_emit_p): It's OK for a clone to be extern at this
+	point.
+
+2015-01-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/64514
+	* pt.c (coerce_template_parameter_pack): Return NULL for a
+	zero-length fixed parameter pack with a pack expansion arg.
+
+2015-01-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/64487
+	* semantics.c (finish_offsetof): Handle templates here.
+	* parser.c (cp_parser_builtin_offsetof): Not here.
+
+	PR c++/64352
+	* pt.c (tsubst_copy_and_build): Pass complain to mark_used.
+
+	PR c++/64251
+	* decl2.c (mark_used): Don't mark if in_template_function.
+
+	PR c++/64297
+	* typeck.c (apply_memfn_quals): Correct wrong TYPE_CANONICAL.
+
+	PR c++/64029
+	* decl.c (grok_reference_init): Complete array type.
+
+	PR c++/63657
+	PR c++/38958
+	* call.c (set_up_extended_ref_temp): Set TREE_USED on the reference
+	if the temporary has a non-trivial destructor.
+	* decl.c (poplevel): Don't look through references.
+
+	PR c++/63658
+	* pt.c (convert_nontype_argument): Call convert_from_reference.
+	(check_instantiated_arg): Don't be confused by reference refs.
+	(unify): Look through reference refs on the arg, too.
+	* mangle.c (write_template_arg): Look through reference refs.
+
+2014-12-19  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/60955
+	* pt.c (struct warning_sentinel): Move it...
+	* cp-tree.h: ... here.
+	* semantics.c (force_paren_expr): Use it.
+
+2014-11-21  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63849
+	* mangle.c (decl_mangling_context): Use template_type_parameter_p.
+
+2014-11-11  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/63265
+	* pt.c (tsubst_copy_and_build, case COND_EXPR): Maybe fold to
+	constant the condition.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-4_9-branch)
@@ -6084,7 +6084,7 @@
      right type?  */
   gcc_assert (same_type_ignoring_top_level_qualifiers_p
 	      (type, TREE_TYPE (expr)));
-  return expr;
+  return convert_from_reference (expr);
 }
 
 /* Subroutine of coerce_template_template_parms, which returns 1 if
@@ -6671,6 +6671,9 @@
               if (invalid_nontype_parm_type_p (t, complain))
                 return error_mark_node;
             }
+	  /* We don't know how many args we have yet, just
+	     use the unconverted ones for now.  */
+	  return NULL_TREE;
         }
 
       packed_args = make_tree_vec (TREE_VEC_LENGTH (packed_parms));
@@ -14151,16 +14154,6 @@
   return t;
 }
 
-/* Sentinel to disable certain warnings during template substitution.  */
-
-struct warning_sentinel {
-  int &flag;
-  int val;
-  warning_sentinel(int& flag, bool suppress=true)
-    : flag(flag), val(flag) { if (suppress) flag = 0; }
-  ~warning_sentinel() { flag = val; }
-};
-
 /* Like tsubst but deals with expressions and performs semantic
    analysis.  FUNCTION_P is true if T is the "F" in "F (ARGS)".  */
 
@@ -14828,7 +14821,7 @@
 
 	/* Remember that there was a reference to this entity.  */
 	if (DECL_P (function))
-	  mark_used (function);
+	  mark_used (function, complain);
 
 	/* Put back tf_decltype for the actual call.  */
 	complain |= decltype_flag;
@@ -14875,11 +14868,13 @@
     case COND_EXPR:
       {
 	tree cond = RECUR (TREE_OPERAND (t, 0));
+	tree folded_cond = (maybe_constant_value
+			    (fold_non_dependent_expr_sfinae (cond, tf_none)));
 	tree exp1, exp2;
 
-	if (TREE_CODE (cond) == INTEGER_CST)
+	if (TREE_CODE (folded_cond) == INTEGER_CST)
 	  {
-	    if (integer_zerop (cond))
+	    if (integer_zerop (folded_cond))
 	      {
 		++c_inhibit_evaluation_warnings;
 		exp1 = RECUR (TREE_OPERAND (t, 1));
@@ -14893,6 +14888,7 @@
 		exp2 = RECUR (TREE_OPERAND (t, 2));
 		--c_inhibit_evaluation_warnings;
 	      }
+	    cond = folded_cond;
 	  }
 	else
 	  {
@@ -15443,6 +15439,7 @@
      constant.  */
   else if (TREE_TYPE (t)
 	   && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (t))
+	   && !REFERENCE_REF_P (t)
 	   && !TREE_CONSTANT (t))
     {
       if (complain & tf_error)
@@ -18166,8 +18163,12 @@
 
     case INDIRECT_REF:
       if (REFERENCE_REF_P (parm))
-	return unify (tparms, targs, TREE_OPERAND (parm, 0), arg,
-		      strict, explain_p);
+	{
+	  if (REFERENCE_REF_P (arg))
+	    arg = TREE_OPERAND (arg, 0);
+	  return unify (tparms, targs, TREE_OPERAND (parm, 0), arg,
+			strict, explain_p);
+	}
       /* FALLTHRU */
 
     default:
@@ -19793,13 +19794,18 @@
 			      args,
 			      tf_warning_or_error, NULL_TREE,
 			      /*integral_constant_expression_p=*/false);
-	  /* Make sure the initializer is still constant, in case of
-	     circular dependency (template/instantiate6.C). */
-	  const_init
-	    = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (code_pattern);
-	  cp_finish_decl (d, init, /*init_const_expr_p=*/const_init,
-			  /*asmspec_tree=*/NULL_TREE,
-			  LOOKUP_ONLYCONVERTING);
+	  /* If instantiating the initializer involved instantiating this
+	     again, don't call cp_finish_decl twice.  */
+	  if (!DECL_INITIAL (d))
+	    {
+	      /* Make sure the initializer is still constant, in case of
+		 circular dependency (template/instantiate6.C). */
+	      const_init
+		= DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (code_pattern);
+	      cp_finish_decl (d, init, /*init_const_expr_p=*/const_init,
+			      /*asmspec_tree=*/NULL_TREE,
+			      LOOKUP_ONLYCONVERTING);
+	    }
 	  pop_nested_class ();
 	  pop_nested_namespace (ns);
 	}
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-4_9-branch)
@@ -1629,6 +1629,9 @@
 	  tree type = unlowered_expr_type (expr);
 	  bool rval = !!(kind & clk_rvalueref);
 	  type = cp_build_reference_type (type, rval);
+	  /* This inhibits warnings in, eg, cxx_mark_addressable
+	     (c++/60955).  */
+	  warning_sentinel s (extra_warnings);
 	  expr = build_static_cast (type, expr, tf_error);
 	  if (expr != error_mark_node)
 	    REF_PARENTHESIZED_P (expr) = true;
@@ -3800,6 +3803,14 @@
 tree
 finish_offsetof (tree expr)
 {
+  /* If we're processing a template, we can't finish the semantics yet.
+     Otherwise we can fold the entire expression now.  */
+  if (processing_template_decl)
+    {
+      expr = build1 (OFFSETOF_EXPR, size_type_node, expr);
+      return expr;
+    }
+
   if (TREE_CODE (expr) == PSEUDO_DTOR_EXPR)
     {
       error ("cannot apply %<offsetof%> to destructor %<~%T%>",
Index: gcc/cp/decl2.c
===================================================================
--- a/src/gcc/cp/decl2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/decl2.c	(.../branches/gcc-4_9-branch)
@@ -2122,9 +2122,12 @@
       tree arg = TREE_VEC_ELT (args, i-1);
       if (TYPE_P (arg))
 	vis = type_visibility (arg);
-      else if (TREE_TYPE (arg) && POINTER_TYPE_P (TREE_TYPE (arg)))
+      else
 	{
-	  STRIP_NOPS (arg);
+	  if (REFERENCE_REF_P (arg))
+	    arg = TREE_OPERAND (arg, 0);
+	  if (TREE_TYPE (arg))
+	    STRIP_NOPS (arg);
 	  if (TREE_CODE (arg) == ADDR_EXPR)
 	    arg = TREE_OPERAND (arg, 0);
 	  if (VAR_OR_FUNCTION_DECL_P (arg))
@@ -4914,7 +4917,7 @@
       --function_depth;
     }
 
-  if (processing_template_decl)
+  if (processing_template_decl || in_template_function ())
     return true;
 
   /* Check this too in case we're within fold_non_dependent_expr.  */
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-4_9-branch)
@@ -8479,12 +8479,7 @@
     }
 
  success:
-  /* If we're processing a template, we can't finish the semantics yet.
-     Otherwise we can fold the entire expression now.  */
-  if (processing_template_decl)
-    expr = build1 (OFFSETOF_EXPR, size_type_node, expr);
-  else
-    expr = finish_offsetof (expr);
+  expr = finish_offsetof (expr);
 
  failure:
   parser->integral_constant_expression_p = save_ice_p;
@@ -28753,6 +28748,7 @@
 		{
 		case MULT_EXPR:
 		case TRUNC_DIV_EXPR:
+		case RDIV_EXPR:
 		case PLUS_EXPR:
 		case MINUS_EXPR:
 		case LSHIFT_EXPR:
Index: gcc/cp/call.c
===================================================================
--- a/src/gcc/cp/call.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/call.c	(.../branches/gcc-4_9-branch)
@@ -9393,6 +9393,10 @@
 	/* Check whether the dtor is callable.  */
 	cxx_maybe_build_cleanup (var, tf_warning_or_error);
     }
+  /* Avoid -Wunused-variable warning (c++/38958).  */
+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)
+      && TREE_CODE (decl) == VAR_DECL)
+    TREE_USED (decl) = DECL_READ_P (decl) = true;
 
   *initp = init;
   return var;
Index: gcc/cp/mangle.c
===================================================================
--- a/src/gcc/cp/mangle.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/mangle.c	(.../branches/gcc-4_9-branch)
@@ -763,8 +763,7 @@
       if (extra)
 	return extra;
     }
-    else if (TREE_CODE (decl) == TYPE_DECL
-	     && TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TYPE_PARM)
+  else if (template_type_parameter_p (decl))
      /* template type parms have no mangling context.  */
       return NULL_TREE;
   return CP_DECL_CONTEXT (decl);
@@ -3112,6 +3111,8 @@
 	}
     }
 
+  if (REFERENCE_REF_P (node))
+    node = TREE_OPERAND (node, 0);
   if (TREE_CODE (node) == NOP_EXPR
       && TREE_CODE (TREE_TYPE (node)) == REFERENCE_TYPE)
     {
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-4_9-branch)
@@ -1098,6 +1098,18 @@
 #define processing_specialization scope_chain->x_processing_specialization
 #define processing_explicit_instantiation scope_chain->x_processing_explicit_instantiation
 
+/* RAII sentinel to disable certain warnings during template substitution
+   and elsewhere.  */
+
+struct warning_sentinel
+{
+  int &flag;
+  int val;
+  warning_sentinel(int& flag, bool suppress=true)
+    : flag(flag), val(flag) { if (suppress) flag = 0; }
+  ~warning_sentinel() { flag = val; }
+};
+
 /* The cached class binding level, from the most recently exited
    class, or NULL if none.  */
 
Index: gcc/lto-cgraph.c
===================================================================
--- a/src/gcc/lto-cgraph.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/lto-cgraph.c	(.../branches/gcc-4_9-branch)
@@ -793,7 +793,8 @@
       if (DECL_ABSTRACT_ORIGIN (node->decl))
 	{
 	  struct cgraph_node *origin_node
-	  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (node->decl));
+	  = cgraph_get_create_node (DECL_ABSTRACT_ORIGIN (node->decl));
+	  origin_node->used_as_abstract_origin = true;
 	  add_node_to (encoder, origin_node, true);
 	}
     }
Index: gcc/ipa-pure-const.c
===================================================================
--- a/src/gcc/ipa-pure-const.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ipa-pure-const.c	(.../branches/gcc-4_9-branch)
@@ -1434,7 +1434,7 @@
 	      else if (e->can_throw_external && !TREE_NOTHROW (y->decl))
 	        can_throw = true;
 	    }
-          for (ie = node->indirect_calls; ie; ie = ie->next_callee)
+          for (ie = w->indirect_calls; ie; ie = ie->next_callee)
 	    if (ie->can_throw_external)
 	      {
 		can_throw = true;
Index: gcc/cse.c
===================================================================
--- a/src/gcc/cse.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cse.c	(.../branches/gcc-4_9-branch)
@@ -1805,6 +1805,8 @@
 	    }
 	  new_elt = insert (exp, class1, hash, mode);
 	  new_elt->in_memory = hash_arg_in_memory;
+	  if (GET_CODE (exp) == ASM_OPERANDS && elt->cost == MAX_COST)
+	    new_elt->cost = MAX_COST;
 	}
     }
 }
@@ -4266,7 +4268,7 @@
     {
       int i, lim = XVECLEN (x, 0);
 
-      /* Go over the epressions of the PARALLEL in forward order, to
+      /* Go over the expressions of the PARALLEL in forward order, to
 	 put them in the same order in the SETS array.  */
       for (i = 0; i < lim; i++)
 	{
@@ -4642,13 +4644,28 @@
 	  && REGNO (dest) >= FIRST_PSEUDO_REGISTER)
 	sets[i].src_volatile = 1;
 
-      /* Also do not record result of a non-volatile inline asm with
-	 more than one result or with clobbers, we do not want CSE to
-	 break the inline asm apart.  */
       else if (GET_CODE (src) == ASM_OPERANDS
 	       && GET_CODE (x) == PARALLEL)
-	sets[i].src_volatile = 1;
+	{
+	  /* Do not record result of a non-volatile inline asm with
+	     more than one result.  */
+	  if (n_sets > 1)
+	    sets[i].src_volatile = 1;
 
+	  int j, lim = XVECLEN (x, 0);
+	  for (j = 0; j < lim; j++)
+	    {
+	      rtx y = XVECEXP (x, 0, j);
+	      /* And do not record result of a non-volatile inline asm
+		 with "memory" clobber.  */
+	      if (GET_CODE (y) == CLOBBER && MEM_P (XEXP (y, 0)))
+		{
+		  sets[i].src_volatile = 1;
+		  break;
+		}
+	    }
+	}
+
 #if 0
       /* It is no longer clear why we used to do this, but it doesn't
 	 appear to still be needed.  So let's try without it since this
@@ -5238,8 +5255,8 @@
 	    ;
 
 	  /* Look for a substitution that makes a valid insn.  */
-	  else if (validate_unshare_change
-		     (insn, &SET_SRC (sets[i].rtl), trial, 0))
+	  else if (validate_unshare_change (insn, &SET_SRC (sets[i].rtl),
+					    trial, 0))
 	    {
 	      rtx new_rtx = canon_reg (SET_SRC (sets[i].rtl), insn);
 
@@ -5600,6 +5617,12 @@
 		  }
 		elt = insert (src, classp, sets[i].src_hash, mode);
 		elt->in_memory = sets[i].src_in_memory;
+		/* If inline asm has any clobbers, ensure we only reuse
+		   existing inline asms and never try to put the ASM_OPERANDS
+		   into an insn that isn't inline asm.  */
+		if (GET_CODE (src) == ASM_OPERANDS
+		    && GET_CODE (x) == PARALLEL)
+		  elt->cost = MAX_COST;
 		sets[i].src_elt = classp = elt;
 	      }
 	    if (sets[i].src_const && sets[i].src_const_elt == 0
@@ -5913,6 +5936,9 @@
 		      }
 		    src_elt = insert (new_src, classp, src_hash, new_mode);
 		    src_elt->in_memory = elt->in_memory;
+		    if (GET_CODE (new_src) == ASM_OPERANDS
+			&& elt->cost == MAX_COST)
+		      src_elt->cost = MAX_COST;
 		  }
 		else if (classp && classp != src_elt->first_same_value)
 		  /* Show that two things that we've seen before are
Index: gcc/web.c
===================================================================
--- a/src/gcc/web.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/web.c	(.../branches/gcc-4_9-branch)
@@ -53,17 +53,17 @@
 
 /* Find the root of unionfind tree (the representative of set).  */
 
-struct web_entry *
-unionfind_root (struct web_entry *element)
+web_entry_base *
+web_entry_base::unionfind_root ()
 {
-  struct web_entry *element1 = element, *element2;
+  web_entry_base *element = this, *element1 = this, *element2;
 
-  while (element->pred)
-    element = element->pred;
-  while (element1->pred)
+  while (element->pred ())
+    element = element->pred ();
+  while (element1->pred ())
     {
-      element2 = element1->pred;
-      element1->pred = element;
+      element2 = element1->pred ();
+      element1->set_pred (element);
       element1 = element2;
     }
   return element;
@@ -74,23 +74,32 @@
    nothing is done.  Otherwise, return false.  */
 
 bool
-unionfind_union (struct web_entry *first, struct web_entry *second)
+unionfind_union (web_entry_base *first, web_entry_base *second)
 {
-  first = unionfind_root (first);
-  second = unionfind_root (second);
+  first = first->unionfind_root ();
+  second = second->unionfind_root ();
   if (first == second)
     return true;
-  second->pred = first;
+  second->set_pred (first);
   return false;
 }
 
+class web_entry : public web_entry_base
+{
+ private:
+  rtx reg_pvt;
+
+ public:
+  rtx reg () { return reg_pvt; }
+  void set_reg (rtx r) { reg_pvt = r; }
+};
+
 /* For INSN, union all defs and uses that are linked by match_dup.
    FUN is the function that does the union.  */
 
 static void
-union_match_dups (rtx insn, struct web_entry *def_entry,
-		  struct web_entry *use_entry,
-		  bool (*fun) (struct web_entry *, struct web_entry *))
+union_match_dups (rtx insn, web_entry *def_entry, web_entry *use_entry,
+		  bool (*fun) (web_entry_base *, web_entry_base *))
 {
   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);
   df_ref *use_link = DF_INSN_INFO_USES (insn_info);
@@ -167,9 +176,9 @@
    the values 0 and 1 are reserved for use by entry_register.  */
 
 void
-union_defs (df_ref use, struct web_entry *def_entry,
-	    unsigned int *used, struct web_entry *use_entry,
- 	    bool (*fun) (struct web_entry *, struct web_entry *))
+union_defs (df_ref use, web_entry *def_entry,
+	    unsigned int *used, web_entry *use_entry,
+ 	    bool (*fun) (web_entry_base *, web_entry_base *))
 {
   struct df_insn_info *insn_info = DF_REF_INSN_INFO (use);
   struct df_link *link = DF_REF_CHAIN (use);
@@ -270,15 +279,15 @@
 /* Find the corresponding register for the given entry.  */
 
 static rtx
-entry_register (struct web_entry *entry, df_ref ref, unsigned int *used)
+entry_register (web_entry *entry, df_ref ref, unsigned int *used)
 {
-  struct web_entry *root;
+  web_entry *root;
   rtx reg, newreg;
 
   /* Find the corresponding web and see if it has been visited.  */
-  root = unionfind_root (entry);
-  if (root->reg)
-    return root->reg;
+  root = (web_entry *)entry->unionfind_root ();
+  if (root->reg ())
+    return root->reg ();
 
   /* We are seeing this web for the first time, do the assignment.  */
   reg = DF_REF_REAL_REG (ref);
@@ -302,7 +311,7 @@
 		 REGNO (newreg));
     }
 
-  root->reg = newreg;
+  root->set_reg (newreg);
   return newreg;
 }
 
@@ -336,8 +345,8 @@
 static unsigned int
 web_main (void)
 {
-  struct web_entry *def_entry;
-  struct web_entry *use_entry;
+  web_entry *def_entry;
+  web_entry *use_entry;
   unsigned int max = max_reg_num ();
   unsigned int *used;
   basic_block bb;
@@ -374,9 +383,9 @@
     }
 
   /* Record the number of uses and defs at the beginning of the optimization.  */
-  def_entry = XCNEWVEC (struct web_entry, DF_DEFS_TABLE_SIZE ());
+  def_entry = XCNEWVEC (web_entry, DF_DEFS_TABLE_SIZE ());
   used = XCNEWVEC (unsigned, max);
-  use_entry = XCNEWVEC (struct web_entry, uses_num);
+  use_entry = XCNEWVEC (web_entry, uses_num);
 
   /* Produce the web.  */
   FOR_ALL_BB_FN (bb, cfun)
Index: gcc/tree-stdarg.c
===================================================================
--- a/src/gcc/tree-stdarg.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-stdarg.c	(.../branches/gcc-4_9-branch)
@@ -823,21 +823,22 @@
       /* For va_list_simple_ptr, we have to check PHI nodes too.  We treat
 	 them as assignments for the purpose of escape analysis.  This is
 	 not needed for non-simple va_list because virtual phis don't perform
-	 any real data movement.  */
-      if (va_list_simple_ptr)
+	 any real data movement.  Also, check PHI nodes for taking address of
+	 the va_list vars.  */
+      tree lhs, rhs;
+      use_operand_p uop;
+      ssa_op_iter soi;
+
+      for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))
 	{
-	  tree lhs, rhs;
-	  use_operand_p uop;
-	  ssa_op_iter soi;
+	  gimple phi = gsi_stmt (i);
+	  lhs = PHI_RESULT (phi);
 
-	  for (i = gsi_start_phis (bb); !gsi_end_p (i); gsi_next (&i))
+	  if (virtual_operand_p (lhs))
+	    continue;
+
+	  if (va_list_simple_ptr)
 	    {
-	      gimple phi = gsi_stmt (i);
-	      lhs = PHI_RESULT (phi);
-
-	      if (virtual_operand_p (lhs))
-		continue;
-
 	      FOR_EACH_PHI_ARG (uop, phi, soi, SSA_OP_USE)
 		{
 		  rhs = USE_FROM_PTR (uop);
@@ -860,6 +861,22 @@
 		    }
 		}
 	    }
+
+	  for (unsigned j = 0; !va_list_escapes
+			       && j < gimple_phi_num_args (phi); ++j)
+	    if ((!va_list_simple_ptr
+		 || TREE_CODE (gimple_phi_arg_def (phi, j)) != SSA_NAME)
+		&& walk_tree (gimple_phi_arg_def_ptr (phi, j),
+			      find_va_list_reference, &wi, NULL))
+	      {
+		if (dump_file && (dump_flags & TDF_DETAILS))
+		  {
+		    fputs ("va_list escapes in ", dump_file);
+		    print_gimple_stmt (dump_file, phi, 0, dump_flags);
+		    fputc ('\n', dump_file);
+		  }
+		va_list_escapes = true;
+	      }
 	}
 
       for (i = gsi_start_bb (bb);
@@ -882,8 +899,8 @@
 
 	  if (is_gimple_assign (stmt))
 	    {
-	      tree lhs = gimple_assign_lhs (stmt);
-	      tree rhs = gimple_assign_rhs1 (stmt);
+	      lhs = gimple_assign_lhs (stmt);
+	      rhs = gimple_assign_rhs1 (stmt);
 
 	      if (va_list_simple_ptr)
 		{
Index: gcc/lto-streamer-out.c
===================================================================
--- a/src/gcc/lto-streamer-out.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/lto-streamer-out.c	(.../branches/gcc-4_9-branch)
@@ -135,8 +135,12 @@
   /* Parameters and return values of functions of variably modified types
      must go to global stream, because they may be used in the type
      definition.  */
-  if (TREE_CODE (t) == PARM_DECL || TREE_CODE (t) == RESULT_DECL)
+  if ((TREE_CODE (t) == PARM_DECL || TREE_CODE (t) == RESULT_DECL)
+      && DECL_CONTEXT (t))
     return variably_modified_type_p (TREE_TYPE (DECL_CONTEXT (t)), NULL_TREE);
+  /* IMPORTED_DECL is put into BLOCK and thus it never can be shared.  */
+  else if (TREE_CODE (t) == IMPORTED_DECL)
+    return false;
   else if (((TREE_CODE (t) == VAR_DECL && !TREE_STATIC (t))
 	    || TREE_CODE (t) == TYPE_DECL
 	    || TREE_CODE (t) == CONST_DECL
Index: gcc/config.in
===================================================================
--- a/src/gcc/config.in	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config.in	(.../branches/gcc-4_9-branch)
@@ -211,6 +211,12 @@
 #endif
 
 
+/* Define if your assembler supports -mrmw option. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_AVR_MRMW_OPTION
+#endif
+
+
 /* Define if your assembler supports cmpb. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_CMPB
@@ -235,6 +241,12 @@
 #endif
 
 
+/* Define if your assembler supports .module. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_DOT_MODULE
+#endif
+
+
 /* Define if your assembler supports DSPR1 mult. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_DSPR1_MULT
@@ -1211,6 +1223,12 @@
 #endif
 
 
+/* Define if isl_schedule_constraints_compute_schedule exists. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#endif
+
+
 /* Define to 1 if you have the `kill' function. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_KILL
Index: gcc/jump.c
===================================================================
--- a/src/gcc/jump.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/jump.c	(.../branches/gcc-4_9-branch)
@@ -133,7 +133,30 @@
 	  if (BARRIER_P (prev))
 	    delete_insn (insn);
 	  else if (prev != PREV_INSN (insn))
-	    reorder_insns_nobb (insn, insn, prev);
+	    {
+	      basic_block bb = BLOCK_FOR_INSN (prev);
+	      rtx end = PREV_INSN (insn);
+	      reorder_insns_nobb (insn, insn, prev);
+	      if (bb)
+		{
+		  /* If the backend called in machine reorg compute_bb_for_insn
+		     and didn't free_bb_for_insn again, preserve basic block
+		     boundaries.  Move the end of basic block to PREV since
+		     it is followed by a barrier now, and clear BLOCK_FOR_INSN
+		     on the following notes.
+		     ???  Maybe the proper solution for the targets that have
+		     cfg around after machine reorg is not to run cleanup_barriers
+		     pass at all.  */
+		  BB_END (bb) = prev;
+		  do
+		    {
+		      prev = NEXT_INSN (prev);
+		      if (prev != insn && BLOCK_FOR_INSN (prev) == bb)
+			BLOCK_FOR_INSN (prev) = NULL;
+		    }
+		  while (prev != end);
+		}
+	    }
 	}
     }
   return 0;
Index: gcc/dwarf2out.c
===================================================================
--- a/src/gcc/dwarf2out.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/dwarf2out.c	(.../branches/gcc-4_9-branch)
@@ -4930,7 +4930,7 @@
 
 /* Return how many bits covers PIECE EXPR_LIST.  */
 
-static int
+static HOST_WIDE_INT
 decl_piece_bitsize (rtx piece)
 {
   int ret = (int) GET_MODE (piece);
@@ -4958,7 +4958,7 @@
 static rtx
 decl_piece_node (rtx loc_note, HOST_WIDE_INT bitsize, rtx next)
 {
-  if (bitsize <= (int) MAX_MACHINE_MODE)
+  if (bitsize > 0 && bitsize <= (int) MAX_MACHINE_MODE)
     return alloc_EXPR_LIST (bitsize, loc_note, next);
   else
     return alloc_EXPR_LIST (0, gen_rtx_CONCAT (VOIDmode,
@@ -4997,7 +4997,7 @@
 		   HOST_WIDE_INT bitpos, HOST_WIDE_INT piece_bitpos,
 		   HOST_WIDE_INT bitsize, rtx loc_note)
 {
-  int diff;
+  HOST_WIDE_INT diff;
   bool copy = inner != NULL;
 
   if (copy)
@@ -5137,7 +5137,7 @@
     {
       struct var_loc_node *last = temp->last, *unused = NULL;
       rtx *piece_loc = NULL, last_loc_note;
-      int piece_bitpos = 0;
+      HOST_WIDE_INT piece_bitpos = 0;
       if (last->next)
 	{
 	  last = last->next;
@@ -5148,7 +5148,7 @@
 	  piece_loc = &last->loc;
 	  do
 	    {
-	      int cur_bitsize = decl_piece_bitsize (*piece_loc);
+	      HOST_WIDE_INT cur_bitsize = decl_piece_bitsize (*piece_loc);
 	      if (piece_bitpos + cur_bitsize > bitpos)
 		break;
 	      piece_bitpos += cur_bitsize;
@@ -13573,7 +13573,7 @@
 dw_sra_loc_expr (tree decl, rtx loc)
 {
   rtx p;
-  unsigned int padsize = 0;
+  unsigned HOST_WIDE_INT padsize = 0;
   dw_loc_descr_ref descr, *descr_tail;
   unsigned HOST_WIDE_INT decl_size;
   rtx varloc;
@@ -13589,11 +13589,11 @@
 
   for (p = loc; p; p = XEXP (p, 1))
     {
-      unsigned int bitsize = decl_piece_bitsize (p);
+      unsigned HOST_WIDE_INT bitsize = decl_piece_bitsize (p);
       rtx loc_note = *decl_piece_varloc_ptr (p);
       dw_loc_descr_ref cur_descr;
       dw_loc_descr_ref *tail, last = NULL;
-      unsigned int opsize = 0;
+      unsigned HOST_WIDE_INT opsize = 0;
 
       if (loc_note == NULL_RTX
 	  || NOTE_VAR_LOCATION_LOC (loc_note) == NULL_RTX)
@@ -19196,6 +19196,9 @@
       case OPT__sysroot_:
       case OPT_nostdinc:
       case OPT_nostdinc__:
+      case OPT_fpreprocessed:
+      case OPT_fltrans_output_list_:
+      case OPT_fresolution_:
 	/* Ignore these.  */
 	continue;
       default:
@@ -23984,8 +23987,13 @@
   gen_remaining_tmpl_value_param_die_attribute ();
 
   /* Add the name for the main input file now.  We delayed this from
-     dwarf2out_init to avoid complications with PCH.  */
-  add_name_attribute (comp_unit_die (), remap_debug_filename (filename));
+     dwarf2out_init to avoid complications with PCH.
+     For LTO produced units use a fixed artificial name to avoid
+     leaking tempfile names into the dwarf.  */
+  if (!in_lto_p)
+    add_name_attribute (comp_unit_die (), remap_debug_filename (filename));
+  else
+    add_name_attribute (comp_unit_die (), "<artificial>");
   if (!IS_ABSOLUTE_PATH (filename) || targetm.force_at_comp_dir)
     add_comp_dir_attribute (comp_unit_die ());
   else if (get_AT (comp_unit_die (), DW_AT_comp_dir) == NULL)
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-4_9-branch)
@@ -6576,11 +6576,12 @@
 	  && mode != TYPE_MODE (TREE_TYPE (exp)))
 	temp = convert_modes (mode, TYPE_MODE (TREE_TYPE (exp)), temp, 1);
 
-      /* If the modes of TEMP and TARGET are both BLKmode, both
-	 must be in memory and BITPOS must be aligned on a byte
-	 boundary.  If so, we simply do a block copy.  Likewise
-	 for a BLKmode-like TARGET.  */
-      if (GET_MODE (temp) == BLKmode
+      /* If TEMP is not a PARALLEL (see below) and its mode and that of TARGET
+	 are both BLKmode, both must be in memory and BITPOS must be aligned
+	 on a byte boundary.  If so, we simply do a block copy.  Likewise for
+	 a BLKmode-like TARGET.  */
+      if (GET_CODE (temp) != PARALLEL
+	  && GET_MODE (temp) == BLKmode
 	  && (GET_MODE (target) == BLKmode
 	      || (MEM_P (target)
 		  && GET_MODE_CLASS (GET_MODE (target)) == MODE_INT
@@ -7630,11 +7631,13 @@
       break;
 
     case COMPOUND_LITERAL_EXPR:
-      /* Allow COMPOUND_LITERAL_EXPR in initializers, if e.g.
-	 rtl_for_decl_init is called on DECL_INITIAL with
-	 COMPOUNT_LITERAL_EXPRs in it, they aren't gimplified.  */
-      if (modifier == EXPAND_INITIALIZER
-	  && COMPOUND_LITERAL_EXPR_DECL (exp))
+      /* Allow COMPOUND_LITERAL_EXPR in initializers or coming from
+	 initializers, if e.g. rtl_for_decl_init is called on DECL_INITIAL
+	 with COMPOUND_LITERAL_EXPRs in it, or ARRAY_REF on a const static
+	 array with address of COMPOUND_LITERAL_EXPR in DECL_INITIAL;
+	 the initializers aren't gimplified.  */
+      if (COMPOUND_LITERAL_EXPR_DECL (exp)
+	  && TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (exp)))
 	return expand_expr_addr_expr_1 (COMPOUND_LITERAL_EXPR_DECL (exp),
 					target, tmode, modifier, as);
       /* FALLTHRU */
@@ -9990,7 +9993,7 @@
 	tree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,
 					&mode1, &unsignedp, &volatilep, true);
 	rtx orig_op0, memloc;
-	bool mem_attrs_from_type = false;
+	bool clear_mem_expr = false;
 
 	/* If we got back the original object, something is wrong.  Perhaps
 	   we are evaluating an expression too early.  In any event, don't
@@ -10086,7 +10089,7 @@
 	    memloc = assign_temp (TREE_TYPE (tem), 1, 1);
 	    emit_move_insn (memloc, op0);
 	    op0 = memloc;
-	    mem_attrs_from_type = true;
+	    clear_mem_expr = true;
 	  }
 
 	if (offset)
@@ -10271,17 +10274,17 @@
 	if (op0 == orig_op0)
 	  op0 = copy_rtx (op0);
 
-	/* If op0 is a temporary because of forcing to memory, pass only the
-	   type to set_mem_attributes so that the original expression is never
-	   marked as ADDRESSABLE through MEM_EXPR of the temporary.  */
-	if (mem_attrs_from_type)
-	  set_mem_attributes (op0, type, 0);
-	else
-	  set_mem_attributes (op0, exp, 0);
+	set_mem_attributes (op0, exp, 0);
 
 	if (REG_P (XEXP (op0, 0)))
 	  mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));
 
+	/* If op0 is a temporary because the original expressions was forced
+	   to memory, clear MEM_EXPR so that the original expression cannot
+	   be marked as addressable through MEM_EXPR of the temporary.  */
+	if (clear_mem_expr)
+	  set_mem_expr (op0, NULL_TREE);
+
 	MEM_VOLATILE_P (op0) |= volatilep;
 	if (mode == mode1 || mode1 == BLKmode || mode1 == tmode
 	    || modifier == EXPAND_CONST_ADDRESS
Index: gcc/dwarf2out.h
===================================================================
--- a/src/gcc/dwarf2out.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/dwarf2out.h	(.../branches/gcc-4_9-branch)
@@ -201,7 +201,7 @@
 /* Locations in memory are described using a sequence of stack machine
    operations.  */
 
-struct GTY(()) dw_loc_descr_node {
+struct GTY((chain_next ("%h.dw_loc_next"))) dw_loc_descr_node {
   dw_loc_descr_ref dw_loc_next;
   ENUM_BITFIELD (dwarf_location_atom) dw_loc_opc : 8;
   /* Used to distinguish DW_OP_addr with a direct symbol relocation
Index: gcc/go/gofrontend/gogo.cc
===================================================================
--- a/src/gcc/go/gofrontend/gogo.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/go/gofrontend/gogo.cc	(.../branches/gcc-4_9-branch)
@@ -338,22 +338,28 @@
   // Now that we know the name of the package we are compiling, set
   // the package path to use for reflect.Type.PkgPath and global
   // symbol names.
-  if (!this->pkgpath_set_)
+  if (this->pkgpath_set_)
+    this->pkgpath_symbol_ = Gogo::pkgpath_for_symbol(this->pkgpath_);
+  else
     {
       if (!this->prefix_from_option_ && package_name == "main")
-	this->pkgpath_ = package_name;
+	{
+	  this->pkgpath_ = package_name;
+	  this->pkgpath_symbol_ = Gogo::pkgpath_for_symbol(package_name);
+	}
       else
 	{
 	  if (!this->prefix_from_option_)
 	    this->prefix_ = "go";
 	  this->pkgpath_ = this->prefix_ + '.' + package_name;
+	  this->pkgpath_symbol_ = (Gogo::pkgpath_for_symbol(this->prefix_) + '.'
+				   + Gogo::pkgpath_for_symbol(package_name));
 	}
       this->pkgpath_set_ = true;
     }
 
-  this->pkgpath_symbol_ = Gogo::pkgpath_for_symbol(this->pkgpath_);
-
-  this->package_ = this->register_package(this->pkgpath_, location);
+  this->package_ = this->register_package(this->pkgpath_,
+					  this->pkgpath_symbol_, location);
   this->package_->set_package_name(package_name, location);
 
   if (this->is_main_package())
@@ -656,10 +662,11 @@
 			   const std::string& alias_arg,
 			   bool is_alias_exported,
 			   const std::string& pkgpath,
+			   const std::string& pkgpath_symbol,
 			   Location location,
 			   bool* padd_to_globals)
 {
-  Package* ret = this->register_package(pkgpath, location);
+  Package* ret = this->register_package(pkgpath, pkgpath_symbol, location);
   ret->set_package_name(real_name, location);
 
   *padd_to_globals = false;
@@ -688,10 +695,13 @@
 // Register a package.  This package may or may not be imported.  This
 // returns the Package structure for the package, creating if it
 // necessary.  LOCATION is the location of the import statement that
-// led us to see this package.
+// led us to see this package.  PKGPATH_SYMBOL is the symbol to use
+// for names in the package; it may be the empty string, in which case
+// we either get it later or make a guess when we need it.
 
 Package*
-Gogo::register_package(const std::string& pkgpath, Location location)
+Gogo::register_package(const std::string& pkgpath,
+		       const std::string& pkgpath_symbol, Location location)
 {
   Package* package = NULL;
   std::pair<Packages::iterator, bool> ins =
@@ -701,6 +711,8 @@
       // We have seen this package name before.
       package = ins.first->second;
       go_assert(package != NULL && package->pkgpath() == pkgpath);
+      if (!pkgpath_symbol.empty())
+	package->set_pkgpath_symbol(pkgpath_symbol);
       if (Linemap::is_unknown_location(package->location()))
 	package->set_location(location);
     }
@@ -707,7 +719,7 @@
   else
     {
       // First time we have seen this package name.
-      package = new Package(pkgpath, location);
+      package = new Package(pkgpath, pkgpath_symbol, location);
       go_assert(ins.first->second == NULL);
       ins.first->second = package;
     }
@@ -3424,10 +3436,24 @@
   // support streaming to a separate file.
   Stream_to_section stream;
 
+  // Write out either the prefix or pkgpath depending on how we were
+  // invoked.
+  std::string prefix;
+  std::string pkgpath;
+  if (this->pkgpath_from_option_)
+    pkgpath = this->pkgpath_;
+  else if (this->prefix_from_option_)
+    prefix = this->prefix_;
+  else if (this->is_main_package())
+    pkgpath = "main";
+  else
+    prefix = "go";
+
   Export exp(&stream);
   exp.register_builtin_types(this);
   exp.export_globals(this->package_name(),
-		     this->pkgpath(),
+		     prefix,
+		     pkgpath,
 		     this->package_priority(),
 		     this->imports_,
 		     (this->need_init_fn_ && !this->is_main_package()
@@ -6030,8 +6056,9 @@
 
 // Class Package.
 
-Package::Package(const std::string& pkgpath, Location location)
-  : pkgpath_(pkgpath), pkgpath_symbol_(Gogo::pkgpath_for_symbol(pkgpath)),
+Package::Package(const std::string& pkgpath,
+		 const std::string& pkgpath_symbol, Location location)
+  : pkgpath_(pkgpath), pkgpath_symbol_(pkgpath_symbol),
     package_name_(), bindings_(new Bindings(NULL)), priority_(0),
     location_(location), used_(false), is_imported_(false),
     uses_sink_alias_(false)
@@ -6055,6 +6082,34 @@
 	     package_name.c_str());
 }
 
+// Return the pkgpath symbol, which is a prefix for symbols defined in
+// this package.
+
+std::string
+Package::pkgpath_symbol() const
+{
+  if (this->pkgpath_symbol_.empty())
+    {
+      // In the general case, this is wrong, because the package might
+      // have been compiled with -fprefix.  However, it is what we
+      // used to do, so it is no more wrong than we were before.
+      return Gogo::pkgpath_for_symbol(this->pkgpath_);
+    }
+  return this->pkgpath_symbol_;
+}
+
+// Set the package path symbol.
+
+void
+Package::set_pkgpath_symbol(const std::string& pkgpath_symbol)
+{
+  go_assert(!pkgpath_symbol.empty());
+  if (this->pkgpath_symbol_.empty())
+    this->pkgpath_symbol_ = pkgpath_symbol;
+  else
+    go_assert(this->pkgpath_symbol_ == pkgpath_symbol);
+}
+
 // Set the priority.  We may see multiple priorities for an imported
 // package; we want to use the largest one.
 
Index: gcc/go/gofrontend/gogo.h
===================================================================
--- a/src/gcc/go/gofrontend/gogo.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/go/gofrontend/gogo.h	(.../branches/gcc-4_9-branch)
@@ -255,6 +255,7 @@
   add_imported_package(const std::string& real_name, const std::string& alias,
 		       bool is_alias_exported,
 		       const std::string& pkgpath,
+		       const std::string& pkgpath_symbol,
 		       Location location,
 		       bool* padd_to_globals);
 
@@ -262,7 +263,8 @@
   // This returns the Package structure for the package, creating if
   // it necessary.
   Package*
-  register_package(const std::string& pkgpath, Location);
+  register_package(const std::string& pkgpath,
+		   const std::string& pkgpath_symbol, Location);
 
   // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a
   // method function should be added to the type of its receiver.
@@ -2597,7 +2599,8 @@
 class Package
 {
  public:
-  Package(const std::string& pkgpath, Location location);
+  Package(const std::string& pkgpath, const std::string& pkgpath_symbol,
+	  Location location);
 
   // Get the package path used for all symbols exported from this
   // package.
@@ -2606,10 +2609,13 @@
   { return this->pkgpath_; }
 
   // Return the package path to use for a symbol name.
-  const std::string&
-  pkgpath_symbol() const
-  { return this->pkgpath_symbol_; }
+  std::string
+  pkgpath_symbol() const;
 
+  // Set the package path symbol.
+  void
+  set_pkgpath_symbol(const std::string&);
+
   // Return the location of the import statement.
   Location
   location() const
Index: gcc/go/gofrontend/export.cc
===================================================================
--- a/src/gcc/go/gofrontend/export.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/go/gofrontend/export.cc	(.../branches/gcc-4_9-branch)
@@ -91,6 +91,7 @@
 
 void
 Export::export_globals(const std::string& package_name,
+		       const std::string& prefix,
 		       const std::string& pkgpath,
 		       int package_priority,
 		       const std::map<std::string, Package*>& imports,
@@ -140,9 +141,18 @@
   this->write_string(package_name);
   this->write_c_string(";\n");
 
-  // The package path, used for all global symbols.
-  this->write_c_string("pkgpath ");
-  this->write_string(pkgpath);
+  // The prefix or package path, used for all global symbols.
+  if (prefix.empty())
+    {
+      go_assert(!pkgpath.empty());
+      this->write_c_string("pkgpath ");
+      this->write_string(pkgpath);
+    }
+  else
+    {
+      this->write_c_string("prefix ");
+      this->write_string(prefix);
+    }
   this->write_c_string(";\n");
 
   // The package priority.
Index: gcc/go/gofrontend/unsafe.cc
===================================================================
--- a/src/gcc/go/gofrontend/unsafe.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/go/gofrontend/unsafe.cc	(.../branches/gcc-4_9-branch)
@@ -22,7 +22,7 @@
   bool add_to_globals;
   Package* package = this->add_imported_package("unsafe", local_name,
 						is_local_name_exported,
-						"unsafe", location,
+						"unsafe", "unsafe", location,
 						&add_to_globals);
 
   if (package == NULL)
Index: gcc/go/gofrontend/export.h
===================================================================
--- a/src/gcc/go/gofrontend/export.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/go/gofrontend/export.h	(.../branches/gcc-4_9-branch)
@@ -117,8 +117,10 @@
   // Export the identifiers in BINDINGS which are marked for export.
   // The exporting is done via a series of calls to THIS->STREAM_.  If
   // is nothing to export, this->stream_->write will not be called.
-  // PKGPATH is the package path.
+  // PREFIX is the package prefix.  PKGPATH is the package path.
+  // Only one of PREFIX and PKGPATH will be non-empty.
   // PACKAGE_PRIORITY is the priority to use for this package.
+  // IMPORTS is the explicitly imported packages.
   // IMPORT_INIT_FN is the name of the import initialization function
   // for this package; it will be empty if none is needed.
   // IMPORTED_INIT_FNS is the list of initialization functions for
@@ -125,6 +127,7 @@
   // imported packages.
   void
   export_globals(const std::string& package_name,
+		 const std::string& prefix,
 		 const std::string& pkgpath,
 		 int package_priority,
 		 const std::map<std::string, Package*>& imports,
Index: gcc/go/gofrontend/import.cc
===================================================================
--- a/src/gcc/go/gofrontend/import.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/go/gofrontend/import.cc	(.../branches/gcc-4_9-branch)
@@ -301,6 +301,7 @@
       this->require_c_string(";\n");
 
       std::string pkgpath;
+      std::string pkgpath_symbol;
       if (this->match_c_string("prefix "))
 	{
 	  this->advance(7);
@@ -307,6 +308,8 @@
 	  std::string unique_prefix = this->read_identifier();
 	  this->require_c_string(";\n");
 	  pkgpath = unique_prefix + '.' + package_name;
+	  pkgpath_symbol = (Gogo::pkgpath_for_symbol(unique_prefix) + '.'
+			    + Gogo::pkgpath_for_symbol(package_name));
 	}
       else
 	{
@@ -313,11 +316,12 @@
 	  this->require_c_string("pkgpath ");
 	  pkgpath = this->read_identifier();
 	  this->require_c_string(";\n");
+	  pkgpath_symbol = Gogo::pkgpath_for_symbol(pkgpath);
 	}
 
       this->package_ = gogo->add_imported_package(package_name, local_name,
 						  is_local_name_exported,
-						  pkgpath,
+						  pkgpath, pkgpath_symbol,
 						  this->location_,
 						  &this->add_to_globals_);
       if (this->package_ == NULL)
@@ -392,7 +396,7 @@
     stream->advance(1);
   this->require_c_string("\";\n");
 
-  Package* p = this->gogo_->register_package(pkgpath,
+  Package* p = this->gogo_->register_package(pkgpath, "",
 					     Linemap::unknown_location());
   p->set_package_name(package_name, this->location());
 }
@@ -649,7 +653,7 @@
     package = this->package_;
   else
     {
-      package = this->gogo_->register_package(pkgpath,
+      package = this->gogo_->register_package(pkgpath, "",
 					      Linemap::unknown_location());
       if (!package_name.empty())
 	package->set_package_name(package_name, this->location());
Index: gcc/go/gofrontend/import-archive.cc
===================================================================
--- a/src/gcc/go/gofrontend/import-archive.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/go/gofrontend/import-archive.cc	(.../branches/gcc-4_9-branch)
@@ -295,6 +295,15 @@
       // This is the symbol table.
       pname->clear();
     }
+  else if (hdr->ar_name[1] == 'S' && hdr->ar_name[2] == 'Y'
+          && hdr->ar_name[3] == 'M' && hdr->ar_name[4] == '6'
+          && hdr->ar_name[5] == '4' && hdr->ar_name[6] == '/'
+          && hdr->ar_name[7] == ' '
+         )
+    {
+      // 64-bit symbol table.
+      pname->clear();
+    }
   else if (hdr->ar_name[1] == '/')
     {
       // This is the extended name table.
Index: gcc/recog.c
===================================================================
--- a/src/gcc/recog.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/recog.c	(.../branches/gcc-4_9-branch)
@@ -2627,9 +2627,14 @@
 		      break;
 		    win = 1;
 		  }
-		/* Before reload, accept what reload can turn into mem.  */
+		/* Before reload, accept what reload can turn into a mem.  */
 		else if (strict < 0 && CONSTANT_P (op))
 		  win = 1;
+		/* Before reload, accept a pseudo,
+		   since LRA can turn it into a mem.  */
+		else if (strict < 0 && targetm.lra_p () && REG_P (op)
+			 && REGNO (op) >= FIRST_PSEUDO_REGISTER)
+		  win = 1;
 		/* During reload, accept a pseudo  */
 		else if (reload_in_progress && REG_P (op)
 			 && REGNO (op) >= FIRST_PSEUDO_REGISTER)
@@ -2708,6 +2713,10 @@
 		    /* Before reload, accept what reload can handle.  */
 		    || (strict < 0
 			&& (CONSTANT_P (op) || MEM_P (op)))
+		    /* Before reload, accept a pseudo,
+		       since LRA can turn it into a mem.  */
+		    || (strict < 0 && targetm.lra_p () && REG_P (op)
+			&& REGNO (op) >= FIRST_PSEUDO_REGISTER)
 		    /* During reload, accept a pseudo  */
 		    || (reload_in_progress && REG_P (op)
 			&& REGNO (op) >= FIRST_PSEUDO_REGISTER))
@@ -2739,8 +2748,12 @@
 			   /* Every memory operand can be reloaded to fit.  */
 			   && ((strict < 0 && MEM_P (op))
 			       /* Before reload, accept what reload can turn
-				  into mem.  */
+				  into a mem.  */
 			       || (strict < 0 && CONSTANT_P (op))
+			       /* Before reload, accept a pseudo,
+				  since LRA can turn it into a mem.  */
+			       || (strict < 0 && targetm.lra_p () && REG_P (op)
+				   && REGNO (op) >= FIRST_PSEUDO_REGISTER)
 			       /* During reload, accept a pseudo  */
 			       || (reload_in_progress && REG_P (op)
 				   && REGNO (op) >= FIRST_PSEUDO_REGISTER)))
Index: gcc/ada/mlib-utl.adb
===================================================================
--- a/src/gcc/ada/mlib-utl.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/mlib-utl.adb	(.../branches/gcc-4_9-branch)
@@ -282,6 +282,10 @@
          if not Opt.Quiet_Output then
             Write_Str  (Ranlib_Name.all);
             Write_Char (' ');
+            for J in Ranlib_Options'Range loop
+               Write_Str  (Ranlib_Options (J).all);
+               Write_Char (' ');
+            end loop;
             Write_Line (Arguments (Ar_Options'Length + 1).all);
          end if;
 
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,42 @@
+2015-03-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils2.c (gnat_invariant_expr): Return null if the type
+	of the expression ends up being composite.
+
+2015-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (is_cplusplus_method): Use Is_Primitive flag to
+	detect primitive operations of tagged and untagged types.
+
+2015-01-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/64492
+	* gcc-interface/Makefile.in (../stamp-tools): Reinstate dropped code.
+
+2014-11-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (push_range_check_info): Replace early test
+	with assertion.
+	(Raise_Error_to_gnu): Do not call push_range_check_info if the loop
+	stack is empty.
+	* gcc-interface/utils.c (convert_to_fat_pointer): Fix formatting.
+	* gcc-interface/utils2.c (gnat_invariant_expr): Deal with padded types
+	and revert latest change.
+
+2014-11-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2014-11-20  Vincent Celier  <celier@adacore.com>
+
+	PR ada/47500
+	* back_end.adb (Scan_Back_End_Switches): Skip switch -G and
+	its argument.
+
+2014-11-11  Simon Wright  <simon@pushface.org>
+
+	PR ada/42978
+	* mlib-utl.adb (ar): Output the options passed to ranlib.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/ada/back_end.adb
===================================================================
--- a/src/gcc/ada/back_end.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/back_end.adb	(.../branches/gcc-4_9-branch)
@@ -210,9 +210,10 @@
          Last  : constant Natural  := Switch_Last (Switch_Chars);
 
       begin
-         --  Skip -o or internal GCC switches together with their argument
+         --  Skip -o, -G or internal GCC switches together with their argument.
 
          if Switch_Chars (First .. Last) = "o"
+           or else Switch_Chars (First .. Last) = "G"
            or else Is_Internal_GCC_Switch (Switch_Chars)
          then
             Next_Arg := Next_Arg + 1;
Index: gcc/ada/gcc-interface/utils.c
===================================================================
--- a/src/gcc/ada/gcc-interface/utils.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/utils.c	(.../branches/gcc-4_9-branch)
@@ -4371,8 +4371,7 @@
 	{
 	  /* The template type can still be dummy at this point so we build an
 	     empty constructor.  The middle-end will fill it in with zeros.  */
-	  t = build_constructor (template_type,
-				 NULL);
+	  t = build_constructor (template_type, NULL);
 	  TREE_CONSTANT (t) = TREE_STATIC (t) = 1;
 	  null_bounds = build_unary_op (ADDR_EXPR, NULL_TREE, t);
 	  SET_TYPE_NULL_BOUNDS (ptr_template_type, null_bounds);
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- a/src/gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -2510,9 +2510,16 @@
 # Build directory for the tools. Let's copy the target-dependent
 # sources using the same mechanism as for gnatlib. The other sources are
 # accessed using the vpath directive below
-# Note: dummy target, stamp-tools is mainly handled by gnattools.
 
 ../stamp-tools:
+	-$(RM) tools/*
+	-$(RMDIR) tools
+	-$(MKDIR) tools
+	-(cd tools; $(LN_S) ../sdefault.adb ../snames.ads ../snames.adb .)
+	-$(foreach PAIR,$(TOOLS_TARGET_PAIRS), \
+	          $(RM) tools/$(word 1,$(subst <, ,$(PAIR)));\
+	          $(LN_S) $(fsrcpfx)ada/$(word 2,$(subst <, ,$(PAIR))) \
+	                tools/$(word 1,$(subst <, ,$(PAIR)));)
 	touch ../stamp-tools
 
 # when compiling the tools, the runtime has to be first on the path so that
Index: gcc/ada/gcc-interface/decl.c
===================================================================
--- a/src/gcc/ada/gcc-interface/decl.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/decl.c	(.../branches/gcc-4_9-branch)
@@ -5510,8 +5510,10 @@
   if (Convention (gnat_entity) != Convention_CPP)
     return false;
 
-  /* This is the main case: C++ method imported as a primitive operation.  */
-  if (Is_Dispatching_Operation (gnat_entity))
+  /* This is the main case: C++ method imported as a primitive operation.
+     Note that a C++ class with no virtual functions can be imported as a
+     limited record type so the operation is not necessarily dispatching.  */
+  if (Is_Primitive (gnat_entity))
     return true;
 
   /* A thunk needs to be handled like its associated primitive operation.  */
@@ -5518,8 +5520,7 @@
   if (Is_Subprogram (gnat_entity) && Is_Thunk (gnat_entity))
     return true;
 
-  /* C++ classes with no virtual functions can be imported as limited
-     record types, but we need to return true for the constructors.  */
+  /* A constructor is a method on the C++ side.  */
   if (Is_Constructor (gnat_entity))
     return true;
 
Index: gcc/ada/gcc-interface/utils2.c
===================================================================
--- a/src/gcc/ada/gcc-interface/utils2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/utils2.c	(.../branches/gcc-4_9-branch)
@@ -2784,8 +2784,20 @@
 	  || (TREE_CODE (expr) == VAR_DECL && TREE_READONLY (expr)))
 	 && decl_function_context (expr) == current_function_decl
 	 && DECL_INITIAL (expr))
-    expr = remove_conversions (DECL_INITIAL (expr), false);
+    {
+      expr = DECL_INITIAL (expr);
+      /* Look into CONSTRUCTORs built to initialize padded types.  */
+      if (TYPE_IS_PADDING_P (TREE_TYPE (expr)))
+	expr = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (expr))), expr);
+      expr = remove_conversions (expr, false);
+    }
 
+  /* We are only interested in scalar types at the moment and, even if we may
+     have gone through padding types in the above loop, we must be back to a
+     scalar value at this point.  */
+  if (AGGREGATE_TYPE_P (TREE_TYPE (expr)))
+    return NULL_TREE;
+
   if (TREE_CONSTANT (expr))
     return fold_convert (type, expr);
 
@@ -2840,7 +2852,7 @@
   if (!TREE_READONLY (t))
     return NULL_TREE;
 
-  if (TREE_CODE (t) == CONSTRUCTOR || TREE_CODE (t) == PARM_DECL)
+  if (TREE_CODE (t) == PARM_DECL)
     return fold_convert (type, expr);
 
   if (TREE_CODE (t) == VAR_DECL
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- a/src/gcc/ada/gcc-interface/trans.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/trans.c	(.../branches/gcc-4_9-branch)
@@ -2424,9 +2424,6 @@
   struct loop_info_d *iter = NULL;
   unsigned int i;
 
-  if (vec_safe_is_empty (gnu_loop_stack))
-    return NULL;
-
   var = remove_conversions (var, false);
 
   if (TREE_CODE (var) != VAR_DECL)
@@ -2435,6 +2432,8 @@
   if (decl_function_context (var) != current_function_decl)
     return NULL;
 
+  gcc_assert (vec_safe_length (gnu_loop_stack) > 0);
+
   for (i = vec_safe_length (gnu_loop_stack) - 1;
        vec_safe_iterate (gnu_loop_stack, i, &iter);
        i--)
@@ -5165,6 +5164,7 @@
 	     the original checks reinstated, and a run time selection.
 	     The former loop will be suitable for vectorization.  */
 	  if (flag_unswitch_loops
+	      && !vec_safe_is_empty (gnu_loop_stack)
 	      && (!gnu_low_bound
 		  || (gnu_low_bound = gnat_invariant_expr (gnu_low_bound)))
 	      && (!gnu_high_bound
Index: gcc/tsan.c
===================================================================
--- a/src/gcc/tsan.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tsan.c	(.../branches/gcc-4_9-branch)
@@ -651,25 +651,24 @@
 static void
 instrument_func_entry (void)
 {
-  basic_block succ_bb;
-  gimple_stmt_iterator gsi;
   tree ret_addr, builtin_decl;
   gimple g;
+  gimple_seq seq = NULL;
 
-  succ_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));
-  gsi = gsi_after_labels (succ_bb);
-
   builtin_decl = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);
   g = gimple_build_call (builtin_decl, 1, integer_zero_node);
   ret_addr = make_ssa_name (ptr_type_node, NULL);
   gimple_call_set_lhs (g, ret_addr);
   gimple_set_location (g, cfun->function_start_locus);
-  gsi_insert_before (&gsi, g, GSI_SAME_STMT);
+  gimple_seq_add_stmt_without_update (&seq, g);
 
-  builtin_decl =  builtin_decl_implicit (BUILT_IN_TSAN_FUNC_ENTRY);
+  builtin_decl = builtin_decl_implicit (BUILT_IN_TSAN_FUNC_ENTRY);
   g = gimple_build_call (builtin_decl, 1, ret_addr);
   gimple_set_location (g, cfun->function_start_locus);
-  gsi_insert_before (&gsi, g, GSI_SAME_STMT);
+  gimple_seq_add_stmt_without_update (&seq, g);
+
+  edge e = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));
+  gsi_insert_seq_on_edge_immediate (e, seq);
 }
 
 /* Instruments function exits.  */
Index: gcc/dse.c
===================================================================
--- a/src/gcc/dse.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/dse.c	(.../branches/gcc-4_9-branch)
@@ -1549,6 +1549,10 @@
 	    = rtx_group_vec[group_id];
 	  mem_addr = group->canon_base_addr;
 	}
+      /* get_addr can only handle VALUE but cannot handle expr like:
+	 VALUE + OFFSET, so call get_addr to get original addr for
+	 mem_addr before plus_constant.  */
+      mem_addr = get_addr (mem_addr);
       if (offset)
 	mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);
     }
@@ -2166,6 +2170,10 @@
 	    = rtx_group_vec[group_id];
 	  mem_addr = group->canon_base_addr;
 	}
+      /* get_addr can only handle VALUE but cannot handle expr like:
+	 VALUE + OFFSET, so call get_addr to get original addr for
+	 mem_addr before plus_constant.  */
+      mem_addr = get_addr (mem_addr);
       if (offset)
 	mem_addr = plus_constant (get_address_mode (mem), mem_addr, offset);
     }
Index: gcc/fortran/interface.c
===================================================================
--- a/src/gcc/fortran/interface.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/interface.c	(.../branches/gcc-4_9-branch)
@@ -1204,8 +1204,15 @@
 	  return false;
 	}
 
+      if (s1->as->corank != s2->as->corank)
+	{
+	  snprintf (errmsg, err_len, "Corank mismatch in argument '%s' (%i/%i)",
+		    s1->name, s1->as->corank, s2->as->corank);
+	  return false;
+	}
+
       if (s1->as->type == AS_EXPLICIT)
-	for (i = 0; i < s1->as->rank + s1->as->corank; i++)
+	for (i = 0; i < s1->as->rank + MAX (0, s1->as->corank-1); i++)
 	  {
 	    shape1 = gfc_subtract (gfc_copy_expr (s1->as->upper[i]),
 				  gfc_copy_expr (s1->as->lower[i]));
@@ -1219,8 +1226,12 @@
 	      case -1:
 	      case  1:
 	      case -3:
-		snprintf (errmsg, err_len, "Shape mismatch in dimension %i of "
-			  "argument '%s'", i + 1, s1->name);
+		if (i < s1->as->rank)
+		  snprintf (errmsg, err_len, "Shape mismatch in dimension %i of"
+			    " argument '%s'", i + 1, s1->name);
+		else
+		  snprintf (errmsg, err_len, "Shape mismatch in codimension %i "
+			    "of argument '%s'", i - s1->as->rank + 1, s1->name);
 		return false;
 
 	      case -2:
@@ -3675,6 +3686,8 @@
   gfc_user_op *uop;
   gfc_intrinsic_op i;
   const char *gname;
+  gfc_typebound_proc* tbo;
+  gfc_expr* tb_base;
 
   sym = NULL;
 
@@ -3691,8 +3704,50 @@
 
   i = fold_unary_intrinsic (e->value.op.op);
 
+  /* See if we find a matching type-bound operator.  */
   if (i == INTRINSIC_USER)
+    tbo = matching_typebound_op (&tb_base, actual,
+				  i, e->value.op.uop->name, &gname);
+  else
+    switch (i)
+      {
+#define CHECK_OS_COMPARISON(comp) \
+  case INTRINSIC_##comp: \
+  case INTRINSIC_##comp##_OS: \
+    tbo = matching_typebound_op (&tb_base, actual, \
+				 INTRINSIC_##comp, NULL, &gname); \
+    if (!tbo) \
+      tbo = matching_typebound_op (&tb_base, actual, \
+				   INTRINSIC_##comp##_OS, NULL, &gname); \
+    break;
+	CHECK_OS_COMPARISON(EQ)
+	CHECK_OS_COMPARISON(NE)
+	CHECK_OS_COMPARISON(GT)
+	CHECK_OS_COMPARISON(GE)
+	CHECK_OS_COMPARISON(LT)
+	CHECK_OS_COMPARISON(LE)
+#undef CHECK_OS_COMPARISON
+
+	default:
+	  tbo = matching_typebound_op (&tb_base, actual, i, NULL, &gname);
+	  break;
+      }
+
+  /* If there is a matching typebound-operator, replace the expression with
+      a call to it and succeed.  */
+  if (tbo)
     {
+      gcc_assert (tb_base);
+      build_compcall_for_operator (e, actual, tb_base, tbo, gname);
+
+      if (!gfc_resolve_expr (e))
+	return MATCH_ERROR;
+      else
+	return MATCH_YES;
+    }
+ 
+  if (i == INTRINSIC_USER)
+    {
       for (ns = gfc_current_ns; ns; ns = ns->parent)
 	{
 	  uop = gfc_find_uop (e->value.op.uop->name, ns);
@@ -3741,58 +3796,9 @@
 
   if (sym == NULL)
     {
-      gfc_typebound_proc* tbo;
-      gfc_expr* tb_base;
-
-      /* See if we find a matching type-bound operator.  */
-      if (i == INTRINSIC_USER)
-	tbo = matching_typebound_op (&tb_base, actual,
-				     i, e->value.op.uop->name, &gname);
-      else
-	switch (i)
-	  {
-#define CHECK_OS_COMPARISON(comp) \
-  case INTRINSIC_##comp: \
-  case INTRINSIC_##comp##_OS: \
-    tbo = matching_typebound_op (&tb_base, actual, \
-				 INTRINSIC_##comp, NULL, &gname); \
-    if (!tbo) \
-      tbo = matching_typebound_op (&tb_base, actual, \
-				   INTRINSIC_##comp##_OS, NULL, &gname); \
-    break;
-	    CHECK_OS_COMPARISON(EQ)
-	    CHECK_OS_COMPARISON(NE)
-	    CHECK_OS_COMPARISON(GT)
-	    CHECK_OS_COMPARISON(GE)
-	    CHECK_OS_COMPARISON(LT)
-	    CHECK_OS_COMPARISON(LE)
-#undef CHECK_OS_COMPARISON
-
-	    default:
-	      tbo = matching_typebound_op (&tb_base, actual, i, NULL, &gname);
-	      break;
-	  }
-
-      /* If there is a matching typebound-operator, replace the expression with
-	 a call to it and succeed.  */
-      if (tbo)
-	{
-	  bool result;
-
-	  gcc_assert (tb_base);
-	  build_compcall_for_operator (e, actual, tb_base, tbo, gname);
-
-	  result = gfc_resolve_expr (e);
-	  if (!result)
-	    return MATCH_ERROR;
-
-	  return MATCH_YES;
-	}
-
       /* Don't use gfc_free_actual_arglist().  */
       free (actual->next);
       free (actual);
-
       return MATCH_NO;
     }
 
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-4_9-branch)
@@ -92,6 +92,7 @@
    in future implementations.  Use the corresponding APIs.  */
 #define CLASS_DATA_FIELD 0
 #define CLASS_VPTR_FIELD 1
+#define CLASS_LEN_FIELD 2
 #define VTABLE_HASH_FIELD 0
 #define VTABLE_SIZE_FIELD 1
 #define VTABLE_EXTENDS_FIELD 2
@@ -146,6 +147,20 @@
 }
 
 
+tree
+gfc_class_len_get (tree decl)
+{
+  tree len;
+  if (POINTER_TYPE_P (TREE_TYPE (decl)))
+    decl = build_fold_indirect_ref_loc (input_location, decl);
+  len = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),
+			    CLASS_LEN_FIELD);
+  return fold_build3_loc (input_location, COMPONENT_REF,
+			  TREE_TYPE (len), decl, len,
+			  NULL_TREE);
+}
+
+
 static tree
 gfc_vtable_field_get (tree decl, int field)
 {
@@ -599,6 +614,45 @@
 	}
     }
 
+  /* When the actual arg is a char array, then set the _len component of the
+     unlimited polymorphic entity, too.  */
+  if (e->ts.type == BT_CHARACTER)
+    {
+      ctree = gfc_class_len_get (var);
+      /* Start with parmse->string_length because this seems to be set to a
+	 correct value more often.  */
+      if (parmse->string_length)
+	  gfc_add_modify (&parmse->pre, ctree, parmse->string_length);
+      /* When the string_length is not yet set, then try the backend_decl of
+	 the cl.  */
+      else if (e->ts.u.cl->backend_decl)
+          gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);
+      /* If both of the above approaches fail, then try to generate an
+	 expression from the input, which is only feasible currently, when the
+	 expression can be evaluated to a constant one.  */
+      else
+	{
+	  /* Try to simplify the expression.  */
+	  gfc_simplify_expr (e, 0);
+	  if (e->expr_type == EXPR_CONSTANT && !e->ts.u.cl->resolved)
+	    {
+	      /* Amazingly all data is present to compute the length of a
+		 constant string, but the expression is not yet there.  */
+	      e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 4,
+							  &e->where);
+	      mpz_set_ui (e->ts.u.cl->length->value.integer,
+			  e->value.character.length);
+	      gfc_conv_const_charlen (e->ts.u.cl);
+	      e->ts.u.cl->resolved = 1;
+	      gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);
+	    }
+	  else
+	    {
+	      gfc_error ("Can't compute the length of the char array at %L.",
+			 &e->where);
+	    }
+	}
+    }
   /* Pass the address of the class object.  */
   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);
 }
@@ -1657,10 +1711,12 @@
 
   c = ref->u.c.component;
 
-  gcc_assert (c->backend_decl);
+  if (c->backend_decl == NULL_TREE
+      && ref->u.c.sym != NULL)
+    gfc_get_derived_type (ref->u.c.sym);
 
   field = c->backend_decl;
-  gcc_assert (TREE_CODE (field) == FIELD_DECL);
+  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);
   decl = se->expr;
 
   /* Components can correspond to fields of different containing
@@ -6191,7 +6247,7 @@
 	 of EXPR_NULL,... by default, the static nullify is not needed
 	 since this is done every time we come into scope.  */
       if (!c->expr || (cm->attr.allocatable && cm->attr.flavor != FL_PROCEDURE))
-        continue;
+	continue;
 
       if (cm->initializer && cm->initializer->expr_type != EXPR_NULL
 	  && strcmp (cm->name, "_extends") == 0
@@ -6209,6 +6265,10 @@
 	  val = TYPE_SIZE_UNIT (gfc_get_derived_type (cm->ts.u.derived));
 	  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
 	}
+      else if (cm->ts.type == BT_INTEGER && strcmp (cm->name, "_len") == 0)
+	CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl,
+				fold_convert (TREE_TYPE (cm->backend_decl),
+					      integer_zero_node));
       else
 	{
 	  val = gfc_conv_initializer (c->expr, &cm->ts,
@@ -6285,7 +6345,8 @@
      null_pointer_node.  C_PTR and C_FUNPTR are converted to match the
      typespec for the C_PTR and C_FUNPTR symbols, which has already been
      updated to be an integer with a kind equal to the size of a (void *).  */
-  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->ts.f90_type == BT_VOID)
+  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->ts.f90_type == BT_VOID
+      && expr->ts.u.derived->attr.is_bind_c)
     {
       if (expr->expr_type == EXPR_VARIABLE
 	  && (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR
@@ -6550,6 +6611,27 @@
 	rse.expr = build_fold_indirect_ref_loc (input_location,
 					    rse.expr);
 
+      /* For string assignments to unlimited polymorphic pointers add an
+	 assignment of the string_length to the _len component of the
+	 pointer.  */
+      if ((expr1->ts.type == BT_CLASS || expr1->ts.type == BT_DERIVED)
+	  && expr1->ts.u.derived->attr.unlimited_polymorphic
+	  && (expr2->ts.type == BT_CHARACTER ||
+	      ((expr2->ts.type == BT_DERIVED || expr2->ts.type == BT_CLASS)
+	       && expr2->ts.u.derived->attr.unlimited_polymorphic)))
+	{
+	  gfc_expr *len_comp;
+	  gfc_se se;
+	  len_comp = gfc_get_len_component (expr1);
+	  gfc_init_se (&se, NULL);
+	  gfc_conv_expr (&se, len_comp);
+
+	  /* ptr % _len = len (str)  */
+	  gfc_add_modify (&block, se.expr, rse.string_length);
+	  lse.string_length = se.expr;
+	  gfc_free_expr (len_comp);
+	}
+
       gfc_add_block_to_block (&block, &lse.pre);
       gfc_add_block_to_block (&block, &rse.pre);
 
@@ -6661,6 +6743,7 @@
 					       bound, bound, 0,
 					       GFC_ARRAY_POINTER_CONT, false);
 	      tmp = gfc_create_var (tmp, "ptrtemp");
+	      lse.descriptor_only = 0;
 	      lse.expr = tmp;
 	      lse.direct_byref = 1;
 	      gfc_conv_expr_descriptor (&lse, expr2);
@@ -6676,6 +6759,7 @@
       else if (expr2->expr_type == EXPR_VARIABLE)
 	{
 	  /* Assign directly to the LHS's descriptor.  */
+	  lse.descriptor_only = 0;
 	  lse.direct_byref = 1;
 	  gfc_conv_expr_descriptor (&lse, expr2);
 	  strlen_rhs = lse.string_length;
@@ -6726,6 +6810,7 @@
 	  /* Assign to a temporary descriptor and then copy that
 	     temporary to the pointer.  */
 	  tmp = gfc_create_var (TREE_TYPE (desc), "ptrtemp");
+	  lse.descriptor_only = 0;
 	  lse.expr = tmp;
 	  lse.direct_byref = 1;
 	  gfc_conv_expr_descriptor (&lse, expr2);
Index: gcc/fortran/trans-array.c
===================================================================
--- a/src/gcc/fortran/trans-array.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans-array.c	(.../branches/gcc-4_9-branch)
@@ -4350,6 +4350,13 @@
 	      && ss_expr->rank)
 	    nDepend = gfc_check_dependency (dest_expr, ss_expr, true);
 
+	  /* Check for cases like   c(:)(1:2) = c(2)(2:3)  */
+	  if (!nDepend && dest_expr->rank > 0
+	      && dest_expr->ts.type == BT_CHARACTER
+	      && ss_expr->expr_type == EXPR_VARIABLE)
+	    
+	    nDepend = gfc_check_dependency (dest_expr, ss_expr, false);
+
 	  continue;
 	}
 
Index: gcc/fortran/class.c
===================================================================
--- a/src/gcc/fortran/class.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/class.c	(.../branches/gcc-4_9-branch)
@@ -34,6 +34,12 @@
              (pointer/allocatable/dimension/...).
     * _vptr: A pointer to the vtable entry (see below) of the dynamic type.
 
+    Only for unlimited polymorphic classes:
+    * _len:  An integer(4) to store the string length when the unlimited
+             polymorphic pointer is used to point to a char array.  The '_len'
+             component will be zero when no character array is stored in
+             '_data'.
+
    For each derived type we set up a "vtable" entry, i.e. a structure with the
    following fields:
     * _hash:     A hash value serving as a unique identifier for this type.
@@ -544,10 +550,48 @@
 }
 
 
+/* Get the _len component from a class/derived object storing a string.
+   For unlimited polymorphic entities a ref to the _data component is available
+   while a ref to the _len component is needed.  This routine traverses the
+   ref-chain and strips the last ref to a _data from it replacing it with a
+   ref to the _len component.  */
+
+gfc_expr *
+gfc_get_len_component (gfc_expr *e)
+{
+  gfc_expr *ptr;
+  gfc_ref *ref, **last;
+
+  ptr = gfc_copy_expr (e);
+
+  /* We need to remove the last _data component ref from ptr.  */
+  last = &(ptr->ref);
+  ref = ptr->ref;
+  while (ref)
+    {
+      if (!ref->next
+	  && ref->type == REF_COMPONENT
+	  && strcmp ("_data", ref->u.c.component->name)== 0)
+	{
+	  gfc_free_ref_list (ref);
+	  *last = NULL;
+	  break;
+	}
+      last = &(ref->next);
+      ref = ref->next;
+    }
+  /* And replace if with a ref to the _len component.  */
+  gfc_add_component_ref (ptr, "_len");
+  return ptr;
+}
+
+
 /* Build a polymorphic CLASS entity, using the symbol that comes from
    build_sym. A CLASS entity is represented by an encapsulating type,
    which contains the declared type as '_data' component, plus a pointer
-   component '_vptr' which determines the dynamic type.  */
+   component '_vptr' which determines the dynamic type.  When this CLASS
+   entity is unlimited polymorphic, then also add a component '_len' to
+   store the length of string when that is stored in it.  */
 
 bool
 gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
@@ -645,6 +689,8 @@
       if (!gfc_add_component (fclass, "_vptr", &c))
 	return false;
       c->ts.type = BT_DERIVED;
+      c->attr.access = ACCESS_PRIVATE;
+      c->attr.pointer = 1;
 
       if (ts->u.derived->attr.unlimited_polymorphic)
 	{
@@ -651,13 +697,20 @@
 	  vtab = gfc_find_derived_vtab (ts->u.derived);
 	  gcc_assert (vtab);
 	  c->ts.u.derived = vtab->ts.u.derived;
+
+	  /* Add component '_len'.  Only unlimited polymorphic pointers may
+             have a string assigned to them, i.e., only those need the _len
+             component.  */
+	  if (!gfc_add_component (fclass, "_len", &c))
+	    return false;
+	  c->ts.type = BT_INTEGER;
+	  c->ts.kind = 4;
+	  c->attr.access = ACCESS_PRIVATE;
+	  c->attr.artificial = 1;
 	}
       else
 	/* Build vtab later.  */
 	c->ts.u.derived = NULL;
-
-      c->attr.access = ACCESS_PRIVATE;
-      c->attr.pointer = 1;
     }
 
   if (!ts->u.derived->attr.unlimited_polymorphic)
@@ -828,7 +881,8 @@
 
 static void
 finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,
-		    gfc_symbol *stat, gfc_symbol *fini_coarray, gfc_code **code)
+		    gfc_symbol *stat, gfc_symbol *fini_coarray, gfc_code **code,
+		    gfc_namespace *sub_ns)
 {
   gfc_expr *e;
   gfc_ref *ref;
@@ -875,7 +929,7 @@
       /* Add IF (fini_coarray).  */
       if (comp->attr.codimension
 	  || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)
-	      && CLASS_DATA (comp)->attr.allocatable))
+	      && CLASS_DATA (comp)->attr.codimension))
 	{
 	  block = gfc_get_code (EXEC_IF);
 	  if (*code)
@@ -897,15 +951,32 @@
       dealloc->ext.alloc.list->expr = e;
       dealloc->expr1 = gfc_lval_expr_from_sym (stat);
 
+      gfc_code *cond = gfc_get_code (EXEC_IF);
+      cond->block = gfc_get_code (EXEC_IF);
+      cond->block->expr1 = gfc_get_expr ();
+      cond->block->expr1->expr_type = EXPR_FUNCTION;
+      gfc_get_sym_tree ("associated", sub_ns, &cond->block->expr1->symtree, false);
+      cond->block->expr1->symtree->n.sym->attr.flavor = FL_PROCEDURE;
+      cond->block->expr1->symtree->n.sym->attr.intrinsic = 1;
+      cond->block->expr1->symtree->n.sym->result = cond->block->expr1->symtree->n.sym;
+      gfc_commit_symbol (cond->block->expr1->symtree->n.sym);
+      cond->block->expr1->ts.type = BT_LOGICAL;
+      cond->block->expr1->ts.kind = gfc_default_logical_kind;
+      cond->block->expr1->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_ASSOCIATED);
+      cond->block->expr1->value.function.actual = gfc_get_actual_arglist ();
+      cond->block->expr1->value.function.actual->expr = gfc_copy_expr (expr);
+      cond->block->expr1->value.function.actual->next = gfc_get_actual_arglist ();
+      cond->block->next = dealloc;
+
       if (block)
-	block->next = dealloc;
+	block->next = cond;
       else if (*code)
 	{
-	  (*code)->next = dealloc;
+	  (*code)->next = cond;
 	  (*code) = (*code)->next;
 	}
       else
-	(*code) = dealloc;
+	(*code) = cond;
     }
   else if (comp->ts.type == BT_DERIVED
 	    && comp->ts.u.derived->f2k_derived
@@ -941,7 +1012,8 @@
       gfc_component *c;
 
       for (c = comp->ts.u.derived->components; c; c = c->next)
-	finalize_component (e, comp->ts.u.derived, c, stat, fini_coarray, code);
+	finalize_component (e, comp->ts.u.derived, c, stat, fini_coarray, code,
+			    sub_ns);
       gfc_free_expr (e);
     }
 }
@@ -1874,7 +1946,7 @@
     {
       gfc_finalizer *fini, *fini_elem = NULL;
 
-      gfc_get_symbol ("ptr", sub_ns, &ptr);
+      gfc_get_symbol ("ptr1", sub_ns, &ptr);
       ptr->ts.type = BT_DERIVED;
       ptr->ts.u.derived = derived;
       ptr->attr.flavor = FL_VARIABLE;
@@ -1998,7 +2070,7 @@
 
       if (!ptr)
 	{
-	  gfc_get_symbol ("ptr", sub_ns, &ptr);
+	  gfc_get_symbol ("ptr2", sub_ns, &ptr);
 	  ptr->ts.type = BT_DERIVED;
 	  ptr->ts.u.derived = derived;
 	  ptr->attr.flavor = FL_VARIABLE;
@@ -2047,7 +2119,7 @@
 	    continue;
 
 	  finalize_component (gfc_lval_expr_from_sym (ptr), derived, comp,
-			      stat, fini_coarray, &block);
+			      stat, fini_coarray, &block, sub_ns);
 	  if (!last_code->block->next)
 	    last_code->block->next = block;
 	}
@@ -2415,18 +2487,9 @@
   gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;
   int charlen = 0;
 
-  if (ts->type == BT_CHARACTER)
-    {
-      if (ts->deferred)
-	{
-	  gfc_error ("TODO: Deferred character length variable at %C cannot "
-		     "yet be associated with unlimited polymorphic entities");
-	  return NULL;
-	}
-      else if (ts->u.cl && ts->u.cl->length
-	       && ts->u.cl->length->expr_type == EXPR_CONSTANT)
-	charlen = mpz_get_si (ts->u.cl->length->value.integer);
-    }
+  if (ts->type == BT_CHARACTER && !ts->deferred && ts->u.cl && ts->u.cl->length
+      && ts->u.cl->length->expr_type == EXPR_CONSTANT)
+    charlen = mpz_get_si (ts->u.cl->length->value.integer);
 
   /* Find the top-level namespace.  */
   for (ns = gfc_current_ns; ns; ns = ns->parent)
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-4_9-branch)
@@ -2683,6 +2683,18 @@
     }
 
   lhsaddr = save_expr (lhsaddr);
+  if (TREE_CODE (lhsaddr) != SAVE_EXPR
+      && (TREE_CODE (lhsaddr) != ADDR_EXPR
+	  || TREE_CODE (TREE_OPERAND (lhsaddr, 0)) != VAR_DECL))
+    {
+      /* Make sure LHS is simple enough so that goa_lhs_expr_p can recognize
+	 it even after unsharing function body.  */
+      tree var = create_tmp_var_raw (TREE_TYPE (lhsaddr), NULL);
+      DECL_CONTEXT (var) = current_function_decl;
+      lhsaddr = build4 (TARGET_EXPR, TREE_TYPE (lhsaddr), var, lhsaddr,
+			NULL_TREE, NULL_TREE);
+    }
+
   rhs = gfc_evaluate_now (rse.expr, &block);
 
   if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)
Index: gcc/fortran/gfortran.h
===================================================================
--- a/src/gcc/fortran/gfortran.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/gfortran.h	(.../branches/gcc-4_9-branch)
@@ -3173,6 +3173,7 @@
 bool gfc_is_class_container_ref (gfc_expr *e);
 gfc_expr *gfc_class_initializer (gfc_typespec *, gfc_expr *);
 unsigned int gfc_hash_value (gfc_symbol *);
+gfc_expr *gfc_get_len_component (gfc_expr *e);
 bool gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,
 			     gfc_array_spec **);
 gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,159 @@
+2015-03-23  Andre Vehreschild  <vehre@gmx.de>
+	    Janus Weil  <janus@gcc.gnu.org>
+
+	Backported from mainline
+	PR fortran/60255
+	Initial patch version: Janus Weil
+	* class.c (gfc_get_len_component): New.
+	(gfc_build_class_symbol): Add _len component to unlimited
+	polymorphic entities.
+	(find_intrinsic_vtab): Removed emitting of error message.
+	* gfortran.h: Added prototype for gfc_get_len_component.
+	* simplify.c (gfc_simplify_len): Use _len component where
+	available.
+	* trans-expr.c (gfc_class_len_get): New.
+	(gfc_conv_intrinsic_to_class): Add handling for deferred
+	character arrays.
+	(gfc_conv_structure): Treat _len component correctly.
+	(gfc_conv_expr): Prevent bind_c handling when not required.
+	(gfc_trans_pointer_assignment): Propagate _len component.
+	* trans-stmt.c (class_has_len_component): New.
+	(trans_associate_var): _len component treatement for associate
+	context.
+	(gfc_trans_allocate): Same as for trans_associate_var()
+	* trans.h: Add prototype for gfc_class_len_get.
+
+2015-03-21  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/61138
+	* trans-expr.c (gfc_trans_pointer_assignment): Clear DESCRIPTOR_ONLY
+	field before reusing LSE.
+
+2015-03-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/59198
+	* trans-types.c (gfc_get_derived_type): If an abstract derived
+	type with procedure pointer components has no other type of
+	component, return the backend_decl. Otherwise build the
+	components if any of the non-procedure pointer components have
+	no backend_decl.
+
+2015-03-12  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/60898
+	* resolve.c (resolve_symbol): Check that the symbol found by
+	name lookup really is the current symbol being resolved.
+
+2015-03-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from mainline
+	PR fortran/65024
+	* trans-expr.c (gfc_conv_component_ref): If the component
+	backend declaration is missing and the derived type symbol is
+	available in the reference, call gfc_build_derived_type.
+
+2015-02-13  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/63744
+	* module.c (check_for_ambiguous): Change argument type
+	from gfc_symbol to gfc_symtree.  Check local (symtree) name
+	instead of original (symbol) name.
+	(read_module): Update caller.
+
+2015-02-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from mainline
+	2015-02-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/64932
+	* trans-stmt.c (gfc_trans_deallocate): If a component array
+	expression is not a descriptor type and it is a derived type
+	that has allocatable components and is not finalizable, then
+	deallocate the allocatable components.
+
+2015-02-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	* intrinsic.texi (CO_ASSOCIATED): c_prt_1 should be c_ptr_1.
+
+2015-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/62044
+	* resolve.c (resolve_allocate_expr): If the default initializer
+	is NULL, keep the original MOLD expression so that the correct
+	typespec is available.
+
+2015-01-27  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/64771
+	* interface.c (check_dummy_characteristics): Fix coarray handling.
+
+2015-01-26  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/64230
+	* class.c (finalize_component): New argument 'sub_ns'. Insert code to
+	check if 'expr' is associated.
+	(generate_finalization_wrapper): Rename 'ptr' symbols to 'ptr1' and
+	'ptr2'. Pass 'sub_ns' to finalize_component.
+
+2015-01-24  Thomas Koenig  <tkoenig@netcologne.de>
+
+	Backport from trunk
+	PR fortran/57023
+	* dependency.c (callback_dummy_intent_not_int):  New function.
+	(dummy_intent_not_in):  New function.
+	(gfc_full_array_ref_p):  Use dummy_intent_not_in.
+
+2015-01-24  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/60922
+	* class.c (finalize_component): Apply the check for 'fini_coarray' only
+	to coarray components.
+
+2015-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2015-01-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/64528
+	* trans-decl.c (create_function_arglist): Don't set TREE_READONLY
+	on dummy args with VALUE attribute.
+
+2015-01-12  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/63733
+	* interface.c (gfc_extend_expr): Look for type-bound operators before
+	non-typebound ones.
+
+2015-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56867
+	* trans-array.c (gfc_conv_resolve_dependencies):  Also check
+	dependencies when there may be substrings of character arrays.
+
+2014-12-23  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/64244
+	* resolve.c (resolve_typebound_call): New argument to pass out the
+	non-overridable attribute of the specific procedure.
+	(resolve_typebound_subroutine): Get overridable flag from
+	resolve_typebound_call.
+
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/63938
+	* trans-openmp.c (gfc_trans_omp_atomic): Make sure lhsaddr is
+	simple enough for goa_lhs_expr_p.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/fortran/trans-stmt.c
===================================================================
--- a/src/gcc/fortran/trans-stmt.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans-stmt.c	(.../branches/gcc-4_9-branch)
@@ -1133,6 +1133,22 @@
 }
 
 
+/* Return true, when the class has a _len component.  */
+
+static bool
+class_has_len_component (gfc_symbol *sym)
+{
+  gfc_component *comp = sym->ts.u.derived->components;
+  while (comp)
+    {
+      if (strcmp (comp->name, "_len") == 0)
+	return true;
+      comp = comp->next;
+    }
+  return false;
+}
+
+
 /* Do proper initialization for ASSOCIATE names.  */
 
 static void
@@ -1146,6 +1162,8 @@
   tree offset;
   tree dim;
   int n;
+  tree charlen;
+  bool need_len_assign;
 
   gcc_assert (sym->assoc);
   e = sym->assoc->target;
@@ -1156,6 +1174,20 @@
 
   unlimited = UNLIMITED_POLY (e);
 
+  /* Assignments to the string length need to be generated, when
+     ( sym is a char array or
+       sym has a _len component)
+     and the associated expression is unlimited polymorphic, which is
+     not (yet) correctly in 'unlimited', because for an already associated
+     BT_DERIVED the u-poly flag is not set, i.e.,
+      __tmp_CHARACTER_0_1 => w => arg
+       ^ generated temp      ^ from code, the w does not have the u-poly
+     flag set, where UNLIMITED_POLY(e) expects it.  */
+  need_len_assign = ((unlimited || (e->ts.type == BT_DERIVED
+                     && e->ts.u.derived->attr.unlimited_polymorphic))
+      && (sym->ts.type == BT_CHARACTER
+          || ((sym->ts.type == BT_CLASS || sym->ts.type == BT_DERIVED)
+              && class_has_len_component (sym))));
   /* Do a `pointer assignment' with updated descriptor (or assign descriptor
      to array temporary) for arrays with either unknown shape or if associating
      to a variable.  */
@@ -1255,8 +1287,11 @@
 	 unconditionally associate pointers and the symbol is scalar.  */
       if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.dimension)
 	{
+	  tree target_expr;
 	  /* For a class array we need a descriptor for the selector.  */
 	  gfc_conv_expr_descriptor (&se, e);
+	  /* Needed to get/set the _len component below.  */
+	  target_expr = se.expr;
 
 	  /* Obtain a temporary class container for the result.  */
 	  gfc_conv_class_to_class (&se, e, sym->ts, false, true, false, false);
@@ -1276,6 +1311,23 @@
 				        gfc_array_index_type,
 				        offset, tmp);
 	    }
+	  if (need_len_assign)
+	    {
+	      /* Get the _len comp from the target expr by stripping _data
+		 from it and adding component-ref to _len.  */
+	      tmp = gfc_class_len_get (TREE_OPERAND (target_expr, 0));
+	      /* Get the component-ref for the temp structure's _len comp.  */
+	      charlen = gfc_class_len_get (se.expr);
+	      /* Add the assign to the beginning of the the block...  */
+	      gfc_add_modify (&se.pre, charlen,
+			      fold_convert (TREE_TYPE (charlen), tmp));
+	      /* and the oposite way at the end of the block, to hand changes
+		 on the string length back.  */
+	      gfc_add_modify (&se.post, tmp,
+			      fold_convert (TREE_TYPE (tmp), charlen));
+	      /* Length assignment done, prevent adding it again below.  */
+	      need_len_assign = false;
+	    }
 	  gfc_conv_descriptor_offset_set (&se.pre, desc, offset);
 	}
       else if (sym->ts.type == BT_CLASS && e->ts.type == BT_CLASS
@@ -1290,7 +1342,13 @@
 	  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);
 	}
       else
-	gfc_conv_expr (&se, e);
+	{
+	  /* For BT_CLASS and BT_DERIVED, this boils down to a pointer assign,
+	     which has the string length included.  For CHARACTERS it is still
+	     needed and will be done at the end of this routine.  */
+	  gfc_conv_expr (&se, e);
+	  need_len_assign = need_len_assign && sym->ts.type == BT_CHARACTER;
+	}
 
       tmp = TREE_TYPE (sym->backend_decl);
       tmp = gfc_build_addr_expr (tmp, se.expr);
@@ -1311,21 +1369,30 @@
       gfc_add_init_cleanup (block, tmp, NULL_TREE);
     }
 
-  /* Set the stringlength from the vtable size.  */
-  if (sym->ts.type == BT_CHARACTER && sym->attr.select_type_temporary)
+  /* Set the stringlength, when needed.  */
+  if (need_len_assign)
     {
-      tree charlen;
       gfc_se se;
       gfc_init_se (&se, NULL);
-      gcc_assert (UNLIMITED_POLY (e->symtree->n.sym));
-      tmp = gfc_get_symbol_decl (e->symtree->n.sym);
-      tmp = gfc_vtable_size_get (tmp);
+      if (e->symtree->n.sym->ts.type == BT_CHARACTER)
+	{
+	  /* What about deferred strings?  */
+	  gcc_assert (!e->symtree->n.sym->ts.deferred);
+	  tmp = e->symtree->n.sym->ts.u.cl->backend_decl;
+	}
+      else
+	tmp = gfc_class_len_get (gfc_get_symbol_decl (e->symtree->n.sym));
       gfc_get_symbol_decl (sym);
-      charlen = sym->ts.u.cl->backend_decl;
-      gfc_add_modify (&se.pre, charlen,
-		      fold_convert (TREE_TYPE (charlen), tmp));
-      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),
-			    gfc_finish_block (&se.post));
+      charlen = sym->ts.type == BT_CHARACTER ? sym->ts.u.cl->backend_decl
+					: gfc_class_len_get (sym->backend_decl);
+      /* Prevent adding a noop len= len.  */
+      if (tmp != charlen)
+	{
+	  gfc_add_modify (&se.pre, charlen,
+			  fold_convert (TREE_TYPE (charlen), tmp));
+	  gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),
+				gfc_finish_block (&se.post));
+	}
     }
 }
 
@@ -5038,6 +5105,15 @@
 		gfc_add_modify (&se.pre, se.string_length,
 				fold_convert (TREE_TYPE (se.string_length),
 				memsz));
+	      else if ((al->expr->ts.type == BT_DERIVED
+			|| al->expr->ts.type == BT_CLASS)
+		       && expr->ts.u.derived->attr.unlimited_polymorphic)
+		{
+		  tmp = gfc_class_len_get (al->expr->symtree->n.sym->backend_decl);
+		  gfc_add_modify (&se.pre, tmp,
+				  fold_convert (TREE_TYPE (tmp),
+						memsz));
+		}
 
 	      /* Convert to size in bytes, using the character KIND.  */
 	      if (unlimited_char)
@@ -5458,11 +5534,13 @@
 
       if (expr->rank || gfc_is_coarray (expr))
 	{
+	  gfc_ref *ref;
+
 	  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp
 	      && !gfc_is_finalizable (expr->ts.u.derived, NULL))
 	    {
-	      gfc_ref *ref;
 	      gfc_ref *last = NULL;
+
 	      for (ref = expr->ref; ref; ref = ref->next)
 		if (ref->type == REF_COMPONENT)
 		  last = ref;
@@ -5473,13 +5551,45 @@
 		    && !(!last && expr->symtree->n.sym->attr.pointer))
 		{
 		  tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, se.expr,
-						  expr->rank);
+						   expr->rank);
 		  gfc_add_expr_to_block (&se.pre, tmp);
 		}
 	    }
-	  tmp = gfc_array_deallocate (se.expr, pstat, errmsg, errlen,
-				      label_finish, expr);
-	  gfc_add_expr_to_block (&se.pre, tmp);
+
+	  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)))
+	    {
+	      tmp = gfc_array_deallocate (se.expr, pstat, errmsg, errlen,
+				          label_finish, expr);
+	      gfc_add_expr_to_block (&se.pre, tmp);
+	    }
+	  else if (TREE_CODE (se.expr) == COMPONENT_REF
+		   && TREE_CODE (TREE_TYPE (se.expr)) == ARRAY_TYPE
+		   && TREE_CODE (TREE_TYPE (TREE_TYPE (se.expr)))
+			== RECORD_TYPE)
+	    {
+	      /* class.c(finalize_component) generates these, when a
+		 finalizable entity has a non-allocatable derived type array
+		 component, which has allocatable components. Obtain the
+		 derived type of the array and deallocate the allocatable
+		 components. */
+	      for (ref = expr->ref; ref; ref = ref->next)
+		{
+		  if (ref->u.c.component->attr.dimension
+		      && ref->u.c.component->ts.type == BT_DERIVED)
+		    break;
+		}
+
+	      if (ref && ref->u.c.component->ts.u.derived->attr.alloc_comp
+		  && !gfc_is_finalizable (ref->u.c.component->ts.u.derived,
+					  NULL))
+		{
+		  tmp = gfc_deallocate_alloc_comp
+				(ref->u.c.component->ts.u.derived,
+				 se.expr, expr->rank);
+		  gfc_add_expr_to_block (&se.pre, tmp);
+		}
+	    }
+
 	  if (al->expr->ts.type == BT_CLASS)
 	    gfc_reset_vptr (&se.pre, al->expr);
 	}
Index: gcc/fortran/module.c
===================================================================
--- a/src/gcc/fortran/module.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/module.c	(.../branches/gcc-4_9-branch)
@@ -4849,19 +4849,21 @@
 /* It is not quite enough to check for ambiguity in the symbols by
    the loaded symbol and the new symbol not being identical.  */
 static bool
-check_for_ambiguous (gfc_symbol *st_sym, pointer_info *info)
+check_for_ambiguous (gfc_symtree *st, pointer_info *info)
 {
   gfc_symbol *rsym;
   module_locus locus;
   symbol_attribute attr;
+  gfc_symbol *st_sym;
 
-  if (gfc_current_ns->proc_name && st_sym->name == gfc_current_ns->proc_name->name)
+  if (gfc_current_ns->proc_name && st->name == gfc_current_ns->proc_name->name)
     {
       gfc_error ("'%s' of module '%s', imported at %C, is also the name of the "
-		 "current program unit", st_sym->name, module_name);
+		 "current program unit", st->name, module_name);
       return true;
     }
 
+  st_sym = st->n.sym;
   rsym = info->u.rsym.sym;
   if (st_sym == rsym)
     return false;
@@ -5093,7 +5095,7 @@
 	  if (st != NULL)
 	    {
 	      /* Check for ambiguous symbols.  */
-	      if (check_for_ambiguous (st->n.sym, info))
+	      if (check_for_ambiguous (st, info))
 		st->ambiguous = 1;
 	      else
 		info->u.rsym.symtree = st;
Index: gcc/fortran/trans-types.c
===================================================================
--- a/src/gcc/fortran/trans-types.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans-types.c	(.../branches/gcc-4_9-branch)
@@ -2415,9 +2415,24 @@
       /* Its components' backend_decl have been built or we are
 	 seeing recursion through the formal arglist of a procedure
 	 pointer component.  */
-      if (TYPE_FIELDS (derived->backend_decl)
-	    || derived->attr.proc_pointer_comp)
+      if (TYPE_FIELDS (derived->backend_decl))
         return derived->backend_decl;
+      else if (derived->attr.abstract
+	       && derived->attr.proc_pointer_comp)
+	{
+	  /* If an abstract derived type with procedure pointer
+	     components has no other type of component, return the
+	     backend_decl. Otherwise build the components if any of the
+	     non-procedure pointer components have no backend_decl.  */
+	  for (c = derived->components; c; c = c->next)
+	    {
+	      if (!c->attr.proc_pointer && c->backend_decl == NULL)
+		break;
+	      else if (c->next == NULL)
+		return derived->backend_decl;
+	    }
+	  typenode = derived->backend_decl;
+	}
       else
         typenode = derived->backend_decl;
     }
Index: gcc/fortran/trans.h
===================================================================
--- a/src/gcc/fortran/trans.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans.h	(.../branches/gcc-4_9-branch)
@@ -347,6 +347,7 @@
 /* Class API functions.  */
 tree gfc_class_data_get (tree);
 tree gfc_class_vptr_get (tree);
+tree gfc_class_len_get (tree);
 void gfc_reset_vptr (stmtblock_t *, gfc_expr *);
 tree gfc_class_set_static_fields (tree, tree, tree);
 tree gfc_vtable_hash_get (tree);
Index: gcc/fortran/resolve.c
===================================================================
--- a/src/gcc/fortran/resolve.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/resolve.c	(.../branches/gcc-4_9-branch)
@@ -1815,7 +1815,7 @@
 	      && sym->ns->proc_name->attr.flavor != FL_MODULE)
 	    {
 	      if (!gfc_notify_std (GFC_STD_F2008, "Internal procedure '%s' is"
-				   " used as actual argument at %L", 
+				   " used as actual argument at %L",
 				   sym->name, &e->where))
 		goto cleanup;
 	    }
@@ -2435,7 +2435,7 @@
 
       if (!gfc_compare_interfaces (sym, def_sym, sym->name, 0, 1,
 				   reason, sizeof(reason), NULL, NULL))
-	{	
+	{
 	  gfc_error ("Interface mismatch in global procedure '%s' at %L: %s ",
 		    sym->name, &sym->declared_at, reason);
 	  goto done;
@@ -2449,7 +2449,7 @@
       if (sym->attr.if_source != IFSRC_IFBODY)
 	gfc_procedure_use (def_sym, actual, where);
     }
-    
+
 done:
   gfc_errors_to_warnings (0);
 
@@ -2551,7 +2551,7 @@
 
   if (intr)
     {
-      if (!gfc_convert_to_structure_constructor (expr, intr->sym, NULL, 
+      if (!gfc_convert_to_structure_constructor (expr, intr->sym, NULL,
 						 NULL, false))
 	return false;
       return resolve_structure_cons (expr, 0);
@@ -2853,7 +2853,7 @@
   no_formal_args = sym && is_external_proc (sym)
   		       && gfc_sym_get_dummy_args (sym) == NULL;
 
-  if (!resolve_actual_arglist (expr->value.function.actual, 
+  if (!resolve_actual_arglist (expr->value.function.actual,
 			       p, no_formal_args))
     {
       inquiry_argument = false;
@@ -4122,7 +4122,7 @@
     }
 
   if (index->ts.type == BT_REAL)
-    if (!gfc_notify_std (GFC_STD_LEGACY, "REAL array index at %L", 
+    if (!gfc_notify_std (GFC_STD_LEGACY, "REAL array index at %L",
 			 &index->where))
       return false;
 
@@ -5590,7 +5590,7 @@
 /* Resolve a call to a type-bound subroutine.  */
 
 static bool
-resolve_typebound_call (gfc_code* c, const char **name)
+resolve_typebound_call (gfc_code* c, const char **name, bool *overridable)
 {
   gfc_actual_arglist* newactual;
   gfc_symtree* target;
@@ -5614,6 +5614,10 @@
   if (!resolve_typebound_generic_call (c->expr1, name))
     return false;
 
+  /* Pass along the NON_OVERRIDABLE attribute of the specific TBP. */
+  if (overridable)
+    *overridable = !c->expr1->value.compcall.tbp->non_overridable;
+
   /* Transform into an ordinary EXEC_CALL for now.  */
 
   if (!resolve_typebound_static (c->expr1, &target, &newactual))
@@ -5778,7 +5782,7 @@
 
   /* Get the CLASS declared type.  */
   declared = get_declared_from_expr (&class_ref, &new_ref, e, true);
-  
+
   if (!resolve_fl_derived (declared))
     return false;
 
@@ -5873,7 +5877,7 @@
       if (c->ts.u.derived == NULL)
 	c->ts.u.derived = gfc_find_derived_vtab (declared);
 
-      if (!resolve_typebound_call (code, &name))
+      if (!resolve_typebound_call (code, &name, NULL))
 	return false;
 
       /* Use the generic name if it is there.  */
@@ -5905,7 +5909,7 @@
     }
 
   if (st == NULL)
-    return resolve_typebound_call (code, NULL);
+    return resolve_typebound_call (code, NULL, NULL);
 
   if (!resolve_ref (code->expr1))
     return false;
@@ -5918,10 +5922,10 @@
 	 || (!class_ref && st->n.sym->ts.type != BT_CLASS))
     {
       gfc_free_ref_list (new_ref);
-      return resolve_typebound_call (code, NULL);
+      return resolve_typebound_call (code, NULL, NULL);
     }
 
-  if (!resolve_typebound_call (code, &name))
+  if (!resolve_typebound_call (code, &name, &overridable))
     {
       gfc_free_ref_list (new_ref);
       return false;
@@ -5978,8 +5982,8 @@
 
   c->ext.actual = c->expr1->value.compcall.actual;
 
-  if (!resolve_actual_arglist (c->ext.actual, comp->attr.proc, 
-			       !(comp->ts.interface 
+  if (!resolve_actual_arglist (c->ext.actual, comp->attr.proc,
+			       !(comp->ts.interface
 				 && comp->ts.interface->formal)))
     return false;
 
@@ -6013,8 +6017,8 @@
   if (!resolve_ref (e))
     return false;
 
-  if (!resolve_actual_arglist (e->value.function.actual, comp->attr.proc, 
-			       !(comp->ts.interface 
+  if (!resolve_actual_arglist (e->value.function.actual, comp->attr.proc,
+			       !(comp->ts.interface
 				 && comp->ts.interface->formal)))
     return false;
 
@@ -6226,19 +6230,19 @@
   if (!gfc_resolve_iterator_expr (iter->var, real_ok, "Loop variable"))
     return false;
 
-  if (!gfc_check_vardef_context (iter->var, false, false, own_scope, 
+  if (!gfc_check_vardef_context (iter->var, false, false, own_scope,
 				 _("iterator variable")))
     return false;
 
-  if (!gfc_resolve_iterator_expr (iter->start, real_ok, 
+  if (!gfc_resolve_iterator_expr (iter->start, real_ok,
 				  "Start expression in DO loop"))
     return false;
 
-  if (!gfc_resolve_iterator_expr (iter->end, real_ok, 
+  if (!gfc_resolve_iterator_expr (iter->end, real_ok,
 				  "End expression in DO loop"))
     return false;
 
-  if (!gfc_resolve_iterator_expr (iter->step, real_ok, 
+  if (!gfc_resolve_iterator_expr (iter->step, real_ok,
 				  "Step expression in DO loop"))
     return false;
 
@@ -6496,10 +6500,10 @@
     }
 
   if (pointer
-      && !gfc_check_vardef_context (e, true, true, false, 
+      && !gfc_check_vardef_context (e, true, true, false,
 				    _("DEALLOCATE object")))
     return false;
-  if (!gfc_check_vardef_context (e, false, true, false, 
+  if (!gfc_check_vardef_context (e, false, true, false,
 				 _("DEALLOCATE object")))
     return false;
 
@@ -6849,10 +6853,10 @@
   e2 = remove_last_array_ref (e);
   t = true;
   if (t && pointer)
-    t = gfc_check_vardef_context (e2, true, true, false, 
+    t = gfc_check_vardef_context (e2, true, true, false,
 				  _("ALLOCATE object"));
   if (t)
-    t = gfc_check_vardef_context (e2, false, true, false, 
+    t = gfc_check_vardef_context (e2, false, true, false,
 				  _("ALLOCATE object"));
   gfc_free_expr (e2);
   if (!t)
@@ -6895,9 +6899,12 @@
     {
       /* Default initialization via MOLD (non-polymorphic).  */
       gfc_expr *rhs = gfc_default_initializer (&code->expr3->ts);
-      gfc_resolve_expr (rhs);
-      gfc_free_expr (code->expr3);
-      code->expr3 = rhs;
+      if (rhs != NULL)
+	{
+	  gfc_resolve_expr (rhs);
+	  gfc_free_expr (code->expr3);
+	  code->expr3 = rhs;
+	}
     }
 
   if (e->ts.type == BT_CLASS && !unlimited && !UNLIMITED_POLY (code->expr3))
@@ -7051,7 +7058,7 @@
   /* Check the stat variable.  */
   if (stat)
     {
-      gfc_check_vardef_context (stat, false, false, false, 
+      gfc_check_vardef_context (stat, false, false, false,
 				_("STAT variable"));
 
       if ((stat->ts.type != BT_INTEGER
@@ -8264,7 +8271,7 @@
      code->ext.dt may be NULL if the TRANSFER is related to
      an INQUIRE statement -- but in this case, we are not reading, either.  */
   if (code->ext.dt && code->ext.dt->dt_io_kind->value.iokind == M_READ
-      && !gfc_check_vardef_context (exp, false, false, false, 
+      && !gfc_check_vardef_context (exp, false, false, false,
 				    _("item in READ")))
     return;
 
@@ -8394,7 +8401,7 @@
 	       &code->expr2->where);
 
   if (code->expr2
-      && !gfc_check_vardef_context (code->expr2, false, false, false, 
+      && !gfc_check_vardef_context (code->expr2, false, false, false,
 				    _("STAT variable")))
     return;
 
@@ -8406,7 +8413,7 @@
 	       &code->expr3->where);
 
   if (code->expr3
-      && !gfc_check_vardef_context (code->expr3, false, false, false, 
+      && !gfc_check_vardef_context (code->expr3, false, false, false,
 				    _("ERRMSG variable")))
     return;
 
@@ -8418,7 +8425,7 @@
 	       "variable", &code->expr4->where);
 
   if (code->expr4
-      && !gfc_check_vardef_context (code->expr4, false, false, false, 
+      && !gfc_check_vardef_context (code->expr4, false, false, false,
 				    _("ACQUIRED_LOCK variable")))
     return;
 }
@@ -9077,7 +9084,7 @@
 
   if (rhs->is_boz
       && !gfc_notify_std (GFC_STD_GNU, "BOZ literal at %L outside "
-			  "a DATA statement and outside INT/REAL/DBLE/CMPLX", 
+			  "a DATA statement and outside INT/REAL/DBLE/CMPLX",
 			  &code->loc))
     return false;
 
@@ -9878,7 +9885,7 @@
 	  if (!t)
 	    break;
 
-	  if (!gfc_check_vardef_context (code->expr1, false, false, false, 
+	  if (!gfc_check_vardef_context (code->expr1, false, false, false,
 					 _("assignment")))
 	    break;
 
@@ -10686,7 +10693,7 @@
 	      return false;
 	    }
 	  else if (!gfc_notify_std (GFC_STD_F2003, "Scalar object "
-				    "'%s' at %L may not be ALLOCATABLE", 
+				    "'%s' at %L may not be ALLOCATABLE",
 				    sym->name, &sym->declared_at))
 	    return false;
 	}
@@ -11017,8 +11024,8 @@
 	      && !gfc_check_symbol_access (arg->sym->ts.u.derived)
 	      && !gfc_notify_std (GFC_STD_F2003, "'%s' is of a PRIVATE type "
 				  "and cannot be a dummy argument"
-				  " of '%s', which is PUBLIC at %L", 
-				  arg->sym->name, sym->name, 
+				  " of '%s', which is PUBLIC at %L",
+				  arg->sym->name, sym->name,
 				  &sym->declared_at))
 	    {
 	      /* Stop this message from recurring.  */
@@ -11040,8 +11047,8 @@
 		  && !gfc_notify_std (GFC_STD_F2003, "Procedure '%s' in "
 				      "PUBLIC interface '%s' at %L "
 				      "takes dummy arguments of '%s' which "
-				      "is PRIVATE", iface->sym->name, 
-				      sym->name, &iface->sym->declared_at, 
+				      "is PRIVATE", iface->sym->name,
+				      sym->name, &iface->sym->declared_at,
 				      gfc_typename(&arg->sym->ts)))
 		{
 		  /* Stop this message from recurring.  */
@@ -11064,8 +11071,8 @@
 		  && !gfc_notify_std (GFC_STD_F2003, "Procedure '%s' in "
 				      "PUBLIC interface '%s' at %L takes "
 				      "dummy arguments of '%s' which is "
-				      "PRIVATE", iface->sym->name, 
-				      sym->name, &iface->sym->declared_at, 
+				      "PRIVATE", iface->sym->name,
+				      sym->name, &iface->sym->declared_at,
 				      gfc_typename(&arg->sym->ts)))
 		{
 		  /* Stop this message from recurring.  */
@@ -11176,7 +11183,7 @@
       gfc_formal_arglist *curr_arg;
       int has_non_interop_arg = 0;
 
-      if (!verify_bind_c_sym (sym, &(sym->ts), sym->attr.in_common, 
+      if (!verify_bind_c_sym (sym, &(sym->ts), sym->attr.in_common,
 			      sym->common_block))
         {
           /* Clear these to prevent looking at them again if there was an
@@ -12019,7 +12026,7 @@
   for (op = 0; op != GFC_INTRINSIC_OPS; ++op)
     {
       gfc_typebound_proc* p = derived->f2k_derived->tb_op[op];
-      if (p && !resolve_typebound_intrinsic_op (derived, 
+      if (p && !resolve_typebound_intrinsic_op (derived,
 						(gfc_intrinsic_op)op, p))
 	resolve_bindings_result = false;
     }
@@ -12471,7 +12478,7 @@
 	  && !gfc_check_symbol_access (c->ts.u.derived)
 	  && !gfc_notify_std (GFC_STD_F2003, "the component '%s' is a "
 			      "PRIVATE type and cannot be a component of "
-			      "'%s', which is PUBLIC at %L", c->name, 
+			      "'%s', which is PUBLIC at %L", c->name,
 			      sym->name, &sym->declared_at))
 	return false;
 
@@ -12545,8 +12552,8 @@
 	    && sym != c->ts.u.derived)
 	add_dt_to_dt_list (c->ts.u.derived);
 
-      if (!gfc_resolve_array_spec (c->as, 
-				   !(c->attr.pointer || c->attr.proc_pointer 
+      if (!gfc_resolve_array_spec (c->as,
+				   !(c->attr.pointer || c->attr.proc_pointer
 				     || c->attr.allocatable)))
 	return false;
 
@@ -12595,13 +12602,13 @@
 	  || gen_dt->generic->sym->module != gen_dt->generic->next->sym->module)
       && !gfc_notify_std (GFC_STD_F2003, "Generic name '%s' of function "
 			  "'%s' at %L being the same name as derived "
-			  "type at %L", sym->name, 
-			  gen_dt->generic->sym == sym 
-			  ? gen_dt->generic->next->sym->name 
-			  : gen_dt->generic->sym->name, 
-			  gen_dt->generic->sym == sym 
-			  ? &gen_dt->generic->next->sym->declared_at 
-			  : &gen_dt->generic->sym->declared_at, 
+			  "type at %L", sym->name,
+			  gen_dt->generic->sym == sym
+			  ? gen_dt->generic->next->sym->name
+			  : gen_dt->generic->sym->name,
+			  gen_dt->generic->sym == sym
+			  ? &gen_dt->generic->next->sym->declared_at
+			  : &gen_dt->generic->sym->declared_at,
 			  &sym->declared_at))
     return false;
 
@@ -12656,13 +12663,13 @@
 
       if (nl->sym->as && nl->sym->as->type == AS_ASSUMED_SHAPE
 	  && !gfc_notify_std (GFC_STD_F2003, "NAMELIST array object '%s' "
-			      "with assumed shape in namelist '%s' at %L", 
+			      "with assumed shape in namelist '%s' at %L",
 			      nl->sym->name, sym->name, &sym->declared_at))
 	return false;
 
       if (is_non_constant_shape_array (nl->sym)
 	  && !gfc_notify_std (GFC_STD_F2003, "NAMELIST array object '%s' "
-			      "with nonconstant shape in namelist '%s' at %L", 
+			      "with nonconstant shape in namelist '%s' at %L",
 			      nl->sym->name, sym->name, &sym->declared_at))
 	return false;
 
@@ -12671,7 +12678,7 @@
 	      || !gfc_is_constant_expr (nl->sym->ts.u.cl->length))
 	  && !gfc_notify_std (GFC_STD_F2003, "NAMELIST object '%s' with "
 			      "nonconstant character length in "
-			      "namelist '%s' at %L", nl->sym->name, 
+			      "namelist '%s' at %L", nl->sym->name,
 			      sym->name, &sym->declared_at))
 	return false;
 
@@ -12691,7 +12698,7 @@
 	{
 	  if (!gfc_notify_std (GFC_STD_F2003, "NAMELIST object '%s' in "
 			       "namelist '%s' at %L with ALLOCATABLE "
-			       "or POINTER components", nl->sym->name, 
+			       "or POINTER components", nl->sym->name,
 			       sym->name, &sym->declared_at))
 	    return false;
 
@@ -12857,10 +12864,13 @@
 	    {
 	      this_symtree = gfc_find_symtree (gfc_current_ns->sym_root,
 					       sym->name);
-	      gfc_release_symbol (sym);
-	      symtree->n.sym->refs++;
-	      this_symtree->n.sym = symtree->n.sym;
-	      return;
+	      if (this_symtree->n.sym == sym)
+		{
+		  symtree->n.sym->refs++;
+		  gfc_release_symbol (sym);
+		  this_symtree->n.sym = symtree->n.sym;
+		  return;
+		}
 	    }
 	}
 
@@ -13261,10 +13271,10 @@
       && gfc_check_symbol_access (sym)
       && !gfc_check_symbol_access (sym->ts.u.derived)
       && !gfc_notify_std (GFC_STD_F2003, "PUBLIC %s '%s' at %L of PRIVATE "
-			  "derived type '%s'", 
-			  (sym->attr.flavor == FL_PARAMETER) 
-			  ? "parameter" : "variable", 
-			  sym->name, &sym->declared_at, 
+			  "derived type '%s'",
+			  (sym->attr.flavor == FL_PARAMETER)
+			  ? "parameter" : "variable",
+			  sym->name, &sym->declared_at,
 			  sym->ts.u.derived->name))
     return;
 
@@ -13407,15 +13417,15 @@
       if (!gfc_logical_kinds[i].c_bool && sym->attr.dummy
 	  && !gfc_notify_std (GFC_STD_GNU, "LOGICAL dummy argument '%s' at "
 			      "%L with non-C_Bool kind in BIND(C) procedure "
-			      "'%s'", sym->name, &sym->declared_at, 
+			      "'%s'", sym->name, &sym->declared_at,
 			      sym->ns->proc_name->name))
 	return;
       else if (!gfc_logical_kinds[i].c_bool
 	       && !gfc_notify_std (GFC_STD_GNU, "LOGICAL result variable "
 				   "'%s' at %L with non-C_Bool kind in "
-				   "BIND(C) procedure '%s'", sym->name, 
-				   &sym->declared_at, 
-				   sym->attr.function ? sym->name 
+				   "BIND(C) procedure '%s'", sym->name,
+				   &sym->declared_at,
+				   sym->attr.function ? sym->name
 				   : sym->ns->proc_name->name))
 	return;
     }
@@ -14618,7 +14628,7 @@
       unsigned letter;
       for (letter = 0; letter != GFC_LETTERS; ++letter)
 	if (ns->set_flag[letter]
-	    && !resolve_typespec_used (&ns->default_type[letter], 
+	    && !resolve_typespec_used (&ns->default_type[letter],
 				       &ns->implicit_loc[letter], NULL))
 	  return;
     }
Index: gcc/fortran/trans-decl.c
===================================================================
--- a/src/gcc/fortran/trans-decl.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans-decl.c	(.../branches/gcc-4_9-branch)
@@ -2262,8 +2262,9 @@
       /* Fill in arg stuff.  */
       DECL_CONTEXT (parm) = fndecl;
       DECL_ARG_TYPE (parm) = TREE_VALUE (typelist);
-      /* All implementation args are read-only.  */
-      TREE_READONLY (parm) = 1;
+      /* All implementation args except for VALUE are read-only.  */
+      if (!f->sym->attr.value)
+	TREE_READONLY (parm) = 1;
       if (POINTER_TYPE_P (type)
 	  && (!f->sym->attr.proc_pointer
 	      && f->sym->attr.flavor != FL_PROCEDURE))
Index: gcc/fortran/dependency.c
===================================================================
--- a/src/gcc/fortran/dependency.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/dependency.c	(.../branches/gcc-4_9-branch)
@@ -1848,11 +1848,40 @@
   return GFC_DEP_EQUAL;
 }
 
+/* Callback function for checking if an expression depends on a
+   dummy variable which is any other than INTENT(IN).  */
 
+static int
+callback_dummy_intent_not_in (gfc_expr **ep,
+			      int *walk_subtrees ATTRIBUTE_UNUSED,
+			      void *data ATTRIBUTE_UNUSED)
+{
+  gfc_expr *e = *ep;
+
+  if (e->expr_type == EXPR_VARIABLE && e->symtree
+      && e->symtree->n.sym->attr.dummy)
+    return e->symtree->n.sym->attr.intent != INTENT_IN;
+  else
+    return 0;
+}
+
+/* Auxiliary function to check if subexpressions have dummy variables which
+   are not intent(in).
+*/
+
+static bool
+dummy_intent_not_in (gfc_expr **ep)
+{
+  return gfc_expr_walker (ep, callback_dummy_intent_not_in, NULL);
+}
+
 /* Determine if an array ref, usually an array section specifies the
    entire array.  In addition, if the second, pointer argument is
    provided, the function will return true if the reference is
-   contiguous; eg. (:, 1) gives true but (1,:) gives false.  */
+   contiguous; eg. (:, 1) gives true but (1,:) gives false. 
+   If one of the bounds depends on a dummy variable which is
+   not INTENT(IN), also return false, because the user may
+   have changed the variable.  */
 
 bool
 gfc_full_array_ref_p (gfc_ref *ref, bool *contiguous)
@@ -1916,7 +1945,8 @@
 	  && (!ref->u.ar.as
 	      || !ref->u.ar.as->lower[i]
 	      || gfc_dep_compare_expr (ref->u.ar.start[i],
-				       ref->u.ar.as->lower[i])))
+				       ref->u.ar.as->lower[i])
+	      || dummy_intent_not_in (&ref->u.ar.start[i])))
 	lbound_OK = false;
       /* Check the upper bound.  */
       if (ref->u.ar.end[i]
@@ -1923,7 +1953,8 @@
 	  && (!ref->u.ar.as
 	      || !ref->u.ar.as->upper[i]
 	      || gfc_dep_compare_expr (ref->u.ar.end[i],
-				       ref->u.ar.as->upper[i])))
+				       ref->u.ar.as->upper[i])
+	      || dummy_intent_not_in (&ref->u.ar.end[i])))
 	ubound_OK = false;
       /* Check the stride.  */
       if (ref->u.ar.stride[i]
Index: gcc/fortran/simplify.c
===================================================================
--- a/src/gcc/fortran/simplify.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/simplify.c	(.../branches/gcc-4_9-branch)
@@ -3690,6 +3690,14 @@
       mpz_set (result->value.integer, e->ts.u.cl->length->value.integer);
       return range_check (result, "LEN");
     }
+  else if (e->expr_type == EXPR_VARIABLE && e->ts.type == BT_CHARACTER
+	   && e->symtree->n.sym
+	   && e->symtree->n.sym->assoc && e->symtree->n.sym->assoc->target
+	   && e->symtree->n.sym->assoc->target->ts.type == BT_DERIVED)
+    /* The expression in assoc->target points to a ref to the _data component
+       of the unlimited polymorphic entity.  To get the _len component the last
+       _data ref needs to be stripped and a ref to the _len component added.  */
+    return gfc_get_len_component (e->symtree->n.sym->assoc->target);
   else
     return NULL;
 }
Index: gcc/configure.ac
===================================================================
--- a/src/gcc/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/configure.ac	(.../branches/gcc-4_9-branch)
@@ -3603,6 +3603,13 @@
 		[Define if your assembler supports the -no-mul-bug-abort option.])])
     ;;
 
+  avr-*-*)
+    gcc_GAS_CHECK_FEATURE([-mrmw option], gcc_cv_as_avr_mrmw,,
+      [-mrmw], [.text],,
+      [AC_DEFINE(HAVE_AS_AVR_MRMW_OPTION, 1,
+		[Define if your assembler supports -mrmw option.])])
+    ;;
+
   sparc*-*-*)
     gcc_GAS_CHECK_FEATURE([.register], gcc_cv_as_sparc_register_op,,,
       [.register %g2, #scratch],,
@@ -4251,6 +4258,13 @@
       [AC_DEFINE(HAVE_AS_GNU_ATTRIBUTE, 1,
 	  [Define if your assembler supports .gnu_attribute.])])
 
+    gcc_GAS_CHECK_FEATURE([.module support],
+      gcc_cv_as_mips_dot_module,,[-32],
+      [.module mips2
+       .module fp=xx],,
+      [AC_DEFINE(HAVE_AS_DOT_MODULE, 1,
+	  [Define if your assembler supports .module.])])
+
     gcc_GAS_CHECK_FEATURE([.micromips support],
       gcc_cv_as_micromips_support,,[--fatal-warnings],
       [.set micromips],,
@@ -5495,8 +5509,31 @@
 AC_ARG_VAR(CLOOGINC,[How to find CLOOG include files])
 if test "x${CLOOGLIBS}" != "x" ; then 
    AC_DEFINE(HAVE_cloog, 1, [Define if cloog is in use.])
+
+  # Check whether isl_schedule_constraints_compute_schedule is available;
+  # it's new in ISL-0.13.
+  saved_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS $ISLINC"
+  saved_LIBS="$LIBS"
+  LIBS="$LIBS $CLOOGLIBS $ISLLIBS $GMPLIBS"
+
+  AC_MSG_CHECKING([Checking for isl_schedule_constraints_compute_schedule])
+  AC_TRY_LINK([#include <isl/schedule.h>],
+              [isl_schedule_constraints_compute_schedule (NULL);],
+              [ac_has_isl_schedule_constraints_compute_schedule=yes],
+              [ac_has_isl_schedule_constraints_compute_schedule=no])
+  AC_MSG_RESULT($ac_has_isl_schedule_constraints_compute_schedule)
+
+  LIBS="$saved_LIBS"
+  CFLAGS="$saved_CFLAGS"
+
+  if test x"$ac_has_isl_schedule_constraints_compute_schedule" = x"yes"; then
+     AC_DEFINE(HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE, 1,
+               [Define if isl_schedule_constraints_compute_schedule exists.])
+  fi
 fi
 
+
 # Check for plugin support
 AC_ARG_ENABLE(plugin,
 [AS_HELP_STRING([--enable-plugin], [enable plugin support])],
Index: gcc/function.c
===================================================================
--- a/src/gcc/function.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/function.c	(.../branches/gcc-4_9-branch)
@@ -7193,6 +7193,15 @@
     df_insn_rescan (insn);
 }
 
+/* Add the decl D to the local_decls list of FUN.  */
+
+void
+add_local_decl (struct function *fun, tree d)
+{
+  gcc_assert (TREE_CODE (d) == VAR_DECL);
+  vec_safe_push (fun->local_decls, d);
+}
+
 static unsigned
 rest_of_match_asm_constraints (void)
 {
Index: gcc/function.h
===================================================================
--- a/src/gcc/function.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/function.h	(.../branches/gcc-4_9-branch)
@@ -674,11 +674,7 @@
 
 /* Add the decl D to the local_decls list of FUN.  */
 
-static inline void
-add_local_decl (struct function *fun, tree d)
-{
-  vec_safe_push (fun->local_decls, d);
-}
+void add_local_decl (struct function *fun, tree d);
 
 #define FOR_EACH_LOCAL_DECL(FUN, I, D)		\
   FOR_EACH_VEC_SAFE_ELT_REVERSE ((FUN)->local_decls, I, D)
Index: gcc/df.h
===================================================================
--- a/src/gcc/df.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/df.h	(.../branches/gcc-4_9-branch)
@@ -1134,20 +1134,22 @@
 
 /* web */
 
-/* This entry is allocated for each reference in the insn stream.  */
-struct web_entry
+class web_entry_base
 {
-  /* Pointer to the parent in the union/find tree.  */
-  struct web_entry *pred;
-  /* Newly assigned register to the entry.  Set only for roots.  */
-  rtx reg;
-  void* extra_info;
+ private:
+  /* Reference to the parent in the union/find tree.  */
+  web_entry_base *pred_pvt;
+
+ public:
+  /* Accessors.  */
+  web_entry_base *pred () { return pred_pvt; }
+  void set_pred (web_entry_base *p) { pred_pvt = p; }
+
+  /* Find representative in union-find tree.  */
+  web_entry_base *unionfind_root ();
+
+  /* Union with another set, returning TRUE if they are already unioned.  */
+  friend bool unionfind_union (web_entry_base *first, web_entry_base *second);
 };
 
-extern struct web_entry *unionfind_root (struct web_entry *);
-extern bool unionfind_union (struct web_entry *, struct web_entry *);
-extern void union_defs (df_ref, struct web_entry *,
-			unsigned int *used, struct web_entry *,
-			bool (*fun) (struct web_entry *, struct web_entry *));
-
 #endif /* GCC_DF_H */
Index: gcc/alias.c
===================================================================
--- a/src/gcc/alias.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/alias.c	(.../branches/gcc-4_9-branch)
@@ -383,17 +383,9 @@
 static inline int
 mems_in_disjoint_alias_sets_p (const_rtx mem1, const_rtx mem2)
 {
-/* Perform a basic sanity check.  Namely, that there are no alias sets
-   if we're not using strict aliasing.  This helps to catch bugs
-   whereby someone uses PUT_CODE, but doesn't clear MEM_ALIAS_SET, or
-   where a MEM is allocated in some way other than by the use of
-   gen_rtx_MEM, and the MEM_ALIAS_SET is not cleared.  If we begin to
-   use alias sets to indicate that spilled registers cannot alias each
-   other, we might need to remove this check.  */
-  gcc_assert (flag_strict_aliasing
-	      || (!MEM_ALIAS_SET (mem1) && !MEM_ALIAS_SET (mem2)));
-
-  return ! alias_sets_conflict_p (MEM_ALIAS_SET (mem1), MEM_ALIAS_SET (mem2));
+  return (flag_strict_aliasing
+	  && ! alias_sets_conflict_p (MEM_ALIAS_SET (mem1),
+				      MEM_ALIAS_SET (mem2)));
 }
 
 /* Insert the NODE into the splay tree given by DATA.  Used by
@@ -2517,6 +2509,7 @@
 true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,
 		   const_rtx x, rtx x_addr, bool mem_canonicalized)
 {
+  rtx true_mem_addr;
   rtx base;
   int ret;
 
@@ -2536,10 +2529,26 @@
       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)
     return 1;
 
+  if (! x_addr)
+    x_addr = XEXP (x, 0);
+  x_addr = get_addr (x_addr);
+
+  if (! mem_addr)
+    {
+      mem_addr = XEXP (mem, 0);
+      if (mem_mode == VOIDmode)
+	mem_mode = GET_MODE (mem);
+    }
+  true_mem_addr = get_addr (mem_addr);
+
   /* Read-only memory is by definition never modified, and therefore can't
-     conflict with anything.  We don't expect to find read-only set on MEM,
-     but stupid user tricks can produce them, so don't die.  */
-  if (MEM_READONLY_P (x))
+     conflict with anything.  However, don't assume anything when AND
+     addresses are involved and leave to the code below to determine
+     dependence.  We don't expect to find read-only set on MEM, but
+     stupid user tricks can produce them, so don't die.  */
+  if (MEM_READONLY_P (x)
+      && GET_CODE (x_addr) != AND
+      && GET_CODE (true_mem_addr) != AND)
     return 0;
 
   /* If we have MEMs referring to different address spaces (which can
@@ -2548,29 +2557,6 @@
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  if (! mem_addr)
-    {
-      mem_addr = XEXP (mem, 0);
-      if (mem_mode == VOIDmode)
-	mem_mode = GET_MODE (mem);
-    }
-
-  if (! x_addr)
-    {
-      x_addr = XEXP (x, 0);
-      if (!((GET_CODE (x_addr) == VALUE
-	     && GET_CODE (mem_addr) != VALUE
-	     && reg_mentioned_p (x_addr, mem_addr))
-	    || (GET_CODE (x_addr) != VALUE
-		&& GET_CODE (mem_addr) == VALUE
-		&& reg_mentioned_p (mem_addr, x_addr))))
-	{
-	  x_addr = get_addr (x_addr);
-	  if (! mem_canonicalized)
-	    mem_addr = get_addr (mem_addr);
-	}
-    }
-
   base = find_base_term (x_addr);
   if (base && (GET_CODE (base) == LABEL_REF
 	       || (GET_CODE (base) == SYMBOL_REF
@@ -2577,14 +2563,14 @@
 		   && CONSTANT_POOL_ADDRESS_P (base))))
     return 0;
 
-  rtx mem_base = find_base_term (mem_addr);
-  if (! base_alias_check (x_addr, base, mem_addr, mem_base,
+  rtx mem_base = find_base_term (true_mem_addr);
+  if (! base_alias_check (x_addr, base, true_mem_addr, mem_base,
 			  GET_MODE (x), mem_mode))
     return 0;
 
   x_addr = canon_rtx (x_addr);
   if (!mem_canonicalized)
-    mem_addr = canon_rtx (mem_addr);
+    mem_addr = canon_rtx (true_mem_addr);
 
   if ((ret = memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,
 				 SIZE_FOR_MODE (x), x_addr, 0)) != -1)
@@ -2637,6 +2623,7 @@
 		    bool mem_canonicalized, bool x_canonicalized, bool writep)
 {
   rtx mem_addr;
+  rtx true_mem_addr, true_x_addr;
   rtx base;
   int ret;
 
@@ -2657,8 +2644,20 @@
       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)
     return 1;
 
-  /* A read from read-only memory can't conflict with read-write memory.  */
-  if (!writep && MEM_READONLY_P (mem))
+  if (!x_addr)
+    x_addr = XEXP (x, 0);
+  true_x_addr = get_addr (x_addr);
+
+  mem_addr = XEXP (mem, 0);
+  true_mem_addr = get_addr (mem_addr);
+
+  /* A read from read-only memory can't conflict with read-write memory.
+     Don't assume anything when AND addresses are involved and leave to
+     the code below to determine dependence.  */
+  if (!writep
+      && MEM_READONLY_P (mem)
+      && GET_CODE (true_x_addr) != AND
+      && GET_CODE (true_mem_addr) != AND)
     return 0;
 
   /* If we have MEMs referring to different address spaces (which can
@@ -2667,24 +2666,7 @@
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  mem_addr = XEXP (mem, 0);
-  if (!x_addr)
-    {
-      x_addr = XEXP (x, 0);
-      if (!((GET_CODE (x_addr) == VALUE
-	     && GET_CODE (mem_addr) != VALUE
-	     && reg_mentioned_p (x_addr, mem_addr))
-	    || (GET_CODE (x_addr) != VALUE
-		&& GET_CODE (mem_addr) == VALUE
-		&& reg_mentioned_p (mem_addr, x_addr))))
-	{
-	  x_addr = get_addr (x_addr);
-	  if (!mem_canonicalized)
-	    mem_addr = get_addr (mem_addr);
-	}
-    }
-
-  base = find_base_term (mem_addr);
+  base = find_base_term (true_mem_addr);
   if (! writep
       && base
       && (GET_CODE (base) == LABEL_REF
@@ -2692,18 +2674,18 @@
 	      && CONSTANT_POOL_ADDRESS_P (base))))
     return 0;
 
-  rtx x_base = find_base_term (x_addr);
-  if (! base_alias_check (x_addr, x_base, mem_addr, base, GET_MODE (x),
-			  GET_MODE (mem)))
+  rtx x_base = find_base_term (true_x_addr);
+  if (! base_alias_check (true_x_addr, x_base, true_mem_addr, base,
+			  GET_MODE (x), GET_MODE (mem)))
     return 0;
 
   if (!x_canonicalized)
     {
-      x_addr = canon_rtx (x_addr);
+      x_addr = canon_rtx (true_x_addr);
       x_mode = GET_MODE (x);
     }
   if (!mem_canonicalized)
-    mem_addr = canon_rtx (mem_addr);
+    mem_addr = canon_rtx (true_mem_addr);
 
   if ((ret = memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,
 				 GET_MODE_SIZE (x_mode), x_addr, 0)) != -1)
@@ -2771,10 +2753,20 @@
       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)
     return 1;
 
+  x_addr = XEXP (x, 0);
+  x_addr = get_addr (x_addr);
+
+  mem_addr = XEXP (mem, 0);
+  mem_addr = get_addr (mem_addr);
+
   /* Read-only memory is by definition never modified, and therefore can't
-     conflict with anything.  We don't expect to find read-only set on MEM,
-     but stupid user tricks can produce them, so don't die.  */
-  if (MEM_READONLY_P (x))
+     conflict with anything.  However, don't assume anything when AND
+     addresses are involved and leave to the code below to determine
+     dependence.  We don't expect to find read-only set on MEM, but
+     stupid user tricks can produce them, so don't die.  */
+  if (MEM_READONLY_P (x)
+      && GET_CODE (x_addr) != AND
+      && GET_CODE (mem_addr) != AND)
     return 0;
 
   /* If we have MEMs referring to different address spaces (which can
@@ -2783,19 +2775,6 @@
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  x_addr = XEXP (x, 0);
-  mem_addr = XEXP (mem, 0);
-  if (!((GET_CODE (x_addr) == VALUE
-	 && GET_CODE (mem_addr) != VALUE
-	 && reg_mentioned_p (x_addr, mem_addr))
-	|| (GET_CODE (x_addr) != VALUE
-	    && GET_CODE (mem_addr) == VALUE
-	    && reg_mentioned_p (mem_addr, x_addr))))
-    {
-      x_addr = get_addr (x_addr);
-      mem_addr = get_addr (mem_addr);
-    }
-
   rtx x_base = find_base_term (x_addr);
   rtx mem_base = find_base_term (mem_addr);
   if (! base_alias_check (x_addr, x_base, mem_addr, mem_base,
@@ -2802,9 +2781,6 @@
 			  GET_MODE (x), GET_MODE (mem_addr)))
     return 0;
 
-  x_addr = canon_rtx (x_addr);
-  mem_addr = canon_rtx (mem_addr);
-
   if (nonoverlapping_memrefs_p (mem, x, true))
     return 0;
 
Index: gcc/tree-vect-loop.c
===================================================================
--- a/src/gcc/tree-vect-loop.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vect-loop.c	(.../branches/gcc-4_9-branch)
@@ -1647,6 +1647,13 @@
       return false;
     }
 
+  /* Classify all cross-iteration scalar data-flow cycles.
+     Cross-iteration cycles caused by virtual phis are analyzed separately.  */
+
+  vect_analyze_scalar_cycles (loop_vinfo);
+
+  vect_pattern_recog (loop_vinfo, NULL);
+
   /* Analyze the access patterns of the data-refs in the loop (consecutive,
      complex, etc.). FORNOW: Only handle consecutive access pattern.  */
 
@@ -1659,13 +1666,6 @@
       return false;
     }
 
-  /* Classify all cross-iteration scalar data-flow cycles.
-     Cross-iteration cycles caused by virtual phis are analyzed separately.  */
-
-  vect_analyze_scalar_cycles (loop_vinfo);
-
-  vect_pattern_recog (loop_vinfo, NULL);
-
   /* Data-flow analysis to detect stmts that do not need to be vectorized.  */
 
   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);
@@ -2801,6 +2801,11 @@
      statements.  */
 
   scalar_single_iter_cost = vect_get_single_scalar_iteration_cost (loop_vinfo);
+  /* ???  Below we use this cost as number of stmts with scalar_stmt cost,
+     thus divide by that.  This introduces rounding errors, thus better
+     introduce a new cost kind (raw_cost?  scalar_iter_cost?). */
+  int scalar_single_iter_stmts
+    = scalar_single_iter_cost / vect_get_stmt_cost (scalar_stmt);
 
   /* Add additional cost for the peeled instructions in prologue and epilogue
      loop.
@@ -2835,10 +2840,10 @@
       /* FORNOW: Don't attempt to pass individual scalar instructions to
 	 the model; just assume linear cost for scalar iterations.  */
       (void) add_stmt_cost (target_cost_data,
-			    peel_iters_prologue * scalar_single_iter_cost,
+			    peel_iters_prologue * scalar_single_iter_stmts,
 			    scalar_stmt, NULL, 0, vect_prologue);
       (void) add_stmt_cost (target_cost_data, 
-			    peel_iters_epilogue * scalar_single_iter_cost,
+			    peel_iters_epilogue * scalar_single_iter_stmts,
 			    scalar_stmt, NULL, 0, vect_epilogue);
     }
   else
@@ -2854,7 +2859,7 @@
 
       (void) vect_get_known_peeling_cost (loop_vinfo, peel_iters_prologue,
 					  &peel_iters_epilogue,
-					  scalar_single_iter_cost,
+					  scalar_single_iter_stmts,
 					  &prologue_cost_vec,
 					  &epilogue_cost_vec);
 
@@ -4521,7 +4526,10 @@
                            && !STMT_VINFO_LIVE_P (exit_phi_vinfo))
                           || double_reduc);
 
-              STMT_VINFO_VEC_STMT (exit_phi_vinfo) = epilog_stmt;
+	      if (double_reduc)
+		STMT_VINFO_VEC_STMT (exit_phi_vinfo) = inner_phi;
+	      else
+		STMT_VINFO_VEC_STMT (exit_phi_vinfo) = epilog_stmt;
               if (!double_reduc
                   || STMT_VINFO_DEF_TYPE (exit_phi_vinfo)
                       != vect_double_reduction_def)
@@ -4901,6 +4909,12 @@
   if (!vectype_in)
     vectype_in = tem;
   gcc_assert (is_simple_use);
+  if (!found_nested_cycle_def)
+    reduc_def_stmt = def_stmt;
+
+  if (reduc_def_stmt && gimple_code (reduc_def_stmt) != GIMPLE_PHI)
+    return false;
+
   if (!(dt == vect_reduction_def
 	|| dt == vect_nested_cycle
 	|| ((dt == vect_internal_def || dt == vect_external_def
@@ -4913,10 +4927,7 @@
       gcc_assert (orig_stmt);
       return false;
     }
-  if (!found_nested_cycle_def)
-    reduc_def_stmt = def_stmt;
 
-  gcc_assert (gimple_code (reduc_def_stmt) == GIMPLE_PHI);
   if (orig_stmt)
     gcc_assert (orig_stmt == vect_is_simple_reduction (loop_vinfo,
                                                        reduc_def_stmt,
Index: gcc/ipa.c
===================================================================
--- a/src/gcc/ipa.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ipa.c	(.../branches/gcc-4_9-branch)
@@ -364,9 +364,17 @@
 	      && DECL_ABSTRACT_ORIGIN (node->decl))
 	    {
 	      struct cgraph_node *origin_node
-	      = cgraph_get_create_node (DECL_ABSTRACT_ORIGIN (node->decl));
-	      origin_node->used_as_abstract_origin = true;
-	      enqueue_node (origin_node, &first, reachable);
+	      = cgraph_get_node (DECL_ABSTRACT_ORIGIN (node->decl));
+	      if (origin_node && !origin_node->used_as_abstract_origin)
+		{
+	          origin_node->used_as_abstract_origin = true;
+		  gcc_assert (!origin_node->prev_sibling_clone);
+		  gcc_assert (!origin_node->next_sibling_clone);
+		  for (cgraph_node *n = origin_node->clones; n;
+		       n = n->next_sibling_clone)
+		    if (n->decl == DECL_ABSTRACT_ORIGIN (node->decl))
+		      n->used_as_abstract_origin = true;
+		}
 	    }
 	  /* If any symbol in a comdat group is reachable, force
 	     all externally visible symbols in the same comdat
Index: gcc/tree-data-ref.c
===================================================================
--- a/src/gcc/tree-data-ref.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-data-ref.c	(.../branches/gcc-4_9-branch)
@@ -663,6 +663,9 @@
 
     case SSA_NAME:
       {
+	if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))
+	  return false;
+
 	gimple def_stmt = SSA_NAME_DEF_STMT (op0);
 	enum tree_code subcode;
 
@@ -970,6 +973,24 @@
 				fold_convert (ssizetype, memoff));
 	      memoff = build_int_cst (TREE_TYPE (memoff), 0);
 	    }
+	  /* Adjust the offset so it is a multiple of the access type
+	     size and thus we separate bases that can possibly be used
+	     to produce partial overlaps (which the access_fn machinery
+	     cannot handle).  */
+	  double_int rem;
+	  if (TYPE_SIZE_UNIT (TREE_TYPE (ref))
+	      && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (ref))) == INTEGER_CST
+	      && !integer_zerop (TYPE_SIZE_UNIT (TREE_TYPE (ref))))
+	    rem = tree_to_double_int (off).mod
+		(tree_to_double_int (TYPE_SIZE_UNIT (TREE_TYPE (ref))), false,
+		 TRUNC_MOD_EXPR);
+	  else
+	    /* If we can't compute the remainder simply force the initial
+	       condition to zero.  */
+	    rem = tree_to_double_int (off);
+	  off = double_int_to_tree (ssizetype, tree_to_double_int (off) - rem);
+	  memoff = double_int_to_tree (TREE_TYPE (memoff), rem);
+	  /* And finally replace the initial condition.  */
 	  access_fn = chrec_replace_initial_condition
 	      (access_fn, fold_convert (orig_type, off));
 	  /* ???  This is still not a suitable base object for
Index: gcc/tree-vect-data-refs.c
===================================================================
--- a/src/gcc/tree-vect-data-refs.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vect-data-refs.c	(.../branches/gcc-4_9-branch)
@@ -1150,10 +1150,13 @@
     }
 
   single_iter_cost = vect_get_single_scalar_iteration_cost (loop_vinfo);
-  outside_cost += vect_get_known_peeling_cost (loop_vinfo, elem->npeel,
-					       &dummy, single_iter_cost,
-					       &prologue_cost_vec,
-					       &epilogue_cost_vec);
+  outside_cost += vect_get_known_peeling_cost
+    (loop_vinfo, elem->npeel, &dummy,
+     /* ???  We use this cost as number of stmts with scalar_stmt cost,
+	thus divide by that.  This introduces rounding errors, thus better 
+	introduce a new cost kind (raw_cost?  scalar_iter_cost?). */
+     single_iter_cost / vect_get_stmt_cost (scalar_stmt),
+     &prologue_cost_vec, &epilogue_cost_vec);
 
   /* Prologue and epilogue costs are added to the target model later.
      These costs depend only on the scalar iteration cost, the
Index: gcc/trans-mem.c
===================================================================
--- a/src/gcc/trans-mem.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/trans-mem.c	(.../branches/gcc-4_9-branch)
@@ -164,6 +164,9 @@
 static tree
 get_attrs_for (const_tree x)
 {
+  if (x == NULL_TREE)
+    return NULL_TREE;
+
   switch (TREE_CODE (x))
     {
     case FUNCTION_DECL:
@@ -172,16 +175,16 @@
 
     default:
       if (TYPE_P (x))
-	return NULL;
+	return NULL_TREE;
       x = TREE_TYPE (x);
       if (TREE_CODE (x) != POINTER_TYPE)
-	return NULL;
+	return NULL_TREE;
       /* FALLTHRU */
 
     case POINTER_TYPE:
       x = TREE_TYPE (x);
       if (TREE_CODE (x) != FUNCTION_TYPE && TREE_CODE (x) != METHOD_TYPE)
-	return NULL;
+	return NULL_TREE;
       /* FALLTHRU */
 
     case FUNCTION_TYPE:
Index: gcc/ipa-inline-analysis.c
===================================================================
--- a/src/gcc/ipa-inline-analysis.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ipa-inline-analysis.c	(.../branches/gcc-4_9-branch)
@@ -861,9 +861,19 @@
 	}
       if (c->code == IS_NOT_CONSTANT || c->code == CHANGED)
 	continue;
-      res = fold_binary_to_constant (c->code, boolean_type_node, val, c->val);
-      if (res && integer_zerop (res))
-	continue;
+
+      if (operand_equal_p (TYPE_SIZE (TREE_TYPE (c->val)),
+			   TYPE_SIZE (TREE_TYPE (val)), 0))
+	{
+	  val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);
+
+	  res = val
+	    ? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)
+	    : NULL;
+
+	  if (res && integer_zerop (res))
+	    continue;
+	}
       clause |= 1 << (i + predicate_first_dynamic_condition);
     }
   return clause;
Index: gcc/expmed.c
===================================================================
--- a/src/gcc/expmed.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/expmed.c	(.../branches/gcc-4_9-branch)
@@ -463,7 +463,7 @@
   /* Check for cases where the C++ memory model applies.  */
   if (bitregion_end != 0
       && (bitnum - bitnum % modesize < bitregion_start
-	  || bitnum - bitnum % modesize + modesize > bitregion_end))
+	  || bitnum - bitnum % modesize + modesize - 1 > bitregion_end))
     return false;
 
   return true;
@@ -3321,6 +3321,9 @@
       enum mult_variant variant;
       struct algorithm algorithm;
 
+      if (coeff == 0)
+	return CONST0_RTX (mode);
+
       /* Special case powers of two.  */
       if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))
 	{
Index: gcc/simplify-rtx.c
===================================================================
--- a/src/gcc/simplify-rtx.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/simplify-rtx.c	(.../branches/gcc-4_9-branch)
@@ -3633,7 +3633,21 @@
 	  while (GET_MODE (vec) != mode
 		 && GET_CODE (vec) == VEC_CONCAT)
 	    {
-	      HOST_WIDE_INT vec_size = GET_MODE_SIZE (GET_MODE (XEXP (vec, 0)));
+	      HOST_WIDE_INT vec_size;
+
+	      if (CONST_INT_P (XEXP (vec, 0)))
+	        {
+	          /* vec_concat of two const_ints doesn't make sense with
+	             respect to modes.  */
+	          if (CONST_INT_P (XEXP (vec, 1)))
+	            return 0;
+
+	          vec_size = GET_MODE_SIZE (GET_MODE (trueop0))
+	                     - GET_MODE_SIZE (GET_MODE (XEXP (vec, 1)));
+	        }
+	      else
+	        vec_size = GET_MODE_SIZE (GET_MODE (XEXP (vec, 0)));
+
 	      if (offset < vec_size)
 		vec = XEXP (vec, 0);
 	      else
Index: gcc/tree-predcom.c
===================================================================
--- a/src/gcc/tree-predcom.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-predcom.c	(.../branches/gcc-4_9-branch)
@@ -1391,8 +1391,8 @@
     off = size_binop (PLUS_EXPR, off,
 		      size_binop (MULT_EXPR, DR_STEP (dr), ssize_int (iter)));
   tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);
-  addr = force_gimple_operand_1 (addr, stmts, is_gimple_mem_ref_addr,
-				 NULL_TREE);
+  addr = force_gimple_operand_1 (unshare_expr (addr), stmts,
+				 is_gimple_mem_ref_addr, NULL_TREE);
   tree alias_ptr = fold_convert (reference_alias_ptr_type (DR_REF (dr)), coff);
   /* While data-ref analysis punts on bit offsets it still handles
      bitfield accesses at byte boundaries.  Cope with that.  Note that
@@ -1715,9 +1715,8 @@
   if (chain->combined)
     {
       /* For combined chains, just remove the statements that are used to
-	 compute the values of the expression (except for the root one).  */
-      for (i = 1; chain->refs.iterate (i, &a); i++)
-	remove_stmt (a->stmt);
+	 compute the values of the expression (except for the root one).
+	 We delay this until after all chains are processed.  */
     }
   else
     {
@@ -1746,9 +1745,21 @@
 
   FOR_EACH_VEC_ELT (chains, i, chain)
     {
-      if (chain->type == CT_INVARIANT || chain->combined)
+      if (chain->type == CT_INVARIANT)
 	continue;
 
+      if (chain->combined)
+	{
+	  /* For combined chains, we can't handle unrolling if we replace
+	     looparound PHIs.  */
+	  dref a;
+	  unsigned j;
+	  for (j = 1; chain->refs.iterate (j, &a); j++)
+	    if (gimple_code (a->stmt) == GIMPLE_PHI)
+	      return 1;
+	  continue;
+	}
+
       /* The best unroll factor for this chain is equal to the number of
 	 temporary variables that we create for it.  */
       af = chain->length;
@@ -1781,6 +1792,21 @@
 	execute_pred_commoning_chain (loop, chain, tmp_vars);
     }
 
+  FOR_EACH_VEC_ELT (chains, i, chain)
+    {
+      if (chain->type == CT_INVARIANT)
+	;
+      else if (chain->combined)
+	{
+	  /* For combined chains, just remove the statements that are used to
+	     compute the values of the expression (except for the root one).  */
+	  dref a;
+	  unsigned j;
+	  for (j = 1; chain->refs.iterate (j, &a); j++)
+	    remove_stmt (a->stmt);
+	}
+    }
+
   update_ssa (TODO_update_ssa_only_virtuals);
 }
 
Index: gcc/ubsan.c
===================================================================
--- a/src/gcc/ubsan.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ubsan.c	(.../branches/gcc-4_9-branch)
@@ -47,6 +47,7 @@
 #include "asan.h"
 #include "gimplify-me.h"
 #include "intl.h"
+#include "tree-eh.h"
 
 /* Map from a tree to a VAR_DECL tree.  */
 
@@ -807,7 +808,9 @@
       || TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)
     return;
 
+  bool can_throw = stmt_could_throw_p (stmt);
   location_t loc = gimple_location (stmt);
+  tree lhs = gimple_assign_lhs (stmt);
   tree ptype = build_pointer_type (TREE_TYPE (rhs));
   tree atype = reference_alias_ptr_type (rhs);
   gimple g = gimple_build_assign (make_ssa_name (ptype, NULL),
@@ -817,9 +820,24 @@
   tree mem = build2 (MEM_REF, utype, gimple_assign_lhs (g),
 		     build_int_cst (atype, 0));
   tree urhs = make_ssa_name (utype, NULL);
-  g = gimple_build_assign (urhs, mem);
-  gimple_set_location (g, loc);
-  gsi_insert_before (gsi, g, GSI_SAME_STMT);
+  if (can_throw)
+    {
+      gimple_assign_set_lhs (stmt, urhs);
+      g = gimple_build_assign_with_ops (NOP_EXPR, lhs, urhs, NULL_TREE);
+      gimple_set_location (g, loc);
+      edge e = find_fallthru_edge (gimple_bb (stmt)->succs);
+      gsi_insert_on_edge_immediate (e, g);
+      gimple_assign_set_rhs_from_tree (gsi, mem);
+      update_stmt (stmt);
+      *gsi = gsi_for_stmt (g);
+      g = stmt;
+    }
+  else
+    {
+      g = gimple_build_assign (urhs, mem);
+      gimple_set_location (g, loc);
+      gsi_insert_before (gsi, g, GSI_SAME_STMT);
+    }
   minv = fold_convert (utype, minv);
   maxv = fold_convert (utype, maxv);
   if (!integer_zerop (minv))
@@ -841,8 +859,11 @@
   gimple_set_location (g, loc);
   gsi_insert_after (gsi, g, GSI_NEW_STMT);
 
-  gimple_assign_set_rhs_with_ops (&gsi2, NOP_EXPR, urhs, NULL_TREE);
-  update_stmt (stmt);
+  if (!can_throw)
+    {
+      gimple_assign_set_rhs_with_ops (&gsi2, NOP_EXPR, urhs, NULL_TREE);
+      update_stmt (stmt);
+    }
 
   tree data = ubsan_create_data ("__ubsan_invalid_value_data",
 				 &loc, NULL,
Index: gcc/tree-ssa-forwprop.c
===================================================================
--- a/src/gcc/tree-ssa-forwprop.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-forwprop.c	(.../branches/gcc-4_9-branch)
@@ -1534,7 +1534,8 @@
 	  use_operand_p use_p;
 
 	  if (!tree_fits_shwi_p (val2)
-	      || !tree_fits_uhwi_p (len2))
+	      || !tree_fits_uhwi_p (len2)
+	      || compare_tree_int (len2, 1024) == 1)
 	    break;
 	  if (is_gimple_call (stmt1))
 	    {
@@ -1600,7 +1601,8 @@
 	     is not constant, or is bigger than memcpy length, bail out.  */
 	  if (diff == NULL
 	      || !tree_fits_uhwi_p (diff)
-	      || tree_int_cst_lt (len1, diff))
+	      || tree_int_cst_lt (len1, diff)
+	      || compare_tree_int (diff, 1024) == 1)
 	    break;
 
 	  /* Use maximum of difference plus memset length and memcpy length
@@ -3178,7 +3180,9 @@
 	  && (INTEGRAL_TYPE_P (TREE_TYPE (def_op))
 	      || POINTER_TYPE_P (TREE_TYPE (def_op)))
 	  && (TYPE_PRECISION (TREE_TYPE (op))
-	      == TYPE_PRECISION (TREE_TYPE (def_op))))
+	      == TYPE_PRECISION (TREE_TYPE (def_op)))
+	  && (TYPE_SIZE (TREE_TYPE (op))
+	      == TYPE_SIZE (TREE_TYPE (def_op))))
 	{
 	  TREE_OPERAND (gimple_assign_rhs1 (stmt), 0) = def_op;
 	  update_stmt (stmt);
Index: gcc/graphite-clast-to-gimple.c
===================================================================
--- a/src/gcc/graphite-clast-to-gimple.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-clast-to-gimple.c	(.../branches/gcc-4_9-branch)
@@ -30,7 +30,12 @@
 #include <isl/aff.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/lp.h>
+#include <isl/deprecated/ilp_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: gcc/common.opt
===================================================================
--- a/src/gcc/common.opt	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/common.opt	(.../branches/gcc-4_9-branch)
@@ -1745,6 +1745,11 @@
 Common Ignore
 Does nothing. Preserved for backward compatibility.
 
+flifetime-dse
+Common Report Var(flag_lifetime_dse) Init(1) Optimization
+Tell DSE that the storage for a C++ object is dead when the constructor
+starts and when the destructor finishes.
+
 flive-range-shrinkage
 Common Report Var(flag_live_range_shrinkage) Init(0) Optimization
 Relief of register pressure through live range shrinkage
Index: gcc/graphite-optimize-isl.c
===================================================================
--- a/src/gcc/graphite-optimize-isl.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-optimize-isl.c	(.../branches/gcc-4_9-branch)
@@ -28,7 +28,11 @@
 #include <isl/band.h>
 #include <isl/aff.h>
 #include <isl/options.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/aff_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
@@ -373,7 +377,11 @@
 	{
 	  for (i = ScheduleDimensions - 1 ;  i >= 0 ; i--)
 	    {
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+	      if (isl_band_member_is_coincident (Band, i))
+#else
 	      if (isl_band_member_is_zero_distance (Band, i))
+#endif
 		{
 		  isl_map *TileMap;
 		  isl_union_map *TileUMap;
Index: gcc/varasm.c
===================================================================
--- a/src/gcc/varasm.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/varasm.c	(.../branches/gcc-4_9-branch)
@@ -95,11 +95,6 @@
 
 bool first_function_block_is_cold;
 
-/* We give all constants their own alias set.  Perhaps redundant with
-   MEM_READONLY_P, but pre-dates it.  */
-
-static alias_set_type const_alias_set;
-
 /* Whether we saw any functions with no_split_stack.  */
 
 static bool saw_no_split_stack;
@@ -3250,7 +3245,6 @@
   rtl = gen_const_mem (TYPE_MODE (TREE_TYPE (exp)), symbol);
   set_mem_attributes (rtl, exp, 1);
   set_mem_alias_set (rtl, 0);
-  set_mem_alias_set (rtl, const_alias_set);
 
   /* We cannot share RTX'es in pool entries.
      Mark this piece of RTL as required for unsharing.  */
@@ -5957,7 +5951,6 @@
   const_desc_htab = htab_create_ggc (1009, const_desc_hash,
 				     const_desc_eq, NULL);
 
-  const_alias_set = new_alias_set ();
   shared_constant_pool = create_constant_pool ();
 
 #ifdef TEXT_SECTION_ASM_OP
@@ -6964,7 +6957,13 @@
     fputs (ASM_APP_OFF, asm_out_file);
 
   if (targetm.asm_file_start_file_directive)
-    output_file_directive (asm_out_file, main_input_filename);
+    {
+      /* LTO produced units have no meaningful main_input_filename.  */
+      if (in_lto_p)
+	output_file_directive (asm_out_file, "<artificial>");
+      else
+	output_file_directive (asm_out_file, main_input_filename);
+    }
 }
 
 /* This is a generic routine suitable for use as TARGET_ASM_FILE_END
Index: gcc/ira.c
===================================================================
--- a/src/gcc/ira.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ira.c	(.../branches/gcc-4_9-branch)
@@ -5347,7 +5347,18 @@
 	      ira_allocno_iterator ai;
 
 	      FOR_EACH_ALLOCNO (a, ai)
-		ALLOCNO_REGNO (a) = REGNO (ALLOCNO_EMIT_DATA (a)->reg);
+		{
+		  int old_regno = ALLOCNO_REGNO (a);
+		  int new_regno = REGNO (ALLOCNO_EMIT_DATA (a)->reg);
+
+		  ALLOCNO_REGNO (a) = new_regno;
+
+		  if (old_regno != new_regno)
+		    setup_reg_classes (new_regno, reg_preferred_class (old_regno),
+		                       reg_alternate_class (old_regno),
+		                       reg_allocno_class (old_regno));
+		}
+
 	    }
 	  else
 	    {
Index: gcc/graphite-poly.c
===================================================================
--- a/src/gcc/graphite-poly.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-poly.c	(.../branches/gcc-4_9-branch)
@@ -30,7 +30,11 @@
 #include <isl/aff.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/ilp_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: gcc/tree-vect-stmts.c
===================================================================
--- a/src/gcc/tree-vect-stmts.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vect-stmts.c	(.../branches/gcc-4_9-branch)
@@ -325,7 +325,8 @@
 
   /* changing memory.  */
   if (gimple_code (stmt) != GIMPLE_PHI)
-    if (gimple_vdef (stmt))
+    if (gimple_vdef (stmt)
+	&& !gimple_clobber_p (stmt))
       {
 	if (dump_enabled_p ())
 	  dump_printf_loc (MSG_NOTE, vect_location,
@@ -3184,7 +3185,7 @@
   set_vinfo_for_stmt (new_stmt, stmt_info);
   set_vinfo_for_stmt (stmt, NULL);
   STMT_VINFO_STMT (stmt_info) = new_stmt;
-  gsi_replace (gsi, new_stmt, false);
+  gsi_replace (gsi, new_stmt, true);
   unlink_stmt_vdef (stmt);
 
   return true;
Index: gcc/symtab.c
===================================================================
--- a/src/gcc/symtab.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/symtab.c	(.../branches/gcc-4_9-branch)
@@ -969,6 +969,7 @@
   DECL_VISIBILITY_SPECIFIED (decl) = 0;
   DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;
   TREE_PUBLIC (decl) = 0;
+  DECL_DLLIMPORT_P (decl) = 0;
   if (!DECL_RTL_SET_P (decl))
     return;
 
@@ -1222,6 +1223,7 @@
 
   /* Otherwise create a new one.  */
   new_decl = copy_node (node->decl);
+  DECL_DLLIMPORT_P (new_decl) = 0;
   DECL_NAME (new_decl) = clone_function_name (node->decl, "localalias");
   if (TREE_CODE (new_decl) == FUNCTION_DECL)
     DECL_STRUCT_FUNCTION (new_decl) = NULL;
Index: gcc/graphite-sese-to-poly.c
===================================================================
--- a/src/gcc/graphite-sese-to-poly.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-sese-to-poly.c	(.../branches/gcc-4_9-branch)
@@ -29,7 +29,12 @@
 #include <cloog/cloog.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/aff_int.h>
+#include <isl/deprecated/constraint_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: gcc/combine.c
===================================================================
--- a/src/gcc/combine.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/combine.c	(.../branches/gcc-4_9-branch)
@@ -1529,8 +1529,8 @@
       uns3 = TYPE_UNSIGNED (DECL_ARG_TYPE (arg));
 
       /* The mode and signedness of the argument as it is actually passed,
-         after any TARGET_PROMOTE_FUNCTION_ARGS-driven ABI promotions.  */
-      mode3 = promote_function_mode (DECL_ARG_TYPE (arg), mode2, &uns3,
+         see assign_parm_setup_reg in function.c.  */
+      mode3 = promote_function_mode (TREE_TYPE (arg), mode1, &uns3,
 				     TREE_TYPE (cfun->decl), 0);
 
       /* The mode of the register in which the argument is being passed.  */
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-4_9-branch)
@@ -2273,28 +2273,32 @@
 powerpc*-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h freebsd-spec.h rs6000/sysv4.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
-	tmake_file="rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-ppccomm"
 	extra_objs="$extra_objs rs6000-linux.o"
 	case ${target} in
 	    powerpc*le-*-*)
 		tm_file="${tm_file} rs6000/sysv4le.h" ;;
 	esac
-	maybe_biarch=yes
+	case ${target}:${with_cpu} in
+	    powerpc64*: | powerpc64*:native) cpu_is_64bit=yes ;;
+	esac
+	maybe_biarch=${cpu_is_64bit}
+	case ${enable_targets} in
+	    *powerpc64*) maybe_biarch=yes ;;
+	esac
 	case ${target} in
 	    powerpc64*-*-linux*spe* | powerpc64*-*-linux*paired*)
-	    	echo "*** Configuration ${target} not supported" 1>&2
+		echo "*** Configuration ${target} not supported" 1>&2
 		exit 1
 		;;
 	    powerpc*-*-linux*spe* | powerpc*-*-linux*paired*)
 		maybe_biarch=
 		;;
-	    powerpc64*-*-linux*)
-	    	test x$with_cpu != x || cpu_is_64bit=yes
-		maybe_biarch=always
-		;;
 	esac
-	case ${maybe_biarch}:${enable_targets}:${cpu_is_64bit} in
-	    always:* | yes:*powerpc64* | yes:all:* | yes:*:yes)
+	case ${target}:${enable_targets}:${maybe_biarch} in
+	    powerpc64-* | powerpc-*:*:yes | *:*powerpc64-*:yes | *:all:yes \
+	    | powerpc64le*:*powerpcle* | powerpc64le*:*powerpc-* \
+	    | powerpcle-*:*powerpc64le*:yes)
 		if test x$cpu_is_64bit = xyes; then
 		    tm_file="${tm_file} rs6000/default64.h"
 		fi
@@ -2315,9 +2319,14 @@
 		esac
 		extra_options="${extra_options} rs6000/linux64.opt"
 		;;
+	    powerpc64*)
+		tm_file="${tm_file} rs6000/default64.h rs6000/linux64.h glibc-stdint.h"
+		extra_options="${extra_options} rs6000/linux64.opt"
+		tmake_file="${tmake_file} rs6000/t-linux"
+		;;
 	    *)
 		tm_file="${tm_file} rs6000/linux.h glibc-stdint.h"
-		tmake_file="$tmake_file rs6000/t-linux"
+		tmake_file="${tmake_file} rs6000/t-ppcos rs6000/t-linux"
 		;;
 	esac
 	case ${target} in
@@ -2662,7 +2671,7 @@
 	;;
 sparc-*-rtems*)
 	tm_file="${tm_file} dbxelf.h elfos.h sparc/sysv4.h sparc/sp-elf.h sparc/rtemself.h rtems.h newlib-stdint.h"
-	tmake_file="${tmake_file} sparc/t-sparc sparc/t-elf sparc/t-rtems"
+	tmake_file="${tmake_file} sparc/t-sparc sparc/t-rtems"
 	;;
 sparc-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h sparc/sysv4.h gnu-user.h linux.h glibc-stdint.h sparc/tso.h"
@@ -3205,6 +3214,9 @@
 	*-leon[3-9]*)
 	  with_cpu=leon3
 	  ;;
+	*-leon[3-9]v7*)
+	  with_cpu=leon3v7
+	  ;;
 	*)
 	  with_cpu="`echo ${target} | sed 's/-.*$//'`"
 	  ;;
@@ -3993,7 +4005,7 @@
 			case ${val} in
 			"" | sparc | sparcv9 | sparc64 \
 			| v7 | cypress \
-			| v8 | supersparc | hypersparc | leon | leon3 \
+			| v8 | supersparc | hypersparc | leon | leon3 | leon3v7 \
 			| sparclite | f930 | f934 | sparclite86x \
 			| sparclet | tsc701 \
 			| v9 | ultrasparc | ultrasparc3 | niagara | niagara2 \
Index: gcc/ree.c
===================================================================
--- a/src/gcc/ree.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ree.c	(.../branches/gcc-4_9-branch)
@@ -261,6 +261,50 @@
 
 static int max_insn_uid;
 
+/* Update or remove REG_EQUAL or REG_EQUIV notes for INSN.  */
+
+static bool
+update_reg_equal_equiv_notes (rtx insn, enum machine_mode new_mode,
+			      enum machine_mode old_mode, enum rtx_code code)
+{
+  rtx *loc = &REG_NOTES (insn);
+  while (*loc)
+    {
+      enum reg_note kind = REG_NOTE_KIND (*loc);
+      if (kind == REG_EQUAL || kind == REG_EQUIV)
+	{
+	  rtx orig_src = XEXP (*loc, 0);
+	  /* Update equivalency constants.  Recall that RTL constants are
+	     sign-extended.  */
+	  if (GET_CODE (orig_src) == CONST_INT
+	      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (new_mode))
+	    {
+	      if (INTVAL (orig_src) >= 0 || code == SIGN_EXTEND)
+		/* Nothing needed.  */;
+	      else
+		{
+		  /* Zero-extend the negative constant by masking out the
+		     bits outside the source mode.  */
+		  rtx new_const_int
+		    = gen_int_mode (INTVAL (orig_src)
+				    & GET_MODE_MASK (old_mode),
+				    new_mode);
+		  if (!validate_change (insn, &XEXP (*loc, 0),
+					new_const_int, true))
+		    return false;
+		}
+	      loc = &XEXP (*loc, 1);
+	    }
+	  /* Drop all other notes, they assume a wrong mode.  */
+	  else if (!validate_change (insn, loc, XEXP (*loc, 1), true))
+	    return false;
+	}
+      else
+	loc = &XEXP (*loc, 1);
+    }
+  return true;
+}
+
 /* Given a insn (CURR_INSN), an extension candidate for removal (CAND)
    and a pointer to the SET rtx (ORIG_SET) that needs to be modified,
    this code modifies the SET rtx to a new SET rtx that extends the
@@ -282,6 +326,7 @@
 combine_set_extension (ext_cand *cand, rtx curr_insn, rtx *orig_set)
 {
   rtx orig_src = SET_SRC (*orig_set);
+  enum machine_mode orig_mode = GET_MODE (SET_DEST (*orig_set));
   rtx new_set;
   rtx cand_pat = PATTERN (cand->insn);
 
@@ -318,9 +363,8 @@
 	{
 	  /* Zero-extend the negative constant by masking out the bits outside
 	     the source mode.  */
-	  enum machine_mode src_mode = GET_MODE (SET_DEST (*orig_set));
 	  rtx new_const_int
-	    = gen_int_mode (INTVAL (orig_src) & GET_MODE_MASK (src_mode),
+	    = gen_int_mode (INTVAL (orig_src) & GET_MODE_MASK (orig_mode),
 			    GET_MODE (new_reg));
 	  new_set = gen_rtx_SET (VOIDmode, new_reg, new_const_int);
 	}
@@ -359,7 +403,9 @@
 
   /* This change is a part of a group of changes.  Hence,
      validate_change will not try to commit the change.  */
-  if (validate_change (curr_insn, orig_set, new_set, true))
+  if (validate_change (curr_insn, orig_set, new_set, true)
+      && update_reg_equal_equiv_notes (curr_insn, cand->mode, orig_mode,
+				       cand->code))
     {
       if (dump_file)
         {
@@ -409,7 +455,9 @@
   ifexpr = gen_rtx_IF_THEN_ELSE (cand->mode, cond, map_srcreg, map_srcreg2);
   new_set = gen_rtx_SET (VOIDmode, map_dstreg, ifexpr);
 
-  if (validate_change (def_insn, &PATTERN (def_insn), new_set, true))
+  if (validate_change (def_insn, &PATTERN (def_insn), new_set, true)
+      && update_reg_equal_equiv_notes (def_insn, cand->mode, GET_MODE (dstreg),
+				       cand->code))
     {
       if (dump_file)
         {
@@ -719,6 +767,17 @@
        != REGNO (get_extended_src_reg (SET_SRC (PATTERN (cand->insn)))));
   if (copy_needed)
     {
+      /* Considering transformation of
+	 (set (reg1) (expression))
+	 ...
+	 (set (reg2) (any_extend (reg1)))
+
+	 into
+
+	 (set (reg2) (any_extend (expression)))
+	 (set (reg1) (reg2))
+	 ...  */
+
       /* In theory we could handle more than one reaching def, it
 	 just makes the code to update the insn stream more complex.  */
       if (state->defs_list.length () != 1)
@@ -734,18 +793,6 @@
       if (state->modified[INSN_UID (cand->insn)].kind != EXT_MODIFIED_NONE)
 	return false;
 
-      /* Transformation of
-	 (set (reg1) (expression))
-	 (set (reg2) (any_extend (reg1)))
-	 into
-	 (set (reg2) (any_extend (expression)))
-	 (set (reg1) (reg2))
-	 is only valid for scalar integral modes, as it relies on the low
-	 subreg of reg1 to have the value of (expression), which is not true
-	 e.g. for vector modes.  */
-      if (!SCALAR_INT_MODE_P (GET_MODE (SET_DEST (PATTERN (cand->insn)))))
-	return false;
-
       /* There's only one reaching def.  */
       rtx def_insn = state->defs_list[0];
 
@@ -954,6 +1001,7 @@
 	 different extension.  FIXME: this obviously can be improved.  */
       for (def = defs; def; def = def->next)
 	if ((idx = def_map[INSN_UID (DF_REF_INSN (def->ref))])
+	    && idx != -1U
 	    && (cand = &(*insn_list)[idx - 1])
 	    && cand->code != code)
 	  {
@@ -965,7 +1013,58 @@
 	      }
 	    return;
 	  }
+	/* For vector mode extensions, ensure that all uses of the
+	   XEXP (src, 0) register are the same extension (both code
+	   and to which mode), as unlike integral extensions lowpart
+	   subreg of the sign/zero extended register are not equal
+	   to the original register, so we have to change all uses or
+	   none.  */
+	else if (VECTOR_MODE_P (GET_MODE (XEXP (src, 0))))
+	  {
+	    if (idx == 0)
+	      {
+		struct df_link *ref_chain, *ref_link;
 
+		ref_chain = DF_REF_CHAIN (def->ref);
+		for (ref_link = ref_chain; ref_link; ref_link = ref_link->next)
+		  {
+		    if (ref_link->ref == NULL
+			|| DF_REF_INSN_INFO (ref_link->ref) == NULL)
+		      {
+			idx = -1U;
+			break;
+		      }
+		    rtx use_insn = DF_REF_INSN (ref_link->ref);
+		    const_rtx use_set;
+		    if (use_insn == insn || DEBUG_INSN_P (use_insn))
+		      continue;
+		    if (!(use_set = single_set (use_insn))
+			|| !REG_P (SET_DEST (use_set))
+			|| GET_MODE (SET_DEST (use_set)) != GET_MODE (dest)
+			|| GET_CODE (SET_SRC (use_set)) != code
+			|| !rtx_equal_p (XEXP (SET_SRC (use_set), 0),
+					 XEXP (src, 0)))
+		      {
+			idx = -1U;
+			break;
+		      }
+		  }
+		if (idx == -1U)
+		  def_map[INSN_UID (DF_REF_INSN (def->ref))] = idx;
+	      }
+	    if (idx == -1U)
+	      {
+		if (dump_file)
+		  {
+		    fprintf (dump_file, "Cannot eliminate extension:\n");
+		    print_rtl_single (dump_file, insn);
+		    fprintf (dump_file,
+			     " because some vector uses aren't extension\n");
+		  }
+		return;
+	      }
+	  }
+
       /* Then add the candidate to the list and insert the reaching definitions
          into the definition map.  */
       ext_cand e = {expr, code, mode, insn};
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- a/src/gcc/tree-ssa-reassoc.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-reassoc.c	(.../branches/gcc-4_9-branch)
@@ -2047,7 +2047,7 @@
 	      else
 		return -1;
 	    }
-	  else if (p->high != NULL_TREE)
+	  else if (q->high != NULL_TREE)
 	    return 1;
 	  /* If both ranges are the same, sort below by ascending idx.  */
 	}
@@ -3692,6 +3692,9 @@
   switch (DECL_FUNCTION_CODE (fndecl))
     {
     CASE_FLT_FN (BUILT_IN_POW):
+      if (flag_errno_math)
+	return false;
+
       *base = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
 
Index: gcc/config/alpha/alpha.md
===================================================================
--- a/src/gcc/config/alpha/alpha.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/alpha/alpha.md	(.../branches/gcc-4_9-branch)
@@ -4496,8 +4496,8 @@
 (define_insn_and_split "reload_out<mode>_aligned"
   [(set (match_operand:I12MODE 0 "memory_operand" "=m")
         (match_operand:I12MODE 1 "register_operand" "r"))
-   (clobber (match_operand:SI 2 "register_operand" "=r"))
-   (clobber (match_operand:SI 3 "register_operand" "=r"))]
+   (clobber (match_operand:SI 2 "register_operand" "=&r"))
+   (clobber (match_operand:SI 3 "register_operand" "=&r"))]
   "!TARGET_BWX && (reload_in_progress || reload_completed)"
   "#"
   "!TARGET_BWX && reload_completed"
@@ -5984,16 +5984,38 @@
   [(set_attr "type" "jsr")
    (set_attr "length" "*,*,8")])
 
-(define_insn_and_split "call_value_osf_tlsgd"
+(define_int_iterator TLS_CALL
+	[UNSPEC_TLSGD_CALL
+	 UNSPEC_TLSLDM_CALL])
+
+(define_int_attr tls
+	[(UNSPEC_TLSGD_CALL "tlsgd")
+	 (UNSPEC_TLSLDM_CALL "tlsldm")])
+
+(define_insn "call_value_osf_<tls>"
   [(set (match_operand 0)
 	(call (mem:DI (match_operand:DI 1 "symbolic_operand"))
 	      (const_int 0)))
-   (unspec [(match_operand:DI 2 "const_int_operand")] UNSPEC_TLSGD_CALL)
+   (unspec [(match_operand:DI 2 "const_int_operand")] TLS_CALL)
    (use (reg:DI 29))
    (clobber (reg:DI 26))]
   "HAVE_AS_TLS"
-  "#"
-  "&& reload_completed"
+  "ldq $27,%1($29)\t\t!literal!%2\;jsr $26,($27),%1\t\t!lituse_<tls>!%2\;ldah $29,0($26)\t\t!gpdisp!%*\;lda $29,0($29)\t\t!gpdisp!%*"
+  [(set_attr "type" "jsr")
+   (set_attr "length" "16")])
+
+;; We must use peep2 instead of a split because we need accurate life
+;; information for $gp.
+(define_peephole2
+  [(parallel
+    [(set (match_operand 0)
+	  (call (mem:DI (match_operand:DI 1 "symbolic_operand"))
+		(const_int 0)))
+     (unspec [(match_operand:DI 2 "const_int_operand")] TLS_CALL)
+     (use (reg:DI 29))
+     (clobber (reg:DI 26))])]
+  "HAVE_AS_TLS && reload_completed
+   && peep2_regno_dead_p (1, 29)"
   [(set (match_dup 3)
 	(unspec:DI [(match_dup 5)
 		    (match_dup 1)
@@ -6001,10 +6023,9 @@
    (parallel [(set (match_dup 0)
 		   (call (mem:DI (match_dup 3))
 			 (const_int 0)))
-	      (set (match_dup 5)
-		   (unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP1))
+	      (use (match_dup 5))
 	      (use (match_dup 1))
-	      (use (unspec [(match_dup 2)] UNSPEC_TLSGD_CALL))
+	      (use (unspec [(match_dup 2)] TLS_CALL))
 	      (clobber (reg:DI 26))])
    (set (match_dup 5)
 	(unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP2))]
@@ -6012,19 +6033,18 @@
   operands[3] = gen_rtx_REG (Pmode, 27);
   operands[4] = GEN_INT (alpha_next_sequence_number++);
   operands[5] = pic_offset_table_rtx;
-}
-  [(set_attr "type" "multi")])
+})
 
-(define_insn_and_split "call_value_osf_tlsldm"
-  [(set (match_operand 0)
-	(call (mem:DI (match_operand:DI 1 "symbolic_operand"))
-	      (const_int 0)))
-   (unspec [(match_operand:DI 2 "const_int_operand")] UNSPEC_TLSLDM_CALL)
-   (use (reg:DI 29))
-   (clobber (reg:DI 26))]
-  "HAVE_AS_TLS"
-  "#"
-  "&& reload_completed"
+(define_peephole2
+  [(parallel
+    [(set (match_operand 0)
+	  (call (mem:DI (match_operand:DI 1 "symbolic_operand"))
+		(const_int 0)))
+     (unspec [(match_operand:DI 2 "const_int_operand")] TLS_CALL)
+     (use (reg:DI 29))
+     (clobber (reg:DI 26))])]
+  "HAVE_AS_TLS && reload_completed
+   && !peep2_regno_dead_p (1, 29)"
   [(set (match_dup 3)
 	(unspec:DI [(match_dup 5)
 		    (match_dup 1)
@@ -6035,7 +6055,7 @@
 	      (set (match_dup 5)
 		   (unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP1))
 	      (use (match_dup 1))
-	      (use (unspec [(match_dup 2)] UNSPEC_TLSLDM_CALL))
+	      (use (unspec [(match_dup 2)] TLS_CALL))
 	      (clobber (reg:DI 26))])
    (set (match_dup 5)
 	(unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP2))]
@@ -6043,8 +6063,7 @@
   operands[3] = gen_rtx_REG (Pmode, 27);
   operands[4] = GEN_INT (alpha_next_sequence_number++);
   operands[5] = pic_offset_table_rtx;
-}
-  [(set_attr "type" "multi")])
+})
 
 (define_insn "*call_value_osf_1"
   [(set (match_operand 0)
Index: gcc/config/s390/s390.c
===================================================================
--- a/src/gcc/config/s390/s390.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/s390/s390.c	(.../branches/gcc-4_9-branch)
@@ -436,25 +436,10 @@
    bytes on a z10 (or higher) CPU.  */
 #define PREDICT_DISTANCE (TARGET_Z10 ? 384 : 2048)
 
-static const int s390_hotpatch_trampoline_halfwords_default = 12;
-static const int s390_hotpatch_trampoline_halfwords_max = 1000000;
-static int s390_hotpatch_trampoline_halfwords = -1;
+static const int s390_hotpatch_hw_max = 1000000;
+static int s390_hotpatch_hw_before_label = 0;
+static int s390_hotpatch_hw_after_label = 0;
 
-/* Return the argument of the given hotpatch attribute or the default value if
-   no argument is present.  */
-
-static inline int
-get_hotpatch_attribute (tree hotpatch_attr)
-{
-  const_tree args;
-
-  args = TREE_VALUE (hotpatch_attr);
-
-  return (args) ?
-    TREE_INT_CST_LOW (TREE_VALUE (args)):
-    s390_hotpatch_trampoline_halfwords_default;
-}
-
 /* Check whether the hotpatch attribute is applied to a function and, if it has
    an argument, the argument is valid.  */
 
@@ -462,6 +447,10 @@
 s390_handle_hotpatch_attribute (tree *node, tree name, tree args,
 				int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
 {
+  tree expr;
+  tree expr2;
+  int err;
+
   if (TREE_CODE (*node) != FUNCTION_DECL)
     {
       warning (OPT_Wattributes, "%qE attribute only applies to functions",
@@ -468,28 +457,38 @@
 	       name);
       *no_add_attrs = true;
     }
-  else if (args)
+  if (args != NULL && TREE_CHAIN (args) != NULL)
     {
-      tree expr = TREE_VALUE (args);
-
-      if (TREE_CODE (expr) != INTEGER_CST
-	  || !INTEGRAL_TYPE_P (TREE_TYPE (expr))
-	  || TREE_INT_CST_HIGH (expr) != 0
-	  || TREE_INT_CST_LOW (expr) > (unsigned int)
-	  s390_hotpatch_trampoline_halfwords_max)
-	{
-	  error ("requested %qE attribute is not a non-negative integer"
-		 " constant or too large (max. %d)", name,
-		 s390_hotpatch_trampoline_halfwords_max);
-	  *no_add_attrs = true;
-	}
+      expr = TREE_VALUE (args);
+      expr2 = TREE_VALUE (TREE_CHAIN (args));
     }
+  if (args == NULL || TREE_CHAIN (args) == NULL)
+    err = 1;
+  else if (TREE_CODE (expr) != INTEGER_CST
+	   || !INTEGRAL_TYPE_P (TREE_TYPE (expr))
+	   || TREE_INT_CST_HIGH (expr) != 0
+	   || TREE_INT_CST_LOW (expr) > (unsigned int)s390_hotpatch_hw_max)
+    err = 1;
+  else if (TREE_CODE (expr2) != INTEGER_CST
+	   || !INTEGRAL_TYPE_P (TREE_TYPE (expr2))
+	   || TREE_INT_CST_HIGH (expr2) != 0
+	   || TREE_INT_CST_LOW (expr2) > (unsigned int)s390_hotpatch_hw_max)
+    err = 1;
+  else
+    err = 0;
+  if (err)
+    {
+      error ("requested %qE attribute is not a comma separated pair of"
+	     " non-negative integer constants or too large (max. %d)", name,
+	     s390_hotpatch_hw_max);
+      *no_add_attrs = true;
+    }
 
   return NULL_TREE;
 }
 
 static const struct attribute_spec s390_attribute_table[] = {
-  { "hotpatch", 0, 1, true, false, false, s390_handle_hotpatch_attribute, false
+  { "hotpatch", 2, 2, true, false, false, s390_handle_hotpatch_attribute, false
   },
   /* End element.  */
   { NULL,        0, 0, false, false, false, NULL, false }
@@ -2384,16 +2383,29 @@
 /* Implement TARGET_REGISTER_MOVE_COST.  */
 
 static int
-s390_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,
+s390_register_move_cost (enum machine_mode mode,
                          reg_class_t from, reg_class_t to)
 {
-  /* On s390, copy between fprs and gprs is expensive as long as no
-     ldgr/lgdr can be used.  */
-  if ((!TARGET_Z10 || GET_MODE_SIZE (mode) != 8)
-      && ((reg_classes_intersect_p (from, GENERAL_REGS)
-	   && reg_classes_intersect_p (to, FP_REGS))
-	  || (reg_classes_intersect_p (from, FP_REGS)
-	      && reg_classes_intersect_p (to, GENERAL_REGS))))
+  /* On s390, copy between fprs and gprs is expensive.  */
+
+  /* It becomes somewhat faster having ldgr/lgdr.  */
+  if (TARGET_Z10 && GET_MODE_SIZE (mode) == 8)
+    {
+      /* ldgr is single cycle. */
+      if (reg_classes_intersect_p (from, GENERAL_REGS)
+	  && reg_classes_intersect_p (to, FP_REGS))
+	return 1;
+      /* lgdr needs 3 cycles. */
+      if (reg_classes_intersect_p (to, GENERAL_REGS)
+	  && reg_classes_intersect_p (from, FP_REGS))
+	return 3;
+    }
+
+  /* Otherwise copying is done via memory.  */
+  if ((reg_classes_intersect_p (from, GENERAL_REGS)
+       && reg_classes_intersect_p (to, FP_REGS))
+      || (reg_classes_intersect_p (from, FP_REGS)
+	  && reg_classes_intersect_p (to, GENERAL_REGS)))
     return 10;
 
   return 1;
@@ -2406,7 +2418,7 @@
 		       reg_class_t rclass ATTRIBUTE_UNUSED,
 		       bool in ATTRIBUTE_UNUSED)
 {
-  return 1;
+  return 2;
 }
 
 /* Compute a (partial) cost for rtx X.  Return true if the complete
@@ -5241,53 +5253,51 @@
   gcc_unreachable ();
 }
 
-/* Returns -1 if the function should not be made hotpatchable.  Otherwise it
-   returns a number >= 0 that is the desired size of the hotpatch trampoline
-   in halfwords. */
+/* Returns false if the function should not be made hotpatchable.
+   Otherwise it assigns the number of NOP halfwords to be emitted
+   before and after the function label to hw_before and hw_after.
+   Both must not be NULL.  */
 
-static int s390_function_num_hotpatch_trampoline_halfwords (tree decl,
-							    bool do_warn)
+static bool
+s390_function_num_hotpatch_hw (tree decl,
+			       int *hw_before,
+			       int *hw_after)
 {
   tree attr;
 
-  if (DECL_DECLARED_INLINE_P (decl)
-      || DECL_ARTIFICIAL (decl)
-      || MAIN_NAME_P (DECL_NAME (decl)))
+  *hw_before = 0;
+  *hw_after = 0;
+
+  attr = lookup_attribute ("hotpatch", DECL_ATTRIBUTES (decl));
+
+  /* Handle the arguments of the hotpatch attribute.  The values
+     specified via attribute might override the cmdline argument
+     values.  */
+  if (attr)
     {
-      /* - Explicitly inlined functions cannot be hotpatched.
-	 - Artificial functions need not be hotpatched.
-	 - Making the main function hotpatchable is useless. */
-      return -1;
+      tree args = TREE_VALUE (attr);
+
+      *hw_before = TREE_INT_CST_LOW (TREE_VALUE (args));
+      *hw_after = TREE_INT_CST_LOW (TREE_VALUE (TREE_CHAIN (args)));
     }
-  attr = lookup_attribute ("hotpatch", DECL_ATTRIBUTES (decl));
-  if (attr || s390_hotpatch_trampoline_halfwords >= 0)
+  else
     {
-      if (lookup_attribute ("always_inline", DECL_ATTRIBUTES (decl)))
-	{
-	  if (do_warn)
-	    warning (OPT_Wattributes, "function %qE with the %qs attribute"
-		     " is not hotpatchable", DECL_NAME (decl), "always_inline");
-	  return -1;
-	}
-      else
-	{
-	  return (attr) ?
-	    get_hotpatch_attribute (attr) : s390_hotpatch_trampoline_halfwords;
-	}
+      /* Use the values specified by the cmdline arguments.  */
+      *hw_before = s390_hotpatch_hw_before_label;
+      *hw_after = s390_hotpatch_hw_after_label;
     }
 
-  return -1;
-}
+  if (*hw_before == 0 && *hw_after == 0)
+    return false;
 
-/* Hook to determine if one function can safely inline another.  */
+  if (decl_function_context (decl) != NULL_TREE)
+    {
+      warning_at (DECL_SOURCE_LOCATION (decl), OPT_mhotpatch_,
+		  "hotpatching is not compatible with nested functions");
+      return false;
+    }
 
-static bool
-s390_can_inline_p (tree caller, tree callee)
-{
-  if (s390_function_num_hotpatch_trampoline_halfwords (callee, false) >= 0)
-    return false;
-
-  return default_target_can_inline_p (caller, callee);
+  return true;
 }
 
 /* Write the extra assembler code needed to declare a function properly.  */
@@ -5296,29 +5306,21 @@
 s390_asm_output_function_label (FILE *asm_out_file, const char *fname,
 				tree decl)
 {
-  int hotpatch_trampoline_halfwords = -1;
+  int hw_before, hw_after;
+  bool hotpatch_p = (decl
+		     ? s390_function_num_hotpatch_hw (decl,
+						      &hw_before, &hw_after)
+		     : false);
 
-  if (decl)
+  if (hotpatch_p)
     {
-      hotpatch_trampoline_halfwords =
-	s390_function_num_hotpatch_trampoline_halfwords (decl, true);
-      if (hotpatch_trampoline_halfwords >= 0
-	  && decl_function_context (decl) != NULL_TREE)
-	{
-	  warning_at (DECL_SOURCE_LOCATION (decl), OPT_mhotpatch,
-		      "hotpatching is not compatible with nested functions");
-	  hotpatch_trampoline_halfwords = -1;
-	}
-    }
-
-  if (hotpatch_trampoline_halfwords > 0)
-    {
+      unsigned int function_alignment;
       int i;
 
       /* Add a trampoline code area before the function label and initialize it
 	 with two-byte nop instructions.  This area can be overwritten with code
 	 that jumps to a patched version of the function.  */
-      for (i = 0; i < hotpatch_trampoline_halfwords; i++)
+      for (i = 0; i < hw_before; i++)
 	asm_fprintf (asm_out_file, "\tnopr\t%%r7\n");
       /* Note:  The function label must be aligned so that (a) the bytes of the
 	 following nop do not cross a cacheline boundary, and (b) a jump address
@@ -5326,14 +5328,14 @@
 	 stored directly before the label without crossing a cacheline
 	 boundary.  All this is necessary to make sure the trampoline code can
 	 be changed atomically.  */
+      function_alignment = MAX (8, DECL_ALIGN (decl) / BITS_PER_UNIT);
+      if (! DECL_USER_ALIGN (decl))
+	function_alignment = MAX (function_alignment,
+				  (unsigned int) align_functions);
+      ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (function_alignment));
     }
 
   ASM_OUTPUT_LABEL (asm_out_file, fname);
-
-  /* Output a four-byte nop if hotpatching is enabled.  This can be overwritten
-     atomically with a relative backwards jump to the trampoline area.  */
-  if (hotpatch_trampoline_halfwords >= 0)
-    asm_fprintf (asm_out_file, "\tnop\t0\n");
 }
 
 /* Output machine-dependent UNSPECs occurring in address constant X
@@ -11311,6 +11313,7 @@
 s390_reorg (void)
 {
   bool pool_overflow = false;
+  int hw_before, hw_after;
 
   /* Make sure all splits have been performed; splits after
      machine_dependent_reorg might confuse insn length counts.  */
@@ -11445,6 +11448,40 @@
       if (insn_added_p)
 	shorten_branches (get_insns ());
     }
+
+  s390_function_num_hotpatch_hw (current_function_decl, &hw_before, &hw_after);
+  if (hw_after > 0)
+    {
+      rtx insn;
+
+      /* Inject nops for hotpatching. */
+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+	{
+	  if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG)
+	    break;
+	}
+      gcc_assert (insn);
+      /* Output a series of NOPs after the NOTE_INSN_FUNCTION_BEG.  */
+      while (hw_after > 0)
+	{
+	  if (hw_after >= 3 && TARGET_CPU_ZARCH)
+	    {
+	      insn = emit_insn_after (gen_nop_6_byte (), insn);
+	      hw_after -= 3;
+	    }
+	  else if (hw_after >= 2)
+	    {
+	      insn = emit_insn_after (gen_nop_4_byte (), insn);
+	      hw_after -= 2;
+	    }
+	  else
+	    {
+	      insn = emit_insn_after (gen_nop_2_byte (), insn);
+	      hw_after -= 1;
+	    }
+	}
+      gcc_assert (hw_after == 0);
+    }
 }
 
 /* Return true if INSN is a fp load insn writing register REGNO.  */
@@ -11850,29 +11887,44 @@
       {
 	switch (opt->opt_index)
 	  {
-	  case OPT_mhotpatch:
-	    s390_hotpatch_trampoline_halfwords = (opt->value) ?
-	      s390_hotpatch_trampoline_halfwords_default : -1;
-	    break;
 	  case OPT_mhotpatch_:
 	    {
-	      int val;
+	      int val1;
+	      int val2;
+	      char s[256];
+	      char *t;
 
-	      val = integral_argument (opt->arg);
-	      if (val == -1)
+	      strncpy (s, opt->arg, 256);
+	      s[255] = 0;
+	      t = strchr (s, ',');
+	      if (t != NULL)
 		{
+		  *t = 0;
+		  t++;
+		  val1 = integral_argument (s);
+		  val2 = integral_argument (t);
+		}
+	      else
+		{
+		  val1 = -1;
+		  val2 = -1;
+		}
+	      if (val1 == -1 || val2 == -1)
+		{
 		  /* argument is not a plain number */
-		  error ("argument to %qs should be a non-negative integer",
-			 "-mhotpatch=");
+		  error ("arguments to %qs should be non-negative integers",
+			 "-mhotpatch=n,m");
 		  break;
 		}
-	      else if (val > s390_hotpatch_trampoline_halfwords_max)
+	      else if (val1 > s390_hotpatch_hw_max
+		       || val2 > s390_hotpatch_hw_max)
 		{
 		  error ("argument to %qs is too large (max. %d)",
-			 "-mhotpatch=", s390_hotpatch_trampoline_halfwords_max);
+			 "-mhotpatch=n,m", s390_hotpatch_hw_max);
 		  break;
 		}
-	      s390_hotpatch_trampoline_halfwords = val;
+	      s390_hotpatch_hw_before_label = val1;
+	      s390_hotpatch_hw_after_label = val2;
 	      break;
 	    }
 	  default:
@@ -12242,8 +12294,8 @@
 #undef TARGET_ATTRIBUTE_TABLE
 #define TARGET_ATTRIBUTE_TABLE s390_attribute_table
 
-#undef TARGET_CAN_INLINE_P
-#define TARGET_CAN_INLINE_P s390_can_inline_p
+#undef TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P
+#define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P hook_bool_const_tree_true
 
 #undef TARGET_SET_UP_BY_PROLOGUE
 #define TARGET_SET_UP_BY_PROLOGUE s300_set_up_by_prologue
Index: gcc/config/s390/s390.md
===================================================================
--- a/src/gcc/config/s390/s390.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/s390/s390.md	(.../branches/gcc-4_9-branch)
@@ -153,6 +153,11 @@
    UNSPECV_CAS
    UNSPECV_ATOMIC_OP
 
+   ; Hotpatching (unremovable NOPs)
+   UNSPECV_NOP_2_BYTE
+   UNSPECV_NOP_4_BYTE
+   UNSPECV_NOP_6_BYTE
+
    ; Transactional Execution support
    UNSPECV_TBEGIN
    UNSPECV_TBEGIN_TDB
@@ -460,7 +465,7 @@
 ;; This iterator and attribute allow to combine most atomic operations.
 (define_code_iterator ATOMIC [and ior xor plus minus mult])
 (define_code_iterator ATOMIC_Z196 [and ior xor plus])
-(define_code_attr atomic [(and "and") (ior "ior") (xor "xor")
+(define_code_attr atomic [(and "and") (ior "or") (xor "xor")
 			  (plus "add") (minus "sub") (mult "nand")])
 (define_code_attr noxa [(and "n") (ior "o") (xor "x") (plus "a")])
 
@@ -9634,7 +9639,27 @@
   "lr\t1,1"
   [(set_attr "op_type" "RR")])
 
+;;- Undeletable nops (used for hotpatching)
 
+(define_insn "nop_2_byte"
+  [(unspec_volatile [(const_int 0)] UNSPECV_NOP_2_BYTE)]
+  ""
+  "nopr\t%%r7"
+  [(set_attr "op_type" "RR")])
+
+(define_insn "nop_4_byte"
+  [(unspec_volatile [(const_int 0)] UNSPECV_NOP_4_BYTE)]
+  ""
+  "nop\t0"
+  [(set_attr "op_type" "RX")])
+
+(define_insn "nop_6_byte"
+  [(unspec_volatile [(const_int 0)] UNSPECV_NOP_6_BYTE)]
+  "TARGET_CPU_ZARCH"
+  "brcl\t0, 0"
+  [(set_attr "op_type" "RIL")])
+
+
 ;
 ; Special literal pool access instruction pattern(s).
 ;
Index: gcc/config/s390/s390.opt
===================================================================
--- a/src/gcc/config/s390/s390.opt	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/s390/s390.opt	(.../branches/gcc-4_9-branch)
@@ -96,13 +96,15 @@
 Target Report RejectNegative Negative(msoft-float) InverseMask(SOFT_FLOAT, HARD_FLOAT)
 Enable hardware floating point
 
-mhotpatch
-Target Report Var(s390_deferred_options) Defer
-Prepend the function label with 12 two-byte Nop instructions, and add a four byte Nop instruction after the label for hotpatching.
-
 mhotpatch=
 Target RejectNegative Report Joined Var(s390_deferred_options) Defer
-Prepend the function label with the given number of two-byte Nop instructions, and add a four byte Nop instruction after the label for hotpatching.
+Takes two non-negative integer numbers separated by a comma.
+Prepend the function label with the number of two-byte Nop
+instructions indicated by the first.  Append Nop instructions
+covering the number of halfwords indicated by the second after the
+label.  Nop instructions of the largest possible size are used
+(six, four or two bytes), beginning with the largest possible
+size.  Using 0 for both values disables hotpatching.
 
 mlong-double-128
 Target Report RejectNegative Negative(mlong-double-64) Mask(LONG_DOUBLE_128)
Index: gcc/config/sparc/t-rtems
===================================================================
--- a/src/gcc/config/sparc/t-rtems	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/t-rtems	(.../branches/gcc-4_9-branch)
@@ -17,6 +17,15 @@
 # <http://www.gnu.org/licenses/>.
 #
 
-MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3
-MULTILIB_DIRNAMES = soft v8 leon3
+MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3/mcpu=leon3v7 muser-mode
+MULTILIB_DIRNAMES = soft v8 leon3 leon3v7 user-mode
 MULTILIB_MATCHES = msoft-float=mno-fpu
+
+MULTILIB_EXCEPTIONS = muser-mode
+MULTILIB_EXCEPTIONS += mcpu=leon3
+MULTILIB_EXCEPTIONS += mcpu=leon3v7
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3v7
+MULTILIB_EXCEPTIONS += msoft-float/muser-mode
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/muser-mode
+MULTILIB_EXCEPTIONS += mcpu=v8/muser-mode
Index: gcc/config/sparc/sparc.md
===================================================================
--- a/src/gcc/config/sparc/sparc.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.md	(.../branches/gcc-4_9-branch)
@@ -221,6 +221,7 @@
    hypersparc,
    leon,
    leon3,
+   leon3v7,
    sparclite,
    f930,
    f934,
Index: gcc/config/sparc/sparc.opt
===================================================================
--- a/src/gcc/config/sparc/sparc.opt	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.opt	(.../branches/gcc-4_9-branch)
@@ -153,6 +153,9 @@
 Enum(sparc_processor_type) String(leon3) Value(PROCESSOR_LEON3)
 
 EnumValue
+Enum(sparc_processor_type) String(leon3v7) Value(PROCESSOR_LEON3V7)
+
+EnumValue
 Enum(sparc_processor_type) String(sparclite) Value(PROCESSOR_SPARCLITE)
 
 EnumValue
Index: gcc/config/sparc/sparc-opts.h
===================================================================
--- a/src/gcc/config/sparc/sparc-opts.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc-opts.h	(.../branches/gcc-4_9-branch)
@@ -31,6 +31,7 @@
   PROCESSOR_HYPERSPARC,
   PROCESSOR_LEON,
   PROCESSOR_LEON3,
+  PROCESSOR_LEON3V7,
   PROCESSOR_SPARCLITE,
   PROCESSOR_F930,
   PROCESSOR_F934,
Index: gcc/config/sparc/sparc.c
===================================================================
--- a/src/gcc/config/sparc/sparc.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.c	(.../branches/gcc-4_9-branch)
@@ -1246,6 +1246,7 @@
     { TARGET_CPU_hypersparc, PROCESSOR_HYPERSPARC },
     { TARGET_CPU_leon, PROCESSOR_LEON },
     { TARGET_CPU_leon3, PROCESSOR_LEON3 },
+    { TARGET_CPU_leon3v7, PROCESSOR_LEON3V7 },
     { TARGET_CPU_sparclite, PROCESSOR_F930 },
     { TARGET_CPU_sparclite86x, PROCESSOR_SPARCLITE86X },
     { TARGET_CPU_sparclet, PROCESSOR_TSC701 },
@@ -1274,6 +1275,7 @@
     { "hypersparc",	MASK_ISA, MASK_V8|MASK_FPU },
     { "leon",		MASK_ISA, MASK_V8|MASK_LEON|MASK_FPU },
     { "leon3",		MASK_ISA, MASK_V8|MASK_LEON3|MASK_FPU },
+    { "leon3v7",	MASK_ISA, MASK_LEON3|MASK_FPU },
     { "sparclite",	MASK_ISA, MASK_SPARCLITE },
     /* The Fujitsu MB86930 is the original sparclite chip, with no FPU.  */
     { "f930",		MASK_ISA|MASK_FPU, MASK_SPARCLITE },
@@ -1526,6 +1528,7 @@
       sparc_costs = &leon_costs;
       break;
     case PROCESSOR_LEON3:
+    case PROCESSOR_LEON3V7:
       sparc_costs = &leon3_costs;
       break;
     case PROCESSOR_SPARCLET:
@@ -6801,28 +6804,30 @@
 }
 
 /* Used by function_arg and sparc_function_value_1 to implement the conventions
-   for passing and returning large (BLKmode) vectors.
+   for passing and returning BLKmode vectors.
    Return an expression valid as a return value for the FUNCTION_ARG
    and TARGET_FUNCTION_VALUE.
 
-   SIZE is the size in bytes of the vector (at least 8 bytes).
+   SIZE is the size in bytes of the vector.
    REGNO is the FP hard register the vector will be passed in.  */
 
 static rtx
 function_arg_vector_value (int size, int regno)
 {
-  int i, nregs = size / 8;
-  rtx regs;
+  const int nregs = MAX (1, size / 8);
+  rtx regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nregs));
 
-  regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nregs));
-
-  for (i = 0; i < nregs; i++)
-    {
+  if (size < 8)
+    XVECEXP (regs, 0, 0)
+      = gen_rtx_EXPR_LIST (VOIDmode,
+			   gen_rtx_REG (SImode, regno),
+			   const0_rtx);
+  else
+    for (int i = 0; i < nregs; i++)
       XVECEXP (regs, 0, i)
 	= gen_rtx_EXPR_LIST (VOIDmode,
 			     gen_rtx_REG (DImode, regno + 2*i),
 			     GEN_INT (i*8));
-    }
 
   return regs;
 }
@@ -6868,10 +6873,9 @@
 		  || (TARGET_ARCH64 && size <= 16));
 
       if (mode == BLKmode)
-	return function_arg_vector_value (size,
-					  SPARC_FP_ARG_FIRST + 2*slotno);
-      else
-	mclass = MODE_FLOAT;
+	return function_arg_vector_value (size, SPARC_FP_ARG_FIRST + 2*slotno);
+
+      mclass = MODE_FLOAT;
     }
 
   if (TARGET_ARCH32)
@@ -7315,10 +7319,9 @@
 		  || (TARGET_ARCH64 && size <= 32));
 
       if (mode == BLKmode)
-	return function_arg_vector_value (size,
-					  SPARC_FP_ARG_FIRST);
-      else
-	mclass = MODE_FLOAT;
+	return function_arg_vector_value (size, SPARC_FP_ARG_FIRST);
+
+      mclass = MODE_FLOAT;
     }
 
   if (TARGET_ARCH64 && type)
Index: gcc/config/sparc/leon.md
===================================================================
--- a/src/gcc/config/sparc/leon.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/leon.md	(.../branches/gcc-4_9-branch)
@@ -29,11 +29,11 @@
 
 ;; Use a double reservation to work around the load pipeline hazard on UT699.
 (define_insn_reservation "leon3_load" 1
-  (and (eq_attr "cpu" "leon3") (eq_attr "type" "load,sload"))
+  (and (eq_attr "cpu" "leon3,leon3v7") (eq_attr "type" "load,sload"))
   "leon_memory*2")
 
 (define_insn_reservation "leon_store" 2
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "store"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "store"))
   "leon_memory*2")
 
 ;; This describes Gaisler Research's FPU
@@ -44,21 +44,21 @@
 (define_cpu_unit "grfpu_ds" "grfpu")
 
 (define_insn_reservation "leon_fp_alu" 4
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fp,fpcmp,fpmul"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fp,fpcmp,fpmul"))
   "grfpu_alu, nothing*3")
 
 (define_insn_reservation "leon_fp_divs" 16
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpdivs"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpdivs"))
   "grfpu_ds*14, nothing*2")
 
 (define_insn_reservation "leon_fp_divd" 17
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpdivd"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpdivd"))
   "grfpu_ds*15, nothing*2")
 
 (define_insn_reservation "leon_fp_sqrts" 24
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpsqrts"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpsqrts"))
   "grfpu_ds*22, nothing*2")
 
 (define_insn_reservation "leon_fp_sqrtd" 25
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpsqrtd"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpsqrtd"))
   "grfpu_ds*23, nothing*2")
Index: gcc/config/sparc/sparc.h
===================================================================
--- a/src/gcc/config/sparc/sparc.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.h	(.../branches/gcc-4_9-branch)
@@ -137,21 +137,22 @@
 #define TARGET_CPU_hypersparc	3
 #define TARGET_CPU_leon		4
 #define TARGET_CPU_leon3	5
-#define TARGET_CPU_sparclite	6
-#define TARGET_CPU_f930		6       /* alias */
-#define TARGET_CPU_f934		6       /* alias */
-#define TARGET_CPU_sparclite86x	7
-#define TARGET_CPU_sparclet	8
-#define TARGET_CPU_tsc701	8       /* alias */
-#define TARGET_CPU_v9		9	/* generic v9 implementation */
-#define TARGET_CPU_sparcv9	9	/* alias */
-#define TARGET_CPU_sparc64	9	/* alias */
-#define TARGET_CPU_ultrasparc	10
-#define TARGET_CPU_ultrasparc3	11
-#define TARGET_CPU_niagara	12
-#define TARGET_CPU_niagara2	13
-#define TARGET_CPU_niagara3	14
-#define TARGET_CPU_niagara4	15
+#define TARGET_CPU_leon3v7	6
+#define TARGET_CPU_sparclite	7
+#define TARGET_CPU_f930		7       /* alias */
+#define TARGET_CPU_f934		7       /* alias */
+#define TARGET_CPU_sparclite86x	8
+#define TARGET_CPU_sparclet	9
+#define TARGET_CPU_tsc701	9       /* alias */
+#define TARGET_CPU_v9		10	/* generic v9 implementation */
+#define TARGET_CPU_sparcv9	10	/* alias */
+#define TARGET_CPU_sparc64	10	/* alias */
+#define TARGET_CPU_ultrasparc	11
+#define TARGET_CPU_ultrasparc3	12
+#define TARGET_CPU_niagara	13
+#define TARGET_CPU_niagara2	14
+#define TARGET_CPU_niagara3	15
+#define TARGET_CPU_niagara4	16
 
 #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \
  || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \
@@ -239,8 +240,13 @@
 #define ASM_CPU32_DEFAULT_SPEC AS_LEON_FLAG
 #endif
 
+#if TARGET_CPU_DEFAULT == TARGET_CPU_leon3v7
+#define CPP_CPU32_DEFAULT_SPEC "-D__leon__"
+#define ASM_CPU32_DEFAULT_SPEC AS_LEONV7_FLAG
 #endif
 
+#endif
+
 #if !defined(CPP_CPU32_DEFAULT_SPEC) || !defined(CPP_CPU64_DEFAULT_SPEC)
  #error Unrecognized value in TARGET_CPU_DEFAULT.
 #endif
@@ -285,6 +291,7 @@
 %{mcpu=hypersparc:-D__hypersparc__ -D__sparc_v8__} \
 %{mcpu=leon:-D__leon__ -D__sparc_v8__} \
 %{mcpu=leon3:-D__leon__ -D__sparc_v8__} \
+%{mcpu=leon3v7:-D__leon__} \
 %{mcpu=v9:-D__sparc_v9__} \
 %{mcpu=ultrasparc:-D__sparc_v9__} \
 %{mcpu=ultrasparc3:-D__sparc_v9__} \
@@ -334,6 +341,7 @@
 %{mcpu=hypersparc:-Av8} \
 %{mcpu=leon:" AS_LEON_FLAG "} \
 %{mcpu=leon3:" AS_LEON_FLAG "} \
+%{mcpu=leon3v7:" AS_LEONV7_FLAG "} \
 %{mv8plus:-Av8plus} \
 %{mcpu=v9:-Av9} \
 %{mcpu=ultrasparc:%{!mv8plus:-Av9a}} \
@@ -1760,8 +1768,10 @@
 
 #ifdef HAVE_AS_LEON
 #define AS_LEON_FLAG "-Aleon"
+#define AS_LEONV7_FLAG "-Aleon"
 #else
 #define AS_LEON_FLAG "-Av8"
+#define AS_LEONV7_FLAG "-Av7"
 #endif
 
 /* We use gcc _mcount for profiling.  */
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-4_9-branch)
@@ -2110,7 +2110,8 @@
 	      (const_string "ssemov")
 	    (eq_attr "alternative" "19,20")
 	      (const_string "ssecvt")
-	    (match_operand 1 "pic_32bit_operand")
+	    (and (match_operand 0 "register_operand")
+		 (match_operand 1 "pic_32bit_operand"))
 	      (const_string "lea")
 	   ]
 	   (const_string "imov")))
@@ -2254,7 +2255,8 @@
 	      (const_string "sselog1")
 	    (eq_attr "alternative" "7,8,9,10,12")
 	      (const_string "ssemov")
- 	    (match_operand 1 "pic_32bit_operand")
+	    (and (match_operand 0 "register_operand")
+		 (match_operand 1 "pic_32bit_operand"))
 	      (const_string "lea")
 	   ]
 	   (const_string "imov")))
@@ -17621,8 +17623,8 @@
 	(symbol_ref "memory_address_length (operands[0], false)"))
    (set_attr "memory" "none")])
 
-(define_insn "*prefetch_prefetchwt1_<mode>"
-  [(prefetch (match_operand:P 0 "address_operand" "p")
+(define_insn "*prefetch_prefetchwt1"
+  [(prefetch (match_operand 0 "address_operand" "p")
 	     (const_int 1)
 	     (const_int 2))]
   "TARGET_PREFETCHWT1"
Index: gcc/config/i386/avx2intrin.h
===================================================================
--- a/src/gcc/config/i386/avx2intrin.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/avx2intrin.h	(.../branches/gcc-4_9-branch)
@@ -648,11 +648,20 @@
 #ifdef __OPTIMIZE__
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_bslli_epi128 (__m256i __A, const int __N)
+{
+  return (__m256i)__builtin_ia32_pslldqi256 (__A, __N * 8);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_slli_si256 (__m256i __A, const int __N)
 {
   return (__m256i)__builtin_ia32_pslldqi256 (__A, __N * 8);
 }
 #else
+#define _mm256_bslli_epi128(A, N) \
+  ((__m256i)__builtin_ia32_pslldqi256 ((__m256i)(A), (int)(N) * 8))
 #define _mm256_slli_si256(A, N) \
   ((__m256i)__builtin_ia32_pslldqi256 ((__m256i)(A), (int)(N) * 8))
 #endif
@@ -730,11 +739,20 @@
 #ifdef __OPTIMIZE__
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_bsrli_epi128 (__m256i __A, const int __N)
+{
+  return (__m256i)__builtin_ia32_psrldqi256 (__A, __N * 8);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_srli_si256 (__m256i __A, const int __N)
 {
   return (__m256i)__builtin_ia32_psrldqi256 (__A, __N * 8);
 }
 #else
+#define _mm256_bsrli_epi128(A, N) \
+  ((__m256i)__builtin_ia32_psrldqi256 ((__m256i)(A), (int)(N) * 8))
 #define _mm256_srli_si256(A, N) \
   ((__m256i)__builtin_ia32_psrldqi256 ((__m256i)(A), (int)(N) * 8))
 #endif
Index: gcc/config/i386/mmx.md
===================================================================
--- a/src/gcc/config/i386/mmx.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/mmx.md	(.../branches/gcc-4_9-branch)
@@ -600,20 +600,25 @@
 ;; Avoid combining registers from different units in a single alternative,
 ;; see comment above inline_secondary_memory_needed function in i386.c
 (define_insn "*vec_extractv2sf_1"
-  [(set (match_operand:SF 0 "nonimmediate_operand"     "=y,x,y,x,f,r")
+  [(set (match_operand:SF 0 "nonimmediate_operand"     "=y,x,x,y,x,f,r")
 	(vec_select:SF
-	  (match_operand:V2SF 1 "nonimmediate_operand" " 0,0,o,o,o,o")
+	  (match_operand:V2SF 1 "nonimmediate_operand" " 0,x,x,o,o,o,o")
 	  (parallel [(const_int 1)])))]
   "TARGET_MMX && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "@
    punpckhdq\t%0, %0
-   unpckhps\t%0, %0
+   %vmovshdup\t{%1, %0|%0, %1}
+   shufps\t{$0xe5, %1, %0|%0, %1, 0xe5}
    #
    #
    #
    #"
-  [(set_attr "type" "mmxcvt,sselog1,mmxmov,ssemov,fmov,imov")
-   (set_attr "mode" "DI,V4SF,SF,SF,SF,SF")])
+  [(set_attr "isa" "*,sse3,noavx,*,*,*,*")
+   (set_attr "type" "mmxcvt,sse,sseshuf1,mmxmov,ssemov,fmov,imov")
+   (set_attr "length_immediate" "*,*,1,*,*,*,*")
+   (set_attr "prefix_rep" "*,1,*,*,*,*,*")
+   (set_attr "prefix" "orig,maybe_vex,orig,orig,orig,orig,orig")
+   (set_attr "mode" "DI,V4SF,V4SF,SF,SF,SF,SF")])
 
 (define_split
   [(set (match_operand:SF 0 "register_operand")
@@ -1288,26 +1293,23 @@
 ;; Avoid combining registers from different units in a single alternative,
 ;; see comment above inline_secondary_memory_needed function in i386.c
 (define_insn "*vec_extractv2si_1"
-  [(set (match_operand:SI 0 "nonimmediate_operand"     "=y,x,x,x,y,x,r")
+  [(set (match_operand:SI 0 "nonimmediate_operand"     "=y,x,x,y,x,r")
 	(vec_select:SI
-	  (match_operand:V2SI 1 "nonimmediate_operand" " 0,0,x,0,o,o,o")
+	  (match_operand:V2SI 1 "nonimmediate_operand" " 0,x,x,o,o,o")
 	  (parallel [(const_int 1)])))]
   "TARGET_MMX && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "@
    punpckhdq\t%0, %0
-   punpckhdq\t%0, %0
-   pshufd\t{$85, %1, %0|%0, %1, 85}
-   unpckhps\t%0, %0
+   %vpshufd\t{$0xe5, %1, %0|%0, %1, 0xe5}
+   shufps\t{$0xe5, %1, %0|%0, %1, 0xe5}
    #
    #
    #"
-  [(set (attr "isa")
-     (if_then_else (eq_attr "alternative" "1,2")
-       (const_string "sse2")
-       (const_string "*")))
-   (set_attr "type" "mmxcvt,sselog1,sselog1,sselog1,mmxmov,ssemov,imov")
-   (set_attr "length_immediate" "*,*,1,*,*,*,*")
-   (set_attr "mode" "DI,TI,TI,V4SF,SI,SI,SI")])
+  [(set_attr "isa" "*,sse2,noavx,*,*,*")
+   (set_attr "type" "mmxcvt,sseshuf1,sseshuf1,mmxmov,ssemov,imov")
+   (set_attr "length_immediate" "*,1,1,*,*,*")
+   (set_attr "prefix" "orig,maybe_vex,orig,orig,orig,orig")
+   (set_attr "mode" "DI,TI,V4SF,SI,SI,SI")])
 
 (define_split
   [(set (match_operand:SI 0 "register_operand")
Index: gcc/config/i386/predicates.md
===================================================================
--- a/src/gcc/config/i386/predicates.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/predicates.md	(.../branches/gcc-4_9-branch)
@@ -968,11 +968,16 @@
 ;; a segment override.  Defined as a special predicate to allow
 ;; mode-less const_int operands pass to address_operand.
 (define_special_predicate "address_no_seg_operand"
-  (match_operand 0 "address_operand")
+  (match_test "address_operand (op, VOIDmode)")
 {
   struct ix86_address parts;
   int ok;
 
+  if (!CONST_INT_P (op)
+      && mode != VOIDmode
+      && GET_MODE (op) != mode)
+    return false;
+
   ok = ix86_decompose_address (op, &parts);
   gcc_assert (ok);
   return parts.seg == SEG_DEFAULT;
@@ -981,7 +986,7 @@
 ;; Return true if op if a valid base register, displacement or
 ;; sum of base register and displacement for VSIB addressing.
 (define_predicate "vsib_address_operand"
-  (match_operand 0 "address_operand")
+  (match_test "address_operand (op, VOIDmode)")
 {
   struct ix86_address parts;
   int ok;
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-4_9-branch)
@@ -4385,7 +4385,7 @@
 (define_expand "vec_unpacks_hi_v8sf"
   [(set (match_dup 2)
 	(vec_select:V4SF
-	  (match_operand:V8SF 1 "nonimmediate_operand")
+	  (match_operand:V8SF 1 "register_operand")
 	  (parallel [(const_int 4) (const_int 5)
 		     (const_int 6) (const_int 7)])))
    (set (match_operand:V4DF 0 "register_operand")
@@ -4397,7 +4397,7 @@
 (define_expand "vec_unpacks_hi_v16sf"
   [(set (match_dup 2)
 	(vec_select:V8SF
-	  (match_operand:V16SF 1 "nonimmediate_operand")
+	  (match_operand:V16SF 1 "register_operand")
 	  (parallel [(const_int 8) (const_int 9)
 		     (const_int 10) (const_int 11)
 		     (const_int 12) (const_int 13)
@@ -5890,7 +5890,8 @@
   "TARGET_AVX512F
    && (INTVAL (operands[2]) == (INTVAL (operands[3]) - 1)
        && INTVAL (operands[3]) == (INTVAL (operands[4]) - 1)
-       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))"
+       && INTVAL (operands[4]) == (INTVAL (operands[5]) - 1))
+   && rtx_equal_p (operands[6], operands[0])"
 {
   operands[2] = GEN_INT ((INTVAL (operands[2])) >> 2);
   return "vextract<shuffletype>32x4\t{%2, %1, %0%{%7%}|%0%{%7%}, %1, %2}";
@@ -5985,8 +5986,9 @@
 	      (const_int 2) (const_int 3)]))
 	  (match_operand:<ssehalfvecmode> 2 "memory_operand" "0")
 	  (match_operand:QI 3 "register_operand" "Yk")))]
-  "TARGET_AVX512F"
-"vextract<shuffletype>64x4\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}"
+  "TARGET_AVX512F
+   && rtx_equal_p (operands[2], operands[0])"
+  "vextract<shuffletype>64x4\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
    (set_attr "length_immediate" "1")
@@ -6025,7 +6027,8 @@
 	      (const_int 6) (const_int 7)]))
 	  (match_operand:<ssehalfvecmode> 2 "memory_operand" "0")
 	  (match_operand:QI 3 "register_operand" "Yk")))]
-  "TARGET_AVX512F"
+  "TARGET_AVX512F
+   && rtx_equal_p (operands[2], operands[0])"
   "vextract<shuffletype>64x4\t{$0x1, %1, %0%{%3%}|%0%{%3%}, %1, 0x1}"
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
@@ -10303,7 +10306,7 @@
    movss\t{%2, %0|%0, %2}
    movss\t{%2, %0|%0, %2}
    vmovss\t{%2, %1, %0|%0, %1, %2}"
-  [(set_attr "isa" "sse2,*,noavx,noavx,avx")
+  [(set_attr "isa" "sse2,sse2,noavx,noavx,avx")
    (set_attr "type" "ssemov")
    (set_attr "prefix" "maybe_vex,maybe_vex,orig,orig,vex")
    (set_attr "mode" "TI,TI,V4SF,SF,SF")])
Index: gcc/config/i386/emmintrin.h
===================================================================
--- a/src/gcc/config/i386/emmintrin.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/emmintrin.h	(.../branches/gcc-4_9-branch)
@@ -1161,6 +1161,18 @@
 
 #ifdef __OPTIMIZE__
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_bsrli_si128 (__m128i __A, const int __N)
+{
+  return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);
+}
+
+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+_mm_bslli_si128 (__m128i __A, const int __N)
+{
+  return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);
+}
+
+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srli_si128 (__m128i __A, const int __N)
 {
   return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);
@@ -1172,6 +1184,10 @@
   return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);
 }
 #else
+#define _mm_bsrli_si128(A, N) \
+  ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))
+#define _mm_bslli_si128(A, N) \
+  ((__m128i)__builtin_ia32_pslldqi128 ((__m128i)(A), (int)(N) * 8))
 #define _mm_srli_si128(A, N) \
   ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))
 #define _mm_slli_si128(A, N) \
Index: gcc/config/i386/driver-i386.c
===================================================================
--- a/src/gcc/config/i386/driver-i386.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/driver-i386.c	(.../branches/gcc-4_9-branch)
@@ -670,7 +670,10 @@
 	  cpu = "bonnell";
 	  break;
 	case 0x37:
+	case 0x4a:
 	case 0x4d:
+	case 0x5a:
+	case 0x5d:
 	  /* Silvermont.  */
 	  cpu = "silvermont";
 	  break;
@@ -705,11 +708,22 @@
 	  cpu = "ivybridge";
 	  break;
 	case 0x3c:
+	case 0x3f:
 	case 0x45:
 	case 0x46:
 	  /* Haswell.  */
 	  cpu = "haswell";
 	  break;
+	case 0x3d:
+	case 0x4f:
+	case 0x56:
+	  /* Broadwell.  */
+	  cpu = "broadwell";
+	  break;
+	case 0x57:
+	  /* Knights Landing.  */
+	  cpu = "knl";
+	  break;
 	default:
 	  if (arch)
 	    {
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-4_9-branch)
@@ -5006,6 +5006,10 @@
   if (TREE_CODE (exp) == FUNCTION_DECL)
     return false;
 
+  /* Automatic variables are never large data.  */
+  if (TREE_CODE (exp) == VAR_DECL && !is_global_var (exp))
+    return false;
+
   if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))
     {
       const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));
@@ -5036,8 +5040,7 @@
 x86_64_elf_select_section (tree decl, int reloc,
 			   unsigned HOST_WIDE_INT align)
 {
-  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)
-      && ix86_in_large_data_p (decl))
+  if (ix86_in_large_data_p (decl))
     {
       const char *sname = NULL;
       unsigned int flags = SECTION_WRITE;
@@ -5123,8 +5126,7 @@
 static void ATTRIBUTE_UNUSED
 x86_64_elf_unique_section (tree decl, int reloc)
 {
-  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)
-      && ix86_in_large_data_p (decl))
+  if (ix86_in_large_data_p (decl))
     {
       const char *prefix = NULL;
       /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
@@ -5193,7 +5195,7 @@
 {
   if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)
       && size > (unsigned int)ix86_section_threshold)
-    fputs (".largecomm\t", file);
+    fputs ("\t.largecomm\t", file);
   else
     fputs (COMMON_ASM_OP, file);
   assemble_name (file, name);
@@ -5972,7 +5974,18 @@
       if (abi == SYSV_ABI)
 	{
 	  if (lookup_attribute ("ms_abi", TYPE_ATTRIBUTES (fntype)))
-	    abi = MS_ABI;
+	    {
+	      if (TARGET_X32)
+		{
+		  static bool warned = false;
+		  if (!warned)
+		    {
+		      error ("X32 does not support ms_abi attribute");
+		      warned = true;
+		    }
+		}
+	      abi = MS_ABI;
+	    }
 	}
       else if (lookup_attribute ("sysv_abi", TYPE_ATTRIBUTES (fntype)))
 	abi = SYSV_ABI;
@@ -11063,6 +11076,10 @@
 	      if (sp_is_cfa_reg)
 		m->fs.cfa_offset += UNITS_PER_WORD;
 	      RTX_FRAME_RELATED_P (insn) = 1;
+	      add_reg_note (insn, REG_FRAME_RELATED_EXPR,
+			    gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+					 plus_constant (Pmode, stack_pointer_rtx,
+							-UNITS_PER_WORD)));
 	    }
 	}
 
@@ -11076,6 +11093,10 @@
 	      if (sp_is_cfa_reg)
 		m->fs.cfa_offset += UNITS_PER_WORD;
 	      RTX_FRAME_RELATED_P (insn) = 1;
+	      add_reg_note (insn, REG_FRAME_RELATED_EXPR,
+			    gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+					 plus_constant (Pmode, stack_pointer_rtx,
+							-UNITS_PER_WORD)));
 	    }
 	}
 
@@ -14503,7 +14524,7 @@
       if (mode == CCmode)
 	suffix = "b";
       else if (mode == CCCmode)
-	suffix = "c";
+	suffix = fp ? "b" : "c";
       else
 	gcc_unreachable ();
       break;
@@ -14526,9 +14547,9 @@
       break;
     case GEU:
       if (mode == CCmode)
-	suffix = fp ? "nb" : "ae";
+	suffix = "nb";
       else if (mode == CCCmode)
-	suffix = "nc";
+	suffix = fp ? "nb" : "nc";
       else
 	gcc_unreachable ();
       break;
@@ -23890,7 +23911,8 @@
 		      *noalign = alg_noalign;
 		      return alg;
 		    }
-		  break;
+		  else if (!any_alg_usable_p)
+		    break;
 		}
 	      else if (alg_usable_p (candidate, memset))
 		{
@@ -23928,9 +23950,10 @@
       alg = decide_alg (count, max / 2, min_size, max_size, memset,
 			zero_memset, dynamic_check, noalign);
       gcc_assert (*dynamic_check == -1);
-      gcc_assert (alg != libcall);
       if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)
 	*dynamic_check = max;
+      else
+	gcc_assert (alg != libcall);
       return alg;
     }
   return (alg_usable_p (algs->unknown_size, memset)
@@ -32344,7 +32367,8 @@
     M_AMDFAM15H_BDVER3,
     M_AMDFAM15H_BDVER4,
     M_INTEL_COREI7_IVYBRIDGE,
-    M_INTEL_COREI7_HASWELL
+    M_INTEL_COREI7_HASWELL,
+    M_INTEL_COREI7_BROADWELL
   };
 
   static struct _arch_names_table
@@ -32365,6 +32389,7 @@
       {"sandybridge", M_INTEL_COREI7_SANDYBRIDGE},
       {"ivybridge", M_INTEL_COREI7_IVYBRIDGE},
       {"haswell", M_INTEL_COREI7_HASWELL},
+      {"broadwell", M_INTEL_COREI7_BROADWELL},
       {"bonnell", M_INTEL_BONNELL},
       {"silvermont", M_INTEL_SILVERMONT},
       {"amdfam10h", M_AMDFAM10H},
@@ -41076,9 +41101,7 @@
 {
   default_encode_section_info (decl, rtl, first);
 
-  if (TREE_CODE (decl) == VAR_DECL
-      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))
-      && ix86_in_large_data_p (decl))
+  if (ix86_in_large_data_p (decl))
     SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_FAR_ADDR;
 }
 
Index: gcc/config/rx/rx.h
===================================================================
--- a/src/gcc/config/rx/rx.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rx/rx.h	(.../branches/gcc-4_9-branch)
@@ -433,9 +433,9 @@
 /* Compute the alignment needed for label X in various situations.
    If the user has specified an alignment then honour that, otherwise
    use rx_align_for_label.  */
-#define JUMP_ALIGN(x)				(align_jumps ? align_jumps : rx_align_for_label (x, 0))
-#define LABEL_ALIGN(x)				(align_labels ? align_labels : rx_align_for_label (x, 3))
-#define LOOP_ALIGN(x)				(align_loops ? align_loops : rx_align_for_label (x, 2))
+#define JUMP_ALIGN(x)				(align_jumps > 1 ? align_jumps_log : rx_align_for_label (x, 0))
+#define LABEL_ALIGN(x)				(align_labels > 1 ? align_labels_log : rx_align_for_label (x, 3))
+#define LOOP_ALIGN(x)				(align_loops > 1 ? align_loops_log : rx_align_for_label (x, 2))
 #define LABEL_ALIGN_AFTER_BARRIER(x)		rx_align_for_label (x, 0)
 
 #define ASM_OUTPUT_MAX_SKIP_ALIGN(STREAM, LOG, MAX_SKIP)	\
Index: gcc/config/rx/rx.c
===================================================================
--- a/src/gcc/config/rx/rx.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rx/rx.c	(.../branches/gcc-4_9-branch)
@@ -733,7 +733,7 @@
       break;
 
     case 'R':
-      gcc_assert (GET_MODE_SIZE (GET_MODE (op)) < 4);
+      gcc_assert (GET_MODE_SIZE (GET_MODE (op)) <= 4);
       unsigned_load = true;
       /* Fall through.  */
     case 'Q':
Index: gcc/config/sh/sh-protos.h
===================================================================
--- a/src/gcc/config/sh/sh-protos.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh-protos.h	(.../branches/gcc-4_9-branch)
@@ -221,7 +221,6 @@
 				     signed int, enum machine_mode);
 extern rtx sh_dwarf_register_span (rtx);
 
-extern rtx replace_n_hard_rtx (rtx, rtx *, int , int);
 extern int shmedia_cleanup_truncate (rtx *, void *);
 
 extern bool sh_contains_memref_p (rtx);
Index: gcc/config/sh/sh.c
===================================================================
--- a/src/gcc/config/sh/sh.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh.c	(.../branches/gcc-4_9-branch)
@@ -2957,7 +2957,7 @@
 struct ashl_lshr_sequence
 {
   char insn_count;
-  char amount[6];
+  signed char amount[6];
   char clobbers_t;
 };
 
@@ -12749,147 +12749,7 @@
     }
 }
 
-/* Replace any occurrence of FROM(n) in X with TO(n).  The function does
-   not enter into CONST_DOUBLE for the replace.
-
-   Note that copying is not done so X must not be shared unless all copies
-   are to be modified.
-
-   This is like replace_rtx, except that we operate on N_REPLACEMENTS
-   replacements simultaneously - FROM(n) is replacements[n*2] and to(n) is
-   replacements[n*2+1] - and that we take mode changes into account.
-
-   If a replacement is ambiguous, return NULL_RTX.
-
-   If MODIFY is zero, don't modify any rtl in place,
-   just return zero or nonzero for failure / success.  */
 rtx
-replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)
-{
-  int i, j;
-  const char *fmt;
-
-  /* The following prevents loops occurrence when we change MEM in
-     CONST_DOUBLE onto the same CONST_DOUBLE.  */
-  if (x != NULL_RTX && GET_CODE (x) == CONST_DOUBLE)
-    return x;
-
-  for (i = n_replacements - 1; i >= 0 ; i--)
-  if (x == replacements[i*2] && GET_MODE (x) == GET_MODE (replacements[i*2+1]))
-    return replacements[i*2+1];
-
-  /* Allow this function to make replacements in EXPR_LISTs.  */
-  if (x == NULL_RTX)
-    return NULL_RTX;
-
-  if (GET_CODE (x) == SUBREG)
-    {
-      rtx new_rtx = replace_n_hard_rtx (SUBREG_REG (x), replacements,
-				    n_replacements, modify);
-
-      if (CONST_INT_P (new_rtx))
-	{
-	  x = simplify_subreg (GET_MODE (x), new_rtx,
-			       GET_MODE (SUBREG_REG (x)),
-			       SUBREG_BYTE (x));
-	  if (! x)
-	    abort ();
-	}
-      else if (modify)
-	SUBREG_REG (x) = new_rtx;
-
-      return x;
-    }
-  else if (REG_P (x))
-    {
-      unsigned regno = REGNO (x);
-      unsigned nregs = (regno < FIRST_PSEUDO_REGISTER
-			? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);
-      rtx result = NULL_RTX;
-
-      for (i = n_replacements - 1; i >= 0; i--)
-	{
-	  rtx from = replacements[i*2];
-	  rtx to = replacements[i*2+1];
-	  unsigned from_regno, from_nregs, to_regno, new_regno;
-
-	  if (!REG_P (from))
-	    continue;
-	  from_regno = REGNO (from);
-	  from_nregs = (from_regno < FIRST_PSEUDO_REGISTER
-			? HARD_REGNO_NREGS (from_regno, GET_MODE (from)) : 1);
-	  if (regno < from_regno + from_nregs && regno + nregs > from_regno)
-	    {
-	      if (regno < from_regno
-		  || regno + nregs > from_regno + nregs
-		  || !REG_P (to)
-		  || result)
-		return NULL_RTX;
-	      to_regno = REGNO (to);
-	      if (to_regno < FIRST_PSEUDO_REGISTER)
-		{
-		  new_regno = regno + to_regno - from_regno;
-		  if ((unsigned) HARD_REGNO_NREGS (new_regno, GET_MODE (x))
-		      != nregs)
-		    return NULL_RTX;
-		  result = gen_rtx_REG (GET_MODE (x), new_regno);
-		}
-	      else if (GET_MODE (x) <= GET_MODE (to))
-		result = gen_lowpart_common (GET_MODE (x), to);
-	      else
-		result = gen_lowpart_SUBREG (GET_MODE (x), to);
-	    }
-	}
-      return result ? result : x;
-    }
-  else if (GET_CODE (x) == ZERO_EXTEND)
-    {
-      rtx new_rtx = replace_n_hard_rtx (XEXP (x, 0), replacements,
-				    n_replacements, modify);
-
-      if (CONST_INT_P (new_rtx))
-	{
-	  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
-					new_rtx, GET_MODE (XEXP (x, 0)));
-	  if (! x)
-	    abort ();
-	}
-      else if (modify)
-	XEXP (x, 0) = new_rtx;
-
-      return x;
-    }
-
-  fmt = GET_RTX_FORMAT (GET_CODE (x));
-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
-    {
-      rtx new_rtx;
-
-      if (fmt[i] == 'e')
-	{
-	  new_rtx = replace_n_hard_rtx (XEXP (x, i), replacements,
-				    n_replacements, modify);
-	  if (!new_rtx)
-	    return NULL_RTX;
-	  if (modify)
-	    XEXP (x, i) = new_rtx;
-	}
-      else if (fmt[i] == 'E')
-	for (j = XVECLEN (x, i) - 1; j >= 0; j--)
-	  {
-	    new_rtx = replace_n_hard_rtx (XVECEXP (x, i, j), replacements,
-				      n_replacements, modify);
-	  if (!new_rtx)
-	    return NULL_RTX;
-	    if (modify)
-	      XVECEXP (x, i, j) = new_rtx;
-	  }
-    }
-
-  return x;
-}
-
-rtx
 sh_gen_truncate (enum machine_mode mode, rtx x, int need_sign_ext)
 {
   enum rtx_code code = TRUNCATE;
Index: gcc/config/sh/sh_optimize_sett_clrt.cc
===================================================================
--- a/src/gcc/config/sh/sh_optimize_sett_clrt.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh_optimize_sett_clrt.cc	(.../branches/gcc-4_9-branch)
@@ -111,7 +111,7 @@
   // Given a start insn and its basic block, recursively determine all
   // possible ccreg values in all basic block paths that can lead to the
   // start insn.
-  void find_last_ccreg_values (rtx start_insn, basic_block bb,
+  bool find_last_ccreg_values (rtx start_insn, basic_block bb,
 			       std::vector<ccreg_value>& values_out,
 			       std::vector<basic_block>& prev_visited_bb) const;
 
@@ -226,8 +226,8 @@
 
 	    ccreg_values.clear ();
 	    visited_bbs.clear ();
-	    find_last_ccreg_values (PREV_INSN (i), bb, ccreg_values,
-				    visited_bbs);
+	    bool ok = find_last_ccreg_values (PREV_INSN (i), bb, ccreg_values,
+					      visited_bbs);
 
 	    log_msg ("number of ccreg values collected: %u\n",
 		     (unsigned int)ccreg_values.size ());
@@ -235,7 +235,7 @@
 	    // If all the collected values are equal and are equal to the
 	    // constant value of the setcc insn, the setcc insn can be
 	    // removed.
-	    if (all_ccreg_values_equal (ccreg_values)
+	    if (ok && all_ccreg_values_equal (ccreg_values)
 		&& rtx_equal_p (ccreg_values.front ().value, setcc_val))
 	      {
 		log_msg ("all values are ");
@@ -309,7 +309,7 @@
     gcc_unreachable ();
 }
 
-void
+bool
 sh_optimize_sett_clrt
 ::find_last_ccreg_values (rtx start_insn, basic_block bb,
 			  std::vector<ccreg_value>& values_out,
@@ -348,7 +348,7 @@
 	  log_msg ("\n");
 
 	  values_out.push_back (v);
-	  return;
+	  return true;
 	}
 
       if (any_condjump_p (i) && onlyjump_p (i) && !prev_visited_bb.empty ())
@@ -372,7 +372,7 @@
 	  log_msg ("\n");
 
 	  values_out.push_back (v);
-	  return;
+	  return true;
 	}
     }
 
@@ -393,10 +393,14 @@
       for (edge_iterator ei = ei_start (bb->preds); !ei_end_p (ei);
 	   ei_next (&ei))
 	{
+	  if (ei_edge (ei)->flags & EDGE_COMPLEX)
+	    log_return (false, "aborting due to complex edge\n");
+
 	  basic_block pred_bb = ei_edge (ei)->src;
 	  pred_bb_count += 1;
-	  find_last_ccreg_values (BB_END (pred_bb), pred_bb, values_out,
-				  prev_visited_bb);
+	  if (!find_last_ccreg_values (BB_END (pred_bb), pred_bb, values_out,
+				       prev_visited_bb))
+	    return false;
 	}
 
       prev_visited_bb.pop_back ();
@@ -419,6 +423,8 @@
 
     values_out.push_back (v);
   }
+
+  return true;
 }
 
 bool
Index: gcc/config/sh/sh-mem.cc
===================================================================
--- a/src/gcc/config/sh/sh-mem.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh-mem.cc	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* Helper routines for memory move and comparison insns.
-   Copyright (C) 2013-2014 Free Software Foundation, Inc.
+   Copyright (C) 2013-2015 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -226,7 +226,7 @@
   emit_move_insn (tmp3, addr2);
   emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 4));
 
-  /*start long loop.  */
+  /* start long loop.  */
   emit_label (L_loop_long);
 
   emit_move_insn (tmp2, tmp3);
@@ -335,7 +335,7 @@
   rtx len = force_reg (SImode, operands[3]);
   int constp = CONST_INT_P (operands[3]);
 
-  /* Loop on a register count. */
+  /* Loop on a register count.  */
   if (constp)
     {
       rtx tmp0 = gen_reg_rtx (SImode);
@@ -364,7 +364,7 @@
               add_int_reg_note (jump, REG_BR_PROB, prob_likely);
             }
 
-          /* word count. Do we have iterations ? */
+          /* word count. Do we have iterations ?  */
           emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));
 
           /*start long loop.  */
@@ -407,6 +407,7 @@
           /* end loop.  Reached max iterations.  */
           if (! sbytes)
             {
+              emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));
               jump = emit_jump_insn (gen_jump_compact (L_return));
               emit_barrier_after (jump);
             }
@@ -482,6 +483,13 @@
       jump = emit_jump_insn (gen_jump_compact( L_end_loop_byte));
       emit_barrier_after (jump);
     }
+  else
+    {
+      emit_insn (gen_cmpeqsi_t (len, const0_rtx));
+      emit_move_insn (operands[0], const0_rtx);
+      jump = emit_jump_insn (gen_branch_true (L_return));
+      add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);
+    }
 
   addr1 = adjust_automodify_address (addr1, QImode, s1_addr, 0);
   addr2 = adjust_automodify_address (addr2, QImode, s2_addr, 0);
@@ -522,14 +530,14 @@
     emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));
   emit_insn (gen_zero_extendqisi2 (tmp1, gen_lowpart (QImode, tmp1)));
 
+  emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));
+
   emit_label (L_return);
 
-  emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));
-
   return true;
 }
 
-/* Emit code to perform a strlen
+/* Emit code to perform a strlen.
 
    OPERANDS[0] is the destination.
    OPERANDS[1] is the string.
@@ -568,7 +576,7 @@
 
   addr1 = adjust_automodify_address (addr1, SImode, current_addr, 0);
 
-  /*start long loop.  */
+  /* start long loop.  */
   emit_label (L_loop_long);
 
   /* tmp1 is aligned, OK to load.  */
Index: gcc/config/sh/t-sh
===================================================================
--- a/src/gcc/config/sh/t-sh	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/t-sh	(.../branches/gcc-4_9-branch)
@@ -63,8 +63,12 @@
     done \
   done)
 
-# SH1 only supports big endian.
+# SH1 and SH2A support big endian only.
+ifeq ($(DEFAULT_ENDIAN),ml)
+MULTILIB_EXCEPTIONS = m1 ml/m1 m2a* ml/m2a* $(TM_MULTILIB_EXCEPTIONS_CONFIG)
+else
 MULTILIB_EXCEPTIONS = ml/m1 ml/m2a* $(TM_MULTILIB_EXCEPTIONS_CONFIG)
+endif
 
 MULTILIB_OSDIRNAMES = \
 	$(OTHER_ENDIAN)=!$(OTHER_ENDIAN) \
Index: gcc/config/sh/sh_treg_combine.cc
===================================================================
--- a/src/gcc/config/sh/sh_treg_combine.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh_treg_combine.cc	(.../branches/gcc-4_9-branch)
@@ -78,7 +78,9 @@
 
 In [bb 4] elimination of the comparison would require inversion of the branch
 condition and compensation of other BBs.
-Instead an inverting reg-move can be used:
+Instead the comparison in [bb 3] can be replaced with the comparison in [bb 5]
+by using a reg-reg move.  In [bb 4] a logical not is used to compensate the
+inverted condition.
 
 [bb 3]
 (set (reg:SI 167) (reg:SI 173))
@@ -85,7 +87,8 @@
 -> bb 5
 
 [BB 4]
-(set (reg:SI 167) (not:SI (reg:SI 177)))
+(set (reg:SI 147 t) (eq:SI (reg:SI 177) (const_int 0)))
+(set (reg:SI 167) (reg:SI 147 t))
 -> bb 5
 
 [bb 5]
@@ -214,9 +217,9 @@
       and replace the comparisons in the BBs with reg-reg copies to get the
       operands in place (create new pseudo regs).
 
-    - If the cstores differ, try to apply the special case
-        (eq (reg) (const_int 0)) -> inverted = (not (reg)).
-      for the subordinate cstore types and eliminate the dominating ones.
+    - If the cstores differ and the comparison is a test against zero,
+      use reg-reg copies for the dominating cstores and logical not cstores
+      for the subordinate cstores.
 
 - If the comparison types in the BBs are not the same, or the first approach
   doesn't work out for some reason, try to eliminate the comparison before the
@@ -558,7 +561,8 @@
   bool can_extend_ccreg_usage (const bb_entry& e,
 			       const cbranch_trace& trace) const;
 
-  // Create an insn rtx that is a negating reg move (not operation).
+  // Create an insn rtx that performs a logical not (test != 0) on the src_reg
+  // and stores the result in dst_reg.
   rtx make_not_reg_insn (rtx dst_reg, rtx src_reg) const;
 
   // Create an insn rtx that inverts the ccreg.
@@ -892,12 +896,32 @@
 rtx
 sh_treg_combine::make_not_reg_insn (rtx dst_reg, rtx src_reg) const
 {
-  // This will to go through expanders and may output multiple insns
-  // for multi-word regs.
+  // On SH we can do only SImode and DImode comparisons.
+  if (! (GET_MODE (src_reg) == SImode || GET_MODE (src_reg) == DImode))
+    return NULL;
+
+  // On SH we can store the ccreg into an SImode or DImode reg only.
+  if (! (GET_MODE (dst_reg) == SImode || GET_MODE (dst_reg) == DImode))
+    return NULL;
+
   start_sequence ();
-  expand_simple_unop (GET_MODE (dst_reg), NOT, src_reg, dst_reg, 0);
+
+  emit_insn (gen_rtx_SET (VOIDmode, m_ccreg,
+			  gen_rtx_fmt_ee (EQ, SImode, src_reg, const0_rtx)));
+
+  if (GET_MODE (dst_reg) == SImode)
+    emit_move_insn (dst_reg, m_ccreg);
+  else if (GET_MODE (dst_reg) == DImode)
+    {
+      emit_move_insn (gen_lowpart (SImode, dst_reg), m_ccreg);
+      emit_move_insn (gen_highpart (SImode, dst_reg), const0_rtx);
+    }
+  else
+    gcc_unreachable ();
+
   rtx i = get_insns ();
   end_sequence ();
+
   return i;
 }
 
@@ -1080,7 +1104,12 @@
   // There is one special case though, where an integer comparison
   //     (eq (reg) (const_int 0))
   // can be inverted with a sequence
-  //     (eq (not (reg)) (const_int 0))
+  //     (set (t) (eq (reg) (const_int 0))
+  //     (set (reg) (t))
+  //     (eq (reg) (const_int 0))
+  //
+  // FIXME: On SH2A it might be better to use the nott insn in this case,
+  // i.e. do the try_eliminate_cstores approach instead.
   if (inv_cstore_count != 0 && cstore_count != 0)
     {
       if (make_not_reg_insn (comp_op0, comp_op0) == NULL_RTX)
Index: gcc/config/sh/sh.md
===================================================================
--- a/src/gcc/config/sh/sh.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh.md	(.../branches/gcc-4_9-branch)
@@ -651,32 +651,6 @@
   "tst	#255,%0"
   [(set_attr "type" "mt_group")])
 
-;; This pattern might be risky because it also tests the upper bits and not
-;; only the subreg.  However, it seems that combine will get to this only
-;; when testing sign/zero extended values.  In this case the extended upper
-;; bits do not matter.
-(define_insn "*tst<mode>_t_zero"
-  [(set (reg:SI T_REG)
-	(eq:SI
-	  (subreg:QIHI
-	    (and:SI (match_operand:SI 0 "arith_reg_operand" "%r")
-		    (match_operand:SI 1 "arith_reg_operand" "r")) <lowpart_le>)
-	  (const_int 0)))]
-  "TARGET_SH1 && TARGET_LITTLE_ENDIAN"
-  "tst	%0,%1"
-  [(set_attr "type" "mt_group")])
-
-(define_insn "*tst<mode>_t_zero"
-  [(set (reg:SI T_REG)
-	(eq:SI
-	  (subreg:QIHI
-	    (and:SI (match_operand:SI 0 "arith_reg_operand" "%r")
-		    (match_operand:SI 1 "arith_reg_operand" "r")) <lowpart_be>)
-	  (const_int 0)))]
-  "TARGET_SH1 && TARGET_BIG_ENDIAN"
-  "tst	%0,%1"
-  [(set_attr "type" "mt_group")])
-
 ;; Extract LSB, negate and store in T bit.
 (define_insn "tstsi_t_and_not"
   [(set (reg:SI T_REG)
@@ -1545,78 +1519,6 @@
   replace_rtx (operands[4], operands[0], operands[1]);
 })
 
-(define_peephole2
-  [(set (match_operand 0 "any_register_operand" "")
-	(match_operand 1 "any_register_operand" ""))
-   (set (match_operand 2 "any_register_operand" "") (match_operand 3 "" ""))
-   (set (match_operand 4 "" "") (match_operand 5 "" ""))]
-  "(HARD_REGNO_NREGS (REGNO (operands[0]), GET_MODE (operands[2]))
-    <= HARD_REGNO_NREGS (REGNO (operands[0]), GET_MODE (operands[0])))
-   && peep2_reg_dead_p (3, operands[0]) && peep2_reg_dead_p (3, operands[2])
-   && ! FIND_REG_INC_NOTE (peep2_next_insn (2), operands[0])
-   && ! FIND_REG_INC_NOTE (peep2_next_insn (2), operands[2])
-   && ! reg_overlap_mentioned_p (operands[0], operands[3])
-   && ! reg_overlap_mentioned_p (operands[2], operands[0])
-   && ! reg_overlap_mentioned_p (operands[0], operands[1])
-   && (REGNO_REG_CLASS (REGNO (operands[0]))
-       == REGNO_REG_CLASS (REGNO (operands[2])))
-   && (REGNO_REG_CLASS (REGNO (operands[1]))
-       == REGNO_REG_CLASS (REGNO (operands[0])))"
-  [(set (match_dup 0) (match_dup 3))
-   (set (match_dup 4) (match_dup 5))]
-{
-  rtx set1, set2, insn2;
-  rtx replacements[4];
-
-  /* We want to replace occurrences of operands[0] with operands[1] and
-     operands[2] with operands[0] in operands[4]/operands[5].
-     Doing just two replace_rtx calls naively would result in the second
-     replacement undoing all that the first did if operands[1] and operands[2]
-     are identical, so we must do this simultaneously.  */
-  replacements[0] = operands[0];
-  replacements[1] = operands[1];
-  replacements[2] = operands[2];
-  replacements[3] = operands[0];
-  if (!replace_n_hard_rtx (operands[5], replacements, 2, 0)
-      || !replace_n_hard_rtx (operands[4], replacements, 2, 0)
-      || !replace_n_hard_rtx (operands[2], replacements, 2, 0))
-    FAIL;
-
-  operands[5] = replace_n_hard_rtx (operands[5], replacements, 2, 1);
-  replace_n_hard_rtx (operands[4], replacements, 2, 1);
-  operands[2] = replace_n_hard_rtx (operands[2], replacements, 2, 1);
-  /* The operands array is aliased to recog_data.operand, which gets
-     clobbered by extract_insn, so finish with it now.  */
-  set1 = gen_rtx_SET (VOIDmode, operands[2], operands[3]);
-  set2 = gen_rtx_SET (VOIDmode, operands[4], operands[5]);
-  /* ??? The last insn might be a jump insn, but the generic peephole2 code
-     always uses emit_insn.  */
-  /* Check that we don't violate matching constraints or earlyclobbers.  */
-  extract_insn (emit_insn (set1));
-  if (! constrain_operands (1))
-    goto failure;
-  insn2 = emit (set2);
-  if (GET_CODE (insn2) == BARRIER)
-    goto failure;
-  extract_insn (insn2);
-  if (! constrain_operands (1))
-    {
-      rtx tmp;
-    failure:
-      tmp = replacements[0];
-      replacements[0] = replacements[1];
-      replacements[1] = tmp;
-      tmp = replacements[2];
-      replacements[2] = replacements[3];
-      replacements[3] = tmp;
-      replace_n_hard_rtx (SET_DEST (set1), replacements, 2, 1);
-      replace_n_hard_rtx (SET_DEST (set2), replacements, 2, 1);
-      replace_n_hard_rtx (SET_SRC (set2), replacements, 2, 1);
-      FAIL;
-    }
-  DONE;
-})
-
 ;; The register allocator is rather clumsy in handling multi-way conditional
 ;; moves, so allow the combiner to make them, and we split them up after
 ;; reload.  */
@@ -5847,7 +5749,7 @@
 (define_insn "swapbsi2"
   [(set (match_operand:SI 0 "arith_reg_dest" "=r")
 	(ior:SI (and:SI (match_operand:SI 1 "arith_reg_operand" "r")
-			(const_int 4294901760))
+			(const_int -65536)) ;; 0xFFFF0000
 		(ior:SI (and:SI (ashift:SI (match_dup 1) (const_int 8))
 				(const_int 65280))
 			(and:SI (ashiftrt:SI (match_dup 1) (const_int 8))
@@ -5915,7 +5817,7 @@
 (define_peephole2
   [(set (match_operand:SI 0 "arith_reg_dest" "")
 	(ior:SI (and:SI (match_operand:SI 1 "arith_reg_operand" "")
-			(const_int 4294901760))
+			(const_int -65536)) ;; 0xFFFF0000
 		(ior:SI (and:SI (ashift:SI (match_dup 1) (const_int 8))
 				(const_int 65280))
 			(and:SI (ashiftrt:SI (match_dup 1) (const_int 8))
@@ -5925,7 +5827,7 @@
   "TARGET_SH1 && peep2_reg_dead_p (2, operands[0])"
   [(set (match_dup 2)
 	(ior:SI (and:SI (match_operand:SI 1 "arith_reg_operand" "")
-			(const_int 4294901760))
+			(const_int -65536)) ;; 0xFFFF0000
 		(ior:SI (and:SI (ashift:SI (match_dup 1) (const_int 8))
 				(const_int 65280))
 			(and:SI (ashiftrt:SI (match_dup 1) (const_int 8))
@@ -6331,10 +6233,9 @@
 })
 
 (define_expand "extendqihi2"
-  [(set (match_operand:HI 0 "arith_reg_dest" "")
-	(sign_extend:HI (match_operand:QI 1 "arith_reg_operand" "")))]
-  ""
-  "")
+  [(set (match_operand:HI 0 "arith_reg_dest")
+	(sign_extend:HI (match_operand:QI 1 "arith_reg_operand")))]
+  "TARGET_SH1")
 
 (define_insn "*extendqihi2_compact_reg"
   [(set (match_operand:HI 0 "arith_reg_dest" "=r")
@@ -10237,10 +10138,25 @@
   ""
 {
   rtx mem;
+  bool stack_chk_guard_p = false;
 
   operands[2] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);
   operands[3] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);
 
+  if (!TARGET_SHMEDIA
+      && flag_stack_protect
+      && GET_CODE (operands[1]) == CONST
+      && GET_CODE (XEXP (operands[1], 0)) == UNSPEC
+      && GET_CODE (XVECEXP (XEXP (operands[1], 0), 0, 0)) == SYMBOL_REF
+      && strcmp (XSTR (XVECEXP (XEXP (operands[1], 0), 0, 0), 0),
+		 "__stack_chk_guard") == 0)
+    stack_chk_guard_p = true;
+
+  /* Use R0 to avoid long R0 liveness which stack-protector tends to
+     produce.  */
+  if (stack_chk_guard_p && ! reload_in_progress && ! reload_completed)
+    operands[2] = gen_rtx_REG (Pmode, R0_REG);
+
   if (TARGET_SHMEDIA)
     {
       rtx reg = operands[2];
@@ -10268,13 +10184,7 @@
      insn to avoid combining (set A (plus rX r12)) and (set op0 (mem A))
      when rX is a GOT address for the guard symbol.  Ugly but doesn't
      matter because this is a rare situation.  */
-  if (!TARGET_SHMEDIA
-      && flag_stack_protect
-      && GET_CODE (operands[1]) == CONST
-      && GET_CODE (XEXP (operands[1], 0)) == UNSPEC
-      && GET_CODE (XVECEXP (XEXP (operands[1], 0), 0, 0)) == SYMBOL_REF
-      && strcmp (XSTR (XVECEXP (XEXP (operands[1], 0), 0, 0), 0),
-		 "__stack_chk_guard") == 0)
+  if (stack_chk_guard_p)
     emit_insn (gen_chk_guard_add (operands[3], operands[2]));
   else
     emit_move_insn (operands[3], gen_rtx_PLUS (Pmode, operands[2],
Index: gcc/config/avr/avr-fixed.md
===================================================================
--- a/src/gcc/config/avr/avr-fixed.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr-fixed.md	(.../branches/gcc-4_9-branch)
@@ -231,8 +231,12 @@
               (clobber (reg:HI 24))])
    (set (match_operand:QQ 0 "register_operand" "")
         (reg:QQ 23))]
-  "!AVR_HAVE_MUL")
+  "!AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (QQmode, 24));
+  })
 
+
 (define_expand "muluqq3_nomul"
   [(set (reg:UQQ 22)
         (match_operand:UQQ 1 "register_operand" ""))
@@ -246,7 +250,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:UQQ 0 "register_operand" "")
         (reg:UQQ 25))]
-  "!AVR_HAVE_MUL")
+  "!AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (UQQmode, 22));
+  })
 
 (define_insn "*mulqq3.call"
   [(set (reg:QQ 23)
@@ -274,7 +281,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:ALL2QA 0 "register_operand" "")
         (reg:ALL2QA 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 18));
+  })
 
 ;; "*mulhq3.call"  "*muluhq3.call"
 ;; "*mulha3.call"  "*muluha3.call"
@@ -302,7 +312,10 @@
                     (reg:ALL4A 20)))
    (set (match_operand:ALL4A 0 "register_operand" "")
         (reg:ALL4A 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 16));
+  })
 
 ;; "*mulsa3.call" "*mulusa3.call"
 (define_insn "*mul<mode>3.call"
@@ -330,8 +343,13 @@
                                 (reg:ALL1Q 22)))
               (clobber (reg:QI 25))])
    (set (match_operand:ALL1Q 0 "register_operand" "")
-        (reg:ALL1Q 24))])
+        (reg:ALL1Q 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 25));
+  })
 
+
 ;; "*divqq3.call" "*udivuqq3.call"
 (define_insn "*<code><mode>3.call"
   [(set (reg:ALL1Q 24)
@@ -356,7 +374,11 @@
               (clobber (reg:HI 26))
               (clobber (reg:QI 21))])
    (set (match_operand:ALL2QA 0 "register_operand" "")
-        (reg:ALL2QA 24))])
+        (reg:ALL2QA 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 26));
+  })
 
 ;; "*divhq3.call" "*udivuhq3.call"
 ;; "*divha3.call" "*udivuha3.call"
@@ -385,7 +407,11 @@
               (clobber (reg:HI 26))
               (clobber (reg:HI 30))])
    (set (match_operand:ALL4A 0 "register_operand" "")
-        (reg:ALL4A 22))])
+        (reg:ALL4A 22))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 24));
+  })
 
 ;; "*divsa3.call" "*udivusa3.call"
 (define_insn "*<code><mode>3.call"
@@ -435,6 +461,7 @@
 
     operands[3] = gen_rtx_REG (<MODE>mode, regno_out[(size_t) GET_MODE_SIZE (<MODE>mode)]);
     operands[4] = gen_rtx_REG (<MODE>mode,  regno_in[(size_t) GET_MODE_SIZE (<MODE>mode)]);
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, REGNO (operands[4])));
     operands[5] = simplify_gen_subreg (QImode, force_reg (HImode, operands[2]), HImode, 0);
     // $2 is no more needed, but is referenced for expand.
     operands[2] = const0_rtx;
Index: gcc/config/avr/avr-dimode.md
===================================================================
--- a/src/gcc/config/avr/avr-dimode.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr-dimode.md	(.../branches/gcc-4_9-branch)
@@ -68,6 +68,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (DImode == <MODE>mode
@@ -145,6 +146,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -201,6 +203,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -249,6 +252,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -338,6 +342,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (s8_operand (operands[2], VOIDmode))
@@ -424,6 +429,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
     emit_move_insn (gen_rtx_REG (QImode, 16), operands[2]);
     emit_insn (gen_<code_stdname><mode>3_insn ());
@@ -457,6 +463,7 @@
               (clobber (any_extend:SI (match_dup 1)))])]
   "avr_have_dimode"
   {
+    avr_fix_inputs (operands, 1 << 2, regmask (SImode, 22));
     emit_move_insn (gen_rtx_REG (SImode, 22), operands[1]);
     emit_move_insn (gen_rtx_REG (SImode, 18), operands[2]);
     emit_insn (gen_<extend_u>mulsidi3_insn());
Index: gcc/config/avr/avr.md
===================================================================
--- a/src/gcc/config/avr/avr.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr.md	(.../branches/gcc-4_9-branch)
@@ -352,6 +352,13 @@
 	push __zero_reg__"
   [(set_attr "length" "1,1")])
 
+(define_insn "pushhi1_insn"
+  [(set (mem:HI (post_dec:HI (reg:HI REG_SP)))
+        (match_operand:HI 0 "register_operand" "r"))]
+  ""
+  "push %B0\;push %A0"
+  [(set_attr "length" "2")])
+
 ;; All modes for a multi-byte push.  We must include complex modes here too,
 ;; lest emit_single_push_insn "helpfully" create the auto-inc itself.
 (define_mode_iterator MPUSH
@@ -367,18 +374,43 @@
   [(match_operand:MPUSH 0 "" "")]
   ""
   {
-    int i;
-
-    // Avoid (subreg (mem)) for non-generic address spaces below.  Because
-    // of the poor addressing capabilities of these spaces it's better to
-    // load them in one chunk.  And it avoids PR61443.
-
     if (MEM_P (operands[0])
         && !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (operands[0])))
-      operands[0] = copy_to_mode_reg (<MODE>mode, operands[0]);
+      {
+        // Avoid (subreg (mem)) for non-generic address spaces.  Because
+        // of the poor addressing capabilities of these spaces it's better to
+        // load them in one chunk.  And it avoids PR61443.
 
-    for (i = GET_MODE_SIZE (<MODE>mode) - 1; i >= 0; --i)
+        operands[0] = copy_to_mode_reg (<MODE>mode, operands[0]);
+      }
+    else if (REG_P (operands[0])
+             && IN_RANGE (REGNO (operands[0]), FIRST_VIRTUAL_REGISTER,
+                          LAST_VIRTUAL_REGISTER))
       {
+        // Byte-wise pushing of virtual regs might result in something like
+        //
+        //     (set (mem:QI (post_dec:HI (reg:HI 32 SP)))
+        //          (subreg:QI (plus:HI (reg:HI 28)
+        //                              (const_int 17)) 0))
+        //
+        // after elimination.  This cannot be handled by reload, cf. PR64452.
+        // Reload virtuals in one chunk.  That way it's possible to reload
+        // above situation and finally
+        //
+        //    (set (reg:HI **)
+        //         (const_int 17))
+        //    (set (reg:HI **)
+        //         (plus:HI (reg:HI **)
+        //                  (reg:HI 28)))
+        //    (set (mem:HI (post_dec:HI (reg:HI 32 SP))
+        //         (reg:HI **)))
+ 
+        emit_insn (gen_pushhi1_insn (operands[0]));
+        DONE;
+      }
+
+    for (int i = GET_MODE_SIZE (<MODE>mode) - 1; i >= 0; --i)
+      {
         rtx part = simplify_gen_subreg (QImode, operands[0], <MODE>mode, i);
         if (part != const0_rtx)
           part = force_reg (QImode, part);
@@ -1482,7 +1514,11 @@
    (set (reg:QI 22) (match_operand:QI 2 "register_operand" ""))
    (parallel [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))
               (clobber (reg:QI 22))])
-   (set (match_operand:QI 0 "register_operand" "") (reg:QI 24))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:QI 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
+  })
 
 (define_insn "*mulqi3_call"
   [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))
@@ -2210,8 +2246,14 @@
    (parallel [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))
               (clobber (reg:HI 22))
               (clobber (reg:QI 21))])
-   (set (match_operand:HI 0 "register_operand" "") (reg:HI 24))])
+   (set (match_operand:HI 0 "register_operand" "")
+        (reg:HI 24))]
+  ""
+  {
+    avr_fix_inputs (operands, (1 << 2), regmask (HImode, 24));
+  })
 
+
 (define_insn "*mulhi3_call"
   [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))
    (clobber (reg:HI 22))
@@ -2248,6 +2290,10 @@
         emit_insn (gen_mulohisi3 (operands[0], operands[2], operands[1]));
         DONE;
       }
+
+    if (avr_emit3_fix_outputs (gen_mulsi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
   })
 
 (define_insn_and_split "*mulsi3"
@@ -2287,7 +2333,23 @@
 
 ;; "muluqisi3"
 ;; "muluhisi3"
-(define_insn_and_split "mulu<mode>si3"
+(define_expand "mulu<mode>si3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (zero_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" ""))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulu<mode>si3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+;; "*muluqisi3"
+;; "*muluhisi3"
+(define_insn_and_split "*mulu<mode>si3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                           "=r")
         (mult:SI (zero_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" "r"))
                  (match_operand:SI 2 "pseudo_register_or_const_int_operand"      "rn")))
@@ -2323,7 +2385,23 @@
 
 ;; "mulsqisi3"
 ;; "mulshisi3"
-(define_insn_and_split "muls<mode>si3"
+(define_expand "muls<mode>si3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (sign_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" ""))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_muls<mode>si3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+;; "*mulsqisi3"
+;; "*mulshisi3"
+(define_insn_and_split "*muls<mode>si3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                           "=r")
         (mult:SI (sign_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" "r"))
                  (match_operand:SI 2 "pseudo_register_or_const_int_operand"      "rn")))
@@ -2366,7 +2444,22 @@
 
 ;; One-extend operand 1
 
-(define_insn_and_split "mulohisi3"
+(define_expand "mulohisi3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (not:SI (zero_extend:SI
+                                     (not:HI (match_operand:HI 1 "pseudo_register_operand" ""))))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulohisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+(define_insn_and_split "*mulohisi3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                          "=r")
         (mult:SI (not:SI (zero_extend:SI
                           (not:HI (match_operand:HI 1 "pseudo_register_operand" "r"))))
@@ -2394,7 +2487,12 @@
                             (any_extend:SI (match_operand:HI 2 "register_operand" ""))))
               (clobber (reg:HI 26))
               (clobber (reg:DI 18))])]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    if (avr_emit3_fix_outputs (gen_<extend_u>mulhisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
 
 (define_expand "usmulhisi3"
   [(parallel [(set (match_operand:SI 0 "register_operand" "")
@@ -2402,7 +2500,12 @@
                             (sign_extend:SI (match_operand:HI 2 "register_operand" ""))))
               (clobber (reg:HI 26))
               (clobber (reg:DI 18))])]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    if (avr_emit3_fix_outputs (gen_usmulhisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
 
 ;; "*uumulqihisi3" "*uumulhiqisi3" "*uumulhihisi3" "*uumulqiqisi3"
 ;; "*usmulqihisi3" "*usmulhiqisi3" "*usmulhihisi3" "*usmulqiqisi3"
@@ -2474,7 +2577,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:HI 0 "register_operand" "")
         (reg:HI 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (HImode, 18));
+  })
 
 
 (define_insn "*mulsi3_call"
@@ -2697,6 +2803,10 @@
         emit_insn (gen_mulsqipsi3 (operands[0], reg, operands[1]));
         DONE;
       }
+
+    if (avr_emit3_fix_outputs (gen_mulpsi3, operands, 1u << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
   })
 
 (define_insn "*umulqihipsi3"
@@ -2729,7 +2839,21 @@
   [(set_attr "length" "7")
    (set_attr "cc" "clobber")])
 
-(define_insn_and_split "mulsqipsi3"
+(define_expand "mulsqipsi3"
+  [(parallel [(set (match_operand:PSI 0 "pseudo_register_operand" "")
+                   (mult:PSI (sign_extend:PSI (match_operand:QI 1 "pseudo_register_operand" ""))
+                             (match_operand:PSI 2 "pseudo_register_or_const_int_operand""")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulsqipsi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+(define_insn_and_split "*mulsqipsi3"
   [(set (match_operand:PSI 0 "pseudo_register_operand"                          "=r")
         (mult:PSI (sign_extend:PSI (match_operand:QI 1 "pseudo_register_operand" "r"))
                   (match_operand:PSI 2 "pseudo_register_or_const_int_operand"    "rn")))
@@ -6064,6 +6188,7 @@
         emit_insn (gen_fmul_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmul_insn"
@@ -6107,6 +6232,7 @@
         emit_insn (gen_fmuls_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmuls_insn"
@@ -6150,6 +6276,7 @@
         emit_insn (gen_fmulsu_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmulsu_insn"
Index: gcc/config/avr/avr-protos.h
===================================================================
--- a/src/gcc/config/avr/avr-protos.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr-protos.h	(.../branches/gcc-4_9-branch)
@@ -124,6 +124,15 @@
 extern bool avr_load_libgcc_p (rtx);
 extern bool avr_xload_libgcc_p (enum machine_mode);
 
+static inline unsigned
+regmask (enum machine_mode mode, unsigned regno)
+{
+  return ((1u << GET_MODE_SIZE (mode)) - 1) << regno;
+}
+
+extern void avr_fix_inputs (rtx*, unsigned, unsigned);
+extern bool avr_emit3_fix_outputs (rtx (*)(rtx,rtx,rtx), rtx*, unsigned, unsigned);
+
 extern rtx lpm_reg_rtx;
 extern rtx lpm_addr_reg_rtx;
 extern rtx tmp_reg_rtx;
Index: gcc/config/avr/driver-avr.c
===================================================================
--- a/src/gcc/config/avr/driver-avr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/driver-avr.c	(.../branches/gcc-4_9-branch)
@@ -60,7 +60,10 @@
 
   return concat ("-mmcu=", avr_current_arch->arch_name,
     avr_current_device->dev_attribute & AVR_ERRATA_SKIP ? "" : " -mno-skip-bug",
-    avr_current_device->dev_attribute & AVR_ISA_RMW ? " -mrmw" : "", NULL);
+#ifdef HAVE_AS_AVR_MRMW_OPTION
+    avr_current_device->dev_attribute & AVR_ISA_RMW ? " -mrmw" : "",
+#endif // have as -mrmw
+    NULL);
 }
 
 /* Returns command line parameters to pass to ld.  */
Index: gcc/config/avr/avr.c
===================================================================
--- a/src/gcc/config/avr/avr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr.c	(.../branches/gcc-4_9-branch)
@@ -51,6 +51,8 @@
 #include "target-def.h"
 #include "params.h"
 #include "df.h"
+#include "context.h"
+#include "tree-pass.h"
 
 /* Maximal allowed offset for an address in the LD command */
 #define MAX_LD_OFFSET(MODE) (64 - (signed)GET_MODE_SIZE (MODE))
@@ -285,6 +287,58 @@
 }
 
 
+static const pass_data avr_pass_data_recompute_notes =
+{
+  RTL_PASS,       // type
+  "",             // name (will be patched)
+  OPTGROUP_NONE,  // optinfo_flags
+  false,          // has_gate
+  true,           // has_execute
+  TV_DF_SCAN,     // tv_id
+  0,              // properties_required
+  0,              // properties_provided
+  0,              // properties_destroyed
+  0,              // todo_flags_start
+  // todo_flags_finish
+  TODO_df_finish | TODO_verify_rtl_sharing | TODO_verify_flow
+};
+
+
+class avr_pass_recompute_notes : public rtl_opt_pass
+{
+public:
+  avr_pass_recompute_notes (gcc::context *ctxt, const char *name)
+    : rtl_opt_pass (avr_pass_data_recompute_notes, ctxt)
+  {
+    this->name = name;
+  }
+
+  unsigned int execute (void)
+  {
+    df_note_add_problem ();
+    df_analyze ();
+
+    return 0;
+  }
+}; // avr_pass_recompute_notes
+
+
+static void
+avr_register_passes (void)
+{
+  /* This avr-specific pass (re)computes insn notes, in particular REG_DEAD
+     notes which are used by `avr.c::reg_unused_after' and branch offset
+     computations.  These notes must be correct, i.e. there must be no
+     dangling REG_DEAD notes; otherwise wrong code might result, cf. PR64331.
+
+     DF needs (correct) CFG, hence right before free_cfg is the last
+     opportunity to rectify notes.  */
+
+  register_pass (new avr_pass_recompute_notes (g, "avr-notes-free-cfg"),
+                 PASS_POS_INSERT_BEFORE, "*free_cfg", 1);
+}
+
+
 /* Implement `TARGET_OPTION_OVERRIDE'.  */
 
 static void
@@ -346,6 +400,11 @@
   init_machine_status = avr_init_machine_status;
 
   avr_log_set_avr_log();
+
+  /* Register some avr-specific pass(es).  There is no canonical place for
+     pass registration.  This function is convenient.  */
+
+  avr_register_passes ();
 }
 
 /* Function to set up the backend function structure.  */
@@ -7778,7 +7837,8 @@
      It is easier to state this in an insn attribute "adjust_len" than
      to clutter up code here...  */
 
-  if (-1 == recog_memoized (insn))
+  if (!NONDEBUG_INSN_P (insn)
+      || -1 == recog_memoized (insn))
     {
       return len;
     }
@@ -11118,6 +11178,115 @@
 }
 
 
+/* PR63633: The middle-end might come up with hard regs as input operands.
+
+   RMASK is a bit mask representing a subset of hard registers R0...R31:
+   Rn is an element of that set iff bit n of RMASK is set.
+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then
+   OP[n] has to be fixed; otherwise OP[n] is left alone.
+
+   For each element of OPMASK which is a hard register overlapping RMASK,
+   replace OP[n] with a newly created pseudo register
+
+   HREG == 0:  Also emit a move insn that copies the contents of that
+               hard register into the new pseudo.
+
+   HREG != 0:  Also set HREG[n] to the hard register.  */
+
+static void
+avr_fix_operands (rtx *op, rtx *hreg, unsigned opmask, unsigned rmask)
+{
+  for (; opmask; opmask >>= 1, op++)
+    {
+      rtx reg = *op;
+
+      if (hreg)
+        *hreg = NULL_RTX;
+
+      if ((opmask & 1)
+          && REG_P (reg)
+          && REGNO (reg) < FIRST_PSEUDO_REGISTER
+          // This hard-reg overlaps other prohibited hard regs?
+          && (rmask & regmask (GET_MODE (reg), REGNO (reg))))
+        {
+          *op = gen_reg_rtx (GET_MODE (reg));
+          if (hreg == NULL)
+            emit_move_insn (*op, reg);
+          else
+            *hreg = reg;
+        }
+
+      if (hreg)
+        hreg++;
+    }
+}
+
+
+void
+avr_fix_inputs (rtx *op, unsigned opmask, unsigned rmask)
+{
+  avr_fix_operands (op, NULL, opmask, rmask);
+}
+
+
+/* Helper for the function below:  If bit n of MASK is set and
+   HREG[n] != NULL, then emit a move insn to copy OP[n] to HREG[n].
+   Otherwise do nothing for that n.  Return TRUE.  */
+
+static bool
+avr_move_fixed_operands (rtx *op, rtx *hreg, unsigned mask)
+{
+  for (; mask; mask >>= 1, op++, hreg++)
+    if ((mask & 1)
+        && *hreg)
+      emit_move_insn (*hreg, *op);
+
+  return true;
+}
+
+
+/* PR63633: The middle-end might come up with hard regs as output operands.
+
+   GEN is a sequence generating function like gen_mulsi3 with 3 operands OP[].
+   RMASK is a bit mask representing a subset of hard registers R0...R31:
+   Rn is an element of that set iff bit n of RMASK is set.
+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then
+   OP[n] has to be fixed; otherwise OP[n] is left alone.
+
+   Emit the insn sequence as generated by GEN() with all elements of OPMASK
+   which are hard registers overlapping RMASK replaced by newly created
+   pseudo registers.  After the sequence has been emitted, emit insns that
+   move the contents of respective pseudos to their hard regs.  */
+
+bool
+avr_emit3_fix_outputs (rtx (*gen)(rtx,rtx,rtx), rtx *op,
+                       unsigned opmask, unsigned rmask)
+{
+  const int n = 3;
+  rtx hreg[n];
+
+  /* It is legitimate for GEN to call this function, and in order not to
+     get self-recursive we use the following static kludge.  This is the
+     only way not to duplicate all expanders and to avoid ugly and
+     hard-to-maintain C-code instead of the much more appreciated RTL
+     representation as supplied by define_expand.  */
+  static bool lock = false;
+
+  gcc_assert (opmask < (1u << n));
+
+  if (lock)
+    return false;
+
+  avr_fix_operands (op, hreg, opmask, rmask);
+
+  lock = true;
+  emit_insn (gen (op[0], op[1], op[2]));
+  lock = false;
+
+  return avr_move_fixed_operands (op, hreg, opmask);
+}
+
+
 /* Worker function for movmemhi expander.
    XOP[0]  Destination as MEM:BLK
    XOP[1]  Source      "     "
Index: gcc/config/nios2/nios2.c
===================================================================
--- a/src/gcc/config/nios2/nios2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/nios2/nios2.c	(.../branches/gcc-4_9-branch)
@@ -2135,6 +2135,18 @@
   fprintf (file, ")");
 }
 
+/* Implemet TARGET_ASM_FILE_END.  */
+
+static void
+nios2_asm_file_end (void)
+{
+  /* The Nios II Linux stack is mapped non-executable by default, so add a
+     .note.GNU-stack section for switching to executable stacks only when
+     trampolines are generated.  */
+  if (TARGET_LINUX_ABI && trampolines_created)
+    file_end_indicate_exec_stack ();
+}
+
 /* Implement TARGET_ASM_FUNCTION_PROLOGUE.  */
 static void
 nios2_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)
@@ -3313,6 +3325,9 @@
 #undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA
 #define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA nios2_output_addr_const_extra
 
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END nios2_asm_file_end
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE nios2_option_override
 
Index: gcc/config/ia64/ia64.c
===================================================================
--- a/src/gcc/config/ia64/ia64.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/ia64/ia64.c	(.../branches/gcc-4_9-branch)
@@ -11495,7 +11495,10 @@
       gcc_assert (e < nelt);
       dfinal.perm[i] = e;
     }
-  dfinal.op0 = gen_reg_rtx (dfinal.vmode);
+  if (d->testing_p)
+    dfinal.op0 = gen_raw_REG (dfinal.vmode, LAST_VIRTUAL_REGISTER + 1);
+  else
+    dfinal.op0 = gen_reg_rtx (dfinal.vmode);
   dfinal.op1 = dfinal.op0;
   dfinal.one_operand_p = true;
   dremap.target = dfinal.op0;
Index: gcc/config/aarch64/aarch64-simd.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64-simd.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64-simd.md	(.../branches/gcc-4_9-branch)
@@ -934,6 +934,41 @@
   [(set_attr "type" "neon_minmax<q>")]
 )
 
+(define_expand "<su><maxmin>v2di3"
+  [(parallel [
+    (set (match_operand:V2DI 0 "register_operand" "")
+	 (MAXMIN:V2DI (match_operand:V2DI 1 "register_operand" "")
+		  (match_operand:V2DI 2 "register_operand" "")))
+    (clobber (reg:CC CC_REGNUM))])]
+  "TARGET_SIMD"
+{
+  enum rtx_code cmp_operator;
+  rtx cmp_fmt;
+
+  switch (<CODE>)
+    {
+    case UMIN:
+      cmp_operator = LTU;
+      break;
+    case SMIN:
+      cmp_operator = LT;
+      break;
+    case UMAX:
+      cmp_operator = GTU;
+      break;
+    case SMAX:
+      cmp_operator = GT;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  cmp_fmt = gen_rtx_fmt_ee (cmp_operator, V2DImode, operands[1], operands[2]);
+  emit_insn (gen_aarch64_vcond_internalv2div2di (operands[0], operands[1],
+              operands[2], cmp_fmt, operands[1], operands[2]));
+  DONE;
+})
+
 ;; vec_concat gives a new vector with the low elements from operand 1, and
 ;; the high elements from operand 2.  That is to say, given op1 = { a, b }
 ;; op2 = { c, d }, vec_concat (op1, op2) = { a, b, c, d }.
@@ -4565,8 +4600,8 @@
 })
 
 (define_insn "*aarch64_simd_ld1r<mode>"
-  [(set (match_operand:VALLDI 0 "register_operand" "=w")
-	(vec_duplicate:VALLDI
+  [(set (match_operand:VALL 0 "register_operand" "=w")
+	(vec_duplicate:VALL
 	  (match_operand:<VEL> 1 "aarch64_simd_struct_operand" "Utv")))]
   "TARGET_SIMD"
   "ld1r\\t{%0.<Vtype>}, %1"
Index: gcc/config/aarch64/aarch64.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64.md	(.../branches/gcc-4_9-branch)
@@ -2782,7 +2782,7 @@
 
 ;; Logical right shift using SISD or Integer instruction
 (define_insn "*aarch64_lshr_sisd_or_int_<mode>3"
-  [(set (match_operand:GPI 0 "register_operand" "=w,w,r")
+  [(set (match_operand:GPI 0 "register_operand" "=w,&w,r")
         (lshiftrt:GPI
           (match_operand:GPI 1 "register_operand" "w,w,r")
           (match_operand:QI 2 "aarch64_reg_or_shift_imm_<mode>" "Us<cmode>,w,rUs<cmode>")))]
@@ -2801,11 +2801,13 @@
            (match_operand:DI 1 "aarch64_simd_register")
            (match_operand:QI 2 "aarch64_simd_register")))]
   "TARGET_SIMD && reload_completed"
-  [(set (match_dup 2)
+  [(set (match_dup 3)
         (unspec:QI [(match_dup 2)] UNSPEC_SISD_NEG))
    (set (match_dup 0)
-        (unspec:DI [(match_dup 1) (match_dup 2)] UNSPEC_SISD_USHL))]
-  ""
+        (unspec:DI [(match_dup 1) (match_dup 3)] UNSPEC_SISD_USHL))]
+  {
+    operands[3] = gen_lowpart (QImode, operands[0]);
+  }
 )
 
 (define_split
@@ -2814,11 +2816,13 @@
            (match_operand:SI 1 "aarch64_simd_register")
            (match_operand:QI 2 "aarch64_simd_register")))]
   "TARGET_SIMD && reload_completed"
-  [(set (match_dup 2)
+  [(set (match_dup 3)
         (unspec:QI [(match_dup 2)] UNSPEC_SISD_NEG))
    (set (match_dup 0)
-        (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_USHL_2S))]
-  ""
+        (unspec:SI [(match_dup 1) (match_dup 3)] UNSPEC_USHL_2S))]
+  {
+    operands[3] = gen_lowpart (QImode, operands[0]);
+  }
 )
 
 ;; Arithmetic right shift using SISD or Integer instruction
Index: gcc/config/aarch64/aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64.c	(.../branches/gcc-4_9-branch)
@@ -659,6 +659,10 @@
     case SYMBOL_SMALL_TPREL:
       {
 	rtx tp = aarch64_load_tp (NULL);
+
+	if (GET_MODE (dest) != Pmode)
+	  tp = gen_lowpart (GET_MODE (dest), tp);
+
 	emit_insn (gen_tlsle_small (dest, tp, imm));
 	set_unique_reg_note (get_last_insn (), REG_EQUIV, imm);
 	return;
@@ -5152,7 +5156,6 @@
       if (strlen (cpu->name) == len && strncmp (cpu->name, str, len) == 0)
 	{
 	  selected_cpu = cpu;
-	  selected_tune = cpu;
 	  aarch64_isa_flags = selected_cpu->flags;
 
 	  if (ext != NULL)
@@ -5248,9 +5251,8 @@
 
   gcc_assert (selected_cpu);
 
-  /* The selected cpu may be an architecture, so lookup tuning by core ID.  */
   if (!selected_tune)
-    selected_tune = &all_cores[selected_cpu->core];
+    selected_tune = selected_cpu;
 
   aarch64_tune_flags = selected_tune->flags;
   aarch64_tune = selected_tune->core;
Index: gcc/config/aarch64/aarch64-elf-raw.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-elf-raw.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64-elf-raw.h	(.../branches/gcc-4_9-branch)
@@ -25,9 +25,18 @@
 #define STARTFILE_SPEC " crti%O%s crtbegin%O%s crt0%O%s"
 #define ENDFILE_SPEC " crtend%O%s crtn%O%s"
 
+#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
+#define CA53_ERR_835769_SPEC \
+  " %{!mno-fix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#else
+#define CA53_ERR_835769_SPEC \
+  " %{mfix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#endif
+
 #ifndef LINK_SPEC
 #define LINK_SPEC "%{mbig-endian:-EB} %{mlittle-endian:-EL} -X \
-  -maarch64elf%{mabi=ilp32*:32}%{mbig-endian:b}"
+  -maarch64elf%{mabi=ilp32*:32}%{mbig-endian:b}" \
+  CA53_ERR_835769_SPEC
 #endif
 
 #endif /* GCC_AARCH64_ELF_RAW_H */
Index: gcc/config/aarch64/aarch64-linux.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-linux.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64-linux.h	(.../branches/gcc-4_9-branch)
@@ -35,8 +35,17 @@
    %{mbig-endian:-EB} %{mlittle-endian:-EL}     \
    -maarch64linux%{mbig-endian:b}"
 
-#define LINK_SPEC LINUX_TARGET_LINK_SPEC
+#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
+#define CA53_ERR_835769_SPEC \
+  " %{!mno-fix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#else
+#define CA53_ERR_835769_SPEC \
+  " %{mfix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#endif
 
+#define LINK_SPEC LINUX_TARGET_LINK_SPEC \
+                  CA53_ERR_835769_SPEC
+
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
Index: gcc/config/rs6000/t-fprules
===================================================================
--- a/src/gcc/config/rs6000/t-fprules	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/t-fprules	(.../branches/gcc-4_9-branch)
@@ -18,9 +18,3 @@
 
 SOFT_FLOAT_CPUS = e300c2 401 403 405 440 464 476 ec603e 801 821 823 860
 MULTILIB_MATCHES_FLOAT = $(foreach cpu, $(SOFT_FLOAT_CPUS), msoft-float=mcpu?$(cpu))
-
-# Build the libraries for both hard and soft floating point by default
-
-MULTILIB_OPTIONS = msoft-float
-MULTILIB_DIRNAMES = soft-float
-MULTILIB_MATCHES	= ${MULTILIB_MATCHES_FLOAT}
Index: gcc/config/rs6000/rs6000-tables.opt
===================================================================
--- a/src/gcc/config/rs6000/rs6000-tables.opt	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-tables.opt	(.../branches/gcc-4_9-branch)
@@ -186,5 +186,8 @@
 Enum(rs6000_cpu_opt_value) String(powerpc64) Value(52)
 
 EnumValue
-Enum(rs6000_cpu_opt_value) String(rs64) Value(53)
+Enum(rs6000_cpu_opt_value) String(powerpc64le) Value(53)
 
+EnumValue
+Enum(rs6000_cpu_opt_value) String(rs64) Value(54)
+
Index: gcc/config/rs6000/htm.md
===================================================================
--- a/src/gcc/config/rs6000/htm.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/htm.md	(.../branches/gcc-4_9-branch)
@@ -245,7 +245,7 @@
 	(unspec_volatile:CC [(match_operand 0 "u3bit_cint_operand" "n")]
 			    UNSPECV_HTM_TCHECK))]
   "TARGET_HTM"
-  "tcheck. %0"
+  "tcheck %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
Index: gcc/config/rs6000/t-rtems
===================================================================
--- a/src/gcc/config/rs6000/t-rtems	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/t-rtems	(.../branches/gcc-4_9-branch)
@@ -18,16 +18,24 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-MULTILIB_OPTIONS	= \
-mcpu=403/mcpu=505/mcpu=603e/mcpu=604/mcpu=860/mcpu=7400/mcpu=8540 \
-msoft-float/mfloat-gprs=double
+MULTILIB_OPTIONS =
+MULTILIB_DIRNAMES =
+MULTILIB_MATCHES =
+MULTILIB_EXCEPTIONS =
+MULTILIB_REQUIRED =
 
-MULTILIB_DIRNAMES	= \
-m403 m505 m603e m604 m860 m7400 m8540 \
-nof gprsdouble
+MULTILIB_OPTIONS += mcpu=403/mcpu=505/mcpu=603e/mcpu=604/mcpu=860/mcpu=7400/mcpu=8540/mcpu=e6500
+MULTILIB_DIRNAMES += m403 m505 m603e m604 m860 m7400 m8540 me6500
 
-# MULTILIB_MATCHES	= ${MULTILIB_MATCHES_FLOAT}
-MULTILIB_MATCHES	=
+MULTILIB_OPTIONS += m32
+MULTILIB_DIRNAMES += m32
+
+MULTILIB_OPTIONS += msoft-float/mfloat-gprs=double
+MULTILIB_DIRNAMES += nof gprsdouble
+
+MULTILIB_OPTIONS += mno-spe/mno-altivec
+MULTILIB_DIRNAMES += nospe noaltivec
+
 MULTILIB_MATCHES  	+= ${MULTILIB_MATCHES_ENDIAN}
 MULTILIB_MATCHES	+= ${MULTILIB_MATCHES_SYSV}
 # Map 405 to 403
@@ -52,37 +60,20 @@
 # (mfloat-gprs=single is implicit default)
 MULTILIB_MATCHES	+= mcpu?8540=mcpu?8540/mfloat-gprs?single
 
-# Soft-float only, default implies msoft-float
-# NOTE: Must match with MULTILIB_MATCHES_FLOAT and MULTILIB_MATCHES
-MULTILIB_SOFTFLOAT_ONLY = \
-*mcpu=401/*msoft-float* \
-*mcpu=403/*msoft-float* \
-*mcpu=405/*msoft-float* \
-*mcpu=801/*msoft-float* \
-*mcpu=821/*msoft-float* \
-*mcpu=823/*msoft-float* \
-*mcpu=860/*msoft-float*
+# Enumeration of multilibs
 
-# Hard-float only, take out msoft-float
-MULTILIB_HARDFLOAT_ONLY = \
-*mcpu=505/*msoft-float*
-
-# Targets which do not support gprs
-MULTILIB_NOGPRS = \
-mfloat-gprs=* \
-*mcpu=403/*mfloat-gprs=* \
-*mcpu=505/*mfloat-gprs=* \
-*mcpu=603e/*mfloat-gprs=* \
-*mcpu=604/*mfloat-gprs=* \
-*mcpu=860/*mfloat-gprs=* \
-*mcpu=7400/*mfloat-gprs=*
-
-MULTILIB_EXCEPTIONS =
-
-# Disallow -Dppc and -Dmpc without other options
-MULTILIB_EXCEPTIONS 	+= Dppc* Dmpc*
-
-MULTILIB_EXCEPTIONS	+= \
-${MULTILIB_SOFTFLOAT_ONLY} \
-${MULTILIB_HARDFLOAT_ONLY} \
-${MULTILIB_NOGPRS}
+MULTILIB_REQUIRED += msoft-float
+MULTILIB_REQUIRED += mcpu=403
+MULTILIB_REQUIRED += mcpu=505
+MULTILIB_REQUIRED += mcpu=603e
+MULTILIB_REQUIRED += mcpu=603e/msoft-float
+MULTILIB_REQUIRED += mcpu=604
+MULTILIB_REQUIRED += mcpu=604/msoft-float
+MULTILIB_REQUIRED += mcpu=7400
+MULTILIB_REQUIRED += mcpu=7400/msoft-float
+MULTILIB_REQUIRED += mcpu=8540
+MULTILIB_REQUIRED += mcpu=8540/msoft-float/mno-spe
+MULTILIB_REQUIRED += mcpu=8540/mfloat-gprs=double
+MULTILIB_REQUIRED += mcpu=860
+MULTILIB_REQUIRED += mcpu=e6500/m32
+MULTILIB_REQUIRED += mcpu=e6500/m32/msoft-float/mno-altivec
Index: gcc/config/rs6000/rs6000-cpus.def
===================================================================
--- a/src/gcc/config/rs6000/rs6000-cpus.def	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-cpus.def	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* IBM RS/6000 CPU names..
-   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   Copyright (C) 1991-2015 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -91,6 +91,7 @@
 				 | OPTION_MASK_PPC_GFXOPT		\
 				 | OPTION_MASK_PPC_GPOPT		\
 				 | OPTION_MASK_QUAD_MEMORY		\
+				 | OPTION_MASK_QUAD_MEMORY_ATOMIC	\
 				 | OPTION_MASK_RECIP_PRECISION		\
 				 | OPTION_MASK_SOFT_FLOAT		\
 				 | OPTION_MASK_STRICT_ALIGN_OPTIONAL	\
@@ -188,4 +189,5 @@
 RS6000_CPU ("power8", PROCESSOR_POWER8, MASK_POWERPC64 | ISA_2_7_MASKS_SERVER)
 RS6000_CPU ("powerpc", PROCESSOR_POWERPC, 0)
 RS6000_CPU ("powerpc64", PROCESSOR_POWERPC64, MASK_PPC_GFXOPT | MASK_POWERPC64)
+RS6000_CPU ("powerpc64le", PROCESSOR_POWER8, MASK_POWERPC64 | ISA_2_7_MASKS_SERVER)
 RS6000_CPU ("rs64", PROCESSOR_RS64A, MASK_PPC_GFXOPT | MASK_POWERPC64)
Index: gcc/config/rs6000/t-linux
===================================================================
--- a/src/gcc/config/rs6000/t-linux	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/t-linux	(.../branches/gcc-4_9-branch)
@@ -1,12 +1,22 @@
 # do not define the multiarch name if configured for a soft-float cpu
 # or soft-float.
 ifeq (,$(filter $(with_cpu),$(SOFT_FLOAT_CPUS))$(findstring soft,$(with_float)))
+ifneq (,$(findstring powerpc64,$(target)))
+MULTILIB_OSDIRNAMES := .=../lib64$(call if_multiarch,:powerpc64-linux-gnu)
+else
 ifneq (,$(findstring spe,$(target)))
-MULTIARCH_DIRNAME = powerpc-linux-gnuspe$(if $(findstring 8548,$(with_cpu)),,v1)
+MULTIARCH_DIRNAME := powerpc-linux-gnuspe$(if $(findstring 8548,$(with_cpu)),,v1)
 else
-MULTIARCH_DIRNAME = powerpc-linux-gnu
+MULTIARCH_DIRNAME := powerpc-linux-gnu
 endif
 endif
+ifneq (,$(findstring powerpcle,$(target)))
+MULTIARCH_DIRNAME := $(subst -linux,le-linux,$(MULTIARCH_DIRNAME))
+endif
+ifneq (,$(findstring powerpc64le,$(target)))
+MULTILIB_OSDIRNAMES := $(subst -linux,le-linux,$(MULTILIB_OSDIRNAMES))
+endif
+endif
 
 rs6000-linux.o: $(srcdir)/config/rs6000/rs6000-linux.c
 	$(COMPILE) $<
Index: gcc/config/rs6000/rs6000-protos.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000-protos.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-protos.h	(.../branches/gcc-4_9-branch)
@@ -65,6 +65,7 @@
 extern void altivec_expand_stvex_be (rtx, rtx, enum machine_mode, unsigned);
 extern void rs6000_expand_extract_even (rtx, rtx, rtx);
 extern void rs6000_expand_interleave (rtx, rtx, rtx, bool);
+extern void rs6000_scale_v2df (rtx, rtx, int);
 extern void build_mask64_2_operands (rtx, rtx *);
 extern int expand_block_clear (rtx[]);
 extern int expand_block_move (rtx[]);
Index: gcc/config/rs6000/xcoff.h
===================================================================
--- a/src/gcc/config/rs6000/xcoff.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/xcoff.h	(.../branches/gcc-4_9-branch)
@@ -304,14 +304,15 @@
   do { fputs (LOCAL_COMMON_ASM_OP, (FILE));			\
        RS6000_OUTPUT_BASENAME ((FILE), (NAME));			\
        if ((ALIGN) > 32)					\
-	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s,%u\n",	\
+	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s%u_,%u\n",	\
 		  (SIZE), xcoff_bss_section_name,			\
+		  floor_log2 ((ALIGN) / BITS_PER_UNIT),			\
 		  floor_log2 ((ALIGN) / BITS_PER_UNIT));		\
        else if ((SIZE) > 4)					\
-	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s,3\n",	\
+	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s3_,3\n",	\
 		  (SIZE), xcoff_bss_section_name);		\
        else							\
-	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s\n",	\
+	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s,2\n",	\
 		  (SIZE), xcoff_bss_section_name);		\
      } while (0)
 #endif
Index: gcc/config/rs6000/rtems.h
===================================================================
--- a/src/gcc/config/rs6000/rtems.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rtems.h	(.../branches/gcc-4_9-branch)
@@ -52,7 +52,8 @@
 %{mcpu=750:  %{!Dppc*: %{!Dmpc*: -Dmpc750}  } } \
 %{mcpu=821:  %{!Dppc*: %{!Dmpc*: -Dmpc821}  } } \
 %{mcpu=860:  %{!Dppc*: %{!Dmpc*: -Dmpc860}  } } \
-%{mcpu=8540: %{!Dppc*: %{!Dmpc*: -Dppc8540}  } }" 
+%{mcpu=8540: %{!Dppc*: %{!Dmpc*: -Dppc8540}  } } \
+%{mcpu=e6500: -D__PPC_CPU_E6500__}"
 
 #undef  SUBSUBTARGET_EXTRA_SPECS
 #define SUBSUBTARGET_EXTRA_SPECS \
Index: gcc/config/rs6000/default64.h
===================================================================
--- a/src/gcc/config/rs6000/default64.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/default64.h	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler,
    for 64 bit powerpc linux defaulting to -m64.
-   Copyright (C) 2003-2014 Free Software Foundation, Inc.
+   Copyright (C) 2003-2015 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -18,10 +18,14 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#define RS6000_CPU(NAME, CPU, FLAGS)
+#include "rs6000-cpus.def"
+#undef RS6000_CPU
+
 #if (TARGET_DEFAULT & MASK_LITTLE_ENDIAN)
 #undef TARGET_DEFAULT
-#define TARGET_DEFAULT (MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_64BIT | MASK_LITTLE_ENDIAN)
+#define TARGET_DEFAULT (ISA_2_7_MASKS_SERVER | MASK_POWERPC64 | MASK_64BIT | MASK_LITTLE_ENDIAN)
 #else
 #undef TARGET_DEFAULT
-#define TARGET_DEFAULT (MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_64BIT)
+#define TARGET_DEFAULT (MASK_PPC_GFXOPT | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64 | MASK_64BIT)
 #endif
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
--- a/src/gcc/config/rs6000/rs6000-builtin.def	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-builtin.def	(.../branches/gcc-4_9-branch)
@@ -1258,7 +1258,17 @@
 BU_VSX_2 (VEC_MERGEL_V2DI,    "mergel_2di",	CONST,	vsx_mergel_v2di)
 BU_VSX_2 (VEC_MERGEH_V2DF,    "mergeh_2df",	CONST,	vsx_mergeh_v2df)
 BU_VSX_2 (VEC_MERGEH_V2DI,    "mergeh_2di",	CONST,	vsx_mergeh_v2di)
+BU_VSX_2 (XXSPLTD_V2DF,       "xxspltd_2df",    CONST,  vsx_xxspltd_v2df)
+BU_VSX_2 (XXSPLTD_V2DI,       "xxspltd_2di",    CONST,  vsx_xxspltd_v2di)
+BU_VSX_2 (DIV_V2DI,           "div_2di",        CONST,  vsx_div_v2di)
+BU_VSX_2 (UDIV_V2DI,          "udiv_2di",       CONST,  vsx_udiv_v2di)
+BU_VSX_2 (MUL_V2DI,           "mul_2di",        CONST,  vsx_mul_v2di)
 
+BU_VSX_2 (XVCVSXDDP_SCALE,    "xvcvsxddp_scale", CONST, vsx_xvcvsxddp_scale)
+BU_VSX_2 (XVCVUXDDP_SCALE,    "xvcvuxddp_scale", CONST, vsx_xvcvuxddp_scale)
+BU_VSX_2 (XVCVDPSXDS_SCALE,   "xvcvdpsxds_scale", CONST, vsx_xvcvdpsxds_scale)
+BU_VSX_2 (XVCVDPUXDS_SCALE,   "xvcvdpuxds_scale", CONST, vsx_xvcvdpuxds_scale)
+
 /* VSX abs builtin functions.  */
 BU_VSX_A (XVABSDP,	      "xvabsdp",	CONST,	absv2df2)
 BU_VSX_A (XVNABSDP,	      "xvnabsdp",	CONST,	vsx_nabsv2df2)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-4_9-branch)
@@ -597,6 +597,8 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_ROUND, ALTIVEC_BUILTIN_VRFIN,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_ROUND, VSX_BUILTIN_XVRDPI,
+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_RECIP, ALTIVEC_BUILTIN_VRECIPFP,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_RECIP, VSX_BUILTIN_RECIP_V2DF,
@@ -877,6 +879,18 @@
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -931,6 +945,18 @@
   { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -1118,6 +1144,10 @@
     RS6000_BTI_V4SF, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_CTF, ALTIVEC_BUILTIN_VCFSX,
     RS6000_BTI_V4SF, RS6000_BTI_V4SI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_CTF, VSX_BUILTIN_XVCVSXDDP_SCALE,
+    RS6000_BTI_V2DF, RS6000_BTI_V2DI, RS6000_BTI_INTSI, 0},
+  { ALTIVEC_BUILTIN_VEC_CTF, VSX_BUILTIN_XVCVUXDDP_SCALE,
+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI, 0},
   { ALTIVEC_BUILTIN_VEC_VCFSX, ALTIVEC_BUILTIN_VCFSX,
     RS6000_BTI_V4SF, RS6000_BTI_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_VCFUX, ALTIVEC_BUILTIN_VCFUX,
@@ -1124,12 +1154,20 @@
     RS6000_BTI_V4SF, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_CTS, ALTIVEC_BUILTIN_VCTSXS,
     RS6000_BTI_V4SI, RS6000_BTI_V4SF, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_CTS, VSX_BUILTIN_XVCVDPSXDS_SCALE,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_CTU, ALTIVEC_BUILTIN_VCTUXS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_V4SF, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_CTU, VSX_BUILTIN_XVCVDPUXDS_SCALE,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_V2DF, RS6000_BTI_INTSI, 0 },
   { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_XVDIVSP,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_XVDIVDP,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_DIV_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_UDIV_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
@@ -1595,6 +1633,16 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGHW, ALTIVEC_BUILTIN_VMRGHW,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGHW, ALTIVEC_BUILTIN_VMRGHW,
@@ -1643,6 +1691,16 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGLW, ALTIVEC_BUILTIN_VMRGLW,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGLW, ALTIVEC_BUILTIN_VMRGLW,
@@ -1771,6 +1829,10 @@
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { VSX_BUILTIN_VEC_MUL, VSX_BUILTIN_XVMULDP,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_MUL, VSX_BUILTIN_MUL_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { VSX_BUILTIN_VEC_MUL, VSX_BUILTIN_MUL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_MULE, ALTIVEC_BUILTIN_VMULEUB,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_MULE, ALTIVEC_BUILTIN_VMULESB,
@@ -1812,6 +1874,18 @@
   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
@@ -1842,6 +1916,18 @@
   { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -1945,6 +2031,8 @@
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VPKSWUS, ALTIVEC_BUILTIN_VPKSWUS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_VPKSHUS, ALTIVEC_BUILTIN_VPKSHUS,
@@ -2127,6 +2215,14 @@
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_SPLAT, ALTIVEC_BUILTIN_VSPLTW,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DI,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_VSPLTW, ALTIVEC_BUILTIN_VSPLTW,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_VSPLTW, ALTIVEC_BUILTIN_VSPLTW,
@@ -2519,6 +2615,18 @@
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -2778,6 +2886,8 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_4SI,
@@ -2818,6 +2928,12 @@
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI },
   { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI },
+  { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_V2DI },
   { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI },
   { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_4SF,
@@ -3267,6 +3383,8 @@
 
   { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
   { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
   { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DI,
@@ -3321,6 +3439,8 @@
 
   { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DF,
     RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double },
   { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DI,
     RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
   { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DI,
@@ -3431,6 +3551,18 @@
     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI },
   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, ALTIVEC_BUILTIN_VCMPGTSW_P,
     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SI, RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTUD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTUD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTUD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_V2DI },
   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, ALTIVEC_BUILTIN_VCMPGTFP_P,
     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SF, RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, VSX_BUILTIN_XVCMPGTDP_P,
@@ -3889,6 +4021,8 @@
   { P8V_BUILTIN_VEC_VMRGEW, P8V_BUILTIN_VMRGEW,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
+  { P8V_BUILTIN_VEC_VMRGEW, P8V_BUILTIN_VMRGEW,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
 
   { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
@@ -3895,6 +4029,8 @@
   { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
+  { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
 
   { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTB,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },
Index: gcc/config/rs6000/rs6000.opt
===================================================================
--- a/src/gcc/config/rs6000/rs6000.opt	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000.opt	(.../branches/gcc-4_9-branch)
@@ -588,3 +588,7 @@
 mupper-regs-sf
 Target Undocumented Mask(UPPER_REGS_SF) Var(rs6000_isa_flags)
 Allow float variables in upper registers with -mcpu=power8 or -mp8-vector
+
+moptimize-swaps
+Target Undocumented Var(rs6000_optimize_swaps) Init(1) Save
+Analyze and remove doubleword swaps from VSX computations.
Index: gcc/config/rs6000/linux64.h
===================================================================
--- a/src/gcc/config/rs6000/linux64.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/linux64.h	(.../branches/gcc-4_9-branch)
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler,
    for 64 bit PowerPC linux.
-   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Copyright (C) 2000-2015 Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -71,11 +71,7 @@
 #undef  PROCESSOR_DEFAULT
 #define PROCESSOR_DEFAULT PROCESSOR_POWER7
 #undef  PROCESSOR_DEFAULT64
-#ifdef LINUX64_DEFAULT_ABI_ELFv2
 #define PROCESSOR_DEFAULT64 PROCESSOR_POWER8
-#else
-#define PROCESSOR_DEFAULT64 PROCESSOR_POWER7
-#endif
 
 /* We don't need to generate entries in .fixup, except when
    -mrelocatable or -mrelocatable-lib is given.  */
@@ -101,7 +97,7 @@
     {								\
       if (!global_options_set.x_rs6000_alignment_flags)		\
 	rs6000_alignment_flags = MASK_ALIGN_NATURAL;		\
-      if (TARGET_64BIT)						\
+      if (rs6000_isa_flags & OPTION_MASK_64BIT)			\
 	{							\
 	  if (DEFAULT_ABI != ABI_AIX)				\
 	    {							\
Index: gcc/config/rs6000/darwin.h
===================================================================
--- a/src/gcc/config/rs6000/darwin.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/darwin.h	(.../branches/gcc-4_9-branch)
@@ -206,7 +206,11 @@
     "vrsave", "vscr",							\
     "spe_acc", "spefscr",                                               \
     "sfp",								\
-    "tfhar", "tfiar", "texasr"						\
+    "tfhar", "tfiar", "texasr",						\
+    "rh0",  "rh1",  "rh2",  "rh3",  "rh4",  "rh5",  "rh6",  "rh7",	\
+    "rh8",  "rh9",  "rh10", "rh11", "rh12", "rh13", "rh14", "rh15",	\
+    "rh16", "rh17", "rh18", "rh19", "rh20", "rh21", "rh22", "rh23",	\
+    "rh24", "rh25", "rh26", "rh27", "rh28", "rh29", "rh30", "rh31"	\
 }
 
 /* This outputs NAME to FILE.  */
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* Subroutines used for code generation on IBM RS/6000.
-   Copyright (C) 1991-2014 Free Software Foundation, Inc.
+   Copyright (C) 1991-2015 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -79,6 +79,9 @@
 #include "dumpfile.h"
 #include "cgraph.h"
 #include "target-globals.h"
+#include "real.h"
+#include "context.h"
+#include "tree-pass.h"
 #if TARGET_XCOFF
 #include "xcoffout.h"  /* get declarations of xcoff_*_section_name */
 #endif
@@ -1171,6 +1174,7 @@
 					  enum machine_mode,
 					  secondary_reload_info *,
 					  bool);
+rtl_opt_pass *make_pass_analyze_swaps (gcc::context*);
 
 /* Hash table stuff for keeping track of TOC entries.  */
 
@@ -3099,6 +3103,10 @@
     = ((global_init_p || target_option_default_node == NULL)
        ? NULL : TREE_TARGET_OPTION (target_option_default_node));
 
+  /* Print defaults.  */
+  if ((TARGET_DEBUG_REG || TARGET_DEBUG_TARGET) && global_init_p)
+    rs6000_print_isa_options (stderr, 0, "TARGET_DEFAULT", TARGET_DEFAULT);
+
   /* Remember the explicit arguments.  */
   if (global_init_p)
     rs6000_isa_flags_explicit = global_options_set.x_rs6000_isa_flags;
@@ -3175,7 +3183,13 @@
     }
   else
     {
-      const char *default_cpu = (TARGET_POWERPC64 ? "powerpc64" : "powerpc");
+      /* PowerPC 64-bit LE requires at least ISA 2.07.  */
+      const char *default_cpu = ((!TARGET_POWERPC64)
+				 ? "powerpc"
+				 : ((BYTES_BIG_ENDIAN)
+				    ? "powerpc64"
+				    : "powerpc64le"));
+
       rs6000_cpu_index = cpu_index = rs6000_cpu_name_lookup (default_cpu);
       have_cpu = false;
     }
@@ -3194,15 +3208,18 @@
 			   & set_masks);
     }
   else
-    rs6000_isa_flags |= (processor_target_table[cpu_index].target_enable
-			 & ~rs6000_isa_flags_explicit);
+    {
+      /* If no -mcpu=<xxx>, inherit any default options that were cleared via
+	 POWERPC_MASKS.  Originally, TARGET_DEFAULT was used to initialize
+	 target_flags via the TARGET_DEFAULT_TARGET_FLAGS hook.  When we switched
+	 to using rs6000_isa_flags, we need to do the initialization here.
 
-  /* If no -mcpu=<xxx>, inherit any default options that were cleared via
-     POWERPC_MASKS.  Originally, TARGET_DEFAULT was used to initialize
-     target_flags via the TARGET_DEFAULT_TARGET_FLAGS hook.  When we switched
-     to using rs6000_isa_flags, we need to do the initialization here.  */
-  if (!have_cpu)
-    rs6000_isa_flags |= (TARGET_DEFAULT & ~rs6000_isa_flags_explicit);
+	 If there is a TARGET_DEFAULT, use that.  Otherwise fall back to using
+	 -mcpu=powerpc, -mcpu=powerpc64, or -mcpu=powerpc64le defaults.  */
+      HOST_WIDE_INT flags = ((TARGET_DEFAULT) ? TARGET_DEFAULT
+			     : processor_target_table[cpu_index].target_enable);
+      rs6000_isa_flags |= (flags & ~rs6000_isa_flags_explicit);
+    }
 
   if (rs6000_tune_index >= 0)
     tune_index = rs6000_tune_index;
@@ -4054,12 +4071,8 @@
      target_flags.  */
   rs6000_builtin_mask = rs6000_builtin_mask_calculate ();
   if (TARGET_DEBUG_BUILTIN || TARGET_DEBUG_TARGET)
-    {
-      fprintf (stderr,
-	       "new builtin mask = " HOST_WIDE_INT_PRINT_HEX ", ",
-	       rs6000_builtin_mask);
-      rs6000_print_builtin_options (stderr, 0, NULL, rs6000_builtin_mask);
-    }
+    rs6000_print_builtin_options (stderr, 0, "builtin mask",
+				  rs6000_builtin_mask);
 
   /* Initialize all of the registers.  */
   rs6000_init_hard_regno_mode_ok (global_init_p);
@@ -4084,6 +4097,15 @@
 rs6000_option_override (void)
 {
   (void) rs6000_option_override_internal (true);
+
+  /* Register machine-specific passes.  This needs to be done at start-up.
+     It's convenient to do it here (like i386 does).  */
+  opt_pass *pass_analyze_swaps = make_pass_analyze_swaps (g);
+
+  static struct register_pass_info analyze_swaps_info
+    = { pass_analyze_swaps, "cse1", 1, PASS_POS_INSERT_BEFORE };
+
+  register_pass (&analyze_swaps_info);
 }
 
 
@@ -4929,6 +4951,28 @@
       switch_to_section (toc_section);
       switch_to_section (text_section);
     }
+
+#ifdef USING_ELFOS_H
+  if (rs6000_default_cpu == 0 || rs6000_default_cpu[0] == '\0'
+      || !global_options_set.x_rs6000_cpu_index)
+    {
+      fputs ("\t.machine ", asm_out_file);
+      if ((rs6000_isa_flags & OPTION_MASK_DIRECT_MOVE) != 0)
+	fputs ("power8\n", asm_out_file);
+      else if ((rs6000_isa_flags & OPTION_MASK_POPCNTD) != 0)
+	fputs ("power7\n", asm_out_file);
+      else if ((rs6000_isa_flags & OPTION_MASK_CMPB) != 0)
+	fputs ("power6\n", asm_out_file);
+      else if ((rs6000_isa_flags & OPTION_MASK_POPCNTB) != 0)
+	fputs ("power5\n", asm_out_file);
+      else if ((rs6000_isa_flags & OPTION_MASK_MFCRF) != 0)
+	fputs ("power4\n", asm_out_file);
+      else if ((rs6000_isa_flags & OPTION_MASK_POWERPC64) != 0)
+	fputs ("ppc64\n", asm_out_file);
+      else
+	fputs ("ppc\n", asm_out_file);
+    }
+#endif
 }
 
 
@@ -6896,24 +6940,6 @@
   if (GET_CODE (y) == UNSPEC
       && XINT (y, 1) == UNSPEC_TOCREL)
     {
-#ifdef ENABLE_CHECKING
-      if (REG_P (XVECEXP (y, 0, 1))
-	  && REGNO (XVECEXP (y, 0, 1)) == TOC_REGISTER)
-	{
-	  /* All good.  */
-	}
-      else if (GET_CODE (XVECEXP (y, 0, 1)) == DEBUG_EXPR)
-	{
-	  /* Weirdness alert.  df_note_compute can replace r2 with a
-	     debug_expr when this unspec is in a debug_insn.
-	     Seen in gcc.dg/pr51957-1.c  */
-	}
-      else
-	{
-	  debug_rtx (orig_x);
-	  abort ();
-	}
-#endif
       y = XVECEXP (y, 0, 0);
 
 #ifdef HAVE_AS_TLS
@@ -16653,10 +16679,13 @@
 	      : (offset + 0x8000 < 0x10000 - extra /* legitimate_address_p */
 		 && (offset & 3) != 0))
 	    {
+	      /* -m32 -mpowerpc64 needs to use a 32-bit scratch register.  */
 	      if (in_p)
-		sri->icode = CODE_FOR_reload_di_load;
+		sri->icode = ((TARGET_32BIT) ? CODE_FOR_reload_si_load
+			      : CODE_FOR_reload_di_load);
 	      else
-		sri->icode = CODE_FOR_reload_di_store;
+		sri->icode = ((TARGET_32BIT) ? CODE_FOR_reload_si_store
+			      : CODE_FOR_reload_di_store);
 	      sri->extra_cost = 2;
 	      ret = NO_REGS;
 	    }
@@ -20705,7 +20734,7 @@
      them in again.  More importantly, the mask we compute here is
      used to generate CLOBBERs in the set_vrsave insn, and we do not
      wish the argument registers to die.  */
-  for (i = crtl->args.info.vregno - 1; i >= ALTIVEC_ARG_MIN_REG; --i)
+  for (i = ALTIVEC_ARG_MIN_REG; i < (unsigned) crtl->args.info.vregno; i++)
     mask &= ~ALTIVEC_REG_BIT (i);
 
   /* Similarly, remove the return value from the set.  */
@@ -21114,6 +21143,9 @@
 static rs6000_stack_t *
 rs6000_stack_info (void)
 {
+  /* We should never be called for thunks, we are not set up for that.  */
+  gcc_assert (!cfun->is_thunk);
+
   rs6000_stack_t *info_ptr = &stack_info;
   int reg_size = TARGET_32BIT ? 4 : 8;
   int ehrd_size;
@@ -23835,11 +23867,10 @@
     }
 }
 
-/* Write function prologue.  */
+/* Output .extern statements for the save/restore routines we use.  */
 
 static void
-rs6000_output_function_prologue (FILE *file,
-				 HOST_WIDE_INT size ATTRIBUTE_UNUSED)
+rs6000_output_savres_externs (FILE *file)
 {
   rs6000_stack_t *info = rs6000_stack_info ();
 
@@ -23871,7 +23902,17 @@
 	  fprintf (file, "\t.extern %s\n", name);
 	}
     }
+}
 
+/* Write function prologue.  */
+
+static void
+rs6000_output_function_prologue (FILE *file,
+				 HOST_WIDE_INT size ATTRIBUTE_UNUSED)
+{
+  if (!cfun->is_thunk)
+    rs6000_output_savres_externs (file);
+
   /* ELFv2 ABI r2 setup code and local entry point.  This must follow
      immediately after the global entry point label.  */
   if (DEFAULT_ABI == ABI_ELFv2 && cfun->machine->r2_setup_needed)
@@ -30922,6 +30963,23 @@
   rs6000_do_expand_vec_perm (target, op0, op1, vmode, nelt, perm);
 }
 
+/* Scale a V2DF vector SRC by two to the SCALE and place in TGT.  */
+void
+rs6000_scale_v2df (rtx tgt, rtx src, int scale)
+{
+  HOST_WIDE_INT hwi_scale (scale);
+  REAL_VALUE_TYPE r_pow;
+  rtvec v = rtvec_alloc (2);
+  rtx elt;
+  rtx scale_vec = gen_reg_rtx (V2DFmode);
+  (void)real_powi (&r_pow, DFmode, &dconst2, hwi_scale);
+  elt = CONST_DOUBLE_FROM_REAL_VALUE (r_pow, DFmode);
+  RTVEC_ELT (v, 0) = elt;
+  RTVEC_ELT (v, 1) = elt;
+  rs6000_expand_vector_init (scale_vec, gen_rtx_PARALLEL (V2DFmode, v));
+  emit_insn (gen_mulv2df3 (tgt, src, scale_vec));
+}
+
 /* Return an RTX representing where to find the function value of a
    function returning MODE.  */
 static rtx
@@ -32550,6 +32608,14 @@
   if (complement_op2_p)
     op2 = gen_rtx_NOT (mode, op2);
 
+  /* For canonical RTL, if only one arm is inverted it is the first.  */
+  if (!complement_op1_p && complement_op2_p)
+    {
+      rtx temp = op1;
+      op1 = op2;
+      op2 = temp;
+    }
+
   bool_rtx = ((code == NOT)
 	      ? gen_rtx_NOT (mode, op1)
 	      : gen_rtx_fmt_ee (code, mode, op1, op2));
@@ -33085,7 +33151,1189 @@
 
   return "";
 }
+
+/* Analyze vector computations and remove unnecessary doubleword
+   swaps (xxswapdi instructions).  This pass is performed only
+   for little-endian VSX code generation.
 
+   For this specific case, loads and stores of 4x32 and 2x64 vectors
+   are inefficient.  These are implemented using the lvx2dx and
+   stvx2dx instructions, which invert the order of doublewords in
+   a vector register.  Thus the code generation inserts an xxswapdi
+   after each such load, and prior to each such store.  (For spill
+   code after register assignment, an additional xxswapdi is inserted
+   following each store in order to return a hard register to its
+   unpermuted value.)
+
+   The extra xxswapdi instructions reduce performance.  This can be
+   particularly bad for vectorized code.  The purpose of this pass
+   is to reduce the number of xxswapdi instructions required for
+   correctness.
+
+   The primary insight is that much code that operates on vectors
+   does not care about the relative order of elements in a register,
+   so long as the correct memory order is preserved.  If we have
+   a computation where all input values are provided by lvxd2x/xxswapdi
+   sequences, all outputs are stored using xxswapdi/stvxd2x sequences,
+   and all intermediate computations are pure SIMD (independent of
+   element order), then all the xxswapdi's associated with the loads
+   and stores may be removed.
+
+   This pass uses some of the infrastructure and logical ideas from
+   the "web" pass in web.c.  We create maximal webs of computations
+   fitting the description above using union-find.  Each such web is
+   then optimized by removing its unnecessary xxswapdi instructions.
+
+   The pass is placed prior to global optimization so that we can
+   perform the optimization in the safest and simplest way possible;
+   that is, by replacing each xxswapdi insn with a register copy insn.
+   Subsequent forward propagation will remove copies where possible.
+
+   There are some operations sensitive to element order for which we
+   can still allow the operation, provided we modify those operations.
+   These include CONST_VECTORs, for which we must swap the first and
+   second halves of the constant vector; and SUBREGs, for which we
+   must adjust the byte offset to account for the swapped doublewords.
+   A remaining opportunity would be non-immediate-form splats, for
+   which we should adjust the selected lane of the input.  We should
+   also make code generation adjustments for sum-across operations,
+   since this is a common vectorizer reduction.
+
+   Because we run prior to the first split, we can see loads and stores
+   here that match *vsx_le_perm_{load,store}_<mode>.  These are vanilla
+   vector loads and stores that have not yet been split into a permuting
+   load/store and a swap.  (One way this can happen is with a builtin
+   call to vec_vsx_{ld,st}.)  We can handle these as well, but rather
+   than deleting a swap, we convert the load/store into a permuting
+   load/store (which effectively removes the swap).  */
+
+/* Notes on Permutes
+
+   We do not currently handle computations that contain permutes.  There
+   is a general transformation that can be performed correctly, but it
+   may introduce more expensive code than it replaces.  To handle these
+   would require a cost model to determine when to perform the optimization.
+   This commentary records how this could be done if desired.
+
+   The most general permute is something like this (example for V16QI):
+
+   (vec_select:V16QI (vec_concat:V32QI (op1:V16QI) (op2:V16QI))
+                     (parallel [(const_int a0) (const_int a1)
+                                 ...
+                                (const_int a14) (const_int a15)]))
+
+   where a0,...,a15 are in [0,31] and select elements from op1 and op2
+   to produce in the result.
+
+   Regardless of mode, we can convert the PARALLEL to a mask of 16
+   byte-element selectors.  Let's call this M, with M[i] representing
+   the ith byte-element selector value.  Then if we swap doublewords
+   throughout the computation, we can get correct behavior by replacing
+   M with M' as follows:
+
+            { M[i+8]+8 : i < 8, M[i+8] in [0,7] U [16,23]
+    M'[i] = { M[i+8]-8 : i < 8, M[i+8] in [8,15] U [24,31]
+            { M[i-8]+8 : i >= 8, M[i-8] in [0,7] U [16,23]
+            { M[i-8]-8 : i >= 8, M[i-8] in [8,15] U [24,31]
+
+   This seems promising at first, since we are just replacing one mask
+   with another.  But certain masks are preferable to others.  If M
+   is a mask that matches a vmrghh pattern, for example, M' certainly
+   will not.  Instead of a single vmrghh, we would generate a load of
+   M' and a vperm.  So we would need to know how many xxswapd's we can
+   remove as a result of this transformation to determine if it's
+   profitable; and preferably the logic would need to be aware of all
+   the special preferable masks.
+
+   Another form of permute is an UNSPEC_VPERM, in which the mask is
+   already in a register.  In some cases, this mask may be a constant
+   that we can discover with ud-chains, in which case the above
+   transformation is ok.  However, the common usage here is for the
+   mask to be produced by an UNSPEC_LVSL, in which case the mask 
+   cannot be known at compile time.  In such a case we would have to
+   generate several instructions to compute M' as above at run time,
+   and a cost model is needed again.  */
+
+/* This is based on the union-find logic in web.c.  web_entry_base is
+   defined in df.h.  */
+class swap_web_entry : public web_entry_base
+{
+ public:
+  /* Pointer to the insn.  */
+  rtx insn;
+  /* Set if insn contains a mention of a vector register.  All other
+     fields are undefined if this field is unset.  */
+  unsigned int is_relevant : 1;
+  /* Set if insn is a load.  */
+  unsigned int is_load : 1;
+  /* Set if insn is a store.  */
+  unsigned int is_store : 1;
+  /* Set if insn is a doubleword swap.  This can either be a register swap
+     or a permuting load or store (test is_load and is_store for this).  */
+  unsigned int is_swap : 1;
+  /* Set if the insn has a live-in use of a parameter register.  */
+  unsigned int is_live_in : 1;
+  /* Set if the insn has a live-out def of a return register.  */
+  unsigned int is_live_out : 1;
+  /* Set if the insn contains a subreg reference of a vector register.  */
+  unsigned int contains_subreg : 1;
+  /* Set if the insn contains a 128-bit integer operand.  */
+  unsigned int is_128_int : 1;
+  /* Set if this is a call-insn.  */
+  unsigned int is_call : 1;
+  /* Set if this insn does not perform a vector operation for which
+     element order matters, or if we know how to fix it up if it does.
+     Undefined if is_swap is set.  */
+  unsigned int is_swappable : 1;
+  /* A nonzero value indicates what kind of special handling for this
+     insn is required if doublewords are swapped.  Undefined if
+     is_swappable is not set.  */
+  unsigned int special_handling : 3;
+  /* Set if the web represented by this entry cannot be optimized.  */
+  unsigned int web_not_optimizable : 1;
+  /* Set if this insn should be deleted.  */
+  unsigned int will_delete : 1;
+};
+
+enum special_handling_values {
+  SH_NONE = 0,
+  SH_CONST_VECTOR,
+  SH_SUBREG,
+  SH_NOSWAP_LD,
+  SH_NOSWAP_ST,
+  SH_EXTRACT,
+  SH_SPLAT
+};
+
+/* Union INSN with all insns containing definitions that reach USE.
+   Detect whether USE is live-in to the current function.  */
+static void
+union_defs (swap_web_entry *insn_entry, rtx insn, df_ref use)
+{
+  struct df_link *link = DF_REF_CHAIN (use);
+
+  if (!link)
+    insn_entry[INSN_UID (insn)].is_live_in = 1;
+
+  while (link)
+    {
+      if (DF_REF_IS_ARTIFICIAL (link->ref))
+	insn_entry[INSN_UID (insn)].is_live_in = 1;
+
+      if (DF_REF_INSN_INFO (link->ref))
+	{
+	  rtx def_insn = DF_REF_INSN (link->ref);
+	  (void)unionfind_union (insn_entry + INSN_UID (insn),
+				 insn_entry + INSN_UID (def_insn));
+	}
+
+      link = link->next;
+    }
+}
+
+/* Union INSN with all insns containing uses reached from DEF.
+   Detect whether DEF is live-out from the current function.  */
+static void
+union_uses (swap_web_entry *insn_entry, rtx insn, df_ref def)
+{
+  struct df_link *link = DF_REF_CHAIN (def);
+
+  if (!link)
+    insn_entry[INSN_UID (insn)].is_live_out = 1;
+
+  while (link)
+    {
+      /* This could be an eh use or some other artificial use;
+	 we treat these all the same (killing the optimization).  */
+      if (DF_REF_IS_ARTIFICIAL (link->ref))
+	insn_entry[INSN_UID (insn)].is_live_out = 1;
+
+      if (DF_REF_INSN_INFO (link->ref))
+	{
+	  rtx use_insn = DF_REF_INSN (link->ref);
+	  (void)unionfind_union (insn_entry + INSN_UID (insn),
+				 insn_entry + INSN_UID (use_insn));
+	}
+
+      link = link->next;
+    }
+}
+
+/* Return 1 iff INSN is a load insn, including permuting loads that
+   represent an lvxd2x instruction; else return 0.  */
+static unsigned int
+insn_is_load_p (rtx insn)
+{
+  rtx body = PATTERN (insn);
+
+  if (GET_CODE (body) == SET)
+    {
+      if (GET_CODE (SET_SRC (body)) == MEM)
+	return 1;
+
+      if (GET_CODE (SET_SRC (body)) == VEC_SELECT
+	  && GET_CODE (XEXP (SET_SRC (body), 0)) == MEM)
+	return 1;
+
+      return 0;
+    }
+
+  if (GET_CODE (body) != PARALLEL)
+    return 0;
+
+  rtx set = XVECEXP (body, 0, 0);
+
+  if (GET_CODE (set) == SET && GET_CODE (SET_SRC (set)) == MEM)
+    return 1;
+
+  return 0;
+}
+
+/* Return 1 iff INSN is a store insn, including permuting stores that
+   represent an stvxd2x instruction; else return 0.  */
+static unsigned int
+insn_is_store_p (rtx insn)
+{
+  rtx body = PATTERN (insn);
+  if (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == MEM)
+    return 1;
+  if (GET_CODE (body) != PARALLEL)
+    return 0;
+  rtx set = XVECEXP (body, 0, 0);
+  if (GET_CODE (set) == SET && GET_CODE (SET_DEST (set)) == MEM)
+    return 1;
+  return 0;
+}
+
+/* Return 1 iff INSN swaps doublewords.  This may be a reg-reg swap,
+   a permuting load, or a permuting store.  */
+static unsigned int
+insn_is_swap_p (rtx insn)
+{
+  rtx body = PATTERN (insn);
+  if (GET_CODE (body) != SET)
+    return 0;
+  rtx rhs = SET_SRC (body);
+  if (GET_CODE (rhs) != VEC_SELECT)
+    return 0;
+  rtx parallel = XEXP (rhs, 1);
+  if (GET_CODE (parallel) != PARALLEL)
+    return 0;
+  unsigned int len = XVECLEN (parallel, 0);
+  if (len != 2 && len != 4 && len != 8 && len != 16)
+    return 0;
+  for (unsigned int i = 0; i < len / 2; ++i)
+    {
+      rtx op = XVECEXP (parallel, 0, i);
+      if (GET_CODE (op) != CONST_INT || INTVAL (op) != len / 2 + i)
+	return 0;
+    }
+  for (unsigned int i = len / 2; i < len; ++i)
+    {
+      rtx op = XVECEXP (parallel, 0, i);
+      if (GET_CODE (op) != CONST_INT || INTVAL (op) != i - len / 2)
+	return 0;
+    }
+  return 1;
+}
+
+/* Return 1 iff OP is an operand that will not be affected by having
+   vector doublewords swapped in memory.  */
+static unsigned int
+rtx_is_swappable_p (rtx op, unsigned int *special)
+{
+  enum rtx_code code = GET_CODE (op);
+  int i, j;
+  rtx parallel;
+
+  switch (code)
+    {
+    case LABEL_REF:
+    case SYMBOL_REF:
+    case CLOBBER:
+    case REG:
+      return 1;
+
+    case VEC_CONCAT:
+    case ASM_INPUT:
+    case ASM_OPERANDS:
+      return 0;
+
+    case CONST_VECTOR:
+      {
+	*special = SH_CONST_VECTOR;
+	return 1;
+      }
+
+    case VEC_DUPLICATE:
+      /* Opportunity: If XEXP (op, 0) has the same mode as the result,
+	 and XEXP (op, 1) is a PARALLEL with a single QImode const int,
+	 it represents a vector splat for which we can do special
+	 handling.  */
+      if (GET_CODE (XEXP (op, 0)) == CONST_INT)
+	return 1;
+      else if (GET_CODE (XEXP (op, 0)) == REG
+	       && GET_MODE_INNER (GET_MODE (op)) == GET_MODE (XEXP (op, 0)))
+	/* This catches V2DF and V2DI splat, at a minimum.  */
+	return 1;
+      else if (GET_CODE (XEXP (op, 0)) == VEC_SELECT)
+	/* If the duplicated item is from a select, defer to the select
+	   processing to see if we can change the lane for the splat.  */
+	return rtx_is_swappable_p (XEXP (op, 0), special);
+      else
+	return 0;
+
+    case VEC_SELECT:
+      /* A vec_extract operation is ok if we change the lane.  */
+      if (GET_CODE (XEXP (op, 0)) == REG
+	  && GET_MODE_INNER (GET_MODE (XEXP (op, 0))) == GET_MODE (op)
+	  && GET_CODE ((parallel = XEXP (op, 1))) == PARALLEL
+	  && XVECLEN (parallel, 0) == 1
+	  && GET_CODE (XVECEXP (parallel, 0, 0)) == CONST_INT)
+	{
+	  *special = SH_EXTRACT;
+	  return 1;
+	}
+      else
+	return 0;
+
+    case UNSPEC:
+      {
+	/* Various operations are unsafe for this optimization, at least
+	   without significant additional work.  Permutes are obviously
+	   problematic, as both the permute control vector and the ordering
+	   of the target values are invalidated by doubleword swapping.
+	   Vector pack and unpack modify the number of vector lanes.
+	   Merge-high/low will not operate correctly on swapped operands.
+	   Vector shifts across element boundaries are clearly uncool,
+	   as are vector select and concatenate operations.  Vector
+	   sum-across instructions define one operand with a specific
+	   order-dependent element, so additional fixup code would be
+	   needed to make those work.  Vector set and non-immediate-form
+	   vector splat are element-order sensitive.  A few of these
+	   cases might be workable with special handling if required.  */
+	int val = XINT (op, 1);
+	switch (val)
+	  {
+	  default:
+	    break;
+	  case UNSPEC_VMRGH_DIRECT:
+	  case UNSPEC_VMRGL_DIRECT:
+	  case UNSPEC_VPACK_SIGN_SIGN_SAT:
+	  case UNSPEC_VPACK_SIGN_UNS_SAT:
+	  case UNSPEC_VPACK_UNS_UNS_MOD:
+	  case UNSPEC_VPACK_UNS_UNS_MOD_DIRECT:
+	  case UNSPEC_VPACK_UNS_UNS_SAT:
+	  case UNSPEC_VPERM:
+	  case UNSPEC_VPERM_UNS:
+	  case UNSPEC_VPERMHI:
+	  case UNSPEC_VPERMSI:
+	  case UNSPEC_VPKPX:
+	  case UNSPEC_VSLDOI:
+	  case UNSPEC_VSLO:
+	  case UNSPEC_VSRO:
+	  case UNSPEC_VSUM2SWS:
+	  case UNSPEC_VSUM4S:
+	  case UNSPEC_VSUM4UBS:
+	  case UNSPEC_VSUMSWS:
+	  case UNSPEC_VSUMSWS_DIRECT:
+	  case UNSPEC_VSX_CONCAT:
+	  case UNSPEC_VSX_SET:
+	  case UNSPEC_VSX_SLDWI:
+	  case UNSPEC_VUNPACK_HI_SIGN:
+	  case UNSPEC_VUNPACK_HI_SIGN_DIRECT:
+	  case UNSPEC_VUNPACK_LO_SIGN:
+	  case UNSPEC_VUNPACK_LO_SIGN_DIRECT:
+	  case UNSPEC_VUPKHPX:
+	  case UNSPEC_VUPKHS_V4SF:
+	  case UNSPEC_VUPKHU_V4SF:
+	  case UNSPEC_VUPKLPX:
+	  case UNSPEC_VUPKLS_V4SF:
+	  case UNSPEC_VUPKLU_V4SF:
+	  /* The following could be handled as an idiom with XXSPLTW.
+	     These place a scalar in BE element zero, but the XXSPLTW
+	     will currently expect it in BE element 2 in a swapped
+	     region.  When one of these feeds an XXSPLTW with no other
+	     defs/uses either way, we can avoid the lane change for
+	     XXSPLTW and things will be correct.  TBD.  */
+	  case UNSPEC_VSX_CVDPSPN:
+	  case UNSPEC_VSX_CVSPDP:
+	  case UNSPEC_VSX_CVSPDPN:
+	    return 0;
+	  case UNSPEC_VSPLT_DIRECT:
+	    *special = SH_SPLAT;
+	    return 1;
+	  }
+      }
+
+    default:
+      break;
+    }
+
+  const char *fmt = GET_RTX_FORMAT (code);
+  int ok = 1;
+
+  for (i = 0; i < GET_RTX_LENGTH (code); ++i)
+    if (fmt[i] == 'e' || fmt[i] == 'u')
+      {
+	unsigned int special_op = SH_NONE;
+	ok &= rtx_is_swappable_p (XEXP (op, i), &special_op);
+	/* Ensure we never have two kinds of special handling
+	   for the same insn.  */
+	if (*special != SH_NONE && special_op != SH_NONE
+	    && *special != special_op)
+	  return 0;
+	*special = special_op;
+      }
+    else if (fmt[i] == 'E')
+      for (j = 0; j < XVECLEN (op, i); ++j)
+	{
+	  unsigned int special_op = SH_NONE;
+	  ok &= rtx_is_swappable_p (XVECEXP (op, i, j), &special_op);
+	  /* Ensure we never have two kinds of special handling
+	     for the same insn.  */
+	  if (*special != SH_NONE && special_op != SH_NONE
+	      && *special != special_op)
+	    return 0;
+	  *special = special_op;
+	}
+
+  return ok;
+}
+
+/* Return 1 iff INSN is an operand that will not be affected by
+   having vector doublewords swapped in memory (in which case
+   *SPECIAL is unchanged), or that can be modified to be correct
+   if vector doublewords are swapped in memory (in which case
+   *SPECIAL is changed to a value indicating how).  */
+static unsigned int
+insn_is_swappable_p (swap_web_entry *insn_entry, rtx insn,
+		     unsigned int *special)
+{
+  /* Calls are always bad.  */
+  if (GET_CODE (insn) == CALL_INSN)
+    return 0;
+
+  /* Loads and stores seen here are not permuting, but we can still
+     fix them up by converting them to permuting ones.  Exceptions:
+     UNSPEC_LVE, UNSPEC_LVX, and UNSPEC_STVX, which have a PARALLEL
+     body instead of a SET; and UNSPEC_STVE, which has an UNSPEC
+     for the SET source.  */
+  rtx body = PATTERN (insn);
+  int i = INSN_UID (insn);
+
+  if (insn_entry[i].is_load)
+    {
+      if (GET_CODE (body) == SET)
+	{
+	  *special = SH_NOSWAP_LD;
+	  return 1;
+	}
+      else
+	return 0;
+    }
+
+  if (insn_entry[i].is_store)
+    {
+      if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) != UNSPEC)
+	{
+	  *special = SH_NOSWAP_ST;
+	  return 1;
+	}
+      else
+	return 0;
+    }
+
+  /* Otherwise check the operands for vector lane violations.  */
+  return rtx_is_swappable_p (body, special);
+}
+
+enum chain_purpose { FOR_LOADS, FOR_STORES };
+
+/* Return true if the UD or DU chain headed by LINK is non-empty,
+   and every entry on the chain references an insn that is a
+   register swap.  Furthermore, if PURPOSE is FOR_LOADS, each such
+   register swap must have only permuting loads as reaching defs.
+   If PURPOSE is FOR_STORES, each such register swap must have only
+   register swaps or permuting stores as reached uses.  */
+static bool
+chain_contains_only_swaps (swap_web_entry *insn_entry, struct df_link *link,
+			   enum chain_purpose purpose)
+{
+  if (!link)
+    return false;
+
+  for (; link; link = link->next)
+    {
+      if (!VECTOR_MODE_P (GET_MODE (DF_REF_REG (link->ref))))
+	continue;
+
+      if (DF_REF_IS_ARTIFICIAL (link->ref))
+	return false;
+
+      rtx reached_insn = DF_REF_INSN (link->ref);
+      unsigned uid = INSN_UID (reached_insn);
+
+      if (!insn_entry[uid].is_swap || insn_entry[uid].is_load
+	  || insn_entry[uid].is_store)
+	return false;
+
+      if (purpose == FOR_LOADS)
+	{
+	  df_ref *use_rec;
+	  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
+	    {
+	      df_ref use = *use_rec;
+	      struct df_link *swap_link = DF_REF_CHAIN (use);
+
+	      while (swap_link)
+		{
+		  if (DF_REF_IS_ARTIFICIAL (link->ref))
+		    return false;
+
+		  rtx swap_def_insn = DF_REF_INSN (swap_link->ref);
+		  unsigned uid2 = INSN_UID (swap_def_insn);
+
+		  /* Only permuting loads are allowed.  */
+		  if (!insn_entry[uid2].is_swap || !insn_entry[uid2].is_load)
+		    return false;
+
+		  swap_link = swap_link->next;
+		}
+	    }
+	}
+      else if (purpose == FOR_STORES)
+	{
+	  df_ref *def_rec;
+	  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
+	    {
+	      df_ref def = *def_rec;
+	      struct df_link *swap_link = DF_REF_CHAIN (def);
+
+	      while (swap_link)
+		{
+		  if (DF_REF_IS_ARTIFICIAL (link->ref))
+		    return false;
+
+		  rtx swap_use_insn = DF_REF_INSN (swap_link->ref);
+		  unsigned uid2 = INSN_UID (swap_use_insn);
+
+		  /* Permuting stores or register swaps are allowed.  */
+		  if (!insn_entry[uid2].is_swap || insn_entry[uid2].is_load)
+		    return false;
+
+		  swap_link = swap_link->next;
+		}
+	    }
+	}
+    }
+
+  return true;
+}
+
+/* Mark the xxswapdi instructions associated with permuting loads and
+   stores for removal.  Note that we only flag them for deletion here,
+   as there is a possibility of a swap being reached from multiple
+   loads, etc.  */
+static void
+mark_swaps_for_removal (swap_web_entry *insn_entry, unsigned int i)
+{
+  rtx insn = insn_entry[i].insn;
+  unsigned uid = INSN_UID (insn);
+
+  if (insn_entry[i].is_load)
+    {
+      df_ref *def_rec;
+      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
+	{
+	  df_ref def = *def_rec;
+	  struct df_link *link = DF_REF_CHAIN (def);
+
+	  /* We know by now that these are swaps, so we can delete
+	     them confidently.  */
+	  while (link)
+	    {
+	      rtx use_insn = DF_REF_INSN (link->ref);
+	      insn_entry[INSN_UID (use_insn)].will_delete = 1;
+	      link = link->next;
+	    }
+	}
+    }
+  else if (insn_entry[i].is_store)
+    {
+      df_ref *use_rec;
+      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
+	{
+	  df_ref use = *use_rec;
+	  /* Ignore uses for addressability.  */
+	  machine_mode mode = GET_MODE (DF_REF_REG (use));
+	  if (!VECTOR_MODE_P (mode))
+	    continue;
+
+	  struct df_link *link = DF_REF_CHAIN (use);
+
+	  /* We know by now that these are swaps, so we can delete
+	     them confidently.  */
+	  while (link)
+	    {
+	      rtx def_insn = DF_REF_INSN (link->ref);
+	      insn_entry[INSN_UID (def_insn)].will_delete = 1;
+	      link = link->next;
+	    }
+	}
+    }
+}
+
+/* OP is either a CONST_VECTOR or an expression containing one.
+   Swap the first half of the vector with the second in the first
+   case.  Recurse to find it in the second.  */
+static void
+swap_const_vector_halves (rtx op)
+{
+  int i;
+  enum rtx_code code = GET_CODE (op);
+  if (GET_CODE (op) == CONST_VECTOR)
+    {
+      int half_units = GET_MODE_NUNITS (GET_MODE (op)) / 2;
+      for (i = 0; i < half_units; ++i)
+	{
+	  rtx temp = CONST_VECTOR_ELT (op, i);
+	  CONST_VECTOR_ELT (op, i) = CONST_VECTOR_ELT (op, i + half_units);
+	  CONST_VECTOR_ELT (op, i + half_units) = temp;
+	}
+    }
+  else
+    {
+      int j;
+      const char *fmt = GET_RTX_FORMAT (code);
+      for (i = 0; i < GET_RTX_LENGTH (code); ++i)
+	if (fmt[i] == 'e' || fmt[i] == 'u')
+	  swap_const_vector_halves (XEXP (op, i));
+	else if (fmt[i] == 'E')
+	  for (j = 0; j < XVECLEN (op, i); ++j)
+	    swap_const_vector_halves (XVECEXP (op, i, j));
+    }
+}
+
+/* Find all subregs of a vector expression that perform a narrowing,
+   and adjust the subreg index to account for doubleword swapping.  */
+static void
+adjust_subreg_index (rtx op)
+{
+  enum rtx_code code = GET_CODE (op);
+  if (code == SUBREG
+      && (GET_MODE_SIZE (GET_MODE (op))
+	  < GET_MODE_SIZE (GET_MODE (XEXP (op, 0)))))
+    {
+      unsigned int index = SUBREG_BYTE (op);
+      if (index < 8)
+	index += 8;
+      else
+	index -= 8;
+      SUBREG_BYTE (op) = index;
+    }
+
+  const char *fmt = GET_RTX_FORMAT (code);
+  int i,j;
+  for (i = 0; i < GET_RTX_LENGTH (code); ++i)
+    if (fmt[i] == 'e' || fmt[i] == 'u')
+      adjust_subreg_index (XEXP (op, i));
+    else if (fmt[i] == 'E')
+      for (j = 0; j < XVECLEN (op, i); ++j)
+	adjust_subreg_index (XVECEXP (op, i, j));
+}
+
+/* Convert the non-permuting load INSN to a permuting one.  */
+static void
+permute_load (rtx insn)
+{
+  rtx body = PATTERN (insn);
+  rtx mem_op = SET_SRC (body);
+  rtx tgt_reg = SET_DEST (body);
+  machine_mode mode = GET_MODE (tgt_reg);
+  int n_elts = GET_MODE_NUNITS (mode);
+  int half_elts = n_elts / 2;
+  rtx par = gen_rtx_PARALLEL (mode, rtvec_alloc (n_elts));
+  int i, j;
+  for (i = 0, j = half_elts; i < half_elts; ++i, ++j)
+    XVECEXP (par, 0, i) = GEN_INT (j);
+  for (i = half_elts, j = 0; j < half_elts; ++i, ++j)
+    XVECEXP (par, 0, i) = GEN_INT (j);
+  rtx sel = gen_rtx_VEC_SELECT (mode, mem_op, par);
+  SET_SRC (body) = sel;
+  INSN_CODE (insn) = -1; /* Force re-recognition.  */
+  df_insn_rescan (insn);
+
+  if (dump_file)
+    fprintf (dump_file, "Replacing load %d with permuted load\n",
+	     INSN_UID (insn));
+}
+
+/* Convert the non-permuting store INSN to a permuting one.  */
+static void
+permute_store (rtx insn)
+{
+  rtx body = PATTERN (insn);
+  rtx src_reg = SET_SRC (body);
+  machine_mode mode = GET_MODE (src_reg);
+  int n_elts = GET_MODE_NUNITS (mode);
+  int half_elts = n_elts / 2;
+  rtx par = gen_rtx_PARALLEL (mode, rtvec_alloc (n_elts));
+  int i, j;
+  for (i = 0, j = half_elts; i < half_elts; ++i, ++j)
+    XVECEXP (par, 0, i) = GEN_INT (j);
+  for (i = half_elts, j = 0; j < half_elts; ++i, ++j)
+    XVECEXP (par, 0, i) = GEN_INT (j);
+  rtx sel = gen_rtx_VEC_SELECT (mode, src_reg, par);
+  SET_SRC (body) = sel;
+  INSN_CODE (insn) = -1; /* Force re-recognition.  */
+  df_insn_rescan (insn);
+
+  if (dump_file)
+    fprintf (dump_file, "Replacing store %d with permuted store\n",
+	     INSN_UID (insn));
+}
+
+/* Given OP that contains a vector extract operation, adjust the index
+   of the extracted lane to account for the doubleword swap.  */
+static void
+adjust_extract (rtx insn)
+{
+  rtx src = SET_SRC (PATTERN (insn));
+  /* The vec_select may be wrapped in a vec_duplicate for a splat, so
+     account for that.  */
+  rtx sel = GET_CODE (src) == VEC_DUPLICATE ? XEXP (src, 0) : src;
+  rtx par = XEXP (sel, 1);
+  int half_elts = GET_MODE_NUNITS (GET_MODE (XEXP (sel, 0))) >> 1;
+  int lane = INTVAL (XVECEXP (par, 0, 0));
+  lane = lane >= half_elts ? lane - half_elts : lane + half_elts;
+  XVECEXP (par, 0, 0) = GEN_INT (lane);
+  INSN_CODE (insn) = -1; /* Force re-recognition.  */
+  df_insn_rescan (insn);
+
+  if (dump_file)
+    fprintf (dump_file, "Changing lane for extract %d\n", INSN_UID (insn));
+}
+
+/* Given OP that contains a vector direct-splat operation, adjust the index
+   of the source lane to account for the doubleword swap.  */
+static void
+adjust_splat (rtx insn)
+{
+  rtx body = PATTERN (insn);
+  rtx unspec = XEXP (body, 1);
+  int half_elts = GET_MODE_NUNITS (GET_MODE (unspec)) >> 1;
+  int lane = INTVAL (XVECEXP (unspec, 0, 1));
+  lane = lane >= half_elts ? lane - half_elts : lane + half_elts;
+  XVECEXP (unspec, 0, 1) = GEN_INT (lane);
+  INSN_CODE (insn) = -1; /* Force re-recognition.  */
+  df_insn_rescan (insn);
+
+  if (dump_file)
+    fprintf (dump_file, "Changing lane for splat %d\n", INSN_UID (insn));
+}
+
+/* The insn described by INSN_ENTRY[I] can be swapped, but only
+   with special handling.  Take care of that here.  */
+static void
+handle_special_swappables (swap_web_entry *insn_entry, unsigned i)
+{
+  rtx insn = insn_entry[i].insn;
+  rtx body = PATTERN (insn);
+
+  switch (insn_entry[i].special_handling)
+    {
+    default:
+      gcc_unreachable ();
+    case SH_CONST_VECTOR:
+      {
+	/* A CONST_VECTOR will only show up somewhere in the RHS of a SET.  */
+	gcc_assert (GET_CODE (body) == SET);
+	rtx rhs = SET_SRC (body);
+	swap_const_vector_halves (rhs);
+	if (dump_file)
+	  fprintf (dump_file, "Swapping constant halves in insn %d\n", i);
+	break;
+      }
+    case SH_SUBREG:
+      /* A subreg of the same size is already safe.  For subregs that
+	 select a smaller portion of a reg, adjust the index for
+	 swapped doublewords.  */
+      adjust_subreg_index (body);
+      if (dump_file)
+	fprintf (dump_file, "Adjusting subreg in insn %d\n", i);
+      break;
+    case SH_NOSWAP_LD:
+      /* Convert a non-permuting load to a permuting one.  */
+      permute_load (insn);
+      break;
+    case SH_NOSWAP_ST:
+      /* Convert a non-permuting store to a permuting one.  */
+      permute_store (insn);
+      break;
+    case SH_EXTRACT:
+      /* Change the lane on an extract operation.  */
+      adjust_extract (insn);
+      break;
+    case SH_SPLAT:
+      /* Change the lane on a direct-splat operation.  */
+      adjust_splat (insn);
+      break;
+    }
+}
+
+/* Find the insn from the Ith table entry, which is known to be a
+   register swap Y = SWAP(X).  Replace it with a copy Y = X.  */
+static void
+replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)
+{
+  rtx insn = insn_entry[i].insn;
+  rtx body = PATTERN (insn);
+  rtx src_reg = XEXP (SET_SRC (body), 0);
+  rtx copy = gen_rtx_SET (VOIDmode, SET_DEST (body), src_reg);
+  rtx new_insn = emit_insn_before (copy, insn);
+  set_block_for_insn (new_insn, BLOCK_FOR_INSN (insn));
+  df_insn_rescan (new_insn);
+
+  if (dump_file)
+    {
+      unsigned int new_uid = INSN_UID (new_insn);
+      fprintf (dump_file, "Replacing swap %d with copy %d\n", i, new_uid);
+    }
+
+  df_insn_delete (insn);
+  remove_insn (insn);
+  INSN_DELETED_P (insn) = 1;
+}
+
+/* Dump the swap table to DUMP_FILE.  */
+static void
+dump_swap_insn_table (swap_web_entry *insn_entry)
+{
+  int e = get_max_uid ();
+  fprintf (dump_file, "\nRelevant insns with their flag settings\n\n");
+
+  for (int i = 0; i < e; ++i)
+    if (insn_entry[i].is_relevant)
+      {
+	swap_web_entry *pred_entry = (swap_web_entry *)insn_entry[i].pred ();
+	fprintf (dump_file, "%6d %6d  ", i,
+		 pred_entry && pred_entry->insn
+		 ? INSN_UID (pred_entry->insn) : 0);
+	if (insn_entry[i].is_load)
+	  fputs ("load ", dump_file);
+	if (insn_entry[i].is_store)
+	  fputs ("store ", dump_file);
+	if (insn_entry[i].is_swap)
+	  fputs ("swap ", dump_file);
+	if (insn_entry[i].is_live_in)
+	  fputs ("live-in ", dump_file);
+	if (insn_entry[i].is_live_out)
+	  fputs ("live-out ", dump_file);
+	if (insn_entry[i].contains_subreg)
+	  fputs ("subreg ", dump_file);
+	if (insn_entry[i].is_128_int)
+	  fputs ("int128 ", dump_file);
+	if (insn_entry[i].is_call)
+	  fputs ("call ", dump_file);
+	if (insn_entry[i].is_swappable)
+	  {
+	    fputs ("swappable ", dump_file);
+	    if (insn_entry[i].special_handling == SH_CONST_VECTOR)
+	      fputs ("special:constvec ", dump_file);
+	    else if (insn_entry[i].special_handling == SH_SUBREG)
+	      fputs ("special:subreg ", dump_file);
+	    else if (insn_entry[i].special_handling == SH_NOSWAP_LD)
+	      fputs ("special:load ", dump_file);
+	    else if (insn_entry[i].special_handling == SH_NOSWAP_ST)
+	      fputs ("special:store ", dump_file);
+	    else if (insn_entry[i].special_handling == SH_EXTRACT)
+	      fputs ("special:extract ", dump_file);
+	    else if (insn_entry[i].special_handling == SH_SPLAT)
+	      fputs ("special:splat ", dump_file);
+	  }
+	if (insn_entry[i].web_not_optimizable)
+	  fputs ("unoptimizable ", dump_file);
+	if (insn_entry[i].will_delete)
+	  fputs ("delete ", dump_file);
+	fputs ("\n", dump_file);
+      }
+  fputs ("\n", dump_file);
+}
+
+/* Main entry point for this pass.  */
+unsigned int
+rs6000_analyze_swaps (function *fun)
+{
+  swap_web_entry *insn_entry;
+  basic_block bb;
+  rtx insn;
+
+  /* Dataflow analysis for use-def chains.  */
+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);
+  df_analyze ();
+  df_set_flags (DF_DEFER_INSN_RESCAN);
+
+  /* Allocate structure to represent webs of insns.  */
+  insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());
+
+  /* Walk the insns to gather basic data.  */
+  FOR_ALL_BB_FN (bb, fun)
+    FOR_BB_INSNS (bb, insn)
+    {
+      unsigned int uid = INSN_UID (insn);
+      if (NONDEBUG_INSN_P (insn))
+	{
+	  insn_entry[uid].insn = insn;
+
+	  if (GET_CODE (insn) == CALL_INSN)
+	    insn_entry[uid].is_call = 1;
+
+	  /* Walk the uses and defs to see if we mention vector regs.
+	     Record any constraints on optimization of such mentions.  */
+	  df_ref *use_rec;
+	  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
+	    {
+	      df_ref mention = *use_rec;
+	      /* We use DF_REF_REAL_REG here to get inside any subregs.  */
+	      machine_mode mode = GET_MODE (DF_REF_REAL_REG (mention));
+
+	      /* If a use gets its value from a call insn, it will be
+		 a hard register and will look like (reg:V4SI 3 3).
+		 The df analysis creates two mentions for GPR3 and GPR4,
+		 both DImode.  We must recognize this and treat it as a
+		 vector mention to ensure the call is unioned with this
+		 use.  */
+	      if (mode == DImode && DF_REF_INSN_INFO (mention))
+		{
+		  rtx feeder = DF_REF_INSN (mention);
+		  /* FIXME:  It is pretty hard to get from the df mention
+		     to the mode of the use in the insn.  We arbitrarily
+		     pick a vector mode here, even though the use might
+		     be a real DImode.  We can be too conservative
+		     (create a web larger than necessary) because of
+		     this, so consider eventually fixing this.  */
+		  if (GET_CODE (feeder) == CALL_INSN)
+		    mode = V4SImode;
+		}
+
+	      if (VECTOR_MODE_P (mode) || mode == TImode)
+		{
+		  insn_entry[uid].is_relevant = 1;
+		  if (mode == TImode || mode == V1TImode)
+		    insn_entry[uid].is_128_int = 1;
+		  if (DF_REF_INSN_INFO (mention))
+		    insn_entry[uid].contains_subreg
+		      = !rtx_equal_p (DF_REF_REG (mention),
+				      DF_REF_REAL_REG (mention));
+		  union_defs (insn_entry, insn, mention);
+		}
+	    }
+	  df_ref *def_rec;
+	  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
+	    {
+	      df_ref mention = *def_rec;
+	      /* We use DF_REF_REAL_REG here to get inside any subregs.  */
+	      machine_mode mode = GET_MODE (DF_REF_REAL_REG (mention));
+
+	      /* If we're loading up a hard vector register for a call,
+		 it looks like (set (reg:V4SI 9 9) (...)).  The df
+		 analysis creates two mentions for GPR9 and GPR10, both
+		 DImode.  So relying on the mode from the mentions
+		 isn't sufficient to ensure we union the call into the
+		 web with the parameter setup code.  */
+	      if (mode == DImode && GET_CODE (insn) == SET
+		  && VECTOR_MODE_P (GET_MODE (SET_DEST (insn))))
+		mode = GET_MODE (SET_DEST (insn));
+
+	      if (VECTOR_MODE_P (mode) || mode == TImode)
+		{
+		  insn_entry[uid].is_relevant = 1;
+		  if (mode == TImode || mode == V1TImode)
+		    insn_entry[uid].is_128_int = 1;
+		  if (DF_REF_INSN_INFO (mention))
+		    insn_entry[uid].contains_subreg
+		      = !rtx_equal_p (DF_REF_REG (mention),
+				      DF_REF_REAL_REG (mention));
+		  /* REG_FUNCTION_VALUE_P is not valid for subregs. */
+		  else if (REG_FUNCTION_VALUE_P (DF_REF_REG (mention)))
+		    insn_entry[uid].is_live_out = 1;
+		  union_uses (insn_entry, insn, mention);
+		}
+	    }
+
+	  if (insn_entry[uid].is_relevant)
+	    {
+	      /* Determine if this is a load or store.  */
+	      insn_entry[uid].is_load = insn_is_load_p (insn);
+	      insn_entry[uid].is_store = insn_is_store_p (insn);
+
+	      /* Determine if this is a doubleword swap.  If not,
+		 determine whether it can legally be swapped.  */
+	      if (insn_is_swap_p (insn))
+		insn_entry[uid].is_swap = 1;
+	      else
+		{
+		  unsigned int special = SH_NONE;
+		  insn_entry[uid].is_swappable
+		    = insn_is_swappable_p (insn_entry, insn, &special);
+		  if (special != SH_NONE && insn_entry[uid].contains_subreg)
+		    insn_entry[uid].is_swappable = 0;
+		  else if (special != SH_NONE)
+		    insn_entry[uid].special_handling = special;
+		  else if (insn_entry[uid].contains_subreg)
+		    insn_entry[uid].special_handling = SH_SUBREG;
+		}
+	    }
+	}
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "\nSwap insn entry table when first built\n");
+      dump_swap_insn_table (insn_entry);
+    }
+
+  /* Record unoptimizable webs.  */
+  unsigned e = get_max_uid (), i;
+  for (i = 0; i < e; ++i)
+    {
+      if (!insn_entry[i].is_relevant)
+	continue;
+
+      swap_web_entry *root
+	= (swap_web_entry*)(&insn_entry[i])->unionfind_root ();
+      unsigned uid = INSN_UID (insn_entry[i].insn);
+
+      if (insn_entry[i].is_live_in || insn_entry[i].is_live_out
+	  || (insn_entry[i].contains_subreg
+	      && insn_entry[i].special_handling != SH_SUBREG)
+	  || insn_entry[i].is_128_int || insn_entry[i].is_call
+	  || !(insn_entry[i].is_swappable || insn_entry[i].is_swap))
+	root->web_not_optimizable = 1;
+
+      /* If we have loads or stores that aren't permuting then the
+	 optimization isn't appropriate.  */
+      else if ((insn_entry[i].is_load || insn_entry[i].is_store)
+	  && !insn_entry[i].is_swap && !insn_entry[i].is_swappable)
+	root->web_not_optimizable = 1;
+
+      /* If we have permuting loads or stores that are not accompanied
+	 by a register swap, the optimization isn't appropriate.  */
+      else if (insn_entry[i].is_load && insn_entry[i].is_swap)
+	{
+	  df_ref *def_rec;
+
+	  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
+	    {
+	      df_ref def = *def_rec;
+	      struct df_link *link = DF_REF_CHAIN (def);
+
+	      if (!chain_contains_only_swaps (insn_entry, link, FOR_LOADS))
+		{
+		  root->web_not_optimizable = 1;
+		  break;
+		}
+	    }
+	}
+      else if (insn_entry[i].is_store && insn_entry[i].is_swap)
+	{
+	  df_ref *use_rec;
+
+	  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)
+	    {
+	      df_ref use = *use_rec;
+	      struct df_link *link = DF_REF_CHAIN (use);
+
+	      if (!chain_contains_only_swaps (insn_entry, link, FOR_STORES))
+		{
+		  root->web_not_optimizable = 1;
+		  break;
+		}
+	    }
+	}
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "\nSwap insn entry table after web analysis\n");
+      dump_swap_insn_table (insn_entry);
+    }
+
+  /* For each load and store in an optimizable web (which implies
+     the loads and stores are permuting), find the associated
+     register swaps and mark them for removal.  Due to various
+     optimizations we may mark the same swap more than once.  Also
+     perform special handling for swappable insns that require it.  */
+  for (i = 0; i < e; ++i)
+    if ((insn_entry[i].is_load || insn_entry[i].is_store)
+	&& insn_entry[i].is_swap)
+      {
+	swap_web_entry* root_entry
+	  = (swap_web_entry*)((&insn_entry[i])->unionfind_root ());
+	if (!root_entry->web_not_optimizable)
+	  mark_swaps_for_removal (insn_entry, i);
+      }
+    else if (insn_entry[i].is_swappable && insn_entry[i].special_handling)
+      {
+	swap_web_entry* root_entry
+	  = (swap_web_entry*)((&insn_entry[i])->unionfind_root ());
+	if (!root_entry->web_not_optimizable)
+	  handle_special_swappables (insn_entry, i);
+      }
+
+  /* Now delete the swaps marked for removal.  */
+  for (i = 0; i < e; ++i)
+    if (insn_entry[i].will_delete)
+      replace_swap_with_copy (insn_entry, i);
+
+  /* Clean up.  */
+  free (insn_entry);
+  return 0;
+}
+
+const pass_data pass_data_analyze_swaps =
+{
+  RTL_PASS, /* type */
+  "swaps", /* name */
+  OPTGROUP_NONE, /* optinfo_flags */
+  true, /* has_gate */
+  true, /* has_execute */
+  TV_NONE, /* tv_id */
+  0, /* properties_required */
+  0, /* properties_provided */
+  0, /* properties_destroyed */
+  0, /* todo_flags_start */
+  TODO_df_finish, /* todo_flags_finish */
+};
+
+class pass_analyze_swaps : public rtl_opt_pass
+{
+public:
+  pass_analyze_swaps(gcc::context *ctxt)
+    : rtl_opt_pass(pass_data_analyze_swaps, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  bool gate ()
+    {
+      return (optimize > 0 && !BYTES_BIG_ENDIAN && TARGET_VSX
+	      && rs6000_optimize_swaps);
+    }
+
+  unsigned int execute ()
+    {
+      return rs6000_analyze_swaps (cfun);
+    }
+
+}; // class pass_analyze_swaps
+
+rtl_opt_pass *
+make_pass_analyze_swaps (gcc::context *ctxt)
+{
+  return new pass_analyze_swaps (ctxt);
+}
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-4_9-branch)
@@ -260,6 +260,14 @@
    UNSPEC_VSX_ROUND_IC
    UNSPEC_VSX_SLDWI
    UNSPEC_VSX_XXSPLTW
+   UNSPEC_VSX_XXSPLTD
+   UNSPEC_VSX_DIVSD
+   UNSPEC_VSX_DIVUD
+   UNSPEC_VSX_MULSD
+   UNSPEC_VSX_XVCVSXDDP
+   UNSPEC_VSX_XVCVUXDDP
+   UNSPEC_VSX_XVCVDPSXDS
+   UNSPEC_VSX_XVCVDPUXDS
   ])
 
 ;; VSX moves
@@ -746,6 +754,34 @@
   [(set_attr "type" "<VStype_simple>")
    (set_attr "fp_type" "<VSfptype_mul>")])
 
+; Emulate vector with scalar for vec_mul in V2DImode
+(define_insn_and_split "vsx_mul_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DI 1 "vsx_register_operand" "wa")
+                      (match_operand:V2DI 2 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_MULSD))]
+  "VECTOR_MEM_VSX_P (V2DImode)"
+  "#"
+  "VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress"
+  [(const_int 0)]
+  "
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op3 = gen_reg_rtx (DImode);
+  rtx op4 = gen_reg_rtx (DImode);
+  rtx op5 = gen_reg_rtx (DImode);
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (0)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (0)));
+  emit_insn (gen_muldi3 (op5, op3, op4));
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (1)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (1)));
+  emit_insn (gen_muldi3 (op3, op3, op4));
+  emit_insn (gen_vsx_concat_v2di (op0, op5, op3));
+}"
+  [(set_attr "type" "vecdouble")])
+
 (define_insn "*vsx_div<mode>3"
   [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
         (div:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
@@ -755,6 +791,61 @@
   [(set_attr "type" "<VStype_div>")
    (set_attr "fp_type" "<VSfptype_div>")])
 
+; Emulate vector with scalar for vec_div in V2DImode
+(define_insn_and_split "vsx_div_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DI 1 "vsx_register_operand" "wa")
+                      (match_operand:V2DI 2 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_DIVSD))]
+  "VECTOR_MEM_VSX_P (V2DImode)"
+  "#"
+  "VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress"
+  [(const_int 0)]
+  "
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op3 = gen_reg_rtx (DImode);
+  rtx op4 = gen_reg_rtx (DImode);
+  rtx op5 = gen_reg_rtx (DImode);
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (0)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (0)));
+  emit_insn (gen_divdi3 (op5, op3, op4));
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (1)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (1)));
+  emit_insn (gen_divdi3 (op3, op3, op4));
+  emit_insn (gen_vsx_concat_v2di (op0, op5, op3));
+}"
+  [(set_attr "type" "vecdiv")])
+
+(define_insn_and_split "vsx_udiv_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DI 1 "vsx_register_operand" "wa")
+                      (match_operand:V2DI 2 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_DIVUD))]
+  "VECTOR_MEM_VSX_P (V2DImode)"
+  "#"
+  "VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress"
+  [(const_int 0)]
+  "
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op3 = gen_reg_rtx (DImode);
+  rtx op4 = gen_reg_rtx (DImode);
+  rtx op5 = gen_reg_rtx (DImode);
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (0)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (0)));
+  emit_insn (gen_udivdi3 (op5, op3, op4));
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (1)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (1)));
+  emit_insn (gen_udivdi3 (op3, op3, op4));
+  emit_insn (gen_vsx_concat_v2di (op0, op5, op3));
+}"
+  [(set_attr "type" "vecdiv")])
+
 ;; *tdiv* instruction returning the FG flag
 (define_expand "vsx_tdiv<mode>3_fg"
   [(set (match_dup 3)
@@ -1268,6 +1359,102 @@
   "xscvspdpn %x0,%x1"
   [(set_attr "type" "fp")])
 
+;; Convert and scale (used by vec_ctf, vec_cts, vec_ctu for double/long long)
+
+(define_expand "vsx_xvcvsxddp_scale"
+  [(match_operand:V2DF 0 "vsx_register_operand" "")
+   (match_operand:V2DI 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  int scale = INTVAL(operands[2]);
+  emit_insn (gen_vsx_xvcvsxddp (op0, op1));
+  if (scale != 0)
+    rs6000_scale_v2df (op0, op0, -scale);
+  DONE;
+})
+
+(define_insn "vsx_xvcvsxddp"
+  [(set (match_operand:V2DF 0 "vsx_register_operand" "=wa")
+        (unspec:V2DF [(match_operand:V2DI 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVSXDDP))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvsxddp %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
+(define_expand "vsx_xvcvuxddp_scale"
+  [(match_operand:V2DF 0 "vsx_register_operand" "")
+   (match_operand:V2DI 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  int scale = INTVAL(operands[2]);
+  emit_insn (gen_vsx_xvcvuxddp (op0, op1));
+  if (scale != 0)
+    rs6000_scale_v2df (op0, op0, -scale);
+  DONE;
+})
+
+(define_insn "vsx_xvcvuxddp"
+  [(set (match_operand:V2DF 0 "vsx_register_operand" "=wa")
+        (unspec:V2DF [(match_operand:V2DI 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVUXDDP))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvuxddp %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
+(define_expand "vsx_xvcvdpsxds_scale"
+  [(match_operand:V2DI 0 "vsx_register_operand" "")
+   (match_operand:V2DF 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx tmp = gen_reg_rtx (V2DFmode);
+  int scale = INTVAL(operands[2]);
+  if (scale != 0)
+    rs6000_scale_v2df (tmp, op1, scale);
+  emit_insn (gen_vsx_xvcvdpsxds (op0, tmp));
+  DONE;
+})
+
+(define_insn "vsx_xvcvdpsxds"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DF 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVDPSXDS))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvdpsxds %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
+(define_expand "vsx_xvcvdpuxds_scale"
+  [(match_operand:V2DI 0 "vsx_register_operand" "")
+   (match_operand:V2DF 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx tmp = gen_reg_rtx (V2DFmode);
+  int scale = INTVAL(operands[2]);
+  if (scale != 0)
+    rs6000_scale_v2df (tmp, op1, scale);
+  emit_insn (gen_vsx_xvcvdpuxds (op0, tmp));
+  DONE;
+})
+
+(define_insn "vsx_xvcvdpuxds"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DF 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVDPUXDS))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvdpuxds %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
 ;; Convert from 64-bit to 32-bit types
 ;; Note, favor the Altivec registers since the usual use of these instructions
 ;; is in vector converts and we need to use the Altivec vperm instruction.
@@ -1921,6 +2108,22 @@
   "xxspltw %x0,%x1,%2"
   [(set_attr "type" "vecperm")])
 
+;; V2DF/V2DI splat for use by vec_splat builtin
+(define_insn "vsx_xxspltd_<mode>"
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wa")
+        (unspec:VSX_D [(match_operand:VSX_D 1 "vsx_register_operand" "wa")
+	               (match_operand:QI 2 "u5bit_cint_operand" "i")]
+                      UNSPEC_VSX_XXSPLTD))]
+  "VECTOR_MEM_VSX_P (<MODE>mode)"
+{
+  if ((VECTOR_ELT_ORDER_BIG && INTVAL (operands[2]) == 0)
+      || (!VECTOR_ELT_ORDER_BIG && INTVAL (operands[2]) == 1))
+    return "xxpermdi %x0,%x1,%x1,0";
+  else
+    return "xxpermdi %x0,%x1,%x1,3";
+}
+  [(set_attr "type" "vecperm")])
+
 ;; V4SF/V4SI interleave
 (define_insn "vsx_xxmrghw_<mode>"
   [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
Index: gcc/config/rs6000/altivec.md
===================================================================
--- a/src/gcc/config/rs6000/altivec.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/altivec.md	(.../branches/gcc-4_9-branch)
@@ -67,7 +67,7 @@
    UNSPEC_VCTSXS
    UNSPEC_VLOGEFP
    UNSPEC_VEXPTEFP
-   UNSPEC_VLSDOI
+   UNSPEC_VSLDOI
    UNSPEC_VUNPACK_HI_SIGN
    UNSPEC_VUNPACK_LO_SIGN
    UNSPEC_VUNPACK_HI_SIGN_DIRECT
@@ -2077,7 +2077,7 @@
         (unspec:VM [(match_operand:VM 1 "register_operand" "v")
 		    (match_operand:VM 2 "register_operand" "v")
 		    (match_operand:QI 3 "immediate_operand" "i")]
-		  UNSPEC_VLSDOI))]
+		  UNSPEC_VSLDOI))]
   "TARGET_ALTIVEC"
   "vsldoi %0,%1,%2,%3"
   [(set_attr "type" "vecperm")])
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_9-branch)
@@ -2389,8 +2389,7 @@
 		   (bswap:DI
 		    (match_operand:DI 1 "reg_or_mem_operand" "")))
 	      (clobber (match_scratch:DI 2 ""))
-	      (clobber (match_scratch:DI 3 ""))
-	      (clobber (match_scratch:DI 4 ""))])]
+	      (clobber (match_scratch:DI 3 ""))])]
   ""
 {
   if (!REG_P (operands[0]) && !REG_P (operands[1]))
@@ -2408,11 +2407,10 @@
 
 ;; Power7/cell has ldbrx/stdbrx, so use it directly
 (define_insn "*bswapdi2_ldbrx"
-  [(set (match_operand:DI 0 "reg_or_mem_operand" "=&r,Z,??&r")
+  [(set (match_operand:DI 0 "reg_or_mem_operand" "=r,Z,&r")
 	(bswap:DI (match_operand:DI 1 "reg_or_mem_operand" "Z,r,r")))
    (clobber (match_scratch:DI 2 "=X,X,&r"))
-   (clobber (match_scratch:DI 3 "=X,X,&r"))
-   (clobber (match_scratch:DI 4 "=X,X,&r"))]
+   (clobber (match_scratch:DI 3 "=X,X,&r"))]
   "TARGET_POWERPC64 && TARGET_LDBRX
    && (REG_P (operands[0]) || REG_P (operands[1]))"
   "@
@@ -2424,11 +2422,10 @@
 
 ;; Non-power7/cell, fall back to use lwbrx/stwbrx
 (define_insn "*bswapdi2_64bit"
-  [(set (match_operand:DI 0 "reg_or_mem_operand" "=&r,Z,&r")
+  [(set (match_operand:DI 0 "reg_or_mem_operand" "=r,Z,&r")
 	(bswap:DI (match_operand:DI 1 "reg_or_mem_operand" "Z,r,r")))
    (clobber (match_scratch:DI 2 "=&b,&b,&r"))
-   (clobber (match_scratch:DI 3 "=&r,&r,&r"))
-   (clobber (match_scratch:DI 4 "=&r,X,&r"))]
+   (clobber (match_scratch:DI 3 "=&r,&r,&r"))]
   "TARGET_POWERPC64 && !TARGET_LDBRX
    && (REG_P (operands[0]) || REG_P (operands[1]))
    && !(MEM_P (operands[0]) && MEM_VOLATILE_P (operands[0]))
@@ -2440,8 +2437,7 @@
   [(set (match_operand:DI 0 "gpc_reg_operand" "")
 	(bswap:DI (match_operand:DI 1 "indexed_or_indirect_operand" "")))
    (clobber (match_operand:DI 2 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 4 "gpc_reg_operand" ""))]
+   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))]
   "TARGET_POWERPC64 && !TARGET_LDBRX && reload_completed"
   [(const_int 0)]
   "
@@ -2450,15 +2446,14 @@
   rtx src    = operands[1];
   rtx op2    = operands[2];
   rtx op3    = operands[3];
-  rtx op4    = operands[4];
   rtx op3_32 = simplify_gen_subreg (SImode, op3, DImode,
 				    BYTES_BIG_ENDIAN ? 4 : 0);
-  rtx op4_32 = simplify_gen_subreg (SImode, op4, DImode,
-				    BYTES_BIG_ENDIAN ? 4 : 0);
+  rtx dest_32 = simplify_gen_subreg (SImode, dest, DImode,
+				     BYTES_BIG_ENDIAN ? 4 : 0);
   rtx addr1;
   rtx addr2;
-  rtx word_high;
-  rtx word_low;
+  rtx word1;
+  rtx word2;
 
   addr1 = XEXP (src, 0);
   if (GET_CODE (addr1) == PLUS)
@@ -2483,21 +2478,23 @@
       addr2 = gen_rtx_PLUS (Pmode, op2, addr1);
     }
 
+  word1 = change_address (src, SImode, addr1);
+  word2 = change_address (src, SImode, addr2);
+
   if (BYTES_BIG_ENDIAN)
     {
-      word_high = change_address (src, SImode, addr1);
-      word_low  = change_address (src, SImode, addr2);
+      emit_insn (gen_bswapsi2 (op3_32, word2));
+      emit_insn (gen_bswapsi2 (dest_32, word1));
     }
   else
     {
-      word_high = change_address (src, SImode, addr2);
-      word_low  = change_address (src, SImode, addr1);
+      emit_insn (gen_bswapsi2 (op3_32, word1));
+      emit_insn (gen_bswapsi2 (dest_32, word2));
     }
 
-  emit_insn (gen_bswapsi2 (op3_32, word_low));
-  emit_insn (gen_bswapsi2 (op4_32, word_high));
-  emit_insn (gen_ashldi3 (dest, op3, GEN_INT (32)));
-  emit_insn (gen_iordi3 (dest, dest, op4));
+  emit_insn (gen_ashldi3 (op3, op3, GEN_INT (32)));
+  emit_insn (gen_iordi3 (dest, dest, op3));
+  DONE;
 }")
 
 (define_split
@@ -2504,8 +2501,7 @@
   [(set (match_operand:DI 0 "indexed_or_indirect_operand" "")
 	(bswap:DI (match_operand:DI 1 "gpc_reg_operand" "")))
    (clobber (match_operand:DI 2 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 4 "" ""))]
+   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))]
   "TARGET_POWERPC64 && !TARGET_LDBRX && reload_completed"
   [(const_int 0)]
   "
@@ -2520,8 +2516,8 @@
 				    BYTES_BIG_ENDIAN ? 4 : 0);
   rtx addr1;
   rtx addr2;
-  rtx word_high;
-  rtx word_low;
+  rtx word1;
+  rtx word2;
 
   addr1 = XEXP (dest, 0);
   if (GET_CODE (addr1) == PLUS)
@@ -2546,19 +2542,22 @@
       addr2 = gen_rtx_PLUS (Pmode, op2, addr1);
     }
 
+  word1 = change_address (dest, SImode, addr1);
+  word2 = change_address (dest, SImode, addr2);
+
   emit_insn (gen_lshrdi3 (op3, src, GEN_INT (32)));
+
   if (BYTES_BIG_ENDIAN)
     {
-      word_high = change_address (dest, SImode, addr1);
-      word_low  = change_address (dest, SImode, addr2);
+      emit_insn (gen_bswapsi2 (word1, src_si));
+      emit_insn (gen_bswapsi2 (word2, op3_si));
     }
   else
     {
-      word_high = change_address (dest, SImode, addr2);
-      word_low  = change_address (dest, SImode, addr1);
+      emit_insn (gen_bswapsi2 (word2, src_si));
+      emit_insn (gen_bswapsi2 (word1, op3_si));
     }
-  emit_insn (gen_bswapsi2 (word_high, src_si));
-  emit_insn (gen_bswapsi2 (word_low, op3_si));
+  DONE;
 }")
 
 (define_split
@@ -2565,8 +2564,7 @@
   [(set (match_operand:DI 0 "gpc_reg_operand" "")
 	(bswap:DI (match_operand:DI 1 "gpc_reg_operand" "")))
    (clobber (match_operand:DI 2 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))
-   (clobber (match_operand:DI 4 "" ""))]
+   (clobber (match_operand:DI 3 "gpc_reg_operand" ""))]
   "TARGET_POWERPC64 && reload_completed"
   [(const_int 0)]
   "
@@ -2586,10 +2584,11 @@
   emit_insn (gen_bswapsi2 (op3_si, op2_si));
   emit_insn (gen_ashldi3 (dest, dest, GEN_INT (32)));
   emit_insn (gen_iordi3 (dest, dest, op3));
+  DONE;
 }")
 
 (define_insn "bswapdi2_32bit"
-  [(set (match_operand:DI 0 "reg_or_mem_operand" "=&r,Z,&r")
+  [(set (match_operand:DI 0 "reg_or_mem_operand" "=r,Z,?&r")
 	(bswap:DI (match_operand:DI 1 "reg_or_mem_operand" "Z,r,r")))
    (clobber (match_scratch:SI 2 "=&b,&b,X"))]
   "!TARGET_POWERPC64 && (REG_P (operands[0]) || REG_P (operands[1]))"
@@ -2618,7 +2617,8 @@
   if (GET_CODE (addr1) == PLUS)
     {
       emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));
-      if (TARGET_AVOID_XFORM)
+      if (TARGET_AVOID_XFORM
+	  || REGNO (XEXP (addr1, 1)) == REGNO (dest2))
 	{
 	  emit_insn (gen_add3_insn (op2, XEXP (addr1, 1), op2));
 	  addr2 = op2;
@@ -2626,7 +2626,8 @@
       else
 	addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));
     }
-  else if (TARGET_AVOID_XFORM)
+  else if (TARGET_AVOID_XFORM
+	   || REGNO (addr1) == REGNO (dest2))
     {
       emit_insn (gen_add3_insn (op2, addr1, GEN_INT (4)));
       addr2 = op2;
@@ -2641,7 +2642,10 @@
   word2 = change_address (src, SImode, addr2);
 
   emit_insn (gen_bswapsi2 (dest2, word1));
+  /* The REGNO (dest2) tests above ensure that addr2 has not been trashed,
+     thus allowing us to omit an early clobber on the output.  */
   emit_insn (gen_bswapsi2 (dest1, word2));
+  DONE;
 }")
 
 (define_split
@@ -2690,6 +2694,7 @@
 
   emit_insn (gen_bswapsi2 (word2, src1));
   emit_insn (gen_bswapsi2 (word1, src2));
+  DONE;
 }")
 
 (define_split
@@ -2709,6 +2714,7 @@
 
   emit_insn (gen_bswapsi2 (dest1, src2));
   emit_insn (gen_bswapsi2 (dest2, src1));
+  DONE;
 }")
 
 (define_insn "mulsi3"
@@ -8600,8 +8606,8 @@
   [(set (match_operand:BOOL_128 0 "vlogical_operand" "=<BOOL_REGS_OUTPUT>")
 	(match_operator:BOOL_128 3 "boolean_operator"
 	 [(not:BOOL_128
-	   (match_operand:BOOL_128 2 "vlogical_operand" "<BOOL_REGS_OP1>"))
-	  (match_operand:BOOL_128 1 "vlogical_operand" "<BOOL_REGS_OP2>")]))]
+	   (match_operand:BOOL_128 2 "vlogical_operand" "<BOOL_REGS_OP2>"))
+	  (match_operand:BOOL_128 1 "vlogical_operand" "<BOOL_REGS_OP1>")]))]
   "TARGET_P8_VECTOR || (GET_CODE (operands[3]) == AND)"
 {
   if (TARGET_VSX && vsx_register_operand (operands[0], <MODE>mode))
@@ -8616,7 +8622,7 @@
    && reload_completed && int_reg_operand (operands[0], <MODE>mode)"
   [(const_int 0)]
 {
-  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false,
+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, false, true,
 			NULL_RTX);
   DONE;
 }
@@ -8638,14 +8644,14 @@
   [(set (match_operand:TI2 0 "int_reg_operand" "=&r,r,r")
 	(match_operator:TI2 3 "boolean_operator"
 	 [(not:TI2
-	   (match_operand:TI2 1 "int_reg_operand" "r,0,r"))
-	  (match_operand:TI2 2 "int_reg_operand" "r,r,0")]))]
+	   (match_operand:TI2 2 "int_reg_operand" "r,0,r"))
+	  (match_operand:TI2 1 "int_reg_operand" "r,r,0")]))]
   "!TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)"
   "#"
   "reload_completed && !TARGET_P8_VECTOR && (GET_CODE (operands[3]) != AND)"
   [(const_int 0)]
 {
-  rs6000_split_logical (operands, GET_CODE (operands[3]), false, true, false,
+  rs6000_split_logical (operands, GET_CODE (operands[3]), false, false, true,
 			NULL_RTX);
   DONE;
 }
Index: gcc/config/rs6000/driver-rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/driver-rs6000.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/driver-rs6000.c	(.../branches/gcc-4_9-branch)
@@ -1,5 +1,5 @@
 /* Subroutines for the gcc driver.
-   Copyright (C) 2007-2014 Free Software Foundation, Inc.
+   Copyright (C) 2007-2015 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -327,6 +327,12 @@
     case 0x4000:
       return "power6";
 
+    case 0x8000:
+      return "power7";
+
+    case 0x10000:
+      return "power8";
+
     default:
       return "powerpc";
     }
Index: gcc/config/rs6000/altivec.h
===================================================================
--- a/src/gcc/config/rs6000/altivec.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/altivec.h	(.../branches/gcc-4_9-branch)
@@ -124,6 +124,7 @@
 #define vec_vcfux __builtin_vec_vcfux
 #define vec_cts __builtin_vec_cts
 #define vec_ctu __builtin_vec_ctu
+#define vec_cpsgn __builtin_vec_copysign
 #define vec_expte __builtin_vec_expte
 #define vec_floor __builtin_vec_floor
 #define vec_loge __builtin_vec_loge
@@ -214,8 +215,10 @@
 #define vec_lvsl __builtin_vec_lvsl
 #define vec_lvsr __builtin_vec_lvsr
 #define vec_max __builtin_vec_max
+#define vec_mergee __builtin_vec_vmrgew
 #define vec_mergeh __builtin_vec_mergeh
 #define vec_mergel __builtin_vec_mergel
+#define vec_mergeo __builtin_vec_vmrgow
 #define vec_min __builtin_vec_min
 #define vec_mladd __builtin_vec_mladd
 #define vec_msum __builtin_vec_msum
@@ -319,6 +322,8 @@
 #define vec_sqrt __builtin_vec_sqrt
 #define vec_vsx_ld __builtin_vec_vsx_ld
 #define vec_vsx_st __builtin_vec_vsx_st
+#define vec_xl __builtin_vec_vsx_ld
+#define vec_xst __builtin_vec_vsx_st
 
 /* Note, xxsldi and xxpermdi were added as __builtin_vsx_<xxx> functions
    instead of __builtin_vec_<xxx>  */
@@ -336,6 +341,7 @@
 #define vec_vadduqm __builtin_vec_vadduqm
 #define vec_vbpermq __builtin_vec_vbpermq
 #define vec_vclz __builtin_vec_vclz
+#define vec_cntlz __builtin_vec_vclz
 #define vec_vclzb __builtin_vec_vclzb
 #define vec_vclzd __builtin_vec_vclzd
 #define vec_vclzh __builtin_vec_vclzh
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-4_9-branch)
@@ -16274,7 +16274,7 @@
 	      fputc ('\n', dump_file);
 	    }
 
-	  switch (mp->fix_size)
+	  switch (GET_MODE_SIZE (mp->mode))
 	    {
 #ifdef HAVE_consttable_1
 	    case 1:
@@ -18601,6 +18601,14 @@
   fputs ("\"\n", stream);
 }
 
+/* Whether a register is callee saved or not.  This is necessary because high
+   registers are marked as caller saved when optimizing for size on Thumb-1
+   targets despite being callee saved in order to avoid using them.  */
+#define callee_saved_reg_p(reg) \
+  (!call_used_regs[reg] \
+   || (TARGET_THUMB1 && optimize_size \
+       && reg >= FIRST_HI_REGNUM && reg <= LAST_HI_REGNUM))
+
 /* Compute the register save mask for registers 0 through 12
    inclusive.  This code is used by arm_compute_save_reg_mask.  */
 
@@ -18661,7 +18669,7 @@
       /* In the normal case we only need to save those registers
 	 which are call saved and which are used by this function.  */
       for (reg = 0; reg <= 11; reg++)
-	if (df_regs_ever_live_p (reg) && ! call_used_regs[reg])
+	if (df_regs_ever_live_p (reg) && callee_saved_reg_p (reg))
 	  save_reg_mask |= (1 << reg);
 
       /* Handle the frame pointer as a special case.  */
@@ -18824,7 +18832,7 @@
 
   mask = 0;
   for (reg = 0; reg < 12; reg ++)
-    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
+    if (df_regs_ever_live_p (reg) && callee_saved_reg_p (reg))
       mask |= 1 << reg;
 
   if (flag_pic
@@ -18857,7 +18865,7 @@
       if (reg * UNITS_PER_WORD <= (unsigned) arm_size_return_regs ())
 	reg = LAST_LO_REGNUM;
 
-      if (! call_used_regs[reg])
+      if (callee_saved_reg_p (reg))
 	mask |= 1 << reg;
     }
 
@@ -28492,7 +28500,11 @@
 
 	  addr = plus_constant (Pmode, addr, delta);
 	}
-      emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      /* The store needs to be marked as frame related in order to prevent
+	 DSE from deleting it as dead if it is based on fp.  */
+      rtx insn = emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      RTX_FRAME_RELATED_P (insn) = 1;
+      add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (Pmode, LR_REGNUM));
     }
 }
 
@@ -28544,7 +28556,11 @@
       else
 	addr = plus_constant (Pmode, addr, delta);
 
-      emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      /* The store needs to be marked as frame related in order to prevent
+	 DSE from deleting it as dead if it is based on fp.  */
+      rtx insn = emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      RTX_FRAME_RELATED_P (insn) = 1;
+      add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (Pmode, LR_REGNUM));
     }
   else
     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), source);
@@ -29663,8 +29679,7 @@
       /* When optimizing for size on Thumb-1, it's better not
         to use the HI regs, because of the overhead of
         stacking them.  */
-      for (regno = FIRST_HI_REGNUM;
-	   regno <= LAST_HI_REGNUM; ++regno)
+      for (regno = FIRST_HI_REGNUM; regno <= LAST_HI_REGNUM; ++regno)
 	fixed_regs[regno] = call_used_regs[regno] = 1;
     }
 
Index: gcc/config/arm/t-aprofile
===================================================================
--- a/src/gcc/config/arm/t-aprofile	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/t-aprofile	(.../branches/gcc-4_9-branch)
@@ -88,6 +88,9 @@
 MULTILIB_MATCHES       += march?armv8-a=mcpu?cortex-a57
 MULTILIB_MATCHES       += march?armv8-a=mcpu?cortex-a57.cortex-a53
 
+# Arch Matches
+MULTILIB_MATCHES       += march?armv8-a=march?armv8-a+crc
+
 # FPU matches
 MULTILIB_MATCHES       += mfpu?vfpv3-d16=mfpu?vfpv3
 MULTILIB_MATCHES       += mfpu?vfpv3-d16=mfpu?vfpv3-fp16
Index: gcc/config/arm/arm.h
===================================================================
--- a/src/gcc/config/arm/arm.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/arm.h	(.../branches/gcc-4_9-branch)
@@ -74,8 +74,8 @@
 	builtin_define_with_int_value (				\
 	  "__ARM_SIZEOF_MINIMAL_ENUM",				\
 	  flag_short_enums ? 1 : 4);				\
-	builtin_define_with_int_value (				\
-	  "__ARM_SIZEOF_WCHAR_T", WCHAR_TYPE_SIZE);		\
+	builtin_define_type_sizeof ("__ARM_SIZEOF_WCHAR_T",	\
+				    wchar_type_node);		\
 	if (TARGET_ARM_ARCH_PROFILE)				\
 	  builtin_define_with_int_value (			\
 	    "__ARM_ARCH_PROFILE", TARGET_ARM_ARCH_PROFILE);	\
@@ -2138,9 +2138,10 @@
    ? reverse_condition_maybe_unordered (code) \
    : reverse_condition (code))
 
-/* The arm5 clz instruction returns 32.  */
-#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
-#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE))
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE))
 
 #define CC_STATUS_INIT \
   do { cfun->machine->thumb1_cc_insn = NULL_RTX; } while (0)
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-4_9-branch)
@@ -125,9 +125,10 @@
 ; This can be "a" for ARM, "t" for either of the Thumbs, "32" for
 ; TARGET_32BIT, "t1" or "t2" to specify a specific Thumb mode.  "v6"
 ; for ARM or Thumb-2 with arm_arch6, and nov6 for ARM without
-; arm_arch6.  This attribute is used to compute attribute "enabled",
-; use type "any" to enable an alternative in all cases.
-(define_attr "arch" "any,a,t,32,t1,t2,v6,nov6,neon_for_64bits,avoid_neon_for_64bits,iwmmxt,iwmmxt2"
+; arm_arch6.  "v6t2" for Thumb-2 with arm_arch6.  This attribute is
+; used to compute attribute "enabled", use type "any" to enable an
+; alternative in all cases.
+(define_attr "arch" "any,a,t,32,t1,t2,v6,nov6,v6t2,neon_for_64bits,avoid_neon_for_64bits,iwmmxt,iwmmxt2"
   (const_string "any"))
 
 (define_attr "arch_enabled" "no,yes"
@@ -162,6 +163,10 @@
 	      (match_test "TARGET_32BIT && !arm_arch6"))
 	 (const_string "yes")
 
+	 (and (eq_attr "arch" "v6t2")
+	      (match_test "TARGET_32BIT && arm_arch6 && arm_arch_thumb2"))
+	 (const_string "yes")
+
 	 (and (eq_attr "arch" "avoid_neon_for_64bits")
 	      (match_test "TARGET_NEON")
 	      (not (match_test "TARGET_PREFER_NEON_64BITS")))
@@ -6961,8 +6966,8 @@
 
 ;; Pattern to recognize insn generated default case above
 (define_insn "*movhi_insn_arch4"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,m,r")
-	(match_operand:HI 1 "general_operand"      "rI,K,r,mi"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,m,r")
+	(match_operand:HI 1 "general_operand"      "rI,K,n,r,mi"))]
   "TARGET_ARM
    && arm_arch4
    && (register_operand (operands[0], HImode)
@@ -6970,16 +6975,19 @@
   "@
    mov%?\\t%0, %1\\t%@ movhi
    mvn%?\\t%0, #%B1\\t%@ movhi
+   movw%?\\t%0, %L1\\t%@ movhi
    str%(h%)\\t%1, %0\\t%@ movhi
    ldr%(h%)\\t%0, %1\\t%@ movhi"
   [(set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,*,*,256")
-   (set_attr "neg_pool_range" "*,*,*,244")
+   (set_attr "pool_range" "*,*,*,*,256")
+   (set_attr "neg_pool_range" "*,*,*,*,244")
+   (set_attr "arch" "*,*,v6t2,*,*")
    (set_attr_alternative "type"
                          [(if_then_else (match_operand 1 "const_int_operand" "")
                                         (const_string "mov_imm" )
                                         (const_string "mov_reg"))
                           (const_string "mvn_imm")
+                          (const_string "mov_imm")
                           (const_string "store1")
                           (const_string "load1")])]
 )
@@ -12216,7 +12224,7 @@
 
 (define_insn "consttable_1"
   [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_1)]
-  "TARGET_THUMB1"
+  "TARGET_EITHER"
   "*
   making_const_table = TRUE;
   assemble_integer (operands[0], 1, BITS_PER_WORD, 1);
@@ -12229,14 +12237,23 @@
 
 (define_insn "consttable_2"
   [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_2)]
-  "TARGET_THUMB1"
+  "TARGET_EITHER"
   "*
-  making_const_table = TRUE;
-  gcc_assert (GET_MODE_CLASS (GET_MODE (operands[0])) != MODE_FLOAT);
-  assemble_integer (operands[0], 2, BITS_PER_WORD, 1);
-  assemble_zeros (2);
-  return \"\";
-  "
+  {
+    rtx x = operands[0];
+    making_const_table = TRUE;
+    switch (GET_MODE_CLASS (GET_MODE (x)))
+      {
+      case MODE_FLOAT:
+	arm_emit_fp16_const (x);
+	break;
+      default:
+	assemble_integer (operands[0], 2, BITS_PER_WORD, 1);
+	assemble_zeros (2);
+	break;
+      }
+    return \"\";
+  }"
   [(set_attr "length" "4")
    (set_attr "type" "no_insn")]
 )
@@ -12251,15 +12268,12 @@
     switch (GET_MODE_CLASS (GET_MODE (x)))
       {
       case MODE_FLOAT:
- 	if (GET_MODE (x) == HFmode)
- 	  arm_emit_fp16_const (x);
- 	else
- 	  {
- 	    REAL_VALUE_TYPE r;
- 	    REAL_VALUE_FROM_CONST_DOUBLE (r, x);
- 	    assemble_real (r, GET_MODE (x), BITS_PER_WORD);
- 	  }
- 	break;
+	{
+	  REAL_VALUE_TYPE r;
+	  REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+	  assemble_real (r, GET_MODE (x), BITS_PER_WORD);
+	  break;
+	}
       default:
 	/* XXX: Sometimes gcc does something really dumb and ends up with
 	   a HIGH in a constant pool entry, usually because it's trying to
Index: gcc/config/pa/predicates.md
===================================================================
--- a/src/gcc/config/pa/predicates.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/pa/predicates.md	(.../branches/gcc-4_9-branch)
@@ -528,20 +528,29 @@
 ;; This predicate is used for branch patterns that internally handle
 ;; register reloading.  We need to accept non-symbolic memory operands
 ;; after reload to ensure that the pattern is still valid if reload
-;; didn't find a hard register for the operand.
+;; didn't find a hard register for the operand.  We also reject index
+;; and lo_sum DLT address as these are invalid for move destinations.
 
 (define_predicate "reg_before_reload_operand"
   (match_code "reg,mem")
 {
+  rtx op0;
+
   if (register_operand (op, mode))
     return true;
 
-  if (reload_completed
-      && memory_operand (op, mode)
-      && !symbolic_memory_operand (op, mode))
-    return true;
+  if (!reload_in_progress && !reload_completed)
+    return false;
 
-  return false;
+  if (! MEM_P (op))
+    return false;
+
+  op0 = XEXP (op, 0);
+
+  return (memory_address_p (mode, op0)
+	  && !IS_INDEX_ADDR_P (op0)
+	  && !IS_LO_SUM_DLT_ADDR_P (op0)
+	  && !symbolic_memory_operand (op, mode));
 })
 
 ;; True iff OP is a register or const_0 operand for MODE.
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-4_9-branch)
@@ -123,7 +123,7 @@
 ;; type "binary" insns have two input operands (1,2) and one output (0)
 
 (define_attr "type"
-  "move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,sh_func_adrs,parallel_branch,fpstore_load,store_fpload"
+  "move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,sh_func_adrs,parallel_branch,fpstore_load,store_fpload,trap"
   (const_string "binary"))
 
 (define_attr "pa_combine_type"
@@ -166,7 +166,7 @@
 ;; For conditional branches. Frame related instructions are not allowed
 ;; because they confuse the unwind support.
 (define_attr "in_branch_delay" "false,true"
-  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch")
+  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch,trap")
 		     (eq_attr "length" "4")
 		     (not (match_test "RTX_FRAME_RELATED_P (insn)")))
 		(const_string "true")
@@ -175,7 +175,7 @@
 ;; Disallow instructions which use the FPU since they will tie up the FPU
 ;; even if the instruction is nullified.
 (define_attr "in_nullified_branch_delay" "false,true"
-  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,parallel_branch")
+  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,parallel_branch,trap")
 		     (eq_attr "length" "4")
 		     (not (match_test "RTX_FRAME_RELATED_P (insn)")))
 		(const_string "true")
@@ -184,7 +184,7 @@
 ;; For calls and millicode calls.  Allow unconditional branches in the
 ;; delay slot.
 (define_attr "in_call_delay" "false,true"
-  (cond [(and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch")
+  (cond [(and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch,trap")
 	      (eq_attr "length" "4")
 	      (not (match_test "RTX_FRAME_RELATED_P (insn)")))
 	   (const_string "true")
@@ -2680,6 +2680,29 @@
   [(set_attr "type" "binary")
    (set_attr "length" "4")])
 
+(define_insn ""
+ [(set (match_operand:SI 0 "register_operand" "=r")
+       (lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+		  (unspec:SI [(match_operand 2 "" "")] UNSPEC_DLTIND14R)))]
+  "symbolic_operand (operands[2], Pmode)
+   && ! function_label_operand (operands[2], Pmode)
+   && flag_pic"
+  "ldo RT'%G2(%1),%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
+
+(define_insn ""
+ [(set (match_operand:DI 0 "register_operand" "=r")
+       (lo_sum:DI (match_operand:DI 1 "register_operand" "r")
+		  (unspec:DI [(match_operand 2 "" "")] UNSPEC_DLTIND14R)))]
+  "symbolic_operand (operands[2], Pmode)
+   && ! function_label_operand (operands[2], Pmode)
+   && TARGET_64BIT
+   && flag_pic"
+  "ldo RT'%G2(%1),%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
+
 ;; Always use addil rather than ldil;add sequences.  This allows the
 ;; HP linker to eliminate the dp relocation if the symbolic operand
 ;; lives in the TEXT space.
@@ -5331,6 +5354,15 @@
   [(set_attr "type" "binary,binary")
    (set_attr "length" "4,4")])
 
+;; Trap instructions.
+
+(define_insn "trap"
+  [(trap_if (const_int 1) (const_int 0))]
+  ""
+  "{addit|addi,tc},<> 1,%%r0,%%r0"
+  [(set_attr "type" "trap")
+   (set_attr "length" "4")])
+
 ;; Clobbering a "register_operand" instead of a match_scratch
 ;; in operand3 of millicode calls avoids spilling %r1 and
 ;; produces better code.
@@ -8926,7 +8958,7 @@
 ;; strength reduction is used.  It is actually created when the instruction
 ;; combination phase combines the special loop test.  Since this insn
 ;; is both a jump insn and has an output, it must deal with its own
-;; reloads, hence the `m' constraints.  The `!' constraints direct reload
+;; reloads, hence the `Q' constraints.  The `!' constraints direct reload
 ;; to not choose the register alternatives in the event a reload is needed.
 (define_insn "decrement_and_branch_until_zero"
   [(set (pc)
@@ -8933,7 +8965,7 @@
 	(if_then_else
 	  (match_operator 2 "comparison_operator"
 	   [(plus:SI
-	      (match_operand:SI 0 "reg_before_reload_operand" "+!r,!*f,*m")
+	      (match_operand:SI 0 "reg_before_reload_operand" "+!r,!*f,*Q")
 	      (match_operand:SI 1 "int5_operand" "L,L,L"))
 	    (const_int 0)])
 	  (label_ref (match_operand 3 "" ""))
@@ -9022,7 +9054,7 @@
 	   [(match_operand:SI 1 "register_operand" "r,r,r,r") (const_int 0)])
 	  (label_ref (match_operand 3 "" ""))
 	  (pc)))
-   (set (match_operand:SI 0 "reg_before_reload_operand" "=!r,!*f,*m,!*q")
+   (set (match_operand:SI 0 "reg_before_reload_operand" "=!r,!*f,*Q,!*q")
 	(match_dup 1))]
   ""
 "* return pa_output_movb (operands, insn, which_alternative, 0); "
@@ -9094,7 +9126,7 @@
 	   [(match_operand:SI 1 "register_operand" "r,r,r,r") (const_int 0)])
 	  (pc)
 	  (label_ref (match_operand 3 "" ""))))
-   (set (match_operand:SI 0 "reg_before_reload_operand" "=!r,!*f,*m,!*q")
+   (set (match_operand:SI 0 "reg_before_reload_operand" "=!r,!*f,*Q,!*q")
 	(match_dup 1))]
   ""
 "* return pa_output_movb (operands, insn, which_alternative, 1); "
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-4_9-branch)
@@ -119,6 +119,7 @@
 static int pa_adjust_cost (rtx, rtx, rtx, int);
 static int pa_adjust_priority (rtx, int);
 static int pa_issue_rate (void);
+static int pa_reloc_rw_mask (void);
 static void pa_som_asm_init_sections (void) ATTRIBUTE_UNUSED;
 static section *pa_som_tm_clone_table_section (void) ATTRIBUTE_UNUSED;
 static section *pa_select_section (tree, int, unsigned HOST_WIDE_INT)
@@ -294,6 +295,9 @@
 #define TARGET_ASM_FILE_END output_deferred_plabels
 #endif
 
+#undef TARGET_ASM_RELOC_RW_MASK
+#define TARGET_ASM_RELOC_RW_MASK pa_reloc_rw_mask
+
 #undef TARGET_PRINT_OPERAND_PUNCT_VALID_P
 #define TARGET_PRINT_OPERAND_PUNCT_VALID_P pa_print_operand_punct_valid_p
 
@@ -6013,18 +6017,15 @@
 	{
 	  x = XEXP (x, 0);
 
-	  /* We don't need an intermediate for indexed and LO_SUM DLT
-	     memory addresses.  When INT14_OK_STRICT is true, it might
-	     appear that we could directly allow register indirect
-	     memory addresses.  However, this doesn't work because we
-	     don't support SUBREGs in floating-point register copies
-	     and reload doesn't tell us when it's going to use a SUBREG.  */
-	  if (IS_INDEX_ADDR_P (x)
-	      || IS_LO_SUM_DLT_ADDR_P (x))
+	  /* We don't need a secondary reload for indexed memory addresses.
+
+	     When INT14_OK_STRICT is true, it might appear that we could
+	     directly allow register indirect memory addresses.  However,
+	     this doesn't work because we don't support SUBREGs in
+	     floating-point register copies and reload doesn't tell us
+	     when it's going to use a SUBREG.  */
+	  if (IS_INDEX_ADDR_P (x))
 	    return NO_REGS;
-
-	  /* Request intermediate general register.  */
-	  return GENERAL_REGS;
 	}
 
       /* Request a secondary reload with a general scratch register
@@ -9820,6 +9821,19 @@
     return data_section;
 }
 
+/* Implement pa_reloc_rw_mask.  */
+
+static int
+pa_reloc_rw_mask (void)
+{
+  /* We force (const (plus (symbol) (const_int))) to memory when the
+     const_int doesn't fit in a 14-bit integer.  The SOM linker can't
+     handle this construct in read-only memory and we want to avoid
+     this for ELF.  So, we always force an RTX needing relocation to
+     the data section.  */
+  return 3;
+}
+
 static void
 pa_globalize_label (FILE *stream, const char *name)
 {
Index: gcc/config/pa/constraints.md
===================================================================
--- a/src/gcc/config/pa/constraints.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/pa/constraints.md	(.../branches/gcc-4_9-branch)
@@ -106,7 +106,7 @@
   (and (match_code "mem")
        (match_test "IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))")))
 
-(define_constraint "Q"
+(define_memory_constraint "Q"
   "A memory operand that can be used as the destination operand of an
    integer store, or the source operand of an integer load.  That is
    any memory operand that isn't a symbolic, indexed or lo_sum memory
@@ -122,7 +122,7 @@
   (and (match_code "mem")
        (match_test "IS_INDEX_ADDR_P (XEXP (op, 0))")))
 
-(define_constraint "T"
+(define_memory_constraint "T"
   "A memory operand for floating-point loads and stores."
   (match_test "floating_point_store_memory_operand (op, mode)"))
 
Index: gcc/config/mips/mips.h
===================================================================
--- a/src/gcc/config/mips/mips.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/mips/mips.h	(.../branches/gcc-4_9-branch)
@@ -1163,6 +1163,22 @@
 #define SUBTARGET_ASM_SPEC ""
 #endif
 
+/* FP_ASM_SPEC represents the floating-point options that must be passed
+   to the assembler when FPXX support exists.  Prior to that point the
+   assembler could accept the options but were not required for
+   correctness.  We only add the options when absolutely necessary
+   because passing -msoft-float to the assembler will cause it to reject
+   all hard-float instructions which may require some user code to be
+   updated.  */
+
+#ifdef HAVE_AS_DOT_MODULE
+#define FP_ASM_SPEC "\
+%{mhard-float} %{msoft-float} \
+%{msingle-float} %{mdouble-float}"
+#else
+#define FP_ASM_SPEC
+#endif
+
 #undef ASM_SPEC
 #define ASM_SPEC "\
 %{G*} %(endian_spec) %{mips1} %{mips2} %{mips3} %{mips4} \
@@ -1188,7 +1204,8 @@
 %{mfp32} %{mfp64} %{mnan=*} \
 %{mshared} %{mno-shared} \
 %{msym32} %{mno-sym32} \
-%{mtune=*} \
+%{mtune=*}" \
+FP_ASM_SPEC "\
 %(subtarget_asm_spec)"
 
 /* Extra switches sometimes passed to the linker.  */
Index: gcc/tree-vect-slp.c
===================================================================
--- a/src/gcc/tree-vect-slp.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vect-slp.c	(.../branches/gcc-4_9-branch)
@@ -47,6 +47,7 @@
 #include "optabs.h"
 #include "tree-vectorizer.h"
 #include "langhooks.h"
+#include "gimple-walk.h"
 
 /* Extract the location of the basic block in the source code.
    Return the basic block location if succeed and NULL if not.  */
@@ -671,8 +672,11 @@
 		 ???  We should enhance this to only disallow gaps
 		 inside vectors.  */
               if ((unrolling_factor > 1
-		   && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt
-		   && GROUP_GAP (vinfo_for_stmt (stmt)) != 0)
+		   && ((GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt
+			&& GROUP_GAP (vinfo_for_stmt (stmt)) != 0)
+		       /* If the group is split up then GROUP_GAP
+			  isn't correct here, nor is GROUP_FIRST_ELEMENT.  */
+		       || GROUP_SIZE (vinfo_for_stmt (stmt)) > group_size))
 		  || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != stmt
 		      && GROUP_GAP (vinfo_for_stmt (stmt)) != 1))
                 {
@@ -1761,52 +1765,84 @@
    can't be SLPed) in the tree rooted at NODE.  Mark such stmts as HYBRID.  */
 
 static void
-vect_detect_hybrid_slp_stmts (slp_tree node)
+vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)
 {
-  int i;
-  vec<gimple> stmts = SLP_TREE_SCALAR_STMTS (node);
-  gimple stmt = stmts[0];
+  gimple stmt = SLP_TREE_SCALAR_STMTS (node)[i];
   imm_use_iterator imm_iter;
   gimple use_stmt;
-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);
+  stmt_vec_info use_vinfo, stmt_vinfo = vinfo_for_stmt (stmt);
   slp_tree child;
   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);
-  struct loop *loop = NULL;
-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);
-  basic_block bb = NULL;
+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);
+  int j;
 
-  if (!node)
-    return;
-
-  if (loop_vinfo)
-    loop = LOOP_VINFO_LOOP (loop_vinfo);
+  /* Propagate hybrid down the SLP tree.  */
+  if (stype == hybrid)
+    ;
+  else if (HYBRID_SLP_STMT (stmt_vinfo))
+    stype = hybrid;
   else
-    bb = BB_VINFO_BB (bb_vinfo);
+    {
+      /* Check if a pure SLP stmt has uses in non-SLP stmts.  */
+      gcc_checking_assert (PURE_SLP_STMT (stmt_vinfo));
+      if (TREE_CODE (gimple_op (stmt, 0)) == SSA_NAME)
+	FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))
+	  if (gimple_bb (use_stmt)
+	      && flow_bb_inside_loop_p (loop, gimple_bb (use_stmt))
+	      && (use_vinfo = vinfo_for_stmt (use_stmt))
+	      && !STMT_SLP_TYPE (use_vinfo)
+	      && (STMT_VINFO_RELEVANT (use_vinfo)
+		  || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (use_vinfo))
+		  || (STMT_VINFO_IN_PATTERN_P (use_vinfo)
+		      && STMT_VINFO_RELATED_STMT (use_vinfo)
+		      && !STMT_SLP_TYPE (vinfo_for_stmt
+			    (STMT_VINFO_RELATED_STMT (use_vinfo)))))
+	      && !(gimple_code (use_stmt) == GIMPLE_PHI
+		   && STMT_VINFO_DEF_TYPE (use_vinfo) == vect_reduction_def))
+	    stype = hybrid;
+    }
 
-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)
-    if (PURE_SLP_STMT (vinfo_for_stmt (stmt))
-	&& TREE_CODE (gimple_op (stmt, 0)) == SSA_NAME)
-      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))
-	if (gimple_bb (use_stmt)
-            && ((loop && flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))
-		 || bb == gimple_bb (use_stmt))
-	    && (stmt_vinfo = vinfo_for_stmt (use_stmt))
-	    && !STMT_SLP_TYPE (stmt_vinfo)
-            && (STMT_VINFO_RELEVANT (stmt_vinfo)
-                || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_vinfo))
-		|| (STMT_VINFO_IN_PATTERN_P (stmt_vinfo)
-		    && STMT_VINFO_RELATED_STMT (stmt_vinfo)
-		    && !STMT_SLP_TYPE (vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_vinfo)))))
-	    && !(gimple_code (use_stmt) == GIMPLE_PHI
-                 && STMT_VINFO_DEF_TYPE (stmt_vinfo)
-                  == vect_reduction_def))
-	  vect_mark_slp_stmts (node, hybrid, i);
+  if (stype == hybrid)
+    STMT_SLP_TYPE (stmt_vinfo) = hybrid;
 
-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)
-    vect_detect_hybrid_slp_stmts (child);
+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)
+    vect_detect_hybrid_slp_stmts (child, i, stype);
 }
 
+/* Helpers for vect_detect_hybrid_slp walking pattern stmt uses.  */
 
+static tree
+vect_detect_hybrid_slp_1 (tree *tp, int *, void *data)
+{
+  walk_stmt_info *wi = (walk_stmt_info *)data;
+  struct loop *loopp = (struct loop *)wi->info;
+
+  if (wi->is_lhs)
+    return NULL_TREE;
+
+  if (TREE_CODE (*tp) == SSA_NAME
+      && !SSA_NAME_IS_DEFAULT_DEF (*tp))
+    {
+      gimple def_stmt = SSA_NAME_DEF_STMT (*tp);
+      if (flow_bb_inside_loop_p (loopp, gimple_bb (def_stmt))
+	  && PURE_SLP_STMT (vinfo_for_stmt (def_stmt)))
+	STMT_SLP_TYPE (vinfo_for_stmt (def_stmt)) = hybrid;
+    }
+
+  return NULL_TREE;
+}
+
+static tree
+vect_detect_hybrid_slp_2 (gimple_stmt_iterator *gsi, bool *handled,
+			  walk_stmt_info *)
+{
+  /* If the stmt is in a SLP instance then this isn't a reason
+     to mark use definitions in other SLP instances as hybrid.  */
+  if (STMT_SLP_TYPE (vinfo_for_stmt (gsi_stmt (*gsi))) != loop_vect)
+    *handled = true;
+  return NULL_TREE;
+}
+
 /* Find stmts that must be both vectorized and SLPed.  */
 
 void
@@ -1820,8 +1856,41 @@
     dump_printf_loc (MSG_NOTE, vect_location, "=== vect_detect_hybrid_slp ==="
                      "\n");
 
+  /* First walk all pattern stmt in the loop and mark defs of uses as
+     hybrid because immediate uses in them are not recorded.  */
+  for (i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)
+    {
+      basic_block bb = LOOP_VINFO_BBS (loop_vinfo)[i];
+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gimple stmt = gsi_stmt (gsi);
+	  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);
+	  if (STMT_VINFO_IN_PATTERN_P (stmt_info))
+	    {
+	      walk_stmt_info wi;
+	      memset (&wi, 0, sizeof (wi));
+	      wi.info = LOOP_VINFO_LOOP (loop_vinfo);
+	      gimple_stmt_iterator gsi2
+		= gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));
+	      walk_gimple_stmt (&gsi2, vect_detect_hybrid_slp_2,
+				vect_detect_hybrid_slp_1, &wi);
+	      walk_gimple_seq (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info),
+			       vect_detect_hybrid_slp_2,
+			       vect_detect_hybrid_slp_1, &wi);
+	    }
+	}
+    }
+
+  /* Then walk the SLP instance trees marking stmts with uses in
+     non-SLP stmts as hybrid, also propagating hybrid down the
+     SLP tree, collecting the above info on-the-fly.  */
   FOR_EACH_VEC_ELT (slp_instances, i, instance)
-    vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance));
+    {
+      for (unsigned i = 0; i < SLP_INSTANCE_GROUP_SIZE (instance); ++i)
+	vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance),
+				      i, pure_slp);
+    }
 }
 
 
Index: gcc/cfgrtl.c
===================================================================
--- a/src/gcc/cfgrtl.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cfgrtl.c	(.../branches/gcc-4_9-branch)
@@ -1761,6 +1761,22 @@
       && (any_uncondjump_p (q)
 	  || single_succ_p (b)))
     {
+      rtx label, table;
+
+      if (tablejump_p (q, &label, &table))
+	{
+	  /* The label is likely mentioned in some instruction before
+	     the tablejump and might not be DCEd, so turn it into
+	     a note instead and move before the tablejump that is going to
+	     be deleted.  */
+	  const char *name = LABEL_NAME (label);
+	  PUT_CODE (label, NOTE);
+	  NOTE_KIND (label) = NOTE_INSN_DELETED_LABEL;
+	  NOTE_DELETED_LABEL_NAME (label) = name;
+	  reorder_insns (label, label, PREV_INSN (q));
+	  delete_insn (table);
+	}
+
 #ifdef HAVE_cc0
       /* If this was a conditional jump, we need to also delete
 	 the insn that set cc0.  */
Index: gcc/convert.c
===================================================================
--- a/src/gcc/convert.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/convert.c	(.../branches/gcc-4_9-branch)
@@ -97,6 +97,15 @@
   enum built_in_function fcode = builtin_mathfn_code (expr);
   tree itype = TREE_TYPE (expr);
 
+  if (TREE_CODE (expr) == COMPOUND_EXPR)
+    {
+      tree t = convert_to_real (type, TREE_OPERAND (expr, 1));
+      if (t == TREE_OPERAND (expr, 1))
+	return expr;
+      return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (t),
+			 TREE_OPERAND (expr, 0), t);
+    }    
+
   /* Disable until we figure out how to decide whether the functions are
      present in runtime.  */
   /* Convert (float)sqrt((double)x) where x is float into sqrtf(x) */
@@ -403,6 +412,15 @@
       return error_mark_node;
     }
 
+  if (ex_form == COMPOUND_EXPR)
+    {
+      tree t = convert_to_integer (type, TREE_OPERAND (expr, 1));
+      if (t == TREE_OPERAND (expr, 1))
+	return expr;
+      return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (t),
+			 TREE_OPERAND (expr, 0), t);
+    }    
+
   /* Convert e.g. (long)round(d) -> lround(d).  */
   /* If we're converting to char, we may encounter differing behavior
      between converting from double->char vs double->long->char.
@@ -891,6 +909,14 @@
 
 	if (TYPE_MAIN_VARIANT (elt_type) == TYPE_MAIN_VARIANT (subtype))
 	  return expr;
+	else if (TREE_CODE (expr) == COMPOUND_EXPR)
+	  {
+	    tree t = convert_to_complex (type, TREE_OPERAND (expr, 1));
+	    if (t == TREE_OPERAND (expr, 1))
+	      return expr;
+	    return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR,
+			       TREE_TYPE (t), TREE_OPERAND (expr, 0), t);
+	  }    
 	else if (TREE_CODE (expr) == COMPLEX_EXPR)
 	  return fold_build2 (COMPLEX_EXPR, type,
 			      convert (subtype, TREE_OPERAND (expr, 0)),
Index: gcc/graphite-interchange.c
===================================================================
--- a/src/gcc/graphite-interchange.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-interchange.c	(.../branches/gcc-4_9-branch)
@@ -31,7 +31,13 @@
 #include <isl/ilp.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/aff_int.h>
+#include <isl/deprecated/ilp_int.h>
+#include <isl/deprecated/constraint_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: libgo/configure
===================================================================
--- a/src/libgo/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/configure	(.../branches/gcc-4_9-branch)
@@ -631,6 +631,8 @@
 LIBGO_IS_SPARC64_TRUE
 LIBGO_IS_SPARC_FALSE
 LIBGO_IS_SPARC_TRUE
+LIBGO_IS_PPC64LE_FALSE
+LIBGO_IS_PPC64LE_TRUE
 LIBGO_IS_PPC64_FALSE
 LIBGO_IS_PPC64_TRUE
 LIBGO_IS_PPC_FALSE
@@ -11115,7 +11117,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11118 "configure"
+#line 11120 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11221,7 +11223,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11224 "configure"
+#line 11226 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13599,6 +13601,7 @@
 mips_abi=unknown
 is_ppc=no
 is_ppc64=no
+is_ppc64le=no
 is_sparc=no
 is_sparc64=no
 is_x86_64=no
@@ -13709,13 +13712,27 @@
 if ac_fn_c_try_compile "$LINENO"; then :
   is_ppc=yes
 else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#if defined(_BIG_ENDIAN) || defined(__BIG_ENDIAN__)
+#error 64be
+#endif
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  is_ppc64le=yes
+else
   is_ppc64=yes
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     if test "$is_ppc" = "yes"; then
       GOARCH=ppc
+    elif test "$is_ppc64" = "yes"; then
+      GOARCH=ppc64
     else
-      GOARCH=ppc64
+      GOARCH=ppc64le
     fi
     ;;
   sparc*-*-*)
@@ -13835,6 +13852,14 @@
   LIBGO_IS_PPC64_FALSE=
 fi
 
+ if test $is_ppc64le = yes; then
+  LIBGO_IS_PPC64LE_TRUE=
+  LIBGO_IS_PPC64LE_FALSE='#'
+else
+  LIBGO_IS_PPC64LE_TRUE='#'
+  LIBGO_IS_PPC64LE_FALSE=
+fi
+
  if test $is_sparc = yes; then
   LIBGO_IS_SPARC_TRUE=
   LIBGO_IS_SPARC_FALSE='#'
@@ -15591,6 +15616,10 @@
   as_fn_error "conditional \"LIBGO_IS_PPC64\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${LIBGO_IS_PPC64LE_TRUE}" && test -z "${LIBGO_IS_PPC64LE_FALSE}"; then
+  as_fn_error "conditional \"LIBGO_IS_PPC64LE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${LIBGO_IS_SPARC_TRUE}" && test -z "${LIBGO_IS_SPARC_FALSE}"; then
   as_fn_error "conditional \"LIBGO_IS_SPARC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
Index: libgo/mksysinfo.sh
===================================================================
--- a/src/libgo/mksysinfo.sh	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/mksysinfo.sh	(.../branches/gcc-4_9-branch)
@@ -174,6 +174,9 @@
 #ifdef TIOCGWINSZ
   TIOCGWINSZ_val = TIOCGWINSZ,
 #endif
+#ifdef TIOCSWINSZ
+  TIOCSWINSZ_val = TIOCSWINSZ,
+#endif
 #ifdef TIOCNOTTY
   TIOCNOTTY_val = TIOCNOTTY,
 #endif
@@ -192,6 +195,12 @@
 #ifdef TIOCSIG
   TIOCSIG_val = TIOCSIG,
 #endif
+#ifdef TCGETS
+  TCGETS_val = TCGETS,
+#endif
+#ifdef TCSETS
+  TCSETS_val = TCSETS,
+#endif
 };
 EOF
 
@@ -780,6 +789,11 @@
     echo 'const TIOCGWINSZ = _TIOCGWINSZ_val' >> ${OUT}
   fi
 fi
+if ! grep '^const TIOCSWINSZ' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TIOCSWINSZ_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TIOCSWINSZ = _TIOCSWINSZ_val' >> ${OUT}
+  fi
+fi
 if ! grep '^const TIOCNOTTY' ${OUT} >/dev/null 2>&1; then
   if grep '^const _TIOCNOTTY_val' ${OUT} >/dev/null 2>&1; then
     echo 'const TIOCNOTTY = _TIOCNOTTY_val' >> ${OUT}
@@ -812,8 +826,18 @@
 fi
 
 # The ioctl flags for terminal control
-grep '^const _TC[GS]ET' gen-sysinfo.go | \
+grep '^const _TC[GS]ET' gen-sysinfo.go | grep -v _val | \
     sed -e 's/^\(const \)_\(TC[GS]ET[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
+if ! grep '^const TCGETS' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TCGETS_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TCGETS = _TCGETS_val' >> ${OUT}
+  fi
+fi
+if ! grep '^const TCSETS' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TCSETS_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TCSETS = _TCSETS_val' >> ${OUT}
+  fi
+fi
 
 # ioctl constants.  Might fall back to 0 if TIOCNXCL is missing, too, but
 # needs handling in syscalls.exec.go.
Index: libgo/configure.ac
===================================================================
--- a/src/libgo/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/configure.ac	(.../branches/gcc-4_9-branch)
@@ -179,6 +179,7 @@
 mips_abi=unknown
 is_ppc=no
 is_ppc64=no
+is_ppc64le=no
 is_sparc=no
 is_sparc64=no
 is_x86_64=no
@@ -249,11 +250,18 @@
 #ifdef _ARCH_PPC64
 #error 64-bit
 #endif],
-[is_ppc=yes], [is_ppc64=yes])
+[is_ppc=yes],
+    [AC_COMPILE_IFELSE([
+#if defined(_BIG_ENDIAN) || defined(__BIG_ENDIAN__)
+#error 64be
+#endif],
+[is_ppc64le=yes],[is_ppc64=yes])])
     if test "$is_ppc" = "yes"; then
       GOARCH=ppc
+    elif test "$is_ppc64" = "yes"; then
+      GOARCH=ppc64
     else
-      GOARCH=ppc64
+      GOARCH=ppc64le
     fi
     ;;
   sparc*-*-*)
@@ -281,6 +289,7 @@
 AM_CONDITIONAL(LIBGO_IS_MIPSO64, test $mips_abi = o64)
 AM_CONDITIONAL(LIBGO_IS_PPC, test $is_ppc = yes)
 AM_CONDITIONAL(LIBGO_IS_PPC64, test $is_ppc64 = yes)
+AM_CONDITIONAL(LIBGO_IS_PPC64LE, test $is_ppc64le = yes)
 AM_CONDITIONAL(LIBGO_IS_SPARC, test $is_sparc = yes)
 AM_CONDITIONAL(LIBGO_IS_SPARC64, test $is_sparc64 = yes)
 AM_CONDITIONAL(LIBGO_IS_X86_64, test $is_x86_64 = yes)
Index: libgo/go/debug/elf/file_test.go
===================================================================
--- a/src/libgo/go/debug/elf/file_test.go	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/file_test.go	(.../branches/gcc-4_9-branch)
@@ -261,6 +261,12 @@
 		},
 	},
 	{
+		"testdata/go-relocation-test-gcc447-ppc64.obj",
+		[]relocationTestEntry{
+			{0, &dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{dwarf.Field{Attr: dwarf.AttrProducer, Val: "GNU C 4.4.7 20120313 (Red Hat 4.4.7-4)"}, dwarf.Field{Attr: dwarf.AttrLanguage, Val: int64(1)}, dwarf.Field{Attr: dwarf.AttrName, Val: "t.c"}, dwarf.Field{Attr: dwarf.AttrCompDir, Val: "/tmp"}, dwarf.Field{Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, dwarf.Field{Attr: dwarf.AttrHighpc, Val: uint64(0x24)}, dwarf.Field{Attr: dwarf.AttrStmtList, Val: int64(0)}}}},
+		},
+	},
+	{
 		"testdata/gcc-amd64-openbsd-debug-with-rela.obj",
 		[]relocationTestEntry{
 			{203, &dwarf.Entry{Offset: 0xc62, Tag: dwarf.TagMember, Children: false, Field: []dwarf.Field{{Attr: dwarf.AttrName, Val: "it_interval"}, {Attr: dwarf.AttrDeclFile, Val: int64(7)}, {Attr: dwarf.AttrDeclLine, Val: int64(236)}, {Attr: dwarf.AttrType, Val: dwarf.Offset(0xb7f)}, {Attr: dwarf.AttrDataMemberLoc, Val: []byte{0x23, 0x0}}}}},
Index: libgo/go/debug/elf/file.go
===================================================================
--- a/src/libgo/go/debug/elf/file.go	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/file.go	(.../branches/gcc-4_9-branch)
@@ -519,6 +519,9 @@
 	if f.Class == ELFCLASS64 && f.Machine == EM_X86_64 {
 		return f.applyRelocationsAMD64(dst, rels)
 	}
+	if f.Class == ELFCLASS64 && f.Machine == EM_PPC64 {
+		return f.applyRelocationsPPC64(dst, rels)
+	}
 	if f.Class == ELFCLASS64 && f.Machine == EM_AARCH64 {
 		return f.applyRelocationsARM64(dst, rels)
 	}
@@ -615,6 +618,47 @@
 	return nil
 }
 
+func (f *File) applyRelocationsPPC64(dst []byte, rels []byte) error {
+	// 24 is the size of Rela64.
+	if len(rels)%24 != 0 {
+		return errors.New("length of relocation section is not a multiple of Sym64Size")
+	}
+
+	symbols, _, err := f.getSymbols(SHT_SYMTAB)
+	if err != nil {
+		return err
+	}
+
+	b := bytes.NewBuffer(rels)
+	var rela Rela64
+
+	for b.Len() > 0 {
+		binary.Read(b, f.ByteOrder, &rela)
+		symNo := rela.Info >> 32
+		t := R_PPC64(rela.Info & 0xffff)
+
+		if symNo == 0 || symNo > uint64(len(symbols)) {
+			continue
+		}
+		sym := &symbols[symNo-1]
+
+	switch t {
+		case R_PPC64_ADDR64:
+			if rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {
+				continue
+			}
+			f.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend) + uint64(sym.Value))
+		case R_PPC64_ADDR32:
+			if rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {
+				continue
+			}
+			f.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend) + uint32(sym.Value))
+		}
+	}
+
+	return nil
+}
+
 func (f *File) DWARF() (*dwarf.Data, error) {
 	// There are many other DWARF sections, but these
 	// are the required ones, and the debug/dwarf package
@@ -637,7 +681,7 @@
 	// If there's a relocation table for .debug_info, we have to process it
 	// now otherwise the data in .debug_info is invalid for x86-64 objects.
 	rela := f.Section(".rela.debug_info")
-	if rela != nil && rela.Type == SHT_RELA && (f.Machine == EM_X86_64 || f.Machine == EM_AARCH64) {
+	if rela != nil && rela.Type == SHT_RELA && (f.Machine == EM_X86_64 || f.Machine == EM_AARCH64 || f.Machine == EM_PPC64) {
 		data, err := rela.Data()
 		if err != nil {
 			return nil, err
Index: libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj
===================================================================
--- a/src/libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj	(.../branches/gcc-4_9-branch)

Property changes on: libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: libgo/go/debug/elf/elf.go
===================================================================
--- a/src/libgo/go/debug/elf/elf.go	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/elf.go	(.../branches/gcc-4_9-branch)
@@ -1246,6 +1246,242 @@
 func (i R_386) String() string   { return stringName(uint32(i), r386Strings, false) }
 func (i R_386) GoString() string { return stringName(uint32(i), r386Strings, true) }
 
+// Relocation types for ppc64.
+type R_PPC64 int
+
+const (
+	R_PPC64_NONE                R_PPC64 = 0 /* No relocation. */
+	R_PPC64_ADDR32              R_PPC64 = 1
+	R_PPC64_ADDR24              R_PPC64 = 2
+	R_PPC64_ADDR16              R_PPC64 = 3
+	R_PPC64_ADDR16_LO           R_PPC64 = 4
+	R_PPC64_ADDR16_HI           R_PPC64 = 5
+	R_PPC64_ADDR16_HA           R_PPC64 = 6
+	R_PPC64_ADDR14              R_PPC64 = 7
+	R_PPC64_ADDR14_BRTAKEN      R_PPC64 = 8
+	R_PPC64_ADDR14_BRNTAKEN     R_PPC64 = 9
+	R_PPC64_REL24               R_PPC64 = 10
+	R_PPC64_REL14               R_PPC64 = 11
+	R_PPC64_REL14_BRTAKEN       R_PPC64 = 12
+	R_PPC64_REL14_BRNTAKEN      R_PPC64 = 13
+	R_PPC64_GOT16               R_PPC64 = 14
+	R_PPC64_GOT16_LO            R_PPC64 = 15
+	R_PPC64_GOT16_HI            R_PPC64 = 16
+	R_PPC64_GOT16_HA            R_PPC64 = 17
+				    
+	R_PPC64_COPY                R_PPC64 = 19
+	R_PPC64_GLOB_DAT            R_PPC64 = 20
+	R_PPC64_JMP_SLOT            R_PPC64 = 21
+	R_PPC64_RELATIVE            R_PPC64 = 22
+				    
+	R_PPC64_UADDR32             R_PPC64 = 24
+	R_PPC64_UADDR16             R_PPC64 = 25
+	R_PPC64_REL32               R_PPC64 = 26
+	R_PPC64_PLT32               R_PPC64 = 27
+	R_PPC64_PLTREL32            R_PPC64 = 28
+	R_PPC64_PLT16_LO            R_PPC64 = 29
+	R_PPC64_PLT16_HI            R_PPC64 = 30
+	R_PPC64_PLT16_HA            R_PPC64 = 31
+				    
+	R_PPC64_SECTOFF             R_PPC64 = 33
+	R_PPC64_SECTOFF_LO          R_PPC64 = 34
+	R_PPC64_SECTOFF_HI          R_PPC64 = 35
+	R_PPC64_SECTOFF_HA          R_PPC64 = 36
+	R_PPC64_REL30	            R_PPC64 = 37
+	R_PPC64_ADDR64		    R_PPC64 = 38
+	R_PPC64_ADDR16_HIGHER	    R_PPC64 = 39
+	R_PPC64_ADDR16_HIGHERA	    R_PPC64 = 40
+	R_PPC64_ADDR16_HIGHEST	    R_PPC64 = 41
+	R_PPC64_ADDR16_HIGHESTA     R_PPC64 = 42
+	R_PPC64_UADDR64		    R_PPC64 = 43
+	R_PPC64_REL64		    R_PPC64 = 44
+	R_PPC64_PLT64		    R_PPC64 = 45
+	R_PPC64_PLTREL64	    R_PPC64 = 46
+	R_PPC64_TOC16		    R_PPC64 = 47
+	R_PPC64_TOC16_LO	    R_PPC64 = 48
+	R_PPC64_TOC16_HI	    R_PPC64 = 49
+	R_PPC64_TOC16_HA	    R_PPC64 = 50
+	R_PPC64_TOC		    R_PPC64 = 51
+	R_PPC64_PLTGOT16	    R_PPC64 = 52
+	R_PPC64_PLTGOT16_LO	    R_PPC64 = 53
+	R_PPC64_PLTGOT16_HI	    R_PPC64 = 54
+	R_PPC64_PLTGOT16_HA	    R_PPC64 = 55
+				    
+	R_PPC64_ADDR16_DS	    R_PPC64 = 56
+	R_PPC64_ADDR16_LO_DS	    R_PPC64 = 57
+	R_PPC64_GOT16_DS	    R_PPC64 = 58
+	R_PPC64_GOT16_LO_DS	    R_PPC64 = 59
+	R_PPC64_PLT16_LO_DS	    R_PPC64 = 60
+	R_PPC64_SECTOFF_DS	    R_PPC64 = 61
+	R_PPC64_SECTOFF_LO_DS	    R_PPC64 = 62
+	R_PPC64_TOC16_DS	    R_PPC64 = 63
+	R_PPC64_TOC16_LO_DS	    R_PPC64 = 64
+	R_PPC64_PLTGOT16_DS	    R_PPC64 = 65
+	R_PPC64_PLTGOT16_LO_DS	    R_PPC64 = 66
+				    
+	R_PPC64_TLS		    R_PPC64 = 67
+	R_PPC64_DTPMOD64	    R_PPC64 = 68
+	R_PPC64_TPREL16		    R_PPC64 = 69
+	R_PPC64_TPREL16_LO 	    R_PPC64 = 70
+	R_PPC64_TPREL16_HI          R_PPC64 = 71
+	R_PPC64_TPREL16_HA          R_PPC64 = 72
+	R_PPC64_TPREL64       	    R_PPC64 = 73
+	R_PPC64_DTPREL16            R_PPC64 = 74
+	R_PPC64_DTPREL16_LO   	    R_PPC64 = 75
+	R_PPC64_DTPREL16_HI   	    R_PPC64 = 76
+	R_PPC64_DTPREL16_HA         R_PPC64 = 77
+	R_PPC64_DTPREL64            R_PPC64 = 78
+	R_PPC64_GOT_TLSGD16    	    R_PPC64 = 79
+	R_PPC64_GOT_TLSGD16_LO      R_PPC64 = 80
+	R_PPC64_GOT_TLSGD16_HI      R_PPC64 = 81
+	R_PPC64_GOT_TLSGD16_HA      R_PPC64 = 82
+	R_PPC64_GOT_TLSLD16         R_PPC64 = 83
+	R_PPC64_GOT_TLSLD16_LO      R_PPC64 = 84
+	R_PPC64_GOT_TLSLD16_HI      R_PPC64 = 85
+	R_PPC64_GOT_TLSLD16_HA      R_PPC64 = 86
+	R_PPC64_GOT_TPREL16_DS      R_PPC64 = 87
+	R_PPC64_GOT_TPREL16_LO_DS   R_PPC64 = 88
+	R_PPC64_GOT_TPREL16_HI	    R_PPC64 = 89
+	R_PPC64_GOT_TPREL16_HA      R_PPC64 = 90
+	R_PPC64_GOT_DTPREL16_DS     R_PPC64 = 91
+	R_PPC64_GOT_DTPREL16_LO_DS  R_PPC64 = 92
+	R_PPC64_GOT_DTPREL16_HI     R_PPC64 = 93
+	R_PPC64_GOT_DTPREL16_HA     R_PPC64 = 94
+	R_PPC64_TPREL16_DS	    R_PPC64 = 95
+	R_PPC64_TPREL16_LO_DS       R_PPC64 = 96
+	R_PPC64_TPREL16_HIGHER      R_PPC64 = 97
+	R_PPC64_TPREL16_HIGHERA     R_PPC64 = 98
+	R_PPC64_TPREL16_HIGHEST     R_PPC64 = 99
+	R_PPC64_TPREL16_HIGHESTA    R_PPC64 = 100
+	R_PPC64_DTPREL16_DS	    R_PPC64 = 101
+	R_PPC64_DTPREL16_LO_DS      R_PPC64 = 102
+	R_PPC64_DTPREL16_HIGHER     R_PPC64 = 103
+	R_PPC64_DTPREL16_HIGHERA    R_PPC64 = 104
+	R_PPC64_DTPREL16_HIGHEST    R_PPC64 = 105
+	R_PPC64_DTPREL16_HIGHESTA   R_PPC64 = 106
+
+	R_PPC64_GNU_VTINHERIT	    R_PPC64 = 253
+	R_PPC64_GNU_VTENTRY	    R_PPC64 = 254
+)
+
+var rppc64Strings = []intName{
+        {0, "R_PPC64_NONE"},
+	{1, "R_PPC64_ADDR32"},
+	{2, "R_PPC64_ADDR24"},
+	{3, "R_PPC64_ADDR16"},
+	{4, "R_PPC64_ADDR16_LO"},
+	{5, "R_PPC64_ADDR16_HI"},
+	{6, "R_PPC64_ADDR16_HA"},
+	{7, "R_PPC64_ADDR14"},
+	{8, "R_PPC64_ADDR14_BRTAKEN"},
+	{9, "R_PPC64_ADDR14_BRNTAKEN"},
+	{10, "R_PPC64_REL24"},
+	{11, "R_PPC64_REL14"},
+	{12, "R_PPC64_REL14_BRTAKEN"},
+	{13, "R_PPC64_REL14_BRNTAKEN"},
+	{14, "R_PPC64_GOT16"},
+	{15, "R_PPC64_GOT16_LO"},
+	{16, "R_PPC64_GOT16_HI"},
+	{17, "R_PPC64_GOT16_HA"},
+
+	{19, "R_PPC64_COPY"},
+	{20, "R_PPC64_GLOB_DAT"},
+	{21, "R_PPC64_JMP_SLOT"},
+	{22, "R_PPC64_RELATIVE"},
+
+	{24, "R_PPC64_UADDR32"},
+	{25, "R_PPC64_UADDR16"},
+	{26, "R_PPC64_REL32"},
+	{27, "R_PPC64_PLT32"},
+	{28, "R_PPC64_PLTREL32"},
+	{29, "R_PPC64_PLT16_LO"},
+	{30, "R_PPC64_PLT16_HI"},
+	{31, "R_PPC64_PLT16_HA"},
+
+	{33, "R_PPC64_SECTOFF"},
+	{34, "R_PPC64_SECTOFF_LO"},
+	{35, "R_PPC64_SECTOFF_HI"},
+	{36, "R_PPC64_SECTOFF_HA"},
+	{37, "R_PPC64_REL30"},
+	{38, "R_PPC64_ADDR64"},
+	{39, "R_PPC64_ADDR16_HIGHER"},
+	{40, "R_PPC64_ADDR16_HIGHERA"},
+	{41, "R_PPC64_ADDR16_HIGHEST"},
+	{42, "R_PPC64_ADDR16_HIGHESTA"},
+	{43, "R_PPC64_UADDR64"},
+	{44, "R_PPC64_REL64"},
+	{45, "R_PPC64_PLT64"},
+	{46, "R_PPC64_PLTREL64"},
+	{47, "R_PPC64_TOC16"},
+	{48, "R_PPC64_TOC16_LO"},
+	{49, "R_PPC64_TOC16_HI"},
+	{50, "R_PPC64_TOC16_HA"},
+	{51, "R_PPC64_TOC"},
+	{52, "R_PPC64_PLTGOT16"},
+	{53, "R_PPC64_PLTGOT16_LO"},
+	{54, "R_PPC64_PLTGOT16_HI"},
+	{55, "R_PPC64_PLTGOT16_HA"},
+
+	{56, "R_PPC64_ADDR16_DS"},
+	{57, "R_PPC64_ADDR16_LO_DS"},
+	{58, "R_PPC64_GOT16_DS"},
+	{59, "R_PPC64_GOT16_LO_DS"},
+	{60, "R_PPC64_PLT16_LO_DS"},
+	{61, "R_PPC64_SECTOFF_DS"},
+	{62, "R_PPC64_SECTOFF_LO_DS"},
+	{63, "R_PPC64_TOC16_DS"},
+	{64, "R_PPC64_TOC16_LO_DS"},
+	{65, "R_PPC64_PLTGOT16_DS"},
+	{66, "R_PPC64_PLTGOT16_LO_DS"},
+
+	{67, "R_PPC64_TLS"},
+	{68, "R_PPC64_DTPMOD64"},
+	{69, "R_PPC64_TPREL16"},
+	{70, "R_PPC64_TPREL16_LO"},
+	{71, "R_PPC64_TPREL16_HI"},
+	{72, "R_PPC64_TPREL16_HA"},
+	{73, "R_PPC64_TPREL64"},
+	{74, "R_PPC64_DTPREL16"},
+	{75, "R_PPC64_DTPREL16_LO"},
+	{76, "R_PPC64_DTPREL16_HI"},
+	{77, "R_PPC64_DTPREL16_HA"},
+	{78, "R_PPC64_DTPREL64"},
+	{79, "R_PPC64_GOT_TLSGD16"},
+	{80, "R_PPC64_GOT_TLSGD16_LO"},
+	{81, "R_PPC64_GOT_TLSGD16_HI"},
+	{82, "R_PPC64_GOT_TLSGD16_HA"},
+	{83, "R_PPC64_GOT_TLSLD16"},
+	{84, "R_PPC64_GOT_TLSLD16_LO"},
+	{85, "R_PPC64_GOT_TLSLD16_HI"},
+	{86, "R_PPC64_GOT_TLSLD16_HA"},
+	{87, "R_PPC64_GOT_TPREL16_DS"},
+	{88, "R_PPC64_GOT_TPREL16_LO_DS"},
+	{89, "R_PPC64_GOT_TPREL16_HI"},
+	{90, "R_PPC64_GOT_TPREL16_HA"},
+	{91, "R_PPC64_GOT_DTPREL16_DS"},
+	{92, "R_PPC64_GOT_DTPREL16_LO_DS"},
+	{93, "R_PPC64_GOT_DTPREL16_HI"},
+	{94, "R_PPC64_GOT_DTPREL16_HA"},
+	{95, "R_PPC64_TPREL16_DS"},
+	{96, "R_PPC64_TPREL16_LO_DS"},
+	{97, "R_PPC64_TPREL16_HIGHER"},
+	{98, "R_PPC64_TPREL16_HIGHERA"},
+	{99, "R_PPC64_TPREL16_HIGHEST"},
+	{100, "R_PPC64_TPREL16_HIGHESTA"},
+	{101, "R_PPC64_DTPREL16_DS"},
+	{102, "R_PPC64_DTPREL16_LO_DS"},
+	{103, "R_PPC64_DTPREL16_HIGHER"},
+	{104, "R_PPC64_DTPREL16_HIGHERA"},
+	{105, "R_PPC64_DTPREL16_HIGHEST"},
+	{106, "R_PPC64_DTPREL16_HIGHESTA"},
+
+	{253, "R_PPC64_GNU_VTINHERIT"},
+	{254, "R_PPC64_GNU_VTENTRY"},
+}
+
+func (i R_PPC64) String() string   { return stringName(uint32(i), rppc64Strings, false) }
+func (i R_PPC64) GoString() string { return stringName(uint32(i), rppc64Strings, true) }
+
 // Relocation types for PowerPC.
 type R_PPC int
 
Index: libgo/go/go/build/syslist.go
===================================================================
--- a/src/libgo/go/go/build/syslist.go	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/go/build/syslist.go	(.../branches/gcc-4_9-branch)
@@ -5,4 +5,4 @@
 package build
 
 const goosList = "darwin dragonfly freebsd linux netbsd openbsd plan9 windows solaris "
-const goarchList = "386 amd64 arm arm64 alpha m68k mipso32 mipsn32 mipsn64 mipso64 ppc ppc64 sparc sparc64 "
+const goarchList = "386 amd64 arm arm64 alpha m68k mipso32 mipsn32 mipsn64 mipso64 ppc ppc64 ppc64le sparc sparc64 "
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,15 @@
+2015-03-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/60956
+	Backport from mainline
+	* io/fbuf.c (fbuf_flush_list): New function that only flushes
+	if current fbuf position exceeds a limit.
+	* io/fbuf.h: Declare the new function.
+	* io/io.h (enum unit_mode): Add two new modes.
+	* io/list_read.c (list_formatted_read_scalar): Call new function.
+	* io/write.c: Include fbuf.h. (list_formatted_write_scalar):
+	Call new function.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-4_9-branch)
@@ -2054,6 +2054,7 @@
       free_line (dtp);
       hit_eof (dtp);
     }
+  fbuf_flush_list (dtp->u.p.current_unit, LIST_READING);
   return err;
 }
 
Index: libgfortran/io/io.h
===================================================================
--- a/src/libgfortran/io/io.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libgfortran/io/io.h	(.../branches/gcc-4_9-branch)
@@ -207,7 +207,7 @@
 unit_advance;
 
 typedef enum
-{READING, WRITING}
+{READING, WRITING, LIST_READING, LIST_WRITING}
 unit_mode;
 
 typedef enum
Index: libgfortran/io/fbuf.c
===================================================================
--- a/src/libgfortran/io/fbuf.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgfortran/io/fbuf.c	(.../branches/gcc-4_9-branch)
@@ -174,7 +174,43 @@
 }
 
 
+/* The mode argument is LIST_WRITING for write mode and LIST_READING for
+   read.  This should only be used for list directed  I/O.
+   Return value is 0 for success, -1 on failure.  */
+
 int
+fbuf_flush_list (gfc_unit * u, unit_mode mode)
+{
+  int nwritten;
+
+  if (!u->fbuf)
+    return 0;
+
+  if (u->fbuf->pos < 524288) /* Upper limit for list writing.  */
+    return 0;
+
+  fbuf_debug (u, "fbuf_flush_list with mode %d: ", mode);
+
+  if (mode == LIST_WRITING)
+    {
+      nwritten = swrite (u->s, u->fbuf->buf, u->fbuf->pos);
+      if (nwritten < 0)
+	return -1;
+    }
+
+  /* Salvage remaining bytes for both reading and writing.  */ 
+  if (u->fbuf->act > u->fbuf->pos)
+    memmove (u->fbuf->buf, u->fbuf->buf + u->fbuf->pos, 
+             u->fbuf->act - u->fbuf->pos);
+
+  u->fbuf->act -= u->fbuf->pos;
+  u->fbuf->pos = 0;
+
+  return 0;
+}
+
+
+int
 fbuf_seek (gfc_unit * u, int off, int whence)
 {
   if (!u->fbuf)
Index: libgfortran/io/fbuf.h
===================================================================
--- a/src/libgfortran/io/fbuf.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libgfortran/io/fbuf.h	(.../branches/gcc-4_9-branch)
@@ -59,6 +59,9 @@
 extern int fbuf_flush (gfc_unit *, unit_mode);
 internal_proto(fbuf_flush);
 
+extern int fbuf_flush_list (gfc_unit *, unit_mode);
+internal_proto(fbuf_flush_list);
+
 extern int fbuf_seek (gfc_unit *, int, int);
 internal_proto(fbuf_seek);
 
Index: libgfortran/io/write.c
===================================================================
--- a/src/libgfortran/io/write.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgfortran/io/write.c	(.../branches/gcc-4_9-branch)
@@ -25,6 +25,7 @@
 <http://www.gnu.org/licenses/>.  */
 
 #include "io.h"
+#include "fbuf.h"
 #include "format.h"
 #include "unix.h"
 #include <assert.h>
@@ -1585,6 +1586,7 @@
       internal_error (&dtp->common, "list_formatted_write(): Bad type");
     }
 
+  fbuf_flush_list (dtp->u.p.current_unit, LIST_WRITING);
   dtp->u.p.char_flag = (type == BT_CHARACTER);
 }
 
Index: Makefile.def
===================================================================
--- a/src/Makefile.def	(.../tags/gcc_4_9_2_release)
+++ b/src/Makefile.def	(.../branches/gcc-4_9-branch)
@@ -296,6 +296,10 @@
 // Host modules specific to gcc.
 dependencies = { module=configure-gcc; on=configure-intl; };
 dependencies = { module=configure-gcc; on=all-gmp; };
+dependencies = { module=configure-gcc; on=all-mpfr; };
+dependencies = { module=configure-gcc; on=all-mpc; };
+dependencies = { module=configure-gcc; on=all-isl; };
+dependencies = { module=configure-gcc; on=all-cloog; };
 dependencies = { module=configure-gcc; on=all-lto-plugin; };
 dependencies = { module=configure-gcc; on=all-binutils; };
 dependencies = { module=configure-gcc; on=all-gas; };
Index: libcilkrts/configure
===================================================================
--- a/src/libcilkrts/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/libcilkrts/configure	(.../branches/gcc-4_9-branch)
@@ -634,7 +634,6 @@
 GREP
 CPP
 ALLOCA
-multi_basedir
 am__fastdepCXX_FALSE
 am__fastdepCXX_TRUE
 CXXDEPMODE
@@ -657,6 +656,7 @@
 LDFLAGS
 CFLAGS
 CC
+multi_basedir
 MAINT
 MAINTAINER_MODE_FALSE
 MAINTAINER_MODE_TRUE
@@ -737,8 +737,8 @@
 ac_user_opts='
 enable_option_checking
 enable_maintainer_mode
+enable_multilib
 enable_dependency_tracking
-enable_multilib
 enable_version_specific_runtime_libs
 enable_shared
 enable_static
@@ -1383,9 +1383,9 @@
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
   --enable-maintainer-mode  enable make rules and dependencies not useful
 			  (and sometimes confusing) to the casual installer
+  --enable-multilib       build many library versions (default)
   --disable-dependency-tracking  speeds up one-time build
   --enable-dependency-tracking   do not reject slow dependency extractors
-  --enable-multilib       build many library versions (default)
   --enable-version-specific-runtime-libs
                           Specify that runtime libraries should be installed
                           in a compi ler-specific directory
@@ -2873,6 +2873,44 @@
 
 
 
+# Default to --enable-multilib
+# Check whether --enable-multilib was given.
+if test "${enable_multilib+set}" = set; then :
+  enableval=$enable_multilib; case "$enableval" in
+  yes) multilib=yes ;;
+  no)  multilib=no ;;
+  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
+ esac
+else
+  multilib=yes
+fi
+
+
+# We may get other options which we leave undocumented:
+# --with-target-subdir, --with-multisrctop, --with-multisubdir
+# See config-ml.in if you want the gory details.
+
+if test "$srcdir" = "."; then
+  if test "$with_target_subdir" != "."; then
+    multi_basedir="$srcdir/$with_multisrctop../.."
+  else
+    multi_basedir="$srcdir/$with_multisrctop.."
+  fi
+else
+  multi_basedir="$srcdir/.."
+fi
+
+
+# Even if the default multilib is not a cross compilation,
+# it may be that some of the other multilibs are.
+if test $cross_compiling = no && test $multilib = yes \
+   && test "x${with_multisubdir}" != x ; then
+   cross_compiling=maybe
+fi
+
+ac_config_commands="$ac_config_commands default-1"
+
+
 # Build a DLL on Windows
 # AC_LIBTOOL_WIN32_DLL
 ac_ext=c
@@ -4217,44 +4255,7 @@
 # AC_CONFIG_MACRO_DIR([..])
 ac_config_files="$ac_config_files Makefile libcilkrts.spec"
 
-# Default to --enable-multilib
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "$enableval" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
- esac
-else
-  multilib=yes
-fi
 
-
-# We may get other options which we leave undocumented:
-# --with-target-subdir, --with-multisrctop, --with-multisubdir
-# See config-ml.in if you want the gory details.
-
-if test "$srcdir" = "."; then
-  if test "$with_target_subdir" != "."; then
-    multi_basedir="$srcdir/$with_multisrctop../.."
-  else
-    multi_basedir="$srcdir/$with_multisrctop.."
-  fi
-else
-  multi_basedir="$srcdir/.."
-fi
-
-
-# Even if the default multilib is not a cross compilation,
-# it may be that some of the other multilibs are.
-if test $cross_compiling = no && test $multilib = yes \
-   && test "x${with_multisubdir}" != x ; then
-   cross_compiling=maybe
-fi
-
-ac_config_commands="$ac_config_commands default-1"
-
-
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -11057,7 +11058,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11060 "configure"
+#line 11061 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11163,7 +11164,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11166 "configure"
+#line 11167 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15232,7 +15233,6 @@
 #
 # INIT-COMMANDS
 #
-AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
 
 srcdir="$srcdir"
 host="$host"
@@ -15247,6 +15247,7 @@
 CXX="$CXX"
 GFORTRAN="$GFORTRAN"
 GCJ="$GCJ"
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
 
 
 # The HP-UX ksh and POSIX shell print the target directory to stdout
@@ -15616,10 +15617,10 @@
 for ac_config_target in $ac_config_targets
 do
   case $ac_config_target in
+    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "libcilkrts.spec") CONFIG_FILES="$CONFIG_FILES libcilkrts.spec" ;;
-    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
 
   *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
@@ -16039,6 +16040,14 @@
 
 
   case $ac_file$ac_mode in
+    "default-1":C)
+# Only add multilib support code if we just rebuilt the top-level
+# Makefile.
+case " $CONFIG_FILES " in
+ *" Makefile "*)
+   ac_file=Makefile . ${multi_basedir}/config-ml.in
+   ;;
+esac ;;
     "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
   # Autoconf 2.62 quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
@@ -16134,14 +16143,6 @@
   done
 }
  ;;
-    "default-1":C)
-# Only add multilib support code if we just rebuilt the top-level
-# Makefile.
-case " $CONFIG_FILES " in
- *" Makefile "*)
-   ac_file=Makefile . ${multi_basedir}/config-ml.in
-   ;;
-esac ;;
     "libtool":C)
 
     # See if we are running on zsh, and set the options which allow our
Index: libcilkrts/configure.ac
===================================================================
--- a/src/libcilkrts/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/libcilkrts/configure.ac	(.../branches/gcc-4_9-branch)
@@ -43,6 +43,8 @@
 
 AM_MAINTAINER_MODE
 
+AM_ENABLE_MULTILIB(, ..)
+
 # Build a DLL on Windows
 # AC_LIBTOOL_WIN32_DLL
 AC_PROG_CC
@@ -50,7 +52,6 @@
 # AC_PROG_LIBTOOL
 # AC_CONFIG_MACRO_DIR([..])
 AC_CONFIG_FILES([Makefile libcilkrts.spec])
-AM_ENABLE_MULTILIB(, ..)
 AC_FUNC_ALLOCA
 
 # Check whether the target supports protected visibility.
Index: libcilkrts/ChangeLog
===================================================================
--- a/src/libcilkrts/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libcilkrts/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,8 @@
+2015-01-26  Matthias Klose  <doko@ubuntu.com>
+
+	* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC.
+	* configure: Regenerate.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libcpp/line-map.c
===================================================================
--- a/src/libcpp/line-map.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/line-map.c	(.../branches/gcc-4_9-branch)
@@ -527,10 +527,10 @@
 	  && line_delta * ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) > 1000)
       || (max_column_hint >= (1U << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map)))
       || (max_column_hint <= 80
-	  && ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) >= 10))
-    {
-      add_map = true;
-    }
+	  && ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) >= 10)
+      || (highest > 0x60000000
+	  && (set->max_column_hint || highest > 0x70000000)))
+    add_map = true;
   else
     max_column_hint = set->max_column_hint;
   if (add_map)
@@ -541,7 +541,7 @@
 	  /* If the column number is ridiculous or we've allocated a huge
 	     number of source_locations, give up on column numbers. */
 	  max_column_hint = 0;
-	  if (highest >0x70000000)
+	  if (highest > 0x70000000)
 	    return 0;
 	  column_bits = 0;
 	}
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,13 @@
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/60436
+	* line-map.c (linemap_line_start): If highest is above 0x60000000
+	and we are still tracking columns or highest is above 0x70000000,
+	force add_map.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libcpp/po/ChangeLog
===================================================================
--- a/src/libcpp/po/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/po/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,7 @@
+2014-11-07  Joseph Myers  <joseph@codesourcery.com>
+
+	* ja.po: Update.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libcpp/po/ja.po
===================================================================
--- a/src/libcpp/po/ja.po	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/po/ja.po	(.../branches/gcc-4_9-branch)
@@ -4,15 +4,15 @@
 # Daisuke Yamashita <yamad@mb.infoweb.ne.jp>, 1999-2001
 #    Masahito Yamaga <yamaga@ipc.chiba-u.ac.jp>, 1999.
 #    IIDA Yosiaki <iida@secom.ne.jp>, 1999.
-# Yasuaki Taniguchi <yasuakit@gmail.com>, 2010, 2011.
 # Takeshi Hamasaki <hmatrjp@users.sourceforge.jp>, 2012, 2013
+# Yasuaki Taniguchi <yasuakit@gmail.com>, 2010, 2011, 2014.
 msgid ""
 msgstr ""
-"Project-Id-Version: cpplib 4.8-b20130224\n"
+"Project-Id-Version: cpplib 4.9-b20140202\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
 "POT-Creation-Date: 2014-02-02 17:35+0000\n"
-"PO-Revision-Date: 2013-03-04 18:01+0900\n"
-"Last-Translator: Takeshi Hamasaki <hmatrjp@users.sourceforge.jp>\n"
+"PO-Revision-Date: 2014-11-07 08:19+0000\n"
+"Last-Translator: Yasuaki Taniguchi <yasuakit@gmail.com>\n"
 "Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
 "Language: ja\n"
 "MIME-Version: 1.0\n"
@@ -19,7 +19,6 @@
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: Poedit 1.5.4\n"
 
 #: charset.c:673
 #, c-format
@@ -456,10 +455,8 @@
 msgstr " \"%.*s\" "
 
 #: expr.c:667
-#, fuzzy
-#| msgid "use of C++0x long long integer constant"
 msgid "use of C++11 long long integer constant"
-msgstr "C++0x  long long "
+msgstr "C++11  long long "
 
 #: expr.c:668
 msgid "use of C99 long long integer constant"
@@ -470,10 +467,8 @@
 msgstr " GCC "
 
 #: expr.c:690
-#, fuzzy
-#| msgid "binary constants are a GCC extension"
 msgid "binary constants are a C++1y feature or GCC extension"
-msgstr " GCC "
+msgstr " C++1y  GCC "
 
 #: expr.c:787
 msgid "integer constant is too large for its type"
@@ -703,10 +698,8 @@
 msgstr " 16 "
 
 #: lex.c:1558
-#, fuzzy
-#| msgid "invalid character '%c' in raw string delimiter"
 msgid "invalid new-line in raw string delimiter"
-msgstr " '%c' "
+msgstr ""
 
 #: lex.c:1562
 #, c-format
@@ -718,10 +711,8 @@
 msgstr ""
 
 #: lex.c:1654 lex.c:1783
-#, fuzzy
-#| msgid "invalid suffix on literal; C++11 requires a space between literal and identifier"
 msgid "invalid suffix on literal; C++11 requires a space between literal and string macro"
-msgstr "C++11 "
+msgstr "C++11 "
 
 #: lex.c:1765
 msgid "null character(s) preserved in literal"
@@ -762,7 +753,7 @@
 #: macro.c:236 macro.c:333
 #, c-format
 msgid "macro \"%s\" might prevent reproducible builds"
-msgstr ""
+msgstr " \"%s\" "
 
 #: macro.c:267
 msgid "could not determine file timestamp"
